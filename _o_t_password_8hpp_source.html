<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Open-Transactions: include/otlib/OTPassword.hpp Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Open-Transactions
   &#160;<span id="projectnumber">master/1066fb4910a63ee3f7de8e0807fee3eb663b66c7</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('_o_t_password_8hpp.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">include/otlib/OTPassword.hpp</div>  </div>
</div><!--header-->
<div class="contents">
<a href="_o_t_password_8hpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/************************************************************</span>
<a name="l00002"></a>00002 <span class="comment"> *</span>
<a name="l00003"></a>00003 <span class="comment"> *  OTPassword.hpp</span>
<a name="l00004"></a>00004 <span class="comment"> *</span>
<a name="l00005"></a>00005 <span class="comment"> */</span>
<a name="l00006"></a>00006 
<a name="l00007"></a>00007 <span class="comment">/************************************************************</span>
<a name="l00008"></a>00008 <span class="comment"> -----BEGIN PGP SIGNED MESSAGE-----</span>
<a name="l00009"></a>00009 <span class="comment"> Hash: SHA1</span>
<a name="l00010"></a>00010 <span class="comment"></span>
<a name="l00011"></a>00011 <span class="comment"> *                 OPEN TRANSACTIONS</span>
<a name="l00012"></a>00012 <span class="comment"> *</span>
<a name="l00013"></a>00013 <span class="comment"> *       Financial Cryptography and Digital Cash</span>
<a name="l00014"></a>00014 <span class="comment"> *       Library, Protocol, API, Server, CLI, GUI</span>
<a name="l00015"></a>00015 <span class="comment"> *</span>
<a name="l00016"></a>00016 <span class="comment"> *       -- Anonymous Numbered Accounts.</span>
<a name="l00017"></a>00017 <span class="comment"> *       -- Untraceable Digital Cash.</span>
<a name="l00018"></a>00018 <span class="comment"> *       -- Triple-Signed Receipts.</span>
<a name="l00019"></a>00019 <span class="comment"> *       -- Cheques, Vouchers, Transfers, Inboxes.</span>
<a name="l00020"></a>00020 <span class="comment"> *       -- Basket Currencies, Markets, Payment Plans.</span>
<a name="l00021"></a>00021 <span class="comment"> *       -- Signed, XML, Ricardian-style Contracts.</span>
<a name="l00022"></a>00022 <span class="comment"> *       -- Scripted smart contracts.</span>
<a name="l00023"></a>00023 <span class="comment"> *</span>
<a name="l00024"></a>00024 <span class="comment"> *  Copyright (C) 2010-2013 by &quot;Fellow Traveler&quot; (A pseudonym)</span>
<a name="l00025"></a>00025 <span class="comment"> *</span>
<a name="l00026"></a>00026 <span class="comment"> *  EMAIL:</span>
<a name="l00027"></a>00027 <span class="comment"> *  FellowTraveler@rayservers.net</span>
<a name="l00028"></a>00028 <span class="comment"> *</span>
<a name="l00029"></a>00029 <span class="comment"> *  BITCOIN:  1NtTPVVjDsUfDWybS4BwvHpG2pdS9RnYyQ</span>
<a name="l00030"></a>00030 <span class="comment"> *</span>
<a name="l00031"></a>00031 <span class="comment"> *  KEY FINGERPRINT (PGP Key in license file):</span>
<a name="l00032"></a>00032 <span class="comment"> *  9DD5 90EB 9292 4B48 0484  7910 0308 00ED F951 BB8E</span>
<a name="l00033"></a>00033 <span class="comment"> *</span>
<a name="l00034"></a>00034 <span class="comment"> *  OFFICIAL PROJECT WIKI(s):</span>
<a name="l00035"></a>00035 <span class="comment"> *  https://github.com/FellowTraveler/Moneychanger</span>
<a name="l00036"></a>00036 <span class="comment"> *  https://github.com/FellowTraveler/Open-Transactions/wiki</span>
<a name="l00037"></a>00037 <span class="comment"> *</span>
<a name="l00038"></a>00038 <span class="comment"> *  WEBSITE:</span>
<a name="l00039"></a>00039 <span class="comment"> *  http://www.OpenTransactions.org/</span>
<a name="l00040"></a>00040 <span class="comment"> *</span>
<a name="l00041"></a>00041 <span class="comment"> *  Components and licensing:</span>
<a name="l00042"></a>00042 <span class="comment"> *   -- Moneychanger..A Java client GUI.....LICENSE:.....GPLv3</span>
<a name="l00043"></a>00043 <span class="comment"> *   -- otlib.........A class library.......LICENSE:...LAGPLv3</span>
<a name="l00044"></a>00044 <span class="comment"> *   -- otapi.........A client API..........LICENSE:...LAGPLv3</span>
<a name="l00045"></a>00045 <span class="comment"> *   -- opentxs/ot....Command-line client...LICENSE:...LAGPLv3</span>
<a name="l00046"></a>00046 <span class="comment"> *   -- otserver......Server Application....LICENSE:....AGPLv3</span>
<a name="l00047"></a>00047 <span class="comment"> *  Github.com/FellowTraveler/Open-Transactions/wiki/Components</span>
<a name="l00048"></a>00048 <span class="comment"> *</span>
<a name="l00049"></a>00049 <span class="comment"> *  All of the above OT components were designed and written by</span>
<a name="l00050"></a>00050 <span class="comment"> *  Fellow Traveler, with the exception of Moneychanger, which</span>
<a name="l00051"></a>00051 <span class="comment"> *  was contracted out to Vicky C (bitcointrader4@gmail.com).</span>
<a name="l00052"></a>00052 <span class="comment"> *  The open-source community has since actively contributed.</span>
<a name="l00053"></a>00053 <span class="comment"> *</span>
<a name="l00054"></a>00054 <span class="comment"> *  -----------------------------------------------------</span>
<a name="l00055"></a>00055 <span class="comment"> *</span>
<a name="l00056"></a>00056 <span class="comment"> *   LICENSE:</span>
<a name="l00057"></a>00057 <span class="comment"> *   This program is free software: you can redistribute it</span>
<a name="l00058"></a>00058 <span class="comment"> *   and/or modify it under the terms of the GNU Affero</span>
<a name="l00059"></a>00059 <span class="comment"> *   General Public License as published by the Free Software</span>
<a name="l00060"></a>00060 <span class="comment"> *   Foundation, either version 3 of the License, or (at your</span>
<a name="l00061"></a>00061 <span class="comment"> *   option) any later version.</span>
<a name="l00062"></a>00062 <span class="comment"> *</span>
<a name="l00063"></a>00063 <span class="comment"> *   ADDITIONAL PERMISSION under the GNU Affero GPL version 3</span>
<a name="l00064"></a>00064 <span class="comment"> *   section 7: (This paragraph applies only to the LAGPLv3</span>
<a name="l00065"></a>00065 <span class="comment"> *   components listed above.) If you modify this Program, or</span>
<a name="l00066"></a>00066 <span class="comment"> *   any covered work, by linking or combining it with other</span>
<a name="l00067"></a>00067 <span class="comment"> *   code, such other code is not for that reason alone subject</span>
<a name="l00068"></a>00068 <span class="comment"> *   to any of the requirements of the GNU Affero GPL version 3.</span>
<a name="l00069"></a>00069 <span class="comment"> *   (==&gt; This means if you are only using the OT API, then you</span>
<a name="l00070"></a>00070 <span class="comment"> *   don&#39;t have to open-source your code--only your changes to</span>
<a name="l00071"></a>00071 <span class="comment"> *   Open-Transactions itself must be open source. Similar to</span>
<a name="l00072"></a>00072 <span class="comment"> *   LGPLv3, except it applies to software-as-a-service, not</span>
<a name="l00073"></a>00073 <span class="comment"> *   just to distributing binaries.)</span>
<a name="l00074"></a>00074 <span class="comment"> *</span>
<a name="l00075"></a>00075 <span class="comment"> *   Extra WAIVER for OpenSSL, Lucre, and all other libraries</span>
<a name="l00076"></a>00076 <span class="comment"> *   used by Open Transactions: This program is released under</span>
<a name="l00077"></a>00077 <span class="comment"> *   the AGPL with the additional exemption that compiling,</span>
<a name="l00078"></a>00078 <span class="comment"> *   linking, and/or using OpenSSL is allowed. The same is true</span>
<a name="l00079"></a>00079 <span class="comment"> *   for any other open source libraries included in this</span>
<a name="l00080"></a>00080 <span class="comment"> *   project: complete waiver from the AGPL is hereby granted to</span>
<a name="l00081"></a>00081 <span class="comment"> *   compile, link, and/or use them with Open-Transactions,</span>
<a name="l00082"></a>00082 <span class="comment"> *   according to their own terms, as long as the rest of the</span>
<a name="l00083"></a>00083 <span class="comment"> *   Open-Transactions terms remain respected, with regard to</span>
<a name="l00084"></a>00084 <span class="comment"> *   the Open-Transactions code itself.</span>
<a name="l00085"></a>00085 <span class="comment"> *</span>
<a name="l00086"></a>00086 <span class="comment"> *   Lucre License:</span>
<a name="l00087"></a>00087 <span class="comment"> *   This code is also &quot;dual-license&quot;, meaning that Ben Lau-</span>
<a name="l00088"></a>00088 <span class="comment"> *   rie&#39;s license must also be included and respected, since</span>
<a name="l00089"></a>00089 <span class="comment"> *   the code for Lucre is also included with Open Transactions.</span>
<a name="l00090"></a>00090 <span class="comment"> *   See Open-Transactions/src/otlib/lucre/LUCRE_LICENSE.txt</span>
<a name="l00091"></a>00091 <span class="comment"> *   The Laurie requirements are light, but if there is any</span>
<a name="l00092"></a>00092 <span class="comment"> *   problem with his license, simply remove the Lucre code.</span>
<a name="l00093"></a>00093 <span class="comment"> *   Although there are no other blind token algorithms in Open</span>
<a name="l00094"></a>00094 <span class="comment"> *   Transactions (yet. credlib is coming), the other functions</span>
<a name="l00095"></a>00095 <span class="comment"> *   will continue to operate.</span>
<a name="l00096"></a>00096 <span class="comment"> *   See Lucre on Github:  https://github.com/benlaurie/lucre</span>
<a name="l00097"></a>00097 <span class="comment"> *   -----------------------------------------------------</span>
<a name="l00098"></a>00098 <span class="comment"> *   You should have received a copy of the GNU Affero General</span>
<a name="l00099"></a>00099 <span class="comment"> *   Public License along with this program.  If not, see:</span>
<a name="l00100"></a>00100 <span class="comment"> *   http://www.gnu.org/licenses/</span>
<a name="l00101"></a>00101 <span class="comment"> *</span>
<a name="l00102"></a>00102 <span class="comment"> *   If you would like to use this software outside of the free</span>
<a name="l00103"></a>00103 <span class="comment"> *   software license, please contact FellowTraveler.</span>
<a name="l00104"></a>00104 <span class="comment"> *   (Unfortunately many will run anonymously and untraceably,</span>
<a name="l00105"></a>00105 <span class="comment"> *   so who could really stop them?)</span>
<a name="l00106"></a>00106 <span class="comment"> *</span>
<a name="l00107"></a>00107 <span class="comment"> *   DISCLAIMER:</span>
<a name="l00108"></a>00108 <span class="comment"> *   This program is distributed in the hope that it will be</span>
<a name="l00109"></a>00109 <span class="comment"> *   useful, but WITHOUT ANY WARRANTY; without even the implied</span>
<a name="l00110"></a>00110 <span class="comment"> *   warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR</span>
<a name="l00111"></a>00111 <span class="comment"> *   PURPOSE.  See the GNU Affero General Public License for</span>
<a name="l00112"></a>00112 <span class="comment"> *   more details.</span>
<a name="l00113"></a>00113 <span class="comment"></span>
<a name="l00114"></a>00114 <span class="comment"> -----BEGIN PGP SIGNATURE-----</span>
<a name="l00115"></a>00115 <span class="comment"> Version: GnuPG v1.4.9 (Darwin)</span>
<a name="l00116"></a>00116 <span class="comment"></span>
<a name="l00117"></a>00117 <span class="comment"> iQIcBAEBAgAGBQJRSsfJAAoJEAMIAO35UbuOQT8P/RJbka8etf7wbxdHQNAY+2cC</span>
<a name="l00118"></a>00118 <span class="comment"> vDf8J3X8VI+pwMqv6wgTVy17venMZJa4I4ikXD/MRyWV1XbTG0mBXk/7AZk7Rexk</span>
<a name="l00119"></a>00119 <span class="comment"> KTvL/U1kWiez6+8XXLye+k2JNM6v7eej8xMrqEcO0ZArh/DsLoIn1y8p8qjBI7+m</span>
<a name="l00120"></a>00120 <span class="comment"> aE7lhstDiD0z8mwRRLKFLN2IH5rAFaZZUvj5ERJaoYUKdn4c+RcQVei2YOl4T0FU</span>
<a name="l00121"></a>00121 <span class="comment"> LWND3YLoH8naqJXkaOKEN4UfJINCwxhe5Ke9wyfLWLUO7NamRkWD2T7CJ0xocnD1</span>
<a name="l00122"></a>00122 <span class="comment"> sjAzlVGNgaFDRflfIF4QhBx1Ddl6wwhJfw+d08bjqblSq8aXDkmFA7HeunSFKkdn</span>
<a name="l00123"></a>00123 <span class="comment"> oIEOEgyj+veuOMRJC5pnBJ9vV+7qRdDKQWaCKotynt4sWJDGQ9kWGWm74SsNaduN</span>
<a name="l00124"></a>00124 <span class="comment"> TPMyr9kNmGsfR69Q2Zq/FLcLX/j8ESxU+HYUB4vaARw2xEOu2xwDDv6jt0j3Vqsg</span>
<a name="l00125"></a>00125 <span class="comment"> x7rWv4S/Eh18FDNDkVRChiNoOIilLYLL6c38uMf1pnItBuxP3uhgY6COm59kVaRh</span>
<a name="l00126"></a>00126 <span class="comment"> nyGTYCDYD2TK+fI9o89F1297uDCwEJ62U0Q7iTDp5QuXCoxkPfv8/kX6lS6T3y9G</span>
<a name="l00127"></a>00127 <span class="comment"> M9mqIoLbIQ1EDntFv7/t6fUTS2+46uCrdZWbQ5RjYXdrzjij02nDmJAm2BngnZvd</span>
<a name="l00128"></a>00128 <span class="comment"> kamH0Y/n11lCvo1oQxM+</span>
<a name="l00129"></a>00129 <span class="comment"> =uSzz</span>
<a name="l00130"></a>00130 <span class="comment"> -----END PGP SIGNATURE-----</span>
<a name="l00131"></a>00131 <span class="comment"> **************************************************************/</span>
<a name="l00132"></a>00132 
<a name="l00133"></a>00133 <span class="preprocessor">#ifndef __OT_PASSWORD_HPP__</span>
<a name="l00134"></a>00134 <span class="preprocessor"></span><span class="preprocessor">#define __OT_PASSWORD_HPP__</span>
<a name="l00135"></a>00135 <span class="preprocessor"></span>
<a name="l00136"></a>00136 <span class="preprocessor">#include &lt;string&gt;</span>
<a name="l00137"></a>00137 
<a name="l00138"></a>00138 <span class="preprocessor">#include &quot;<a class="code" href="_o_t_common_8hpp.html">OTCommon.hpp</a>&quot;</span>
<a name="l00139"></a>00139 
<a name="l00140"></a>00140 <span class="preprocessor">#include &quot;<a class="code" href="_o_t_cached_key_8hpp.html">OTCachedKey.hpp</a>&quot;</span>
<a name="l00141"></a>00141 <span class="preprocessor">#include &quot;<a class="code" href="_o_t_password_data_8hpp.html">OTPasswordData.hpp</a>&quot;</span>
<a name="l00142"></a>00142 
<a name="l00143"></a>00143 <span class="keyword">class </span><a class="code" href="class_o_t_string.html">OTString</a>;
<a name="l00144"></a>00144 <span class="keyword">class </span><a class="code" href="class_o_t_password.html">OTPassword</a>;
<a name="l00145"></a>00145 
<a name="l00146"></a>00146 
<a name="l00147"></a>00147 <span class="comment">/*</span>
<a name="l00148"></a>00148 <span class="comment"> To use:</span>
<a name="l00149"></a>00149 <span class="comment"></span>
<a name="l00150"></a>00150 <span class="comment"> OTPassword thePass;</span>
<a name="l00151"></a>00151 <span class="comment"> (Or...)</span>
<a name="l00152"></a>00152 <span class="comment"> OTPassword thePass(strPassword, strPassword.length());</span>
<a name="l00153"></a>00153 <span class="comment"></span>
<a name="l00154"></a>00154 <span class="comment"> const char * szPassword    = thePass.getPassword();</span>
<a name="l00155"></a>00155 <span class="comment"> const int32_t    nPassLength   = thePass.getPasswordSize();</span>
<a name="l00156"></a>00156 <span class="comment"></span>
<a name="l00157"></a>00157 <span class="comment"> If the instance of OTPassword is not going to be destroyed immediately</span>
<a name="l00158"></a>00158 <span class="comment"> after the password is used, then make sure to call zeroMemory() after</span>
<a name="l00159"></a>00159 <span class="comment"> using the password. (Otherwise the destructor will handle this anyway.)</span>
<a name="l00160"></a>00160 <span class="comment"></span>
<a name="l00161"></a>00161 <span class="comment"> (The primary purpose of this class is that it zeros its memory out when</span>
<a name="l00162"></a>00162 <span class="comment"> it is destructed.)</span>
<a name="l00163"></a>00163 <span class="comment"></span>
<a name="l00164"></a>00164 <span class="comment"> This class gives me a safe way to hand-off a password, and off-load the</span>
<a name="l00165"></a>00165 <span class="comment"> handling risk to the user.  This class will be included as part of the</span>
<a name="l00166"></a>00166 <span class="comment"> OT-API SWIG interface so that it&#39;s available inside other languages.</span>
<a name="l00167"></a>00167 <span class="comment"></span>
<a name="l00168"></a>00168 <span class="comment"> */</span>
<a name="l00169"></a>00169 
<a name="l00170"></a><a class="code" href="_o_t_password_8hpp.html#aec99f1909896090ab9b64ce848f50c6a">00170</a> <span class="preprocessor">#define OT_PW_DISPLAY  &quot;Enter master passphrase for wallet.&quot;</span>
<a name="l00171"></a>00171 <span class="preprocessor"></span>
<a name="l00172"></a><a class="code" href="_o_t_password_8hpp.html#a8518e246a1f6b70e0405cbfecf84a38c">00172</a> <span class="preprocessor">#define OTPASSWORD_BLOCKSIZE    128     // (128 bytes max length for a password.)</span>
<a name="l00173"></a><a class="code" href="_o_t_password_8hpp.html#a29efd6c1e01f94b52ecfc0af842c90f5">00173</a> <span class="preprocessor"></span><span class="preprocessor">#define OTPASSWORD_MEMSIZE      129     // +1 for null terminator.</span>
<a name="l00174"></a>00174 <span class="preprocessor"></span>
<a name="l00175"></a>00175 <span class="comment">// UPDATE: Increasing the size here, so we can accommodate private keys (in addition to passphrases.)</span>
<a name="l00176"></a>00176 <span class="comment">//</span>
<a name="l00177"></a><a class="code" href="_o_t_password_8hpp.html#a51a1439766783d2bbaf65be07c1a84cd">00177</a> <span class="preprocessor">#define OT_LARGE_BLOCKSIZE  32767       // (32767 bytes max length for a password.)</span>
<a name="l00178"></a><a class="code" href="_o_t_password_8hpp.html#a8bf7db7c739d4f0c02f147772a4b5c01">00178</a> <span class="preprocessor"></span><span class="preprocessor">#define OT_LARGE_MEMSIZE    32768       // +1 for null terminator.</span>
<a name="l00179"></a>00179 <span class="preprocessor"></span>
<a name="l00180"></a>00180 <span class="comment">// Default is the smaller size.</span>
<a name="l00181"></a><a class="code" href="_o_t_password_8hpp.html#a4bf178a2177ef80b8f15cc855efb7694">00181</a> <span class="preprocessor">#define OT_DEFAULT_BLOCKSIZE  128</span>
<a name="l00182"></a><a class="code" href="_o_t_password_8hpp.html#a35d72f69016b0e6ee7e71b3c153874c4">00182</a> <span class="preprocessor"></span><span class="preprocessor">#define OT_DEFAULT_MEMSIZE    129</span>
<a name="l00183"></a>00183 <span class="preprocessor"></span>
<a name="l00184"></a>00184 
<a name="l00185"></a>00185 <span class="comment">// https://github.com/lorf/keepassx/blob/master/src/lib/SecString.cpp</span>
<a name="l00186"></a>00186 
<a name="l00187"></a>00187 <span class="comment">// Done:  Although we have good memory ZEROING code (for destruction)</span>
<a name="l00188"></a>00188 <span class="comment">// we don&#39;t have code yet that will keep the contents SECURE while they</span>
<a name="l00189"></a>00189 <span class="comment">// are in memory. For example, that will prevent them from being paged</span>
<a name="l00190"></a>00190 <span class="comment">// to the hard drive during swapping. Such code would make OTPassword much</span>
<a name="l00191"></a>00191 <span class="comment">// more appropriate for use cases such as storing passphrases and private</span>
<a name="l00192"></a>00192 <span class="comment">// keys, and would even allow timeout procedures...</span>
<a name="l00193"></a>00193 <span class="comment">//</span>
<a name="l00194"></a>00194 <span class="comment">// NOTE: For Windows, use VirtualLock instead of mlock.</span>
<a name="l00195"></a>00195 <span class="comment">//</span>
<a name="l00196"></a>00196 
<a name="l00197"></a>00197 <span class="comment">/*</span>
<a name="l00198"></a>00198 <span class="comment"> #include &lt;sys/mman.h&gt;</span>
<a name="l00199"></a>00199 <span class="comment"></span>
<a name="l00200"></a>00200 <span class="comment"> void *locking_alloc(size_t numbytes)</span>
<a name="l00201"></a>00201 <span class="comment"> {</span>
<a name="l00202"></a>00202 <span class="comment">    static short have_warned = 0;</span>
<a name="l00203"></a>00203 <span class="comment"></span>
<a name="l00204"></a>00204 <span class="comment">    void *mem = malloc(numbytes);</span>
<a name="l00205"></a>00205 <span class="comment"></span>
<a name="l00206"></a>00206 <span class="comment">    if (mlock(mem, numbytes) &amp;&amp; !have_warned)</span>
<a name="l00207"></a>00207 <span class="comment">    {</span>
<a name="l00208"></a>00208 <span class="comment"></span>
<a name="l00209"></a>00209 <span class="comment">        // We probably do not have permission.</span>
<a name="l00210"></a>00210 <span class="comment">        // Sometimes, it might not be possible to lock enough memory.</span>
<a name="l00211"></a>00211 <span class="comment"></span>
<a name="l00212"></a>00212 <span class="comment">        fprintf(stderr, &quot;Warning: Using insecure memory!\n&quot;);</span>
<a name="l00213"></a>00213 <span class="comment"></span>
<a name="l00214"></a>00214 <span class="comment">        have_warned = 1;</span>
<a name="l00215"></a>00215 <span class="comment"></span>
<a name="l00216"></a>00216 <span class="comment">    }</span>
<a name="l00217"></a>00217 <span class="comment"></span>
<a name="l00218"></a>00218 <span class="comment">    return mem;</span>
<a name="l00219"></a>00219 <span class="comment"> }</span>
<a name="l00220"></a>00220 <span class="comment"></span>
<a name="l00221"></a>00221 <span class="comment">The mlock() call generally locks more memory than you want. Locking is done on a per-page basis. All of the pages the memory spans will be locked in RAM, and will not be swapped out under any circumstances, until the process unlocks something in the same page by using mlock().</span>
<a name="l00222"></a>00222 <span class="comment"></span>
<a name="l00223"></a>00223 <span class="comment">There are some potentially negative consequences here. First, If your process locks two buffers that happen to live on the same page, then unlocking either one will unlock the entire page, causing both buffers to unlock. Second, when locking lots of data, it is easy to lock more pages than necessary (the operating system doesn&#39;t move data around once it has been allocated), which can slow down machine performance significantly.</span>
<a name="l00224"></a>00224 <span class="comment"></span>
<a name="l00225"></a>00225 <span class="comment">Unlocking a chunk of memory looks exactly the same as locking it, except that you call munlock():</span>
<a name="l00226"></a>00226 <span class="comment">        munlock(mem, numbytes);</span>
<a name="l00227"></a>00227 <span class="comment"></span>
<a name="l00228"></a>00228 <span class="comment"></span>
<a name="l00229"></a>00229 <span class="comment"> // TODO: Work in some usage of CryptProtectMemory and CryptUnprotectMemory (Windows only)</span>
<a name="l00230"></a>00230 <span class="comment"> // with sample code below.  Also should make some kind of UNIX version.</span>
<a name="l00231"></a>00231 <span class="comment"></span>
<a name="l00232"></a>00232 <span class="comment"></span>
<a name="l00233"></a>00233 <span class="comment">#ifndef _WINDOWS_</span>
<a name="l00234"></a>00234 <span class="comment">#ifndef WIN32_LEAN_AND_MEAN</span>
<a name="l00235"></a>00235 <span class="comment">#define WIN32_LEAN_AND_MEAN</span>
<a name="l00236"></a>00236 <span class="comment">#endif</span>
<a name="l00237"></a>00237 <span class="comment">#include &lt;windows.h&gt;</span>
<a name="l00238"></a>00238 <span class="comment">#endif</span>
<a name="l00239"></a>00239 <span class="comment">#include &lt;cstdio&gt;</span>
<a name="l00240"></a>00240 <span class="comment">#include &lt;Wincrypt.h&gt;</span>
<a name="l00241"></a>00241 <span class="comment"></span>
<a name="l00242"></a>00242 <span class="comment">#define SSN_STR_LEN 12  // includes null</span>
<a name="l00243"></a>00243 <span class="comment"></span>
<a name="l00244"></a>00244 <span class="comment">void main()</span>
<a name="l00245"></a>00245 <span class="comment">{</span>
<a name="l00246"></a>00246 <span class="comment">    HRESULT hr = S_OK;</span>
<a name="l00247"></a>00247 <span class="comment">    LPWSTR pSensitiveText = NULL;</span>
<a name="l00248"></a>00248 <span class="comment">    DWORD cbSensitiveText = 0;</span>
<a name="l00249"></a>00249 <span class="comment">    DWORD cbPlainText = SSN_STR_LEN*sizeof(WCHAR);</span>
<a name="l00250"></a>00250 <span class="comment">    DWORD dwMod = 0;</span>
<a name="l00251"></a>00251 <span class="comment"></span>
<a name="l00252"></a>00252 <span class="comment">    //  Memory to encrypt must be a multiple of CRYPTPROTECTMEMORY_BLOCK_SIZE.</span>
<a name="l00253"></a>00253 <span class="comment">    if (dwMod = cbPlainText % CRYPTPROTECTMEMORY_BLOCK_SIZE)</span>
<a name="l00254"></a>00254 <span class="comment">        cbSensitiveText = cbPlainText +</span>
<a name="l00255"></a>00255 <span class="comment">        (CRYPTPROTECTMEMORY_BLOCK_SIZE - dwMod);</span>
<a name="l00256"></a>00256 <span class="comment">    else</span>
<a name="l00257"></a>00257 <span class="comment">        cbSensitiveText = cbPlainText;</span>
<a name="l00258"></a>00258 <span class="comment"></span>
<a name="l00259"></a>00259 <span class="comment">    pSensitiveText = (LPWSTR)LocalAlloc(LPTR, cbSensitiveText);</span>
<a name="l00260"></a>00260 <span class="comment">    if (NULL == pSensitiveText)</span>
<a name="l00261"></a>00261 <span class="comment">    {</span>
<a name="l00262"></a>00262 <span class="comment">        wprintf(L&quot;Memory allocation failed.\n&quot;);</span>
<a name="l00263"></a>00263 <span class="comment">        return E_OUTOFMEMORY;</span>
<a name="l00264"></a>00264 <span class="comment">    }</span>
<a name="l00265"></a>00265 <span class="comment"></span>
<a name="l00266"></a>00266 <span class="comment">    //  Place sensitive string to encrypt in pSensitiveText.</span>
<a name="l00267"></a>00267 <span class="comment"></span>
<a name="l00268"></a>00268 <span class="comment">    if (!CryptProtectMemory(pSensitiveText, cbSensitiveText,</span>
<a name="l00269"></a>00269 <span class="comment">        CRYPTPROTECTMEMORY_SAME_PROCESS))</span>
<a name="l00270"></a>00270 <span class="comment">    {</span>
<a name="l00271"></a>00271 <span class="comment">        wprintf(L&quot;CryptProtectMemory failed: %d\n&quot;, GetLastError());</span>
<a name="l00272"></a>00272 <span class="comment">        SecureZeroMemory(pSensitiveText, cbSensitiveText);</span>
<a name="l00273"></a>00273 <span class="comment">        LocalFree(pSensitiveText);</span>
<a name="l00274"></a>00274 <span class="comment">        pSensitiveText = NULL;</span>
<a name="l00275"></a>00275 <span class="comment">        return E_FAIL;</span>
<a name="l00276"></a>00276 <span class="comment">    }</span>
<a name="l00277"></a>00277 <span class="comment"></span>
<a name="l00278"></a>00278 <span class="comment">    //  Call CryptUnprotectMemory to decrypt and use the memory.</span>
<a name="l00279"></a>00279 <span class="comment"></span>
<a name="l00280"></a>00280 <span class="comment">    SecureZeroMemory(pSensitiveText, cbSensitiveText);</span>
<a name="l00281"></a>00281 <span class="comment">    LocalFree(pSensitiveText);</span>
<a name="l00282"></a>00282 <span class="comment">    pSensitiveText = NULL;</span>
<a name="l00283"></a>00283 <span class="comment"></span>
<a name="l00284"></a>00284 <span class="comment">    return hr;</span>
<a name="l00285"></a>00285 <span class="comment">}</span>
<a name="l00286"></a>00286 <span class="comment"></span>
<a name="l00287"></a>00287 <span class="comment"></span>
<a name="l00288"></a>00288 <span class="comment"></span>
<a name="l00289"></a>00289 <span class="comment"></span>
<a name="l00290"></a>00290 <span class="comment">#ifndef _WINDOWS_</span>
<a name="l00291"></a>00291 <span class="comment">#ifndef WIN32_LEAN_AND_MEAN</span>
<a name="l00292"></a>00292 <span class="comment">#define WIN32_LEAN_AND_MEAN</span>
<a name="l00293"></a>00293 <span class="comment">#endif</span>
<a name="l00294"></a>00294 <span class="comment">#include &lt;windows.h&gt;</span>
<a name="l00295"></a>00295 <span class="comment">#endif</span>
<a name="l00296"></a>00296 <span class="comment">#include &lt;cstdio&gt;</span>
<a name="l00297"></a>00297 <span class="comment">#include &lt;Wincrypt.h&gt;</span>
<a name="l00298"></a>00298 <span class="comment">#include &lt;strsafe.h&gt;</span>
<a name="l00299"></a>00299 <span class="comment">#pragma comment(lib, &quot;crypt32.lib&quot;)</span>
<a name="l00300"></a>00300 <span class="comment"></span>
<a name="l00301"></a>00301 <span class="comment">void main()</span>
<a name="l00302"></a>00302 <span class="comment">{</span>
<a name="l00303"></a>00303 <span class="comment">    LPWSTR pEncryptedText;  // contains the encrypted text</span>
<a name="l00304"></a>00304 <span class="comment">    DWORD cbEncryptedText;  // number of bytes to which</span>
<a name="l00305"></a>00305 <span class="comment">                            // pEncryptedText points</span>
<a name="l00306"></a>00306 <span class="comment"></span>
<a name="l00307"></a>00307 <span class="comment">    if (CryptUnprotectMemory(pEncryptedText, cbEncryptedText,</span>
<a name="l00308"></a>00308 <span class="comment">        CRYPTPROTECTMEMORY_SAME_PROCESS))</span>
<a name="l00309"></a>00309 <span class="comment">    {</span>
<a name="l00310"></a>00310 <span class="comment">        // Use the decrypted string.</span>
<a name="l00311"></a>00311 <span class="comment">    }</span>
<a name="l00312"></a>00312 <span class="comment">    else</span>
<a name="l00313"></a>00313 <span class="comment">    {</span>
<a name="l00314"></a>00314 <span class="comment">        wprintf(L&quot;CryptUnprotectMemory failed: %d\n&quot;,</span>
<a name="l00315"></a>00315 <span class="comment">            GetLastError());</span>
<a name="l00316"></a>00316 <span class="comment">    }</span>
<a name="l00317"></a>00317 <span class="comment"></span>
<a name="l00318"></a>00318 <span class="comment">    // Clear and free memory after using</span>
<a name="l00319"></a>00319 <span class="comment">    // the decrypted string or if an error occurs.</span>
<a name="l00320"></a>00320 <span class="comment">    SecureZeroMemory(pEncryptedText, cbEncryptedText);</span>
<a name="l00321"></a>00321 <span class="comment">    LocalFree(pEncryptedText);</span>
<a name="l00322"></a>00322 <span class="comment">    pEncryptedText = NULL;</span>
<a name="l00323"></a>00323 <span class="comment">}</span>
<a name="l00324"></a>00324 <span class="comment"></span>
<a name="l00325"></a>00325 <span class="comment"></span>
<a name="l00326"></a>00326 <span class="comment"> */</span>
<a name="l00327"></a>00327 
<a name="l00328"></a>00328 <span class="comment">// Originally written for the safe storage of passwords.</span>
<a name="l00329"></a>00329 <span class="comment">// Now used for symmetric keys as well.</span>
<a name="l00330"></a>00330 <span class="comment">// Specifically: when the clear version of a password or key must be stored</span>
<a name="l00331"></a>00331 <span class="comment">// usually for temporary reasons, it must be stored in memory locked from swapping</span>
<a name="l00332"></a>00332 <span class="comment">// to disk, and in an object like OTPassword that zeros the memory as soon as we&#39;re done.</span>
<a name="l00333"></a>00333 <span class="comment">//</span>
<a name="l00334"></a><a class="code" href="class_o_t_password.html">00334</a> <span class="keyword">class </span><a class="code" href="class_o_t_password.html">OTPassword</a>
<a name="l00335"></a>00335 {
<a name="l00336"></a>00336 <span class="keyword">public</span>:
<a name="l00337"></a><a class="code" href="class_o_t_password.html#afc1245b2e652a77f0415174795117923">00337</a>     <span class="keyword">enum</span> <a class="code" href="class_o_t_password.html#afc1245b2e652a77f0415174795117923">BlockSize</a>
<a name="l00338"></a>00338         {
<a name="l00339"></a><a class="code" href="class_o_t_password.html#afc1245b2e652a77f0415174795117923a4e1166a2183ba066efb66f133ec92b05">00339</a>             <a class="code" href="class_o_t_password.html#afc1245b2e652a77f0415174795117923a4e1166a2183ba066efb66f133ec92b05">DEFAULT_SIZE</a> = <a class="code" href="_o_t_password_8hpp.html#a4bf178a2177ef80b8f15cc855efb7694">OT_DEFAULT_BLOCKSIZE</a>,  <span class="comment">// (128 bytes max length for a password.)</span>
<a name="l00340"></a><a class="code" href="class_o_t_password.html#afc1245b2e652a77f0415174795117923ab3f2b8f631c9271b5139de430f2176b3">00340</a>             <a class="code" href="class_o_t_password.html#afc1245b2e652a77f0415174795117923ab3f2b8f631c9271b5139de430f2176b3">LARGER_SIZE</a>  = <a class="code" href="_o_t_password_8hpp.html#a51a1439766783d2bbaf65be07c1a84cd">OT_LARGE_BLOCKSIZE</a>     <span class="comment">// Update: now 32767 bytes if you use this size.</span>
<a name="l00341"></a>00341         };
<a name="l00342"></a>00342 
<a name="l00343"></a>00343 <span class="keyword">private</span>:
<a name="l00344"></a>00344     uint32_t m_nPasswordSize; <span class="comment">// [ 0..128 ]  Update: [ 0..9000 ]</span>
<a name="l00345"></a>00345     uint8_t  m_szPassword[<a class="code" href="_o_t_password_8hpp.html#a35d72f69016b0e6ee7e71b3c153874c4">OT_DEFAULT_MEMSIZE</a>]; <span class="comment">// a 129-byte block of char. (128 + 1 for null terminator)</span>
<a name="l00346"></a>00346 <span class="comment">//  uint8_t  m_szPassword[OT_LARGE_MEMSIZE];   // 32767 bytes. (32768 + 1 for null terminator) todo: in optimization phase, revisit this array size.</span>
<a name="l00347"></a>00347 
<a name="l00348"></a>00348     <span class="comment">// OTPassword tries to store a piece of data more securely.</span>
<a name="l00349"></a>00349     <span class="comment">// During the time I have to take a password from the user and pass it to OpenSSL,</span>
<a name="l00350"></a>00350     <span class="comment">// I want it stored as securely as possible, and that&#39;s what this class was written for.</span>
<a name="l00351"></a>00351     <span class="comment">// Now I&#39;m adding the ability to store binary data in here, not just a text-based password.</span>
<a name="l00352"></a>00352     <span class="comment">// That way, OTSymmetricKey can store its plain key in an OTPassword. Well, it actually stores</span>
<a name="l00353"></a>00353     <span class="comment">// its key in an encrypted format, but whenever, for what brief moments that key is decrypted and</span>
<a name="l00354"></a>00354     <span class="comment">// USED, the decrypted form of it will be stored in an OTPassword (in binary mode.)</span>
<a name="l00355"></a>00355     <span class="comment">// This is basically just to save me from duplicating work that&#39;s already done here in OTPassword.</span>
<a name="l00356"></a>00356     <span class="comment">//</span>
<a name="l00357"></a>00357     <span class="keywordtype">bool</span>    m_bIsText;          <span class="comment">// storing a text passphrase?</span>
<a name="l00358"></a>00358     <span class="keywordtype">bool</span>    m_bIsBinary;        <span class="comment">// storing binary memory?</span>
<a name="l00359"></a>00359     <span class="keywordtype">bool</span>    m_bIsPageLocked;    <span class="comment">// is the page locked to prevent us from swapping this secret memory to disk?</span>
<a name="l00360"></a>00360 
<a name="l00361"></a>00361 <span class="keyword">public</span>:
<a name="l00362"></a><a class="code" href="class_o_t_password.html#aea5370f41e798ca581ee8e02bbd15f72">00362</a>         <span class="keyword">const</span>       <a class="code" href="class_o_t_password.html#afc1245b2e652a77f0415174795117923">BlockSize</a>   <a class="code" href="class_o_t_password.html#aea5370f41e798ca581ee8e02bbd15f72">m_theBlockSize</a>;
<a name="l00363"></a>00363     <span class="comment">// -----------------</span>
<a name="l00364"></a>00364 EXPORT  <span class="keywordtype">bool</span>        <a class="code" href="class_o_t_password.html#a9ff2880813b81165a350c92e930ba311">isPassword</a>() <span class="keyword">const</span>;
<a name="l00365"></a>00365 EXPORT  <span class="keyword">const</span>       uint8_t *   <a class="code" href="class_o_t_password.html#a191412ad42e97cd3d36cc4f03068ab68">getPassword_uint8</a>() <span class="keyword">const</span>; <span class="comment">// asserts if m_bIsText is false.</span>
<a name="l00366"></a>00366 
<a name="l00367"></a>00367 EXPORT  <span class="keyword">const</span>       <span class="keywordtype">char</span> *      <a class="code" href="class_o_t_password.html#a2b3bc99637b0b01f9b4ffcae78abc5b4">getPassword</a>()   <span class="keyword">const</span>; <span class="comment">// asserts if m_bIsText is false.</span>
<a name="l00368"></a>00368 EXPORT              uint8_t *   <a class="code" href="class_o_t_password.html#a56c45901d84195e2f0fcfcf4be9eca3d">getPasswordWritable</a>(); <span class="comment">// asserts if m_bIsText is false.</span>
<a name="l00369"></a>00369 EXPORT              <span class="keywordtype">char</span> *      <a class="code" href="class_o_t_password.html#a76a7156aa0d0d87a7eb3b9b5b869e014">getPasswordWritable_char</a>(); <span class="comment">// asserts if m_bIsText is false.</span>
<a name="l00370"></a>00370 
<a name="l00371"></a>00371 EXPORT              int32_t         <a class="code" href="class_o_t_password.html#a251ed5100b869ae4b80166453e75e964">setPassword</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> * szInput, int32_t nInputSize); <span class="comment">// (FYI, truncates if nInputSize larger than getBlockSize.)</span>
<a name="l00372"></a>00372 EXPORT              int32_t     <a class="code" href="class_o_t_password.html#a3284608f45ab63f567944e014b92895d">setPassword_uint8</a>(<span class="keyword">const</span> uint8_t * szInput, uint32_t nInputSize); <span class="comment">// (FYI, truncates if nInputSize larger than getBlockSize.)</span>
<a name="l00373"></a>00373 EXPORT              <span class="keywordtype">bool</span>        <a class="code" href="class_o_t_password.html#aa69787104515ab8c93265613e2cff5ff">addChar</a>(uint8_t theChar);
<a name="l00374"></a>00374     <span class="comment">// ---------------------</span>
<a name="l00375"></a>00375 EXPORT              int32_t     <a class="code" href="class_o_t_password.html#a0e4664e731c30f8a7a8f83a2e20f907f">randomizePassword</a>(uint32_t nNewSize=<a class="code" href="class_o_t_password.html#afc1245b2e652a77f0415174795117923a4e1166a2183ba066efb66f133ec92b05">DEFAULT_SIZE</a>);
<a name="l00376"></a>00376     <span class="comment">// -----------------</span>
<a name="l00377"></a>00377 EXPORT  <span class="keyword">static</span>      <span class="keywordtype">bool</span>        <a class="code" href="class_o_t_password.html#aa1b201e2d59dae5e310fce2e0c423b2e">randomizePassword_uint8</a>(uint8_t * szDestination, uint32_t nNewSize);
<a name="l00378"></a>00378 EXPORT  <span class="keyword">static</span>      <span class="keywordtype">bool</span>        <a class="code" href="class_o_t_password.html#a0e4664e731c30f8a7a8f83a2e20f907f">randomizePassword</a>(<span class="keywordtype">char</span> * szDestination, uint32_t nNewSize);
<a name="l00379"></a>00379     <span class="comment">// -----------------</span>
<a name="l00380"></a>00380 EXPORT              <span class="keywordtype">bool</span>        <a class="code" href="class_o_t_password.html#a59342b6d2f7224d6436e4950d0432612">isMemory</a>()  <span class="keyword">const</span>;
<a name="l00381"></a>00381 EXPORT  <span class="keyword">const</span>       <span class="keywordtype">void</span> *      <a class="code" href="class_o_t_password.html#a459b9d47965257f2180bf925fc82324c">getMemory</a>() <span class="keyword">const</span>; <span class="comment">// asserts if m_bIsBinary is false.</span>
<a name="l00382"></a>00382 EXPORT  <span class="keyword">const</span>       uint8_t *   <a class="code" href="class_o_t_password.html#af3c2834981627910da5408018c588ad1">getMemory_uint8</a>() <span class="keyword">const</span>; <span class="comment">// asserts if m_bIsBinary is false.</span>
<a name="l00383"></a>00383 EXPORT              <span class="keywordtype">void</span> *      <a class="code" href="class_o_t_password.html#a989c3d6d8546c1f5350433a431d8c252">getMemoryWritable</a>(); <span class="comment">// asserts if m_bIsBinary is false.</span>
<a name="l00384"></a>00384 EXPORT              int32_t     <a class="code" href="class_o_t_password.html#ab59ffd8ebd2da40cea868865a55c12ef">setMemory</a>(<span class="keyword">const</span> <span class="keywordtype">void</span> * vInput,  uint32_t nInputSize);  <span class="comment">// (FYI, truncates if nInputSize larger than getBlockSize.)</span>
<a name="l00385"></a>00385 EXPORT              int32_t     <a class="code" href="class_o_t_password.html#a75332e6591d69ec8a090fcef54856579">addMemory</a>(<span class="keyword">const</span> <span class="keywordtype">void</span> * vAppend, uint32_t nAppendSize); <span class="comment">// (FYI, truncates if nInputSize + getPasswordSize() is larger than getBlockSize.)</span>
<a name="l00386"></a>00386     <span class="comment">// ---------------------</span>
<a name="l00387"></a>00387 EXPORT              int32_t     <a class="code" href="class_o_t_password.html#afcf148c0f8fdc26702d9448e97cedcc4">randomizeMemory</a>(uint32_t nNewSize=<a class="code" href="class_o_t_password.html#afc1245b2e652a77f0415174795117923a4e1166a2183ba066efb66f133ec92b05">DEFAULT_SIZE</a>);
<a name="l00388"></a>00388     <span class="comment">// -----------------</span>
<a name="l00389"></a>00389 EXPORT  <span class="keyword">static</span>      <span class="keywordtype">bool</span>        <a class="code" href="class_o_t_password.html#a585d5bb33b5435a8b491e8da20292016">randomizeMemory_uint8</a>(uint8_t * szDestination, uint32_t nNewSize);
<a name="l00390"></a>00390     <span class="comment">// -----------------</span>
<a name="l00391"></a>00391 EXPORT  <span class="keyword">static</span>      <span class="keywordtype">bool</span>        <a class="code" href="class_o_t_password.html#afcf148c0f8fdc26702d9448e97cedcc4">randomizeMemory</a>(<span class="keywordtype">void</span> * szDestination, uint32_t nNewSize);
<a name="l00392"></a>00392     <span class="comment">// -----------------</span>
<a name="l00393"></a>00393 EXPORT              uint32_t    <a class="code" href="class_o_t_password.html#a8a596bf908d5410df57568639d171fe7">getBlockSize</a>()    <span class="keyword">const</span>;
<a name="l00394"></a>00394 EXPORT              <span class="keywordtype">bool</span>        <a class="code" href="class_o_t_password.html#a35306a457b2150a2298baa4f2431940d">Compare</a>(<a class="code" href="class_o_t_password.html">OTPassword</a> &amp; rhs) <span class="keyword">const</span>;
<a name="l00395"></a>00395     <span class="comment">// ----------------------</span>
<a name="l00396"></a>00396 EXPORT              uint32_t    <a class="code" href="class_o_t_password.html#a849be9ea50ea9935feba18a9a0919fe5">getPasswordSize</a>() <span class="keyword">const</span>; <span class="comment">// asserts if m_bIsText is false.</span>
<a name="l00397"></a>00397 EXPORT              uint32_t    <a class="code" href="class_o_t_password.html#a9733667570f4ee91a4c8993d11f198a8">getMemorySize</a>()   <span class="keyword">const</span>; <span class="comment">// asserts if m_bIsBinary is false.</span>
<a name="l00398"></a>00398     <span class="comment">// -----------------</span>
<a name="l00399"></a>00399 EXPORT              <span class="keywordtype">void</span>        <a class="code" href="class_o_t_password.html#a3a971b06f42d1c89802167a0ab5330a5">zeroMemory</a>();
<a name="l00400"></a>00400     <span class="comment">// -----------------</span>
<a name="l00401"></a>00401 EXPORT  <span class="keyword">static</span>      <span class="keywordtype">void</span>        <a class="code" href="class_o_t_password.html#a3a971b06f42d1c89802167a0ab5330a5">zeroMemory</a>(uint8_t * szMemory, uint32_t theSize);
<a name="l00402"></a>00402 EXPORT  <span class="keyword">static</span>      <span class="keywordtype">void</span>        <a class="code" href="class_o_t_password.html#a3a971b06f42d1c89802167a0ab5330a5">zeroMemory</a>(<span class="keywordtype">void</span> * vMemory,     uint32_t theSize);
<a name="l00403"></a>00403     <span class="comment">// -----------------</span>
<a name="l00404"></a>00404 EXPORT  <span class="keyword">static</span>      <span class="keywordtype">void</span> *      <a class="code" href="class_o_t_password.html#aafc648fa0fdc462a670e9a39795a7b33">safe_memcpy</a>(<span class="keywordtype">void</span> *          dest,
<a name="l00405"></a>00405                                             uint32_t        dest_size,
<a name="l00406"></a>00406                                             <span class="keyword">const</span> <span class="keywordtype">void</span> *    src,
<a name="l00407"></a>00407                                             uint32_t        src_length,
<a name="l00408"></a>00408                                             <span class="keywordtype">bool</span>            bZeroSource=<span class="keyword">false</span>); <span class="comment">// if true, sets the source buffer to zero after copying is done.</span>
<a name="l00409"></a>00409     <span class="comment">// ---------------------------------------</span>
<a name="l00410"></a>00410     <span class="comment">// OTPassword thePass; will create a text password.</span>
<a name="l00411"></a>00411     <span class="comment">// But use the below function if you want one that has</span>
<a name="l00412"></a>00412     <span class="comment">// a text buffer of size (versus a 0 size.) This is for</span>
<a name="l00413"></a>00413     <span class="comment">// cases where you need the buffer to pre-exist so that</span>
<a name="l00414"></a>00414     <span class="comment">// some other function can populate that buffer directly.</span>
<a name="l00415"></a>00415     <span class="comment">// (Such as the OpenSSL password callback...)</span>
<a name="l00416"></a>00416     <span class="comment">// CALLER IS RESPONSIBLE TO DELETE.</span>
<a name="l00417"></a>00417     <span class="comment">//</span>
<a name="l00418"></a>00418 EXPORT  <span class="keyword">static</span> <a class="code" href="class_o_t_password.html">OTPassword</a> * <a class="code" href="class_o_t_password.html#a9d2847ff2f726967fbd7816be9b949bb">CreateTextBuffer</a>(); <span class="comment">// asserts already.</span>
<a name="l00419"></a>00419 
<a name="l00420"></a>00420     <span class="comment">// There are certain weird cases, like in OTSymmetricKey::GetPassphraseFromUser,</span>
<a name="l00421"></a>00421     <span class="comment">// where we set the password using the getPassword_writable, and it&#39;s properly</span>
<a name="l00422"></a>00422     <span class="comment">// null-terminated, yet this instance still doesn&#39;t know its actual size (even though</span>
<a name="l00423"></a>00423     <span class="comment">// the size is known.) Therefore I added this call in order to set the size in</span>
<a name="l00424"></a>00424     <span class="comment">// those odd cases where it&#39;s necessary. That being said, YOU should normally NEVER</span>
<a name="l00425"></a>00425     <span class="comment">// need to use this function, so just pretend it doesn&#39;t exist.</span>
<a name="l00426"></a>00426 EXPORT  <span class="keywordtype">bool</span> <a class="code" href="class_o_t_password.html#aa1a20005994cc550df4c72a2df2a2dee">SetSize</a>(uint32_t uSize);
<a name="l00427"></a>00427     <span class="comment">// ---------------------------------------</span>
<a name="l00428"></a>00428 EXPORT
<a name="l00429"></a>00429     <a class="code" href="class_o_t_password.html">OTPassword</a> &amp; <a class="code" href="class_o_t_password.html#a816d822dcb4254ca49281d33d8b1bd7f">operator=</a>(<span class="keyword">const</span> <a class="code" href="class_o_t_password.html">OTPassword</a> &amp; rhs);
<a name="l00430"></a>00430 EXPORT  <a class="code" href="class_o_t_password.html#a62630b501bb49ac3a83a15b7c5251363">OTPassword</a>(<a class="code" href="class_o_t_password.html#afc1245b2e652a77f0415174795117923">BlockSize</a> theBlockSize=<a class="code" href="class_o_t_password.html#afc1245b2e652a77f0415174795117923a4e1166a2183ba066efb66f133ec92b05">DEFAULT_SIZE</a>);
<a name="l00431"></a>00431 EXPORT  <a class="code" href="class_o_t_password.html#a62630b501bb49ac3a83a15b7c5251363">OTPassword</a>(<span class="keyword">const</span> <a class="code" href="class_o_t_password.html">OTPassword</a> &amp; rhs);
<a name="l00432"></a>00432 EXPORT  <a class="code" href="class_o_t_password.html#a62630b501bb49ac3a83a15b7c5251363">OTPassword</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>    * szInput, uint32_t nInputSize, <a class="code" href="class_o_t_password.html#afc1245b2e652a77f0415174795117923">BlockSize</a> theBlockSize=<a class="code" href="class_o_t_password.html#afc1245b2e652a77f0415174795117923a4e1166a2183ba066efb66f133ec92b05">DEFAULT_SIZE</a>);  <span class="comment">// text   / password stored.</span>
<a name="l00433"></a>00433 EXPORT  <a class="code" href="class_o_t_password.html#a62630b501bb49ac3a83a15b7c5251363">OTPassword</a>(<span class="keyword">const</span> uint8_t * szInput, uint32_t nInputSize, <a class="code" href="class_o_t_password.html#afc1245b2e652a77f0415174795117923">BlockSize</a> theBlockSize=<a class="code" href="class_o_t_password.html#afc1245b2e652a77f0415174795117923a4e1166a2183ba066efb66f133ec92b05">DEFAULT_SIZE</a>);  <span class="comment">// text   / password stored.</span>
<a name="l00434"></a>00434 EXPORT  <a class="code" href="class_o_t_password.html#a62630b501bb49ac3a83a15b7c5251363">OTPassword</a>(<span class="keyword">const</span> <span class="keywordtype">void</span>    * vInput,  uint32_t nInputSize, <a class="code" href="class_o_t_password.html#afc1245b2e652a77f0415174795117923">BlockSize</a> theBlockSize=<a class="code" href="class_o_t_password.html#afc1245b2e652a77f0415174795117923a4e1166a2183ba066efb66f133ec92b05">DEFAULT_SIZE</a>);  <span class="comment">// binary / symmetric key stored.</span>
<a name="l00435"></a>00435     <span class="comment">// -----------------</span>
<a name="l00436"></a>00436 EXPORT  <a class="code" href="class_o_t_password.html#a50d241be3e46369141c569ae518170af">~OTPassword</a>();
<a name="l00437"></a>00437 };
<a name="l00438"></a>00438 
<a name="l00439"></a>00439 
<a name="l00440"></a>00440 <span class="comment">//#undef OTPASSWORD_BLOCKSIZE</span>
<a name="l00441"></a>00441 <span class="comment">//#undef OTPASSWORD_MEMSIZE</span>
<a name="l00442"></a>00442 <span class="comment">//</span>
<a name="l00443"></a>00443 <span class="comment">//#undef OT_LARGE_BLOCKSIZE</span>
<a name="l00444"></a>00444 <span class="comment">//#undef OT_LARGE_MEMSIZE</span>
<a name="l00445"></a>00445 <span class="comment">//</span>
<a name="l00446"></a>00446 <span class="comment">//#undef OT_DEFAULT_BLOCKSIZE</span>
<a name="l00447"></a>00447 <span class="comment">//#undef OT_DEFAULT_MEMSIZE</span>
<a name="l00448"></a>00448 
<a name="l00449"></a>00449 
<a name="l00450"></a>00450 <span class="preprocessor">#include &quot;<a class="code" href="_o_t_callback_8hpp.html">OTCallback.hpp</a>&quot;</span>
<a name="l00451"></a>00451 
<a name="l00452"></a>00452 
<a name="l00453"></a>00453 <span class="preprocessor">#include &quot;<a class="code" href="_o_t_caller_8hpp.html">OTCaller.hpp</a>&quot;</span>
<a name="l00454"></a>00454 
<a name="l00455"></a>00455 
<a name="l00456"></a>00456 <span class="comment">/*</span>
<a name="l00457"></a>00457 <span class="comment"> HOW TO PREVENT MEMORY FROM GOING INTO CORE DUMPS</span>
<a name="l00458"></a>00458 <span class="comment"></span>
<a name="l00459"></a>00459 <span class="comment">#include &lt;sys/time.h&gt;</span>
<a name="l00460"></a>00460 <span class="comment"></span>
<a name="l00461"></a>00461 <span class="comment">#include &lt;sys/resource.h&gt;</span>
<a name="l00462"></a>00462 <span class="comment"></span>
<a name="l00463"></a>00463 <span class="comment">#include &lt;unistd.h&gt;</span>
<a name="l00464"></a>00464 <span class="comment"></span>
<a name="l00465"></a>00465 <span class="comment"></span>
<a name="l00466"></a>00466 <span class="comment"></span>
<a name="l00467"></a>00467 <span class="comment">int32_t  main(int32_t argc, char **argv)</span>
<a name="l00468"></a>00468 <span class="comment"></span>
<a name="l00469"></a>00469 <span class="comment"> {</span>
<a name="l00470"></a>00470 <span class="comment"></span>
<a name="l00471"></a>00471 <span class="comment">  struct rlimit rlim;</span>
<a name="l00472"></a>00472 <span class="comment"></span>
<a name="l00473"></a>00473 <span class="comment"></span>
<a name="l00474"></a>00474 <span class="comment"></span>
<a name="l00475"></a>00475 <span class="comment">  getrlimit(RLIMIT_CORE, &amp;rlim);</span>
<a name="l00476"></a>00476 <span class="comment"></span>
<a name="l00477"></a>00477 <span class="comment">  rlim.rlim_max = rlim.rlim_cur = 0;</span>
<a name="l00478"></a>00478 <span class="comment"></span>
<a name="l00479"></a>00479 <span class="comment">  if(setrlimit(RLIMIT_CORE, &amp;rlim)) {</span>
<a name="l00480"></a>00480 <span class="comment"></span>
<a name="l00481"></a>00481 <span class="comment">    exit(-1);</span>
<a name="l00482"></a>00482 <span class="comment"></span>
<a name="l00483"></a>00483 <span class="comment">  }</span>
<a name="l00484"></a>00484 <span class="comment"></span>
<a name="l00485"></a>00485 <span class="comment">  ...</span>
<a name="l00486"></a>00486 <span class="comment"></span>
<a name="l00487"></a>00487 <span class="comment">  return 0;</span>
<a name="l00488"></a>00488 <span class="comment"></span>
<a name="l00489"></a>00489 <span class="comment">}</span>
<a name="l00490"></a>00490 <span class="comment"></span>
<a name="l00491"></a>00491 <span class="comment"></span>
<a name="l00492"></a>00492 <span class="comment"></span>
<a name="l00493"></a>00493 <span class="comment"> http://www.drdobbs.com/cpp/184401646</span>
<a name="l00494"></a>00494 <span class="comment"></span>
<a name="l00495"></a>00495 <span class="comment"></span>
<a name="l00496"></a>00496 <span class="comment"></span>
<a name="l00497"></a>00497 <span class="comment"></span>
<a name="l00498"></a>00498 <span class="comment"> MORE CODE FOR MEMLOCK:</span>
<a name="l00499"></a>00499 <span class="comment"></span>
<a name="l00500"></a>00500 <span class="comment"> namespace Botan</span>
<a name="l00501"></a>00501 <span class="comment"> {</span>
<a name="l00502"></a>00502 <span class="comment"></span>
<a name="l00503"></a>00503 <span class="comment">    bool has_mlock();</span>
<a name="l00504"></a>00504 <span class="comment"></span>
<a name="l00505"></a>00505 <span class="comment">    bool lock_mem(void* addr, size_t length);</span>
<a name="l00506"></a>00506 <span class="comment"></span>
<a name="l00507"></a>00507 <span class="comment">    void unlock_mem(void* addr, size_t length);</span>
<a name="l00508"></a>00508 <span class="comment"> }</span>
<a name="l00509"></a>00509 <span class="comment"></span>
<a name="l00510"></a>00510 <span class="comment"></span>
<a name="l00511"></a>00511 <span class="comment">//</span>
<a name="l00512"></a>00512 <span class="comment">// Memory Locking Functions</span>
<a name="l00513"></a>00513 <span class="comment">// (C) 1999-2007 Jack Lloyd</span>
<a name="l00514"></a>00514 <span class="comment">//</span>
<a name="l00515"></a>00515 <span class="comment">// Distributed under the terms of the Botan license</span>
<a name="l00516"></a>00516 <span class="comment">//</span>
<a name="l00517"></a>00517 <span class="comment"></span>
<a name="l00518"></a>00518 <span class="comment">#include &lt;botan/internal/mlock.h&gt;</span>
<a name="l00519"></a>00519 <span class="comment"></span>
<a name="l00520"></a>00520 <span class="comment">#if defined(BOTAN_TARGET_OS_HAS_POSIX_MLOCK)</span>
<a name="l00521"></a>00521 <span class="comment">  #include &lt;sys/types.h&gt;</span>
<a name="l00522"></a>00522 <span class="comment">  #include &lt;sys/mman.h&gt;</span>
<a name="l00523"></a>00523 <span class="comment">#elif defined(BOTAN_TARGET_OS_HAS_WIN32_VIRTUAL_LOCK)</span>
<a name="l00524"></a>00524 <span class="comment">#ifndef _WINDOWS_</span>
<a name="l00525"></a>00525 <span class="comment">#ifndef WIN32_LEAN_AND_MEAN</span>
<a name="l00526"></a>00526 <span class="comment">#define WIN32_LEAN_AND_MEAN</span>
<a name="l00527"></a>00527 <span class="comment">#endif</span>
<a name="l00528"></a>00528 <span class="comment">#include &lt;windows.h&gt;</span>
<a name="l00529"></a>00529 <span class="comment">#endif</span>
<a name="l00530"></a>00530 <span class="comment">#endif</span>
<a name="l00531"></a>00531 <span class="comment"></span>
<a name="l00532"></a>00532 <span class="comment">namespace Botan {</span>
<a name="l00533"></a>00533 <span class="comment"></span>
<a name="l00534"></a>00534 <span class="comment">bool has_mlock()</span>
<a name="l00535"></a>00535 <span class="comment">   {</span>
<a name="l00536"></a>00536 <span class="comment">   byte buf[4096];</span>
<a name="l00537"></a>00537 <span class="comment">   if(!lock_mem(&amp;buf, sizeof(buf)))</span>
<a name="l00538"></a>00538 <span class="comment">      return false;</span>
<a name="l00539"></a>00539 <span class="comment">   unlock_mem(&amp;buf, sizeof(buf));</span>
<a name="l00540"></a>00540 <span class="comment">   return true;</span>
<a name="l00541"></a>00541 <span class="comment">   }</span>
<a name="l00542"></a>00542 <span class="comment"></span>
<a name="l00543"></a>00543 <span class="comment">//</span>
<a name="l00544"></a>00544 <span class="comment">// Lock an area of memory into RAM</span>
<a name="l00545"></a>00545 <span class="comment">//</span>
<a name="l00546"></a>00546 <span class="comment">bool lock_mem(void* ptr, size_t bytes)</span>
<a name="l00547"></a>00547 <span class="comment">   {</span>
<a name="l00548"></a>00548 <span class="comment">#if defined(BOTAN_TARGET_OS_HAS_POSIX_MLOCK)</span>
<a name="l00549"></a>00549 <span class="comment">   return (::mlock(static_cast&lt;char*&gt;(ptr), bytes) == 0);</span>
<a name="l00550"></a>00550 <span class="comment">#elif defined(BOTAN_TARGET_OS_HAS_WIN32_VIRTUAL_LOCK)</span>
<a name="l00551"></a>00551 <span class="comment">   return (::VirtualLock(ptr, bytes) != 0);</span>
<a name="l00552"></a>00552 <span class="comment">#else</span>
<a name="l00553"></a>00553 <span class="comment">   return false;</span>
<a name="l00554"></a>00554 <span class="comment">#endif</span>
<a name="l00555"></a>00555 <span class="comment">   }</span>
<a name="l00556"></a>00556 <span class="comment"></span>
<a name="l00557"></a>00557 <span class="comment">//</span>
<a name="l00558"></a>00558 <span class="comment">// Unlock a previously locked region of memory</span>
<a name="l00559"></a>00559 <span class="comment">//</span>
<a name="l00560"></a>00560 <span class="comment">void unlock_mem(void* ptr, size_t bytes)</span>
<a name="l00561"></a>00561 <span class="comment">   {</span>
<a name="l00562"></a>00562 <span class="comment">#if defined(BOTAN_TARGET_OS_HAS_POSIX_MLOCK)</span>
<a name="l00563"></a>00563 <span class="comment">   ::munlock(static_cast&lt;char*&gt;(ptr), bytes);</span>
<a name="l00564"></a>00564 <span class="comment">#elif defined(BOTAN_TARGET_OS_HAS_WIN32_VIRTUAL_LOCK)</span>
<a name="l00565"></a>00565 <span class="comment">   ::VirtualUnlock(ptr, bytes);</span>
<a name="l00566"></a>00566 <span class="comment">#endif</span>
<a name="l00567"></a>00567 <span class="comment">   }</span>
<a name="l00568"></a>00568 <span class="comment"></span>
<a name="l00569"></a>00569 <span class="comment">}</span>
<a name="l00570"></a>00570 <span class="comment"></span>
<a name="l00571"></a>00571 <span class="comment"> */</span>
<a name="l00572"></a>00572 
<a name="l00573"></a>00573 
<a name="l00574"></a>00574 <span class="preprocessor">#endif // __OT_PASSWORD_HPP__</span>
</pre></div></div><!-- contents -->
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="_o_t_password_8hpp.html">OTPassword.hpp</a>      </li>

    <li class="footer">Generated on Wed May 21 2014 11:26:00 for Open-Transactions by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1 </li>
   </ul>
 </div>


</body>
</html>
