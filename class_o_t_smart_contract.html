<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Open-Transactions: OTSmartContract Class Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Open-Transactions
   &#160;<span id="projectnumber">master/1066fb4910a63ee3f7de8e0807fee3eb663b66c7</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('class_o_t_smart_contract.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">OTSmartContract Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<!-- doxytag: class="OTSmartContract" --><!-- doxytag: inherits="OTCronItem" -->
<p><code>#include &lt;<a class="el" href="_o_t_smart_contract_8hpp_source.html">OTSmartContract.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for OTSmartContract:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_o_t_smart_contract.png" usemap="#OTSmartContract_map" alt=""/>
  <map id="OTSmartContract_map" name="OTSmartContract_map">
<area href="class_o_t_cron_item.html" alt="OTCronItem" shape="rect" coords="0,224,109,248"/>
<area href="class_o_t_trackable.html" alt="OTTrackable" shape="rect" coords="0,168,109,192"/>
<area href="class_o_t_instrument.html" alt="OTInstrument" shape="rect" coords="0,112,109,136"/>
<area href="class_o_t_scriptable.html" alt="OTScriptable" shape="rect" coords="0,56,109,80"/>
<area href="class_o_t_contract.html" alt="OTContract" shape="rect" coords="0,0,109,24"/>
</map>
 </div></div>

<p><a href="class_o_t_smart_contract-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_t_smart_contract.html#a0724be6ceeab338be3d9ea1469e82114">SetDisplayLabel</a> (const std::string *pstrLabel=NULL)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_o_t_string.html">OTString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_t_smart_contract.html#aeb06c37756e2188d2f05eb3a2102a14a">GetLastSenderUserID</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_o_t_string.html">OTString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_t_smart_contract.html#af1cf6cb6b4d53612f587f5cf5fa70c2d">GetLastSenderAcctID</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_o_t_string.html">OTString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_t_smart_contract.html#a5e4cc7155d92196c3031a725fd199230">GetLastRecipientUserID</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_o_t_string.html">OTString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_t_smart_contract.html#a3493a6e50d526fd228d71eb3d571fda1">GetLastRecipientAcctID</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_t_smart_contract.html#a24f1bc0f448832aaee8f9b665f2eec1e">GetCountStashes</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_t_smart_contract.html#a400c4164f6dbced28ae4155864dcf496">GetCountStashAccts</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_t_smart_contract.html#a5b4a2b0e39d8aa534de380d92778bf0d">Compare</a> (<a class="el" href="class_o_t_scriptable.html">OTScriptable</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_t_smart_contract.html#a894df89d05a2ce8a3effec71abb23f7d">CanRemoveItemFromCron</a> (<a class="el" href="class_o_t_pseudonym.html">OTPseudonym</a> &amp;theNym)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_t_smart_contract.html#a6eaf2a458eb665dae9e25f026db27f8f">HarvestOpeningNumber</a> (<a class="el" href="class_o_t_pseudonym.html">OTPseudonym</a> &amp;theNym)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_t_smart_contract.html#a40befd7381c6c5e68e7d1042c9a7f2d3">HarvestClosingNumbers</a> (<a class="el" href="class_o_t_pseudonym.html">OTPseudonym</a> &amp;theNym)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_t_smart_contract.html#ac49c69ff88ceac23756933c4a915fd60">CloseoutOpeningNumbers</a> (<a class="el" href="class_o_t_pseudonym.html">OTPseudonym</a> *pSignerNym=NULL)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_t_smart_contract.html#a6dc75e512f2cab9acaecf39489f31e6c">HarvestClosingNumbers</a> (<a class="el" href="class_o_t_pseudonym.html">OTPseudonym</a> *pSignerNym=NULL, std::set&lt; <a class="el" href="class_o_t_party.html">OTParty</a> * &gt; *pFailedParties=NULL)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_t_smart_contract.html#a717de2aa486b22c8ccde06c25bbb64f5">ProcessCron</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_t_smart_contract.html#a1952403bb15765cab19f435186b6c362">HasTransactionNum</a> (const int64_t &amp;lInput) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_t_smart_contract.html#ace4cafaf9afe3c3076271564d699cc65">GetAllTransactionNumbers</a> (<a class="el" href="class_o_t_num_list.html">OTNumList</a> &amp;numlistOutput) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_t_smart_contract.html#af2ebb9b6ca7fd398f4bbd7e6dc21df93">AddParty</a> (<a class="el" href="class_o_t_party.html">OTParty</a> &amp;theParty)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_t_smart_contract.html#a361ba96466948934e82da4b8be6bdc8a">ConfirmParty</a> (<a class="el" href="class_o_t_party.html">OTParty</a> &amp;theParty)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_t_smart_contract.html#aa4d0e2f242f874a9a594a31d8af26533">SetServerIDIfEmpty</a> (const <a class="el" href="class_o_t_identifier.html">OTIdentifier</a> &amp;theID)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_t_smart_contract.html#a3b15d58a7c49d3ba2fc8a153bca6af0f">VerifySmartContract</a> (<a class="el" href="class_o_t_pseudonym.html">OTPseudonym</a> &amp;theNym, <a class="el" href="class_o_t_account.html">OTAccount</a> &amp;theAcct, <a class="el" href="class_o_t_pseudonym.html">OTPseudonym</a> &amp;theServerNym, const bool bBurnTransNo=false)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_t_smart_contract.html#afd41dba13f15554183828bd79f0cbb3f">PrepareToActivate</a> (const int64_t &amp;lOpeningTransNo, const int64_t &amp;lClosingTransNo, const <a class="el" href="class_o_t_identifier.html">OTIdentifier</a> &amp;theUserID, const <a class="el" href="class_o_t_identifier.html">OTIdentifier</a> &amp;theAcctID)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_t_smart_contract.html#a77a75cea50a6d4e8a2b199204dc8c7a6">CanCancelContract</a> (const std::string str_party_name)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_t_smart_contract.html#ab039e15191e3294e6a09eaa6f5be8923">SetRemainingTimer</a> (const std::string str_seconds_from_now)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_t_smart_contract.html#a71f505b723bbb56e75a46b9836c3949c">GetRemainingTimer</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_t_smart_contract.html#ae10051f961745a06753f5e22d9a699f1">MoveAcctFundsStr</a> (const std::string from_acct_name, const std::string to_acct_name, const std::string str_Amount)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_t_smart_contract.html#a7d4c35453914e75a252a1f4eac3ce855">StashAcctFunds</a> (const std::string from_acct_name, const std::string to_stash_name, const std::string str_Amount)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_t_smart_contract.html#a7be637de24a11ebd872822b84952c21a">UnstashAcctFunds</a> (const std::string to_acct_name, const std::string from_stash_name, const std::string str_Amount)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_t_smart_contract.html#af6c9cbe669cea11256dc7fd2a6fdddf4">GetAcctBalance</a> (const std::string from_acct_name)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_t_smart_contract.html#a2a92d021daf88edba58aabba629d90e5">GetStashBalance</a> (const std::string stash_name, const std::string asset_type_id)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_t_smart_contract.html#aef2b64b4870a325f36df1e634f744ce9">GetAssetTypeIDofAcct</a> (const std::string from_acct_name)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_t_smart_contract.html#a72762c0413197f084b36e2d0fce59e4f">SendNoticeToParty</a> (const std::string party_name)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_t_smart_contract.html#a63aa006565fab757f33d28215b1f5e0c">SendANoticeToAllParties</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_t_smart_contract.html#ac9ad18ccba9bb19d1ff2568d10386524">DeactivateSmartContract</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_t_smart_contract.html#ad79350fe9df32d0e129e1a8b5fe28a04">RegisterOTNativeCallsWithScript</a> (<a class="el" href="class_o_t_script.html">OTScript</a> &amp;theScript)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_t_stash.html">OTStash</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_t_smart_contract.html#af7305d13e0ac4c2bef284658bdd9ec67">GetStash</a> (const std::string str_stash_name)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_t_smart_contract.html#a83282de7074313974d0db0f50b3b6e09">ExecuteClauses</a> (<a class="el" href="_o_t_clause_8hpp.html#a40c16432fa9c16826c026b74351425ad">mapOfClauses</a> &amp;theClauses, <a class="el" href="class_o_t_string.html">OTString</a> *pParam=NULL)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_t_smart_contract.html#abaebc7e1d2416290139c883698c91025">StashFunds</a> (const <a class="el" href="_o_t_agent_8hpp.html#ac89892658f6bc83e354078647b704e8f">mapOfNyms</a> &amp;map_NymsAlreadyLoaded, const int64_t &amp;lAmount, const <a class="el" href="class_o_t_identifier.html">OTIdentifier</a> &amp;PARTY_ACCT_ID, const <a class="el" href="class_o_t_identifier.html">OTIdentifier</a> &amp;PARTY_USER_ID, <a class="el" href="class_o_t_stash.html">OTStash</a> &amp;theStash)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">EXPORT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_t_smart_contract.html#a9f4865bea6e0a31bfa51b1627611aeb0">OTSmartContract</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">EXPORT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_t_smart_contract.html#ad5db7263909fc4c300a612b4dc546dcf">OTSmartContract</a> (const <a class="el" href="class_o_t_identifier.html">OTIdentifier</a> &amp;SERVER_ID)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">EXPORT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_t_smart_contract.html#a0bb1574c8f345abac7b417981b8c7daa">OTSmartContract</a> (const <a class="el" href="class_o_t_identifier.html">OTIdentifier</a> &amp;SERVER_ID, const <a class="el" href="class_o_t_identifier.html">OTIdentifier</a> &amp;ASSET_ID, const <a class="el" href="class_o_t_identifier.html">OTIdentifier</a> &amp;SENDER_ACCT_ID, const <a class="el" href="class_o_t_identifier.html">OTIdentifier</a> &amp;SENDER_USER_ID, const <a class="el" href="class_o_t_identifier.html">OTIdentifier</a> &amp;RECIPIENT_ACCT_ID, const <a class="el" href="class_o_t_identifier.html">OTIdentifier</a> &amp;RECIPIENT_USER_ID)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_t_smart_contract.html#abd37d88f1828402ae7313aa130ccbe9f">LoadEditable</a> (const <a class="el" href="class_o_t_string.html">OTString</a> &amp;strName)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_t_smart_contract.html#acaa73a3c0357768583a129612d8ebb91">SaveEditable</a> (const <a class="el" href="class_o_t_string.html">OTString</a> &amp;strName)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_t_smart_contract.html#a180d318d02a58976aaf8e8dc1ee729ab">LoadTemplate</a> (const <a class="el" href="class_o_t_identifier.html">OTIdentifier</a> &amp;SERVER_ID, const <a class="el" href="class_o_t_identifier.html">OTIdentifier</a> &amp;CONTRACT_ID)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_t_smart_contract.html#a61617c4df9db720a7b7167f9b92bd750">SaveTemplate</a> (const <a class="el" href="class_o_t_identifier.html">OTIdentifier</a> &amp;SERVER_ID)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual EXPORT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_t_smart_contract.html#aeed0c58a21faf119778953a041f1821b">~OTSmartContract</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_t_smart_contract.html#a6ce8a031a27a75a43275dde21919d0cd">InitSmartContract</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_t_smart_contract.html#a335f903820d3128716c7f7b93200b5ac">Release</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_t_smart_contract.html#a5673ded692d238c80fa6b854feaa68f4">Release_SmartContract</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_t_smart_contract.html#a5e2972487aa71cb86d51393ed749f341">ReleaseStashes</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_t_smart_contract.html#aa5a554f7a5ca7c9a0d0d2377860ef8c2">IsValidOpeningNumber</a> (const int64_t &amp;lOpeningNum) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_t_smart_contract.html#a2bb8a0f8a1ff8ddf637e5d87d5935e51">GetOpeningNumber</a> (const <a class="el" href="class_o_t_identifier.html">OTIdentifier</a> &amp;theNymID) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_t_smart_contract.html#a3a9a2325c23aa03f4e6ce03fec6f69f7">GetClosingNumber</a> (const <a class="el" href="class_o_t_identifier.html">OTIdentifier</a> &amp;theAcctID) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_t_smart_contract.html#a8524c56a7469d39a895bed4b18671972">ProcessXMLNode</a> (<a class="el" href="namespaceirr_1_1io.html#a1628edbb9d5d53f18c82d2a92b0ad27e">irr::io::IrrXMLReader</a> *&amp;xml)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_t_smart_contract.html#a4804dc10ab81b2bde13fce0a3afb0765">UpdateContents</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_t_smart_contract.html#aa39d672a40e0778c205ed308b86c6927">SaveContractWallet</a> (std::ofstream &amp;ofs)</td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_t_smart_contract.html#a16209b074a580bc416cf848025e0647e">CleanupNyms</a> (<a class="el" href="_o_t_agent_8hpp.html#ac89892658f6bc83e354078647b704e8f">mapOfNyms</a> &amp;theMap)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_t_smart_contract.html#a11408d45bd120d44b704637ebbc0c971">CleanupAccts</a> (<a class="el" href="_o_t_agent_8hpp.html#abd4942716d546c8d42670619a03ef99e">mapOfAccounts</a> &amp;theMap)</td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_t_smart_contract.html#a986e939aa9f6e838afc66426cbc0eb12">onActivate</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_t_smart_contract.html#ac956b09210f8037018cd06f11f965df4">onFinalReceipt</a> (<a class="el" href="class_o_t_cron_item.html">OTCronItem</a> &amp;theOrigCronItem, const int64_t &amp;lNewTransactionNumber, <a class="el" href="class_o_t_pseudonym.html">OTPseudonym</a> &amp;theOriginator, <a class="el" href="class_o_t_pseudonym.html">OTPseudonym</a> *pRemover)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_t_smart_contract.html#ad0ed5c23badda402c9493b86bef7542e">onRemovalFromCron</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_t_smart_contract.html#a09de789ac2e616e2119feb9ddf416c9d">ReleaseLastSenderRecipientIDs</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_t_smart_contract.html#a0c0ffa47dacaa8fa79304317f8e04544">SetNextProcessDate</a> (const <a class="el" href="_o_t_common_8hpp.html#ad28ff0a3eda18840f6bda5872819167f">time64_t</a> &amp;tNEXT_DATE)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="_o_t_common_8hpp.html#ad28ff0a3eda18840f6bda5872819167f">time64_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_t_smart_contract.html#a16737b147030f0aaaedc53f798c35a50">GetNextProcessDate</a> () const </td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock">
<p>Definition at line <a class="el" href="_o_t_smart_contract_8hpp_source.html#l00163">163</a> of file <a class="el" href="_o_t_smart_contract_8hpp_source.html">OTSmartContract.hpp</a>.</p>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a9f4865bea6e0a31bfa51b1627611aeb0"></a><!-- doxytag: member="OTSmartContract::OTSmartContract" ref="a9f4865bea6e0a31bfa51b1627611aeb0" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_t_smart_contract.html#a9f4865bea6e0a31bfa51b1627611aeb0">OTSmartContract::OTSmartContract</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_o_t_smart_contract_8cpp_source.html#l04735">4735</a> of file <a class="el" href="_o_t_smart_contract_8cpp_source.html">OTSmartContract.cpp</a>.</p>
<div class="fragment"><pre class="fragment">                                 : ot_super(), m_StashAccts(<a class="code" href="class_o_t_account.html#aadaf6bd4178672bdbc783c6f06313784ac791c14e3cfeb43e698255e47d3db13a">OTAccount::stash</a>), m_tNextProcessDate(<a class="code" href="_o_t_common_8hpp.html#af4ca9fa2c7c290d647dd18de0a9ac25f">OT_TIME_ZERO</a>)
{
    <a class="code" href="class_o_t_smart_contract.html#a6ce8a031a27a75a43275dde21919d0cd">InitSmartContract</a>();
}
</pre></div>
</div>
</div>
<a class="anchor" id="ad5db7263909fc4c300a612b4dc546dcf"></a><!-- doxytag: member="OTSmartContract::OTSmartContract" ref="ad5db7263909fc4c300a612b4dc546dcf" args="(const OTIdentifier &amp;SERVER_ID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_t_smart_contract.html#a9f4865bea6e0a31bfa51b1627611aeb0">OTSmartContract::OTSmartContract</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_t_identifier.html">OTIdentifier</a> &amp;&#160;</td>
          <td class="paramname"><em>SERVER_ID</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_o_t_smart_contract_8cpp_source.html#l04741">4741</a> of file <a class="el" href="_o_t_smart_contract_8cpp_source.html">OTSmartContract.cpp</a>.</p>
<div class="fragment"><pre class="fragment">                                                               :
ot_super(), m_StashAccts(<a class="code" href="class_o_t_account.html#aadaf6bd4178672bdbc783c6f06313784ac791c14e3cfeb43e698255e47d3db13a">OTAccount::stash</a>), m_tNextProcessDate(<a class="code" href="_o_t_common_8hpp.html#af4ca9fa2c7c290d647dd18de0a9ac25f">OT_TIME_ZERO</a>)
{
    <a class="code" href="class_o_t_instrument.html#a80fc5560fdedf911ec0c184ab9fbb5b7">OTInstrument::SetServerID</a>(SERVER_ID);
    <a class="code" href="class_o_t_smart_contract.html#a6ce8a031a27a75a43275dde21919d0cd">InitSmartContract</a>();
}
</pre></div>
</div>
</div>
<a class="anchor" id="a0bb1574c8f345abac7b417981b8c7daa"></a><!-- doxytag: member="OTSmartContract::OTSmartContract" ref="a0bb1574c8f345abac7b417981b8c7daa" args="(const OTIdentifier &amp;SERVER_ID, const OTIdentifier &amp;ASSET_ID, const OTIdentifier &amp;SENDER_ACCT_ID, const OTIdentifier &amp;SENDER_USER_ID, const OTIdentifier &amp;RECIPIENT_ACCT_ID, const OTIdentifier &amp;RECIPIENT_USER_ID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_t_smart_contract.html#a9f4865bea6e0a31bfa51b1627611aeb0">OTSmartContract::OTSmartContract</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_t_identifier.html">OTIdentifier</a> &amp;&#160;</td>
          <td class="paramname"><em>SERVER_ID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_o_t_identifier.html">OTIdentifier</a> &amp;&#160;</td>
          <td class="paramname"><em>ASSET_ID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_o_t_identifier.html">OTIdentifier</a> &amp;&#160;</td>
          <td class="paramname"><em>SENDER_ACCT_ID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_o_t_identifier.html">OTIdentifier</a> &amp;&#160;</td>
          <td class="paramname"><em>SENDER_USER_ID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_o_t_identifier.html">OTIdentifier</a> &amp;&#160;</td>
          <td class="paramname"><em>RECIPIENT_ACCT_ID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_o_t_identifier.html">OTIdentifier</a> &amp;&#160;</td>
          <td class="paramname"><em>RECIPIENT_USER_ID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_o_t_smart_contract_8cpp_source.html#l04749">4749</a> of file <a class="el" href="_o_t_smart_contract_8cpp_source.html">OTSmartContract.cpp</a>.</p>
<div class="fragment"><pre class="fragment">                                                                                                                    :
ot_super(SERVER_ID, ASSET_ID, SENDER_ACCT_ID, SENDER_USER_ID),
m_StashAccts(<a class="code" href="class_o_t_account.html#aadaf6bd4178672bdbc783c6f06313784ac791c14e3cfeb43e698255e47d3db13a">OTAccount::stash</a>), m_tNextProcessDate(<a class="code" href="_o_t_common_8hpp.html#af4ca9fa2c7c290d647dd18de0a9ac25f">OT_TIME_ZERO</a>)
{
    <a class="code" href="class_o_t_smart_contract.html#a6ce8a031a27a75a43275dde21919d0cd">InitSmartContract</a>();

    <span class="comment">// More can go here.</span>

}
</pre></div>
</div>
</div>
<a class="anchor" id="aeed0c58a21faf119778953a041f1821b"></a><!-- doxytag: member="OTSmartContract::~OTSmartContract" ref="aeed0c58a21faf119778953a041f1821b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_t_smart_contract.html#aeed0c58a21faf119778953a041f1821b">OTSmartContract::~OTSmartContract</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_o_t_smart_contract_8cpp_source.html#l04762">4762</a> of file <a class="el" href="_o_t_smart_contract_8cpp_source.html">OTSmartContract.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
    <a class="code" href="class_o_t_smart_contract.html#a5673ded692d238c80fa6b854feaa68f4">Release_SmartContract</a>();
}
</pre></div>
</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="af2ebb9b6ca7fd398f4bbd7e6dc21df93"></a><!-- doxytag: member="OTSmartContract::AddParty" ref="af2ebb9b6ca7fd398f4bbd7e6dc21df93" args="(OTParty &amp;theParty)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_o_t_smart_contract.html#af2ebb9b6ca7fd398f4bbd7e6dc21df93">OTSmartContract::AddParty</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_t_party.html">OTParty</a> &amp;&#160;</td>
          <td class="paramname"><em>theParty</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="class_o_t_scriptable.html#accfde75655f5c49c041ef3a5fbff54e6">OTScriptable</a>.</p>

<p>Definition at line <a class="el" href="_o_t_smart_contract_8cpp_source.html#l04607">4607</a> of file <a class="el" href="_o_t_smart_contract_8cpp_source.html">OTSmartContract.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordflow">if</span> (<span class="keyword">false</span> == theParty.<a class="code" href="class_o_t_party.html#a477b8c4714d7ac086630c236e4be6f89">HasActiveAgent</a>())
    {
        <a class="code" href="class_o_t_log.html#a1f7549d776ee919dcb6517f611ded015">OTLog::Output</a>(0, <span class="stringliteral">&quot;OTSmartContract::AddParty: Party doesn&#39;t have an active agent -- who will sign for this smart contract?\n&quot;</span>);
        <span class="keywordflow">return</span> <span class="keyword">false</span>;
    }

    <span class="comment">// MIGHT move this below (1).. OR this might turn out to be important going first...</span>
    <span class="comment">//</span>
    <span class="keywordflow">if</span> (<span class="keyword">false</span> == <a class="code" href="class_o_t_scriptable.html#accfde75655f5c49c041ef3a5fbff54e6">OTScriptable::AddParty</a>(theParty))
    {
        <a class="code" href="class_o_t_log.html#a1f7549d776ee919dcb6517f611ded015">OTLog::Output</a>(0, <span class="stringliteral">&quot;OTSmartContract::AddParty: Failed adding party.\n&quot;</span>);
        <span class="keywordflow">return</span> <span class="keyword">false</span>;
    }

    <span class="keywordflow">return</span> <span class="keyword">true</span>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a77a75cea50a6d4e8a2b199204dc8c7a6"></a><!-- doxytag: member="OTSmartContract::CanCancelContract" ref="a77a75cea50a6d4e8a2b199204dc8c7a6" args="(const std::string str_party_name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_o_t_smart_contract.html#a77a75cea50a6d4e8a2b199204dc8c7a6">OTSmartContract::CanCancelContract</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>str_party_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_o_t_smart_contract_8cpp_source.html#l03597">3597</a> of file <a class="el" href="_o_t_smart_contract_8cpp_source.html">OTSmartContract.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
    <a class="code" href="class_o_t_cron.html">OTCron</a> * pCron  = <a class="code" href="class_o_t_cron_item.html#af734ad5d309fcc9b4a60d40d6c30f55a">GetCron</a>();
    <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != pCron);
    <span class="comment">// ----------------------------------</span>
    <a class="code" href="class_o_t_pseudonym.html">OTPseudonym</a> * pServerNym = pCron-&gt;<a class="code" href="class_o_t_cron.html#a7756d0dcc047209ca87632939dc11db3">GetServerNym</a>();
    <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != pServerNym);
    <span class="comment">// -------------------------------------------------</span>

    <a class="code" href="class_o_t_party.html">OTParty</a> * pParty = this-&gt;<a class="code" href="class_o_t_scriptable.html#acd0f8e884ed00f1d082fa498323d8894">GetParty</a>(str_party_name);

    <span class="keywordflow">if</span> (NULL == pParty)
    {
        <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(0, <span class="stringliteral">&quot;OTSmartContract::CanCancelContract: Unable to find this party: %s\n&quot;</span>,
                       str_party_name.c_str());
        <span class="keywordflow">return</span> <span class="keyword">false</span>;
    }
    <span class="comment">// Below this point, pParty is good.</span>
    <span class="comment">// ------------------------------------------------</span>

    <span class="comment">// ...This WILL check to see if pParty has its Opening number verified as issued.</span>
    <span class="comment">// (If the opening number is &gt; 0 then VerifyPartyAuthorization() is smart enough to verify it.)</span>
    <span class="comment">//</span>
    <span class="comment">// To KNOW that a party has the right to even ASK the script to cancel a contract, MEANS that</span>
    <span class="comment">// (1) The party is listed as a party on the contract. (2) The party&#39;s copy of that contract</span>
    <span class="comment">// is signed by the authorizing agent for that party. and (3) The opening transaction number for</span>
    <span class="comment">// that party is verified as issued for authorizing agent. (2 and 3 are both performed at the same</span>
    <span class="comment">// time, in VerifyPartyAuthorization(), since the agent may need to be loaded in order to verify</span>
    <span class="comment">// them.) 1 is already done by this point, as it&#39;s performed above.</span>
    <span class="comment">//</span>
    <span class="comment">// Done: notice this code appears in CanCancelContract() (this function) as well as</span>
    <span class="comment">// OTScriptable::CanExecuteClause.</span>
    <span class="comment">// Therefore I can see that THIS VERIFICATION CODE WILL GET CALLED EVERY SINGLE TIME THE SCRIPT</span>
    <span class="comment">// CALLS ANY CLAUSE OR OT NATIVE FUNCTION.  Since technically this only needs to be verified before the</span>
    <span class="comment">// first call, and not for EVERY call during any of a script&#39;s runs, I should probably move this verification</span>
    <span class="comment">// higher, such as each time the OTCronItem triggers, plus each time a party triggers a clause directly</span>
    <span class="comment">// through the API (server message). As long as those are covered, I will be able to remove it from here</span>
    <span class="comment">// which should be a significant improvement for performance.</span>
    <span class="comment">// It will be at the bottom of those same functions that &quot;ClearTemporaryPointers()&quot; should finally be called.</span>
    <span class="comment">//</span>
    <span class="comment">// Also todo:  Need to implement MOVE CONSTRUCTORS and MOVE COPY CONSTRUCTORS all over the place,</span>
    <span class="comment">// once I&#39;m sure C++0x build environments are available for all of the various OT platforms. That should</span>
    <span class="comment">// be another great performance boost!</span>
    <span class="comment">//</span>
    <span class="comment">//  FINAL DECISION: Redundant. See comment in OTSmartContract::StashAcctFunds()</span>
    <span class="comment">//</span>
<span class="comment">//  const OTString strServerID(GetServerID());</span>
<span class="comment">//</span>
<span class="comment">//  mapOfNyms   map_Nyms_Already_Loaded;</span>
<span class="comment">//  this-&gt;RetrieveNymPointers(map_Nyms_Already_Loaded);</span>
<span class="comment">//</span>
<span class="comment">//  bool bVerifiedAuthorization =</span>
<span class="comment">//      this-&gt;VerifyPartyAuthorization(*pParty, *pServerNym, strServerID, &amp;map_Nyms_Already_Loaded);</span>
<span class="comment">//</span>
<span class="comment">//  if (!bVerifiedAuthorization)</span>
<span class="comment">//  {</span>
<span class="comment">//      OTLog::vOutput(0, &quot;OTSmartContract::CanCancelContract: Unable to verify this party: %s\n&quot;,</span>
<span class="comment">//                     str_party_name.c_str());</span>
<span class="comment">//      return false;</span>
<span class="comment">//  }</span>
<span class="comment">//</span>
    <span class="comment">// *****************************************************************************</span>

    <span class="comment">// IF NO CALLBACK IS PROVIDED, The default answer to this function is:</span>
    <span class="comment">//     YES, this party MAY cancel this contract! (Assuming he&#39;s a real party,</span>
    <span class="comment">//     which we have verified by this point.)</span>
    <span class="comment">//</span>
    <span class="comment">// But... first we check to see if this OTScriptable has a clause named:</span>
    <span class="comment">//          &quot;callback_party_may_cancel_contract&quot;</span>
    <span class="comment">// ...and if so, we ask the CALLBACK to make the decision instead. This way, people can define</span>
    <span class="comment">// in their own scripts any rules they want about which parties may cancel the contract.</span>

    <span class="comment">//</span>
    <span class="keyword">const</span> std::string str_CallbackName(<a class="code" href="_o_t_smart_contract_8cpp.html#a868cf7423bbb3819f0c7af0ff701907f">SMARTCONTRACT_CALLBACK_PARTY_MAY_CANCEL</a>);

    <a class="code" href="class_o_t_clause.html">OTClause</a> * pCallbackClause = this-&gt;<a class="code" href="class_o_t_scriptable.html#a390511c5b2f419453b1cc169ec576972">GetCallback</a>(str_CallbackName); <span class="comment">// See if there is a script clause registered for this callback.</span>

    <span class="keywordflow">if</span> (NULL != pCallbackClause) <span class="comment">// Found it! There&#39;s a clause registered for this callback. Let&#39;s call it...</span>
    {
        <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(0, <span class="stringliteral">&quot;OTSmartContract::CanCancelContract: Found script for: %s. Asking...\n&quot;</span>,
                       <a class="code" href="_o_t_smart_contract_8cpp.html#a868cf7423bbb3819f0c7af0ff701907f">SMARTCONTRACT_CALLBACK_PARTY_MAY_CANCEL</a>);

        <span class="comment">// The function we&#39;re IN defaults to TRUE, if there&#39;s no script available.</span>
        <span class="comment">// However, if the script IS available, then our default return value starts as FALSE.</span>
        <span class="comment">// (The script itself will then have to set it to true, if that&#39;s what it wants.)</span>
        <span class="comment">//</span>
        <a class="code" href="class_o_t_variable.html">OTVariable</a> theReturnVal (<span class="stringliteral">&quot;return_val&quot;</span>,        <span class="keyword">false</span>);
        <span class="comment">// -------------------------------------------------------------</span>
        <a class="code" href="class_o_t_variable.html">OTVariable</a> param1       (<span class="stringliteral">&quot;param_party_name&quot;</span>,  str_party_name,   <a class="code" href="class_o_t_variable.html#a649f74cb58ba9ed9aeb8601750c98672a3663696326da4cd07edb796beec5c324">OTVariable::Var_Constant</a>); <span class="comment">// script can reference param_party_name</span>
        <span class="comment">// -------------------------------------------------------------</span>
        <a class="code" href="_o_t_variable_8hpp.html#aa7620bdfc9f969dd2802c11c3260eb37">mapOfVariables</a> theParameters;
        theParameters.insert(std::pair&lt;std::string, OTVariable *&gt;(<span class="stringliteral">&quot;param_party_name&quot;</span>,  &amp;param1));

        <span class="comment">// ****************************************</span>

        <span class="keywordflow">if</span> (<span class="keyword">false</span> == this-&gt;<a class="code" href="class_o_t_scriptable.html#a4a95506db44acbdd3b125f54cac3595a">ExecuteCallback</a>(*pCallbackClause, theParameters, theReturnVal)) <span class="comment">// &lt;============================================</span>
        {
            <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;OTSmartContract::CanCancelContract: Error while running callback script %s, clause %s \n&quot;</span>,
                          <a class="code" href="_o_t_smart_contract_8cpp.html#a868cf7423bbb3819f0c7af0ff701907f">SMARTCONTRACT_CALLBACK_PARTY_MAY_CANCEL</a>, pCallbackClause-&gt;<a class="code" href="class_o_t_clause.html#a325b3cfeedbfc1c699de3d0f787e5120">GetName</a>().<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>());
            <span class="keywordflow">return</span> <span class="keyword">false</span>;
        }
        <span class="keywordflow">else</span>
        {
            <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(0, <span class="stringliteral">&quot;OTSmartContract::CanCancelContract: Success executing callback script %s, clause: %s.\n\n&quot;</span>,
                           <a class="code" href="_o_t_smart_contract_8cpp.html#a868cf7423bbb3819f0c7af0ff701907f">SMARTCONTRACT_CALLBACK_PARTY_MAY_CANCEL</a>, pCallbackClause-&gt;<a class="code" href="class_o_t_clause.html#a325b3cfeedbfc1c699de3d0f787e5120">GetName</a>().<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>());

            <span class="keywordflow">return</span> theReturnVal.CopyValueBool();
        }
        <span class="comment">// ****************************************</span>
    }
    <span class="keywordflow">else</span>
    {
        <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(0, <span class="stringliteral">&quot;OTSmartContract::CanCancelContract: Unable to find script for: %s. Therefore, default return value is: TRUE.\n&quot;</span>,
                       <a class="code" href="_o_t_smart_contract_8cpp.html#a868cf7423bbb3819f0c7af0ff701907f">SMARTCONTRACT_CALLBACK_PARTY_MAY_CANCEL</a>);
    }
    <span class="comment">// *****************************************************************************</span>

    <span class="keywordflow">return</span> <span class="keyword">true</span>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a894df89d05a2ce8a3effec71abb23f7d"></a><!-- doxytag: member="OTSmartContract::CanRemoveItemFromCron" ref="a894df89d05a2ce8a3effec71abb23f7d" args="(OTPseudonym &amp;theNym)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_o_t_smart_contract.html#a894df89d05a2ce8a3effec71abb23f7d">OTSmartContract::CanRemoveItemFromCron</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_t_pseudonym.html">OTPseudonym</a> &amp;&#160;</td>
          <td class="paramname"><em>theNym</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>See if theNym has rights to remove this item from Cron. </p>

<p>Reimplemented from <a class="el" href="class_o_t_cron_item.html#ae79115b7343f9b2700aa59d2701f2334">OTCronItem</a>.</p>

<p>Definition at line <a class="el" href="_o_t_smart_contract_8cpp_source.html#l03720">3720</a> of file <a class="el" href="_o_t_smart_contract_8cpp_source.html">OTSmartContract.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">// You don&#39;t just go willy-nilly and remove a cron item from a market unless you check first</span>
    <span class="comment">// and make sure the Nym who requested it actually has said number (or a related closing number)</span>
    <span class="comment">// signed out to him on his last receipt...</span>
    <span class="comment">//</span>
    <span class="comment">// Note: overrode parent method and NOT calling it.</span>
    <span class="comment">// We do it our own way here, and call a script if it&#39;s available.</span>
    <span class="comment">//</span>
    <span class="comment">// ------------------------------------------------------------------</span>

    <span class="comment">// IT&#39;S ASSUMED that the opening and closing numbers WILL be verified in order to</span>
    <span class="comment">// insure they are CURRENTLY ISSUED.</span>
    <span class="comment">//</span>
    <span class="comment">// theNym.VerifyIssuedNum(strServerID, this-&gt;GetOpeningNum();</span>
    <span class="comment">// theNym.VerifyIssuedNum(strServerID, this-&gt;GetClosingNum();</span>
    <span class="comment">//</span>
    <span class="comment">// The default version OTCronItem does this for theNym, and the PaymentPlan version</span>
    <span class="comment">// has to be a little smarter: it has to figure out whether theNym is the Sender or Recipient,</span>
    <span class="comment">// so that it knows where to verify the numbers from, before allowing theNym to do the removal.</span>
    <span class="comment">//</span>
    <span class="comment">//</span>
    <span class="comment">// ===&gt; THIS version (OTSmartContract) will look up pParty using theNym via:</span>
    <span class="comment">// OTParty * OTScriptable::FindPartyBasedOnNymAsAgent(const OTPseudonym &amp; theNym, OTAgent ** ppAgent=NULL);</span>
    <span class="comment">//</span>
    <span class="comment">// ...Then it WILL check to see if pParty has its Opening number verified as issued.</span>
    <span class="comment">// ...It COULD ALSO loop the partyaccounts and see if pAgent is authorized agent for any of them.</span>
    <span class="comment">//    (If so, pAcct-&gt;VerifyClosingNumber() or pAgent-&gt;VerifyClosingNumber() as well.)</span>
    <span class="comment">//</span>
    <span class="comment">//</span>
    <a class="code" href="class_o_t_agent.html">OTAgent</a> * pAgent = NULL;
    <a class="code" href="class_o_t_party.html">OTParty</a> * pParty = this-&gt;<a class="code" href="class_o_t_scriptable.html#aa89029542587094cd2844cb8bf7a9a16">FindPartyBasedOnNymAsAgent</a>(theNym, &amp;pAgent); <span class="comment">// This sets a pointer to theNym inside pAgent, so pParty can use it later.</span>

    <span class="keywordflow">if</span> (NULL == pParty)
    {
        <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(0, <span class="stringliteral">&quot;OTSmartContract::CanRemoveItemFromCron: Warning: theNym is not an agent &quot;</span>
                       <span class="stringliteral">&quot;for any party to this contract, yet tried to remove it.\n&quot;</span>);
        <span class="keywordflow">return</span> <span class="keyword">false</span>;
    }
    <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != pAgent); <span class="comment">// With one comes the other.</span>

    <span class="comment">// Below this point, pAgent is not only good, but it contains a secret hidden pointer now to theNym.</span>
    <span class="comment">// That way, when the SCRIPT asks the party to verify issued number, without even having a reference to theNym,</span>
    <span class="comment">// the party will internally still be able to handle it. This always works in cases where it&#39;s needed because</span>
    <span class="comment">// we used theNym to look up pParty, and the lookup function is what sets that pointer. That&#39;s why I clean</span>
    <span class="comment">// the pointer again after I&#39;m done. (AT THE BOTTOM OF THIS FUNCTION.)</span>
    <span class="comment">//</span>
    <span class="comment">// ----------------------------------------------------</span>
    <span class="comment">// NOTE: You can see OTCronItem looks up the relevant numbers by trying to figure out if theNym</span>
    <span class="comment">// is sender or receiver, and then calling these methods:</span>
    <span class="comment">// if (this-&gt;GetCountClosingNumbers() &lt; 1)</span>
    <span class="comment">// if (this-&gt;GetRecipientCountClosingNumbers() &lt; 2)</span>
    <span class="comment">// Etc.</span>
    <span class="comment">//</span>
    <span class="comment">// But OTSmartContract doesn&#39;t use those functions, except where it has to in order to</span>
    <span class="comment">// work within the existing OTCronItem system. (That is, the ORIGINATOR who actually activates</span>
    <span class="comment">// a smart contract must still provide at least an opening number, which is stored in the old</span>
    <span class="comment">// system and used by it.)</span>
    <span class="comment">// Instead, OTSmartContract keeps its own records (via its parent class OTScriptable) of all the</span>
    <span class="comment">// parties to the contract, and all of their opening transaction #s, as well as the accounts that</span>
    <span class="comment">// are party to the contract, and the closing transaction #s for each of those.</span>
    <span class="comment">//</span>
    <span class="comment">// ===&gt; Therefore, when it comes to verifying whether the Nym has CERTAIN RIGHTS regarding the</span>
    <span class="comment">// contract, OTSmartContract doesn&#39;t actually use the old system for that, but instead queries its</span>
    <span class="comment">// own, superior system.</span>
    <span class="comment">//</span>
    <span class="comment">// In order to prevent infinite recursion I think I will be adding THAT code into:</span>
    <span class="comment">//      OTSmartContract::CanCancelContract(party_name)</span>
    <span class="comment">//</span>
    <span class="comment">// ----------------------------------------------------------------</span>

            <span class="keywordtype">bool</span>        bReturnValue    = <span class="keyword">false</span>;
            <span class="keywordtype">bool</span>        bPartyHasName   = <span class="keyword">false</span>;
    <span class="keyword">const</span>   std::string str_party_name  = pParty-&gt;<a class="code" href="class_o_t_party.html#ad823a9d89b3d8d0d87bc85114eefcead">GetPartyName</a>(&amp;bPartyHasName);

    <span class="keywordflow">if</span> (bPartyHasName &amp;&amp; this-&gt;<a class="code" href="class_o_t_smart_contract.html#a77a75cea50a6d4e8a2b199204dc8c7a6">CanCancelContract</a>(str_party_name)) <span class="comment">// Here is where it calls the script, inside this call.</span>
    {
        <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(0, <span class="stringliteral">&quot;OTSmartContract::CanRemoveItemFromCron: Looks like theNym represents a party (%s) and &quot;</span>
                       <span class="stringliteral">&quot;IS allowed by this contract to cancel it whenever he chooses.\n&quot;</span>);
        bReturnValue = <span class="keyword">true</span>;
    }
    <span class="comment">// -----------------</span>

    pParty-&gt;<a class="code" href="class_o_t_party.html#a41a428ded2f0477cf8752648cbe51e4e">ClearTemporaryPointers</a>(); <span class="comment">// FindPartyBasedOnNymAsAgent() set the party&#39;s agent&#39;s nym pointer to theNym. This clears it.</span>

    <span class="keywordflow">return</span> bReturnValue;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a11408d45bd120d44b704637ebbc0c971"></a><!-- doxytag: member="OTSmartContract::CleanupAccts" ref="a11408d45bd120d44b704637ebbc0c971" args="(mapOfAccounts &amp;theMap)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_o_t_smart_contract.html#a11408d45bd120d44b704637ebbc0c971">OTSmartContract::CleanupAccts</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_o_t_agent_8hpp.html#abd4942716d546c8d42670619a03ef99e">mapOfAccounts</a> &amp;&#160;</td>
          <td class="paramname"><em>theMap</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_o_t_smart_contract_8cpp_source.html#l04581">4581</a> of file <a class="el" href="_o_t_smart_contract_8cpp_source.html">OTSmartContract.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">// -------------------------------------</span>
    <span class="keywordflow">while</span> (!theMap.empty())
    {
        <a class="code" href="class_o_t_account.html">OTAccount</a> * pAcct = theMap.begin()-&gt;second;
        <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != pAcct);

        <span class="keyword">delete</span> pAcct; pAcct = NULL;

        theMap.erase(theMap.begin());
    }
    <span class="comment">// -------------------------------------</span>
}
</pre></div>
</div>
</div>
<a class="anchor" id="a16209b074a580bc416cf848025e0647e"></a><!-- doxytag: member="OTSmartContract::CleanupNyms" ref="a16209b074a580bc416cf848025e0647e" args="(mapOfNyms &amp;theMap)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_o_t_smart_contract.html#a16209b074a580bc416cf848025e0647e">OTSmartContract::CleanupNyms</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_o_t_agent_8hpp.html#ac89892658f6bc83e354078647b704e8f">mapOfNyms</a> &amp;&#160;</td>
          <td class="paramname"><em>theMap</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_o_t_smart_contract_8cpp_source.html#l04564">4564</a> of file <a class="el" href="_o_t_smart_contract_8cpp_source.html">OTSmartContract.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">// -------------------------------------</span>
    <span class="keywordflow">while</span> (!theMap.empty())
    {
        <a class="code" href="class_o_t_pseudonym.html">OTPseudonym</a> * pNym = theMap.begin()-&gt;second;
        <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != pNym);

        <span class="keyword">delete</span> pNym; pNym = NULL;

        theMap.erase(theMap.begin());
    }
    <span class="comment">// -------------------------------------</span>
}
</pre></div>
</div>
</div>
<a class="anchor" id="ac49c69ff88ceac23756933c4a915fd60"></a><!-- doxytag: member="OTSmartContract::CloseoutOpeningNumbers" ref="ac49c69ff88ceac23756933c4a915fd60" args="(OTPseudonym *pSignerNym=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_o_t_smart_contract.html#ac49c69ff88ceac23756933c4a915fd60">OTSmartContract::CloseoutOpeningNumbers</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_t_pseudonym.html">OTPseudonym</a> *&#160;</td>
          <td class="paramname"><em>pSignerNym</em> = <code>NULL</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_o_t_smart_contract_8cpp_source.html#l04423">4423</a> of file <a class="el" href="_o_t_smart_contract_8cpp_source.html">OTSmartContract.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keyword">const</span> <a class="code" href="class_o_t_string.html">OTString</a> strServerID(<a class="code" href="class_o_t_instrument.html#a878dd8998f7b131b85c082575e255375">GetServerID</a>());
    <span class="comment">// -------------------------------------------------------</span>
    <a class="code" href="_o_t_storage_8hpp.html#aa135ed03585fa4b246d7907afbd5873d">FOR_EACH</a>(<a class="code" href="_o_t_party_8hpp.html#a029bc6921acd4516530e26201cf595f2">mapOfParties</a>, <a class="code" href="class_o_t_scriptable.html#a6a7e4ef3e0ed95f90d950b1718f815ab">m_mapParties</a>)
    {
        <span class="keyword">const</span> std::string str_party_name = it-&gt;first;
        <a class="code" href="class_o_t_party.html">OTParty</a> * pParty = (*it).second;
        <a class="code" href="_o_t_assert_8hpp.html#a033b133f48e61f2b227c52ad2be0c882">OT_ASSERT_MSG</a>(NULL != pParty, <span class="stringliteral">&quot;OTSmartContract::CloseoutOpeningNumbers: Unexpected NULL pointer in party map.&quot;</span>);
        <span class="comment">// --------------------------------------------</span>
        <span class="comment">// Closeout the opening transaction numbers:</span>
        <span class="comment">//</span>
        <span class="keywordflow">if</span> (this-&gt;<a class="code" href="class_o_t_trackable.html#a2594d320e3b24f3210bd38a08de66a70">GetTransactionNum</a>() != pParty-&gt;<a class="code" href="class_o_t_party.html#aa11f990dfe9743dd1d8e34af8bfd693a">GetOpeningTransNo</a>()) <span class="comment">// We skip the activating Nym. (His is already closed-out in NotarizeTransaction.)</span>
            pParty-&gt;<a class="code" href="class_o_t_party.html#ab400cfbda3311a3ae37a0b394cd4bfa5">CloseoutOpeningNumber</a>(strServerID,
                                          <span class="keyword">true</span>,         <span class="comment">// bSave=true</span>
                                          pSignerNym);
    } <span class="comment">// FOR_EACH ---------------------------------------------</span>
}
</pre></div>
</div>
</div>
<a class="anchor" id="a5b4a2b0e39d8aa534de380d92778bf0d"></a><!-- doxytag: member="OTSmartContract::Compare" ref="a5b4a2b0e39d8aa534de380d92778bf0d" args="(OTScriptable &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_o_t_smart_contract.html#a5b4a2b0e39d8aa534de380d92778bf0d">OTSmartContract::Compare</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_t_scriptable.html">OTScriptable</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="class_o_t_scriptable.html#aa4735bf6c25261ea1a021fd8afb57916">OTScriptable</a>.</p>

<p>Definition at line <a class="el" href="_o_t_smart_contract_8cpp_source.html#l04833">4833</a> of file <a class="el" href="_o_t_smart_contract_8cpp_source.html">OTSmartContract.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordflow">if</span> (<span class="keyword">false</span> == <a class="code" href="class_o_t_scriptable.html#aa4735bf6c25261ea1a021fd8afb57916">OTScriptable::Compare</a>(rhs))
        <span class="keywordflow">return</span> <span class="keyword">false</span>;

    <span class="comment">// -------------------------------------------------</span>
    <span class="keywordflow">if</span> (<a class="code" href="class_o_t_smart_contract.html#a24f1bc0f448832aaee8f9b665f2eec1e">GetCountStashes</a>() &gt; 0)
    {
        <a class="code" href="class_o_t_log.html#a5acd90ac91c2618f395b0ff37ad4f8ee">OTLog::Error</a>(<span class="stringliteral">&quot;OTSmartContract::Compare: Error: How is this function EVER being called when there are stashes present? Only the server can create stashes.\n&quot;</span>);
        <span class="keywordflow">return</span> <span class="keyword">false</span>;
    }

    <span class="keywordflow">if</span> (<a class="code" href="class_o_t_smart_contract.html#a400c4164f6dbced28ae4155864dcf496">GetCountStashAccts</a>() &gt; 0)
    {
        <a class="code" href="class_o_t_log.html#a5acd90ac91c2618f395b0ff37ad4f8ee">OTLog::Error</a>(<span class="stringliteral">&quot;OTSmartContract::Compare: Error: How is this function EVER being called when there are &quot;</span>
                     <span class="stringliteral">&quot;stash accounts present? Only the server can create stash accounts.\n&quot;</span>);
        <span class="keywordflow">return</span> <span class="keyword">false</span>;
    }
    <span class="comment">// -------------------------------------------------</span>

    <span class="comment">// Compare OTSmartContract specific info here.</span>
    <span class="keyword">const</span> <a class="code" href="class_o_t_smart_contract.html">OTSmartContract</a> * pSmartContract = <span class="keyword">dynamic_cast&lt;</span><span class="keyword">const </span><a class="code" href="class_o_t_smart_contract.html">OTSmartContract</a> *<span class="keyword">&gt;</span>(&amp;rhs);

    <span class="keywordflow">if</span> (NULL != pSmartContract)
    {
        <span class="keywordflow">if</span> (pSmartContract-&gt;<a class="code" href="class_o_t_smart_contract.html#a24f1bc0f448832aaee8f9b665f2eec1e">GetCountStashes</a>() &gt; 0)
        {
            <a class="code" href="class_o_t_log.html#a5acd90ac91c2618f395b0ff37ad4f8ee">OTLog::Error</a>(<span class="stringliteral">&quot;OTSmartContract::Compare: Error: How is this function EVER being called when there are stashes present on rhs? Only the server can create stashes.\n&quot;</span>);
            <span class="keywordflow">return</span> <span class="keyword">false</span>;
        }

        <span class="keywordflow">if</span> (pSmartContract-&gt;<a class="code" href="class_o_t_smart_contract.html#a400c4164f6dbced28ae4155864dcf496">GetCountStashAccts</a>() &gt; 0)
        {
            <a class="code" href="class_o_t_log.html#a5acd90ac91c2618f395b0ff37ad4f8ee">OTLog::Error</a>(<span class="stringliteral">&quot;OTSmartContract::Compare: Error: How is this function EVER being called when there are stash accounts present on rhs? Only the server can create stash accounts.\n&quot;</span>);
            <span class="keywordflow">return</span> <span class="keyword">false</span>;
        }
        <span class="comment">// ------------------------------------</span>
        <span class="keywordflow">if</span> (
<span class="comment">//          (   GetTransactionNum()  == pSmartContract-&gt;GetTransactionNum()   ) &amp;&amp; // Parties wouldn&#39;t/shouldn&#39;t have to predict the transaction # used by other parties.</span>
<span class="comment">//          (   GetSenderUserID()    == pSmartContract-&gt;GetSenderUserID()     ) &amp;&amp; // Same here -- we should allow parties to leave these blank. (THIS IS ACTIVATOR USER ID.)</span>

            (   <a class="code" href="class_o_t_instrument.html#a878dd8998f7b131b85c082575e255375">GetServerID</a>()        == pSmartContract-&gt;<a class="code" href="class_o_t_instrument.html#a878dd8998f7b131b85c082575e255375">GetServerID</a>()         ) &amp;&amp;
<span class="comment">//          (   GetCreationDate()    == pSmartContract-&gt;GetCreationDate()     ) &amp;&amp; // This gets reset each time a party confirms it. Thus, none of them will match.</span>
            (   <a class="code" href="class_o_t_instrument.html#a08eb5f25566832e1a67b3e33c0dcc13f">GetValidFrom</a>()       == pSmartContract-&gt;<a class="code" href="class_o_t_instrument.html#a08eb5f25566832e1a67b3e33c0dcc13f">GetValidFrom</a>()        ) &amp;&amp;
            (   <a class="code" href="class_o_t_instrument.html#ab83a62f51692c946ff394408026b0c18">GetValidTo</a>()         == pSmartContract-&gt;<a class="code" href="class_o_t_instrument.html#ab83a62f51692c946ff394408026b0c18">GetValidTo</a>()          )     <span class="comment">// These definitely need to match.</span>
           )
            <span class="keywordflow">return</span> <span class="keyword">true</span>;
    }

    <span class="keywordflow">return</span> <span class="keyword">false</span>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a361ba96466948934e82da4b8be6bdc8a"></a><!-- doxytag: member="OTSmartContract::ConfirmParty" ref="a361ba96466948934e82da4b8be6bdc8a" args="(OTParty &amp;theParty)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_o_t_smart_contract.html#a361ba96466948934e82da4b8be6bdc8a">OTSmartContract::ConfirmParty</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_t_party.html">OTParty</a> &amp;&#160;</td>
          <td class="paramname"><em>theParty</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="class_o_t_scriptable.html#a197539281206ac2e950ff0fc4842886b">OTScriptable</a>.</p>

<p>Definition at line <a class="el" href="_o_t_smart_contract_8cpp_source.html#l04640">4640</a> of file <a class="el" href="_o_t_smart_contract_8cpp_source.html">OTSmartContract.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordflow">if</span> (<span class="keyword">false</span> == theParty.<a class="code" href="class_o_t_party.html#a477b8c4714d7ac086630c236e4be6f89">HasActiveAgent</a>())
    {
        <a class="code" href="class_o_t_log.html#a1f7549d776ee919dcb6517f611ded015">OTLog::Output</a>(0, <span class="stringliteral">&quot;OTSmartContract::ConfirmParty: Party doesn&#39;t have an active agent -- who will sign for this smart contract?\n&quot;</span>);
        <span class="keywordflow">return</span> <span class="keyword">false</span>;
    }
    <span class="comment">// ----------------------------------------------------------------------------</span>
    <span class="comment">// Let&#39;s RESERVE however many transaction numbers we need to confirm this smartcontract...</span>
    <span class="comment">//</span>
    <span class="keyword">const</span> <a class="code" href="class_o_t_string.html">OTString</a> strServerID (<a class="code" href="class_o_t_instrument.html#a878dd8998f7b131b85c082575e255375">GetServerID</a>());

    <span class="comment">// ReserveTransNumsForConfirm() sets aside the Opening # for the party,</span>
    <span class="comment">// as well as the Closing #s for all the asset accounts for that party.</span>
    <span class="comment">//</span>
    <span class="comment">// This MUST be done before calling OTScriptable::ConfirmParty, because</span>
    <span class="comment">// *this will get SIGNED in there, and so must have its final data in</span>
    <span class="comment">// place already. If the confirmation fails, we will harvest the numbers</span>
    <span class="comment">// back again.</span>
    <span class="comment">//</span>
    <span class="keywordflow">if</span> (<span class="keyword">false</span> == theParty.<a class="code" href="class_o_t_party.html#acdd3320424cd48622f552653d79b9dc3">ReserveTransNumsForConfirm</a>(strServerID))
    {
        <a class="code" href="class_o_t_log.html#a1f7549d776ee919dcb6517f611ded015">OTLog::Output</a>(0, <span class="stringliteral">&quot;OTSmartContract::ConfirmParty: Failure trying to reserve transaction numbers for &quot;</span>
                      <span class="stringliteral">&quot;the smart contract. (Nym needs more numbers than he has.)\n&quot;</span>);
        <span class="keywordflow">return</span> <span class="keyword">false</span>;
    }
    <span class="comment">// Note: BELOW THIS POINT, the transaction numbers have been set aside, and must be retrieved,</span>
    <span class="comment">// below this point, in the event of any failure, using this call:</span>
    <span class="comment">// theParty.HarvestAllTransactionNumbers(strServerID);</span>
    <span class="comment">// ----------------------------------</span>
    <span class="comment">// Since EVERY party keeps his own signed copy, then we reset the creation date</span>
    <span class="comment">// before EACH signature. That way, we have the date of signing for EVERY signer.</span>
    <span class="comment">// (The final date will be set upon activation.)</span>
    <span class="comment">//</span>
    <span class="keyword">const</span> <a class="code" href="_o_t_common_8hpp.html#ad28ff0a3eda18840f6bda5872819167f">time64_t</a> CURRENT_TIME = <a class="code" href="_o_t_common_8hpp.html#a1163606b2546b160d50c5f0a5afe479a">OTTimeGetCurrentTime</a>(),
                 OLD_TIME     = <a class="code" href="class_o_t_cron_item.html#aec36ac68b9f13f874ce6c56940bcec24">GetCreationDate</a>();

    <span class="comment">// Set the Creation Date.</span>
    <a class="code" href="class_o_t_cron_item.html#a7668dc44368861c09a47de0f420cf2fa">SetCreationDate</a>(CURRENT_TIME);

    <span class="comment">// *********************************************************</span>
    <span class="comment">//</span>
    <span class="comment">// THIS IS where the SIGNED COPY is SAVED, so all final changes must occur ABOVE this point.</span>
    <span class="comment">//</span>
    <span class="keywordflow">if</span> (<span class="keyword">false</span> == <a class="code" href="class_o_t_scriptable.html#a197539281206ac2e950ff0fc4842886b">OTScriptable::ConfirmParty</a>(theParty))
    {
        <a class="code" href="class_o_t_log.html#a1f7549d776ee919dcb6517f611ded015">OTLog::Output</a>(0, <span class="stringliteral">&quot;OTSmartContract::ConfirmParty: Failed confirming party.\n&quot;</span>);
        <a class="code" href="class_o_t_cron_item.html#a7668dc44368861c09a47de0f420cf2fa">SetCreationDate</a>(OLD_TIME); <span class="comment">// Might as well set this back.</span>
        theParty.<a class="code" href="class_o_t_party.html#a27f92ee64f928849bde7f31d3c2b4d0a">HarvestAllTransactionNumbers</a>(strServerID); <span class="comment">// If it failed, grab BACK the numbers that we reserved above.</span>
        <span class="keywordflow">return</span> <span class="keyword">false</span>;
    }
    <span class="comment">// *********************************************************</span>

    <span class="comment">// SUCCESS!!</span>
    <span class="comment">//</span>
    <span class="keywordflow">return</span> <span class="keyword">true</span>;

    <span class="comment">// -----------------------------------------------------------</span>
    <span class="comment">// Are we good? The contract is compared against the other parties&#39; signed contracts; my own party and</span>
    <span class="comment">// transaction #s are added, and a signed copy of everything is saved in my party. Then the entire contract</span>
    <span class="comment">// is re-signed (saving its updated contents) and then sent on to the next party, who is free to release that</span>
    <span class="comment">// signature since I already have a signed copy in my party.</span>
    <span class="comment">//</span>
    <span class="comment">// Assuming all parties have signed AND provided valid transaction #s, then the server is free to get started</span>
    <span class="comment">// immediately upon activation, and furthermore to cancel whenever it wants (and probably just according to</span>
    <span class="comment">// the terms.)  There should be a standard call for seeing if a person can cancel the agreement, and if it&#39;s</span>
    <span class="comment">// not overridden in the contract, then it defaults to return true. (Note: that is done now.)</span>
    <span class="comment">//</span>
    <span class="comment">// Technically ANY party&#39;s authorizing agent could become the originator by activating the contract, but</span>
    <span class="comment">// only if all parties have validly signed.  (Server needs to verify.)</span>
}
</pre></div>
</div>
</div>
<a class="anchor" id="ac9ad18ccba9bb19d1ff2568d10386524"></a><!-- doxytag: member="OTSmartContract::DeactivateSmartContract" ref="ac9ad18ccba9bb19d1ff2568d10386524" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_o_t_smart_contract.html#ac9ad18ccba9bb19d1ff2568d10386524">OTSmartContract::DeactivateSmartContract</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_o_t_smart_contract_8cpp_source.html#l00756">756</a> of file <a class="el" href="_o_t_smart_contract_8cpp_source.html">OTSmartContract.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">// WARNING: If a party has the right to execute a clause that calls DeactivateSmartContract(),</span>
    <span class="comment">// then that party can deactivate the smartcontract by calling that clause, regardless of what</span>
    <span class="comment">// &quot;CanPartyCancelClause()&quot; says he can do.</span>
    <span class="comment">// (And by default, any legitimate party can trigger any clause, at any time, unless your script</span>
    <span class="comment">// override says differently.)</span>

    <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(0, <span class="stringliteral">&quot;OTSmartContract::DeactivateSmartContract: deactivate_contract() was called from within the script. &quot;</span>
                   <span class="stringliteral">&quot;Flagging smartcontract for removal from Cron (%lld).\n&quot;</span>, <a class="code" href="class_o_t_trackable.html#a2594d320e3b24f3210bd38a08de66a70">GetTransactionNum</a>());

    this-&gt;<a class="code" href="class_o_t_cron_item.html#a34c87380d2f8cd419c9a5cfec86427b4">FlagForRemoval</a>(); <span class="comment">// Remove it from future Cron processing, please.</span>
}
</pre></div>
</div>
</div>
<a class="anchor" id="a83282de7074313974d0db0f50b3b6e09"></a><!-- doxytag: member="OTSmartContract::ExecuteClauses" ref="a83282de7074313974d0db0f50b3b6e09" args="(mapOfClauses &amp;theClauses, OTString *pParam=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_o_t_smart_contract.html#a83282de7074313974d0db0f50b3b6e09">OTSmartContract::ExecuteClauses</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_o_t_clause_8hpp.html#a40c16432fa9c16826c026b74351425ad">mapOfClauses</a> &amp;&#160;</td>
          <td class="paramname"><em>theClauses</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_t_string.html">OTString</a> *&#160;</td>
          <td class="paramname"><em>pParam</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_o_t_smart_contract_8cpp_source.html#l03424">3424</a> of file <a class="el" href="_o_t_smart_contract_8cpp_source.html">OTSmartContract.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">// Loop through the clauses passed in, and execute them all.</span>
    <span class="comment">//</span>
    <a class="code" href="_o_t_storage_8hpp.html#a4a94c3435a932ed34e5755f3f472547c">FOR_EACH_IT</a>(<a class="code" href="_o_t_clause_8hpp.html#a40c16432fa9c16826c026b74351425ad">mapOfClauses</a>, theClauses, it_clauses)
    {
        <span class="keyword">const</span> std::string str_clause_name   = (*it_clauses).first;
        <a class="code" href="class_o_t_clause.html">OTClause</a> * pClause                  = (*it_clauses).second;
        <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>((NULL != pClause) &amp;&amp; (str_clause_name.size() &gt; 0));
        <a class="code" href="class_o_t_bylaw.html">OTBylaw</a> * pBylaw = pClause-&gt;<a class="code" href="class_o_t_clause.html#adcfc1603deba61e670b5d1374147bd6a">GetBylaw</a>();
        <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != pBylaw);
        <span class="comment">// -------------------------------------------------</span>
        <span class="comment">// By this point, we have the clause we are executing as pClause,</span>
        <span class="comment">// and we have the Bylaw it belongs to, as pBylaw.</span>
        <span class="comment">// ----------------------------------------</span>
        <span class="keyword">const</span> std::string str_code      =   pClause-&gt;<a class="code" href="class_o_t_clause.html#a29dced05f7ab1026ef191dbc013dddd6">GetCode</a>();     <span class="comment">// source code for the script.</span>
        <span class="keyword">const</span> std::string str_language  =   pBylaw-&gt;<a class="code" href="class_o_t_bylaw.html#a9227cd44b9e3bab6efdf0dcb719e126c">GetLanguage</a>();  <span class="comment">// language it&#39;s in. (Default is &quot;chai&quot;)</span>

        _SharedPtr&lt;OTScript&gt; pScript = <a class="code" href="_o_t_script_8hpp.html#af97c0dd6a02e33a9ff1c837a6d006b88">OTScriptFactory</a>(str_language, str_code);

        <a class="code" href="class_o_t_cleanup.html">OTCleanup&lt;OTVariable&gt;</a> theVarAngel;
        <span class="comment">// ---------------------------------------------------------------</span>
        <span class="comment">//</span>
        <span class="comment">// SET UP THE NATIVE CALLS, REGISTER THE PARTIES, REGISTER THE VARIABLES, AND EXECUTE THE SCRIPT.</span>
        <span class="comment">//</span>
        <span class="keywordflow">if</span> (pScript)
        {
            <span class="comment">// Register the special server-side native OT calls we make available to all scripts.</span>
            <span class="comment">//</span>
            <a class="code" href="class_o_t_smart_contract.html#ad79350fe9df32d0e129e1a8b5fe28a04">RegisterOTNativeCallsWithScript</a>(*pScript);

            <span class="comment">// ---------------------------------------</span>
            <span class="comment">// Register all the parties with the script.</span>
            <span class="comment">//</span>
            <a class="code" href="_o_t_storage_8hpp.html#aa135ed03585fa4b246d7907afbd5873d">FOR_EACH</a>(<a class="code" href="_o_t_party_8hpp.html#a029bc6921acd4516530e26201cf595f2">mapOfParties</a>, <a class="code" href="class_o_t_scriptable.html#a6a7e4ef3e0ed95f90d950b1718f815ab">m_mapParties</a>)
            {
                <span class="keyword">const</span> std::string str_party_name    = (*it).first;
                <a class="code" href="class_o_t_party.html">OTParty</a> * pParty                    = (*it).second;
                <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>((NULL != pParty) &amp;&amp; (str_party_name.size() &gt; 0));
                <span class="comment">// -----------------------</span>

                pScript-&gt;AddParty(str_party_name, *pParty);  <span class="comment">// This also registers all of Party&#39;s accounts with pScript.</span>
                <span class="comment">// -----------------------</span>
            }
            <span class="comment">// ---------------------------------------</span>
            <span class="comment">// Also need to loop through the Variables on pBylaw and register those as well.</span>
            <span class="comment">//</span>
            pBylaw-&gt;<a class="code" href="class_o_t_bylaw.html#aa9a5296f71c28edb48988fe0a8b4bf65">RegisterVariablesForExecution</a>(*pScript); <span class="comment">// This also sets all the variables as CLEAN so we can check for dirtiness after execution.</span>
            <span class="comment">// ---------------------------------------</span>
            <span class="comment">// A parameter might also be passed in, so we add that to the script as well.</span>
            <span class="comment">// (Like if a client is sending a triggerClause message to a server, and passing</span>
            <span class="comment">// a string parameter to that clause as input.)</span>
            <span class="comment">//</span>
            <a class="code" href="class_o_t_variable.html">OTVariable</a> * pVar = NULL;
            <span class="keyword">const</span> std::string str_Name(<span class="stringliteral">&quot;param_string&quot;</span>);
            std::string str_Value(<span class="stringliteral">&quot;&quot;</span>);

            <span class="comment">// See if param_string variable is already found on the bylaw...</span>
            <span class="comment">//</span>
            <span class="keywordflow">if</span> (NULL != pBylaw-&gt;<a class="code" href="class_o_t_bylaw.html#aae26ff96d920fcc17ef69e9f0c762710">GetVariable</a>(str_Name)) <span class="comment">// disallow duplicate names.</span>
            {
                <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;OTSmartContract::ExecuteClauses: While preparing to run smartcontract trans# %lld, clause: %s.  Error: &quot;</span>
                              <span class="stringliteral">&quot;Parameter variable named %s already exists. (Skipping the parameter actually passed in.)\n&quot;</span>,
                              <a class="code" href="class_o_t_trackable.html#a2594d320e3b24f3210bd38a08de66a70">GetTransactionNum</a>(), str_clause_name.c_str(), str_Name.c_str());
            }
            <span class="keywordflow">else</span> <span class="comment">// The param_string variable isn&#39;t already there. (So we add it as blank, if a value wasn&#39;t passed in.)</span>
            {
                <span class="keywordflow">if</span> (NULL != pParam) <span class="comment">// if a param was passed in...</span>
                    str_Value = pParam-&gt;<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>();
                <span class="comment">// else (it&#39;s already &quot;&quot;)</span>

                pVar = <span class="keyword">new</span> <a class="code" href="class_o_t_variable.html">OTVariable</a>(str_Name, str_Value, <a class="code" href="class_o_t_variable.html#a649f74cb58ba9ed9aeb8601750c98672a3663696326da4cd07edb796beec5c324">OTVariable::Var_Constant</a>);
                <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != pVar);
                theVarAngel.<a class="code" href="class_o_t_cleanup.html#a00a399db45f730439d2263d4429d00c1">SetCleanupTarget</a>(*pVar);
                <span class="comment">// -------------------------------------</span>
                pVar-&gt;<a class="code" href="class_o_t_variable.html#a89944d26c87080bbc6aab0ff3fe26de5">RegisterForExecution</a>(*pScript); <span class="comment">// This causes pVar to keep a pointer to the script so it can remove itself from the script upon destruction.</span>
<span class="comment">//              pScript-&gt;AddVariable(str_Name, *pVar);</span>
            }
            <span class="comment">// ****************************************</span>
            <span class="comment">// TEMP FOR TESTING (HARDCODED CLAUSE NAME HERE...)</span>
<span class="comment">//          OTVariable theReturnVal(&quot;return_val&quot;, false); // initial value is: false.</span>

            this-&gt;<a class="code" href="class_o_t_smart_contract.html#a0724be6ceeab338be3d9ea1469e82114">SetDisplayLabel</a>(&amp;str_clause_name);

            pScript-&gt;SetDisplayFilename(<a class="code" href="class_o_t_scriptable.html#a9e1d9c7e46bab582ea1922026a21b357">m_strLabel</a>.<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>());

            <span class="keywordflow">if</span> (<span class="keyword">false</span> == pScript-&gt;ExecuteScript())  <span class="comment">// If I passed theReturnVal in here, then it&#39;d be assumed a bool is expected to be returned inside it.</span>
<span class="comment">//          if (false == pScript-&gt;ExecuteScript((str_clause_name.compare(&quot;process_clause&quot;) == 0) ? &amp;theReturnVal : NULL))</span>
            {
                <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;OTSmartContract::ExecuteClauses: Error while running smartcontract trans# %lld, clause: %s \n\n&quot;</span>,
                             <a class="code" href="class_o_t_trackable.html#a2594d320e3b24f3210bd38a08de66a70">GetTransactionNum</a>(), str_clause_name.c_str());
            }
            <span class="keywordflow">else</span>
                <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(0, <span class="stringliteral">&quot;OTSmartContract::ExecuteClauses: Success executing smartcontract trans# %lld, clause: %s \n\n&quot;</span>,
                               <a class="code" href="class_o_t_trackable.html#a2594d320e3b24f3210bd38a08de66a70">GetTransactionNum</a>(), str_clause_name.c_str());
            <span class="comment">// ****************************************</span>
<span class="comment">//          For now, I&#39;ve decided to allow ALL clauses to trigger on the hook. The flag only matters after</span>
<span class="comment">//          they are done, and not between scripts. Otherwise problems could arise, such as order of execution.</span>
<span class="comment">//          Remember, there is nothing stopping people from using their own variables and ending all behavior</span>
<span class="comment">//          after that flag is set.  Todo security: revisit this just in case.</span>
<span class="comment">//</span>
<span class="comment">//          // Check this after each script.</span>
<span class="comment">//          //</span>
<span class="comment">//          if (IsFlaggedForRemoval())</span>
<span class="comment">//          {</span>
<span class="comment">//              OTLog::Output(3, &quot;OTSmartContract::ExecuteClauses: Flagged for removal by script.\n&quot;);</span>
<span class="comment">//          }</span>
        }
        <span class="comment">// ---------------------------------------------------------------</span>
        <span class="keywordflow">else</span>
        {
            <a class="code" href="class_o_t_log.html#a5acd90ac91c2618f395b0ff37ad4f8ee">OTLog::Error</a>(<span class="stringliteral">&quot;OTSmartContract::ExecuteClauses: Error instantiating script!\n&quot;</span>);
        }
    } <span class="comment">// FOR_EACH clauses...</span>

    <span class="comment">// ***************************************************************</span>

    <span class="comment">// &quot;Important&quot; variables.</span>
    <span class="comment">// (If any of them have changed, then I need to notice the parties.)</span>
    <span class="comment">//</span>
    <span class="comment">// TODO: Fix IsDirtyImportant() so that it checks for changed STASHES</span>
    <span class="comment">// as well. (Or have another function to do it, which is also called here.)</span>
    <span class="comment">//</span>
    <span class="comment">// I&#39;d like to get to where I can just call IsDirty() here, and then SAVE CRON HERE,</span>
    <span class="comment">// so I&#39;m not having to save it after EACH change, which is currently occuring in the</span>
    <span class="comment">// StashAcctFunds / MoveAcctFunds functions. Todo.</span>
    <span class="comment">//</span>
    <span class="keywordflow">if</span> (this-&gt;<a class="code" href="class_o_t_scriptable.html#a9f08ba14dc0e384301b8b69947243581">IsDirtyImportant</a>()) <span class="comment">// This tells us if any &quot;Important&quot; variables have changed since executing the scripts.</span>
    {
        <a class="code" href="class_o_t_cron.html">OTCron</a> * pCron  = <a class="code" href="class_o_t_cron_item.html#af734ad5d309fcc9b4a60d40d6c30f55a">GetCron</a>();
        <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != pCron);

        <a class="code" href="class_o_t_pseudonym.html">OTPseudonym</a> * pServerNym = pCron-&gt;<a class="code" href="class_o_t_cron.html#a7756d0dcc047209ca87632939dc11db3">GetServerNym</a>();
        <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != pServerNym);
        <span class="comment">// -----------------------------------------------------</span>
        <span class="keyword">const</span> int64_t lNewTransactionNumber = pCron-&gt;<a class="code" href="class_o_t_cron.html#a22822e0aeced441b6404cd8a2c8e00da">GetNextTransactionNumber</a>();

<span class="comment">//      OT_ASSERT(lNewTransactionNumber &gt; 0); // this can be my reminder.</span>
        <span class="keywordflow">if</span> (0 == lNewTransactionNumber)
        {
            <a class="code" href="class_o_t_log.html#a5acd90ac91c2618f395b0ff37ad4f8ee">OTLog::Error</a>(<span class="stringliteral">&quot;OTSmartContract::ExecuteClauses: ** ERROR: Notice not sent to parties, since no &quot;</span>
                         <span class="stringliteral">&quot;transaction numbers were available!\n&quot;</span>);
        }
        <span class="keywordflow">else</span>
        {
            this-&gt;<a class="code" href="class_o_t_contract.html#aae54340526fbd8eb8a18de27a4b97c83">ReleaseSignatures</a>();
            this-&gt;<a class="code" href="class_o_t_contract.html#abd60037fe655ee8cae9a3ece5d1e2ea6">SignContract</a>(*pServerNym);
            this-&gt;<a class="code" href="class_o_t_contract.html#a363ae430d4fd9256ab8364dbafb95444">SaveContract</a>();

            <span class="keyword">const</span> <a class="code" href="class_o_t_string.html">OTString</a> strReference(*<span class="keyword">this</span>);
            <span class="keywordtype">bool</span> bDroppedNotice = this-&gt;<a class="code" href="class_o_t_scriptable.html#a03d724ec348f2dc140c9ed45d6133429">SendNoticeToAllParties</a>(<span class="keyword">true</span>, <span class="comment">// bSuccessMsg=true</span>
                                                               *pServerNym, <a class="code" href="class_o_t_instrument.html#a878dd8998f7b131b85c082575e255375">GetServerID</a>(), lNewTransactionNumber,
                                                               <span class="comment">// GetTransactionNum(), // each party has its own opening trans #.</span>
                                                               strReference); <span class="comment">// pstrNote and pstrAttachment aren&#39;t used in this case.</span>

            <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(0, <span class="stringliteral">&quot;%s: FYI, &#39;Important&#39; variables were changed during the execution of this script.\n&quot;</span>
                           <span class="stringliteral">&quot;%s dropping notifications into all parties&#39; nymboxes.\n&quot;</span>,
                           __FUNCTION__, bDroppedNotice ? <span class="stringliteral">&quot;Success&quot;</span> : <span class="stringliteral">&quot;Failure&quot;</span>);
        }
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="af6c9cbe669cea11256dc7fd2a6fdddf4"></a><!-- doxytag: member="OTSmartContract::GetAcctBalance" ref="af6c9cbe669cea11256dc7fd2a6fdddf4" args="(const std::string from_acct_name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="class_o_t_smart_contract.html#af6c9cbe669cea11256dc7fd2a6fdddf4">OTSmartContract::GetAcctBalance</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>from_acct_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_o_t_smart_contract_8cpp_source.html#l00979">979</a> of file <a class="el" href="_o_t_smart_contract_8cpp_source.html">OTSmartContract.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
    <a class="code" href="class_o_t_cron.html">OTCron</a> * pCron  = <a class="code" href="class_o_t_cron_item.html#af734ad5d309fcc9b4a60d40d6c30f55a">GetCron</a>();
    <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != pCron);
    <span class="comment">// ----------------------------------</span>
    <a class="code" href="class_o_t_pseudonym.html">OTPseudonym</a> * pServerNym = pCron-&gt;<a class="code" href="class_o_t_cron.html#a7756d0dcc047209ca87632939dc11db3">GetServerNym</a>();
    <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != pServerNym);
    <span class="comment">// ---------------------------------------------------</span>
    <span class="comment">// Below this point, these are all good:</span>
    <span class="comment">//</span>
    <span class="comment">//      pServerNym, pCron.</span>
    <span class="comment">//</span>
    <span class="comment">// ---------------------------------------------------</span>

    <span class="keywordflow">if</span> (from_acct_name.size() &lt;= 0)
    {
        <a class="code" href="class_o_t_log.html#a5acd90ac91c2618f395b0ff37ad4f8ee">OTLog::Error</a>(<span class="stringliteral">&quot;OTSmartContract::GetAcctBalance: error: from_acct_name is non-existent.\n&quot;</span>);
        <span class="keywordflow">return</span> 0;
    }
    <span class="comment">// ---------------------------------------------------</span>
    <span class="comment">// Below this point, these are all good:</span>
    <span class="comment">//</span>
    <span class="comment">//      from_acct_name,</span>
    <span class="comment">//      pServerNym, pCron.</span>
    <span class="comment">//</span>
    <span class="comment">// ---------------------------------------------------</span>

    <a class="code" href="class_o_t_party_account.html">OTPartyAccount</a>  * pFromAcct = this-&gt;<a class="code" href="class_o_t_scriptable.html#a94c9e55f78357e04e4b9781ab662370f">GetPartyAccount</a>(from_acct_name);

    <span class="keywordflow">if</span> (NULL == pFromAcct)
    {
        <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(0, <span class="stringliteral">&quot;OTSmartContract::GetAcctBalances: error: from_acct (%s) not found on any party.\n&quot;</span>,
                       from_acct_name.c_str());
        <span class="keywordflow">return</span> 0;
    }
    <span class="comment">// ---------------------------------------------------</span>
    <span class="comment">//</span>
    <span class="comment">// Below this point, these are all good:</span>
    <span class="comment">//</span>
    <span class="comment">//      pFromAcct,  from_acct_name,</span>
    <span class="comment">//      pServerNym, pCron.</span>
    <span class="comment">//</span>
    <span class="comment">// ---------------------------------------------------</span>

    <a class="code" href="class_o_t_agent.html">OTAgent</a> * pFromAgent    = pFromAcct-&gt;   GetAuthorizedAgent(); <span class="comment">// This searches the account&#39;s party for the account&#39;s authorized agent.</span>
    <span class="comment">// (That way it&#39;s impossible to get an agent for any other party.)</span>

    <span class="keywordflow">if</span> (NULL == pFromAgent)
    {
        <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(0, <span class="stringliteral">&quot;OTSmartContract::GetAcctBalance: error: authorized agent (%s) not found for from_acct (%s) on acct&#39;s party.\n&quot;</span>,
                       pFromAcct-&gt;<a class="code" href="class_o_t_party_account.html#a86975046b18ac6d6c5841f5ba0befe69">GetAgentName</a>().<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>(), from_acct_name.c_str());
        <span class="keywordflow">return</span> 0;
    }
    <span class="comment">// ---------</span>
    <span class="keywordflow">if</span> (<span class="keyword">false</span> == pFromAgent-&gt;<a class="code" href="class_o_t_agent.html#a1969e4f8a5f13ee34ba0a68d8f082956">IsAnIndividual</a>())
    {
        <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(0, <span class="stringliteral">&quot;OTSmartContract::GetAcctBalance: error: authorized agent (%s) for from_acct (%s) is not an active agent.\n&quot;</span>,
                       pFromAcct-&gt;<a class="code" href="class_o_t_party_account.html#a86975046b18ac6d6c5841f5ba0befe69">GetAgentName</a>().<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>(), from_acct_name.c_str());
        <span class="keywordflow">return</span> 0;
    }
    <span class="comment">//</span>
    <span class="comment">// Below this point, these are all good:</span>
    <span class="comment">//</span>
    <span class="comment">//      pFromAcct,  from_acct_name, pFromAgent,</span>
    <span class="comment">//      pServerNym, pCron.</span>
    <span class="comment">//</span>
    <span class="comment">// ---------------------------------------------------</span>

    <a class="code" href="class_o_t_party.html">OTParty</a> * pFromParty    = pFromAgent-&gt;<a class="code" href="class_o_t_agent.html#a929a2489984f5487bd1819ed6d8862f2">GetParty</a>();

    <span class="keywordflow">if</span> (NULL == pFromParty)
    {
        <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;OTSmartContract::GetAcctBalance: error: Party pointer NULL on authorized agent (%s) for from_acct (%s).\n&quot;</span>,
                      pFromAcct-&gt;<a class="code" href="class_o_t_party_account.html#a86975046b18ac6d6c5841f5ba0befe69">GetAgentName</a>().<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>(), from_acct_name.c_str());
        <span class="keywordflow">return</span> 0;
    }
    <span class="comment">//</span>
    <span class="comment">// Below this point, these are all good:</span>
    <span class="comment">//</span>
    <span class="comment">//      pFromAcct,  from_acct_name, pFromAgent, pFromParty,</span>
    <span class="comment">//      pServerNym, pCron.</span>
    <span class="comment">//</span>
    <span class="comment">// ---------------------------------------------------</span>


    <span class="comment">// Done: I can see that THIS VERIFICATION CODE WILL GET CALLED EVERY SINGLE TIME THE SCRIPT</span>
    <span class="comment">// CALLS MOVE FUNDS.  Maybe that&#39;s good, but since technically this only needs to be verified before the</span>
    <span class="comment">// first call, and not for EVERY call during any of a script&#39;s runs, I should probably move this verification</span>
    <span class="comment">// higher, such as each time the OTCronItem triggers, plus each time a party triggers a clause directly</span>
    <span class="comment">// through the API (server message). As long as those are covered, I will be able to remove it from here</span>
    <span class="comment">// which should be a significant improvement for performance.</span>
    <span class="comment">// It will be at the bottom of those same functions that &quot;ClearTemporaryPointers()&quot; should finally be called.</span>
    <span class="comment">//</span>
    <span class="comment">//</span>
    <span class="comment">//  FINAL DECISION: Redundant, already verified upon activation on cron.</span>
    <span class="comment">//  See longer comment in OTSmartContract::StashAcctFunds()</span>
    <span class="comment">//</span>
<span class="comment">//  const OTString strServerID(GetServerID());</span>
<span class="comment">//</span>
<span class="comment">//  mapOfNyms   map_Nyms_Already_Loaded;</span>
<span class="comment">//  this-&gt;RetrieveNymPointers(map_Nyms_Already_Loaded);</span>
<span class="comment">//  // --------------------------------------------------</span>
<span class="comment">//</span>
<span class="comment">//  if (false == this-&gt;VerifyPartyAuthorization(*pFromParty, *pServerNym, strServerID, &amp;map_Nyms_Already_Loaded))</span>
<span class="comment">//  {</span>
<span class="comment">//      OTLog::vError(&quot;OTSmartContract::GetAcctBalance: error: &#39;From&#39; Party (%s) not authorized for this contract.\n&quot;,</span>
<span class="comment">//                    pFromParty-&gt;GetPartyName().c_str());</span>
<span class="comment">//      return 0;</span>
<span class="comment">//  }</span>
    <span class="comment">// *****************************************************************************</span>

    <span class="comment">// A party might have many agents who are only voting groups, and cannot actually sign for things</span>
    <span class="comment">// the way that nyms can. But at least ONE of those agents IS a Nym -- because there must have been</span>
    <span class="comment">// an authorizing agent who initially signed to accept the agreement, and who fronted the opening</span>
    <span class="comment">// transaction number that activated it.</span>
    <span class="comment">//</span>
    <span class="comment">// Similarly, the authorized agent for any given party&#39;s account (each account has its own authorized</span>
    <span class="comment">// agent) MUST be an active agent (an active agent is one with a Nym--whether that Nym is representing</span>
    <span class="comment">// himself as the party, or whether representing some entity as an employee in a role). Why MUST the</span>
    <span class="comment">// authorized agent be an active agent? Because when funds are moved, that Nym must be loaded since</span>
    <span class="comment">// the account must show that Nym as a legal owner/agent. The MoveFunds will cause a paymentReceipt to</span>
    <span class="comment">// drop into the Inbox for the relevant asset accounts, and that paymentReceipt can ONLY be accepted</span>
    <span class="comment">// by that same Nym, who must use a transaction # that he signed for previously and received through</span>
    <span class="comment">// his nymbox. There is actually no justification at all to take funds from that account, since the</span>
    <span class="comment">// new balance has not yet been signed, UNLESS THE PAYMENTRECEIPT CONTAINS A VALID, SIGNED AUTHORIZATION</span>
    <span class="comment">// FROM THE ACCOUNT HOLDER. *That* is why the authorizing agent must either be the Party&#39;s Owner himself</span>
    <span class="comment">// (representing himself as an agent, which most will do) in which case he will appear as the valid</span>
    <span class="comment">// owner of the account, OR he MUST be a Nym working in a Valid Role for an Entity, where said Entity is</span>
    <span class="comment">// the valid owner on the account in question. Either OT, it will be possible in OT for him to sign for</span>
    <span class="comment">// the paymentReceipts when they come in, and impossible for him to escape liability for them.</span>
    <span class="comment">// (That&#39;s the idea anyway.)</span>
    <span class="comment">//</span>
    <span class="comment">// Since we know that the Authorized Agent for an account must be an ACTIVE agent (one way or the other)</span>
    <span class="comment">// then we can error out here if he&#39;s not.  We can then pass in his Nym ID.</span>
    <span class="comment">//</span>

    <a class="code" href="class_o_t_identifier.html">OTIdentifier</a> theFromAgentID;
    <span class="keyword">const</span> <span class="keywordtype">bool</span> bFromAgentID = pFromAgent-&gt;<a class="code" href="class_o_t_agent.html#a7750c7f5840047c5413d95e92ad87578">GetSignerID</a>(theFromAgentID);

    <span class="keywordflow">if</span> ( ! bFromAgentID )
    {
        <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;OTSmartContract::GetAcctBalance: Failed to find FromAgent&#39;s Signer ID: %s \n&quot;</span>,
                      pFromAgent-&gt;<a class="code" href="class_o_t_agent.html#a123d27f05e46977ecdbe0b83de3c119d">GetName</a>().<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>());
        <span class="keywordflow">return</span> 0;
    }
    <span class="comment">// --------------------------------------</span>

    <span class="keywordflow">if</span> (!pFromAcct-&gt;<a class="code" href="class_o_t_party_account.html#aa5e4e0cc77853d08b3708017fe694876">GetAcctID</a>().<a class="code" href="class_o_t_string.html#adf7489cd917d4ae5bf30853a3ad78daf">Exists</a>())
    {
        <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;OTSmartContract::GetAcctBalance: Error: FromAcct has empty AcctID: %s \n&quot;</span>,
                      from_acct_name.c_str());
        <span class="keywordflow">return</span> 0;
    }

    <span class="keyword">const</span> <a class="code" href="class_o_t_identifier.html">OTIdentifier</a> theFromAcctID(pFromAcct-&gt;<a class="code" href="class_o_t_party_account.html#aa5e4e0cc77853d08b3708017fe694876">GetAcctID</a>());
    <span class="comment">//</span>
    <span class="comment">// BELOW THIS POINT, theFromAcctID and theFromAgentID available.</span>
    <span class="comment">// --------------------------------------</span>

    <span class="keyword">const</span> <a class="code" href="class_o_t_identifier.html">OTIdentifier</a>  SERVER_ID(pCron-&gt;<a class="code" href="class_o_t_cron.html#a93b52f56c0de94e53bb05a610830ba4b">GetServerID</a>());
    <span class="keyword">const</span> <a class="code" href="class_o_t_identifier.html">OTIdentifier</a>  SERVER_USER_ID(*pServerNym);

    <span class="keyword">const</span> std::string   str_party_id = pFromParty-&gt;<a class="code" href="class_o_t_party.html#a4aa12384e93bd6c2f6d437cf8ca97dfa">GetPartyID</a>();
    <span class="keyword">const</span> <a class="code" href="class_o_t_string.html">OTString</a>      strPartyID(str_party_id);
    <span class="keyword">const</span> <a class="code" href="class_o_t_identifier.html">OTIdentifier</a>  PARTY_USER_ID(strPartyID);

    <span class="keyword">const</span> <a class="code" href="class_o_t_identifier.html">OTIdentifier</a> PARTY_ACCT_ID(pFromAcct-&gt;<a class="code" href="class_o_t_party_account.html#aa5e4e0cc77853d08b3708017fe694876">GetAcctID</a>());

    <span class="comment">// --------------------------------------------------------</span>
    <span class="comment">// Load up the party&#39;s account so we can get the balance.</span>
    <span class="comment">//</span>
    <a class="code" href="class_o_t_account.html">OTAccount</a> * pPartyAssetAcct = <a class="code" href="class_o_t_account.html#a6574057f6e3415546d3a9f7d7e445e4f">OTAccount::LoadExistingAccount</a>(PARTY_ACCT_ID, SERVER_ID);

    <span class="keywordflow">if</span> (NULL == pPartyAssetAcct)
    {
        <a class="code" href="class_o_t_log.html#a1f7549d776ee919dcb6517f611ded015">OTLog::Output</a>(0, <span class="stringliteral">&quot;OTSmartContract::GetAcctBalance: ERROR verifying existence of source account.\n&quot;</span>);
        <a class="code" href="class_o_t_cron_item.html#a34c87380d2f8cd419c9a5cfec86427b4">FlagForRemoval</a>(); <span class="comment">// Remove it from future Cron processing, please.</span>
        <span class="keywordflow">return</span> 0;
    }
    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!pPartyAssetAcct-&gt;VerifySignature(*pServerNym))
    {
        <a class="code" href="class_o_t_log.html#a1f7549d776ee919dcb6517f611ded015">OTLog::Output</a>(0, <span class="stringliteral">&quot;OTSmartContract::GetAcctBalance: ERROR failed to verify the server&#39;s signature on the party&#39;s account.\n&quot;</span>);
        <a class="code" href="class_o_t_cron_item.html#a34c87380d2f8cd419c9a5cfec86427b4">FlagForRemoval</a>(); <span class="comment">// Remove it from future Cron processing, please.</span>
        <span class="keywordflow">return</span> 0;
    }
    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!pPartyAssetAcct-&gt;VerifyOwnerByID(PARTY_USER_ID))
    {
        <a class="code" href="class_o_t_log.html#a1f7549d776ee919dcb6517f611ded015">OTLog::Output</a>(0, <span class="stringliteral">&quot;OTSmartContract::GetAcctBalance: ERROR failed to verify party user ownership of party account.\n&quot;</span>);
        <a class="code" href="class_o_t_cron_item.html#a34c87380d2f8cd419c9a5cfec86427b4">FlagForRemoval</a>(); <span class="comment">// Remove it from future Cron processing, please.</span>
        <span class="keywordflow">return</span> 0;
    }
    <span class="comment">// Past this point we know pPartyAssetAcct is good and will clean itself up.</span>
    <a class="code" href="class_o_t_cleanup.html">OTCleanup&lt;OTAccount&gt;</a>    theSourceAcctSmrtPtr(*pPartyAssetAcct);
    <span class="comment">// -----------------------------------------------------------------</span>

    <a class="code" href="class_o_t_string.html">OTString</a> strBalance;
    strBalance.<a class="code" href="class_o_t_string.html#af1c861f21033a1d583b3cb12f952422e">Format</a>(<span class="stringliteral">&quot;%lld&quot;</span>, pPartyAssetAcct-&gt;GetBalance());

    <span class="keywordflow">return</span> strBalance.<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>();
}
</pre></div>
</div>
</div>
<a class="anchor" id="ace4cafaf9afe3c3076271564d699cc65"></a><!-- doxytag: member="OTSmartContract::GetAllTransactionNumbers" ref="ace4cafaf9afe3c3076271564d699cc65" args="(OTNumList &amp;numlistOutput) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_o_t_smart_contract.html#ace4cafaf9afe3c3076271564d699cc65">OTSmartContract::GetAllTransactionNumbers</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_t_num_list.html">OTNumList</a> &amp;&#160;</td>
          <td class="paramname"><em>numlistOutput</em></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="class_o_t_trackable.html#a665238c671ce6b084538141550f9a67d">OTTrackable</a>.</p>

<p>Definition at line <a class="el" href="_o_t_smart_contract_8cpp_source.html#l00840">840</a> of file <a class="el" href="_o_t_smart_contract_8cpp_source.html">OTSmartContract.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
    <a class="code" href="_o_t_storage_8hpp.html#a804eb881e96b7e1846d130a55a94f716">FOR_EACH_CONST</a>(<a class="code" href="_o_t_party_8hpp.html#a029bc6921acd4516530e26201cf595f2">mapOfParties</a>, <a class="code" href="class_o_t_scriptable.html#a6a7e4ef3e0ed95f90d950b1718f815ab">m_mapParties</a>)
    {
        <span class="keyword">const</span> <a class="code" href="class_o_t_party.html">OTParty</a> * pParty = (*it).second;
        <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != pParty);
        <span class="comment">// ----------------------------------</span>
        pParty-&gt;<a class="code" href="class_o_t_party.html#ac8879e0a5d65ac273a56711336a9d45c">GetAllTransactionNumbers</a>(numlistOutput);
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="aef2b64b4870a325f36df1e634f744ce9"></a><!-- doxytag: member="OTSmartContract::GetAssetTypeIDofAcct" ref="aef2b64b4870a325f36df1e634f744ce9" args="(const std::string from_acct_name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="class_o_t_smart_contract.html#aef2b64b4870a325f36df1e634f744ce9">OTSmartContract::GetAssetTypeIDofAcct</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>from_acct_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_o_t_smart_contract_8cpp_source.html#l01181">1181</a> of file <a class="el" href="_o_t_smart_contract_8cpp_source.html">OTSmartContract.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
    <a class="code" href="class_o_t_cron.html">OTCron</a> * pCron  = <a class="code" href="class_o_t_cron_item.html#af734ad5d309fcc9b4a60d40d6c30f55a">GetCron</a>();
    <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != pCron);
    <span class="comment">// ----------------------------------</span>
    <a class="code" href="class_o_t_pseudonym.html">OTPseudonym</a> * pServerNym = pCron-&gt;<a class="code" href="class_o_t_cron.html#a7756d0dcc047209ca87632939dc11db3">GetServerNym</a>();
    <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != pServerNym);
    <span class="comment">// ---------------------------------------------------</span>
    <span class="comment">// Below this point, these are all good:</span>
    <span class="comment">//</span>
    <span class="comment">//      pServerNym, pCron.</span>
    <span class="comment">//</span>
    <span class="comment">// ---------------------------------------------------</span>

    std::string str_return_value;

    <span class="comment">// ---------------------------------------------------</span>
    <span class="keywordflow">if</span> (from_acct_name.size() &lt;= 0)
    {
        <a class="code" href="class_o_t_log.html#a5acd90ac91c2618f395b0ff37ad4f8ee">OTLog::Error</a>(<span class="stringliteral">&quot;OTSmartContract::GetAssetTypeIDofAcct: error: from_acct_name is non-existent.\n&quot;</span>);
        <span class="keywordflow">return</span> str_return_value;
    }
    <span class="comment">// ---------------------------------------------------</span>
    <span class="comment">// Below this point, these are all good:</span>
    <span class="comment">//</span>
    <span class="comment">//      from_acct_name,</span>
    <span class="comment">//      pServerNym, pCron.</span>
    <span class="comment">//</span>
    <span class="comment">// ---------------------------------------------------</span>

    <a class="code" href="class_o_t_party_account.html">OTPartyAccount</a>  * pFromAcct = this-&gt;<a class="code" href="class_o_t_scriptable.html#a94c9e55f78357e04e4b9781ab662370f">GetPartyAccount</a>(from_acct_name);

    <span class="keywordflow">if</span> (NULL == pFromAcct)
    {
        <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(0, <span class="stringliteral">&quot;OTSmartContract::GetAssetTypeIDofAcct: error: from_acct (%s) not found on any party.\n&quot;</span>,
                       from_acct_name.c_str());
        <span class="keywordflow">return</span> str_return_value;
    }
    <span class="comment">// ---------------------------------------------------</span>
    <span class="comment">//</span>
    <span class="comment">// Below this point, these are all good:</span>
    <span class="comment">//</span>
    <span class="comment">//      pFromAcct,  from_acct_name,</span>
    <span class="comment">//      pServerNym, pCron.</span>
    <span class="comment">//</span>
    <span class="comment">// ---------------------------------------------------</span>

    <a class="code" href="class_o_t_agent.html">OTAgent</a> * pFromAgent = pFromAcct-&gt;<a class="code" href="class_o_t_party_account.html#ad8c523b08a478e4071bb2b3ca85749b1">GetAuthorizedAgent</a>(); <span class="comment">// This searches the account&#39;s party for the account&#39;s authorized agent.</span>
    <span class="comment">// (That way it&#39;s impossible to get an agent for any other party.)</span>

    <span class="keywordflow">if</span> (NULL == pFromAgent)
    {
        <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(0, <span class="stringliteral">&quot;OTSmartContract::GetAssetTypeIDofAcct: error: authorized agent (%s) not found for from_acct (%s) on acct&#39;s party.\n&quot;</span>,
                       pFromAcct-&gt;<a class="code" href="class_o_t_party_account.html#a86975046b18ac6d6c5841f5ba0befe69">GetAgentName</a>().<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>(), from_acct_name.c_str());
        <span class="keywordflow">return</span> str_return_value;
    }
    <span class="comment">// ---------</span>
    <span class="keywordflow">if</span> (<span class="keyword">false</span> == pFromAgent-&gt;<a class="code" href="class_o_t_agent.html#a1969e4f8a5f13ee34ba0a68d8f082956">IsAnIndividual</a>())
    {
        <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(0, <span class="stringliteral">&quot;OTSmartContract::GetAssetTypeIDofAcct: error: authorized agent (%s) for from_acct (%s) is not an active agent.\n&quot;</span>,
                       pFromAcct-&gt;<a class="code" href="class_o_t_party_account.html#a86975046b18ac6d6c5841f5ba0befe69">GetAgentName</a>().<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>(), from_acct_name.c_str());
        <span class="keywordflow">return</span> str_return_value;
    }
    <span class="comment">//</span>
    <span class="comment">// Below this point, these are all good:</span>
    <span class="comment">//</span>
    <span class="comment">//      pFromAcct,  from_acct_name, pFromAgent,</span>
    <span class="comment">//      pServerNym, pCron.</span>
    <span class="comment">//</span>
    <span class="comment">// ---------------------------------------------------</span>

    <a class="code" href="class_o_t_party.html">OTParty</a> * pFromParty    = pFromAgent-&gt;<a class="code" href="class_o_t_agent.html#a929a2489984f5487bd1819ed6d8862f2">GetParty</a>();

    <span class="keywordflow">if</span> (NULL == pFromParty)
    {
        <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;OTSmartContract::GetAssetTypeIDofAcct: error: Party pointer NULL on authorized agent (%s) for from_acct (%s).\n&quot;</span>,
                      pFromAcct-&gt;<a class="code" href="class_o_t_party_account.html#a86975046b18ac6d6c5841f5ba0befe69">GetAgentName</a>().<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>(), from_acct_name.c_str());
        <span class="keywordflow">return</span> str_return_value;
    }
    <span class="comment">//</span>
    <span class="comment">// Below this point, these are all good:</span>
    <span class="comment">//</span>
    <span class="comment">//      pFromAcct,  from_acct_name, pFromAgent, pFromParty,</span>
    <span class="comment">//      pServerNym, pCron.</span>
    <span class="comment">//</span>
    <span class="comment">// ---------------------------------------------------</span>


    <span class="comment">// Done: I can see that THIS VERIFICATION CODE WILL GET CALLED EVERY SINGLE TIME THE SCRIPT</span>
    <span class="comment">// CALLS MOVE FUNDS.  Maybe that&#39;s good, but since technically this only needs to be verified before the</span>
    <span class="comment">// first call, and not for EVERY call during any of a script&#39;s runs, I should probably move this verification</span>
    <span class="comment">// higher, such as each time the OTCronItem triggers, plus each time a party triggers a clause directly</span>
    <span class="comment">// through the API (server message). As long as those are covered, I will be able to remove it from here</span>
    <span class="comment">// which should be a significant improvement for performance.</span>
    <span class="comment">// It will be at the bottom of those same functions that &quot;ClearTemporaryPointers()&quot; should finally be called.</span>
    <span class="comment">//</span>
    <span class="comment">//</span>
    <span class="comment">// FINAL DECISION: Redunant, already done upon activation onto cron. Furthermore, expects no stashes to exist,</span>
    <span class="comment">// since they can only be created after activation. (Interfered with script operations by complaining whenever</span>
    <span class="comment">// there was a stash.) See longer comment in StashAcctFunds().</span>
    <span class="comment">//</span>
<span class="comment">//  const OTString strServerID(GetServerID());</span>
<span class="comment">//</span>
<span class="comment">//  mapOfNyms   map_Nyms_Already_Loaded;</span>
<span class="comment">//  this-&gt;RetrieveNymPointers(map_Nyms_Already_Loaded);</span>
<span class="comment">//  // --------------------------------------------------</span>
<span class="comment">//</span>
<span class="comment">//  if (false == this-&gt;VerifyPartyAuthorization(*pFromParty, *pServerNym, strServerID, &amp;map_Nyms_Already_Loaded))</span>
<span class="comment">//  {</span>
<span class="comment">//      OTLog::vError(&quot;OTSmartContract::GetAssetTypeIDofAcct: error: &#39;From&#39; Party (%s) not authorized for this contract.\n&quot;,</span>
<span class="comment">//                    pFromParty-&gt;GetPartyName().c_str());</span>
<span class="comment">//      return str_return_value;</span>
<span class="comment">//  }</span>
    <span class="comment">// *****************************************************************************</span>

    <span class="comment">// A party might have many agents who are only voting groups, and cannot actually sign for things</span>
    <span class="comment">// the way that nyms can. But at least ONE of those agents IS a Nym -- because there must have been</span>
    <span class="comment">// an authorizing agent who initially signed to accept the agreement, and who fronted the opening</span>
    <span class="comment">// transaction number that activated it.</span>
    <span class="comment">//</span>
    <span class="comment">// Similarly, the authorized agent for any given party&#39;s account (each account has its own authorized</span>
    <span class="comment">// agent) MUST be an active agent (an active agent is one with a Nym--whether that Nym is representing</span>
    <span class="comment">// himself as the party, or whether representing some entity as an employee in a role). Why MUST the</span>
    <span class="comment">// authorized agent be an active agent? Because when funds are moved, that Nym must be loaded since</span>
    <span class="comment">// the account must show that Nym as a legal owner/agent. The MoveFunds will cause a paymentReceipt to</span>
    <span class="comment">// drop into the Inbox for the relevant asset accounts, and that paymentReceipt can ONLY be accepted</span>
    <span class="comment">// by that same Nym, who must use a transaction # that he signed for previously and received through</span>
    <span class="comment">// his nymbox. There is actually no justification at all to take funds from that account, since the</span>
    <span class="comment">// new balance has not yet been signed, UNLESS THE PAYMENTRECEIPT CONTAINS A VALID, SIGNED AUTHORIZATION</span>
    <span class="comment">// FROM THE ACCOUNT HOLDER. *That* is why the authorizing agent must either be the Party&#39;s Owner himself</span>
    <span class="comment">// (representing himself as an agent, which most will do) in which case he will appear as the valid</span>
    <span class="comment">// owner of the account, OR he MUST be a Nym working in a Valid Role for an Entity, where said Entity is</span>
    <span class="comment">// the valid owner on the account in question. Either OT, it will be possible in OT for him to sign for</span>
    <span class="comment">// the paymentReceipts when they come in, and impossible for him to escape liability for them.</span>
    <span class="comment">// (That&#39;s the idea anyway.)</span>
    <span class="comment">//</span>
    <span class="comment">// Since we know that the Authorized Agent for an account must be an ACTIVE agent (one way or the other)</span>
    <span class="comment">// then we can error out here if he&#39;s not.  We can then pass in his Nym ID.</span>
    <span class="comment">//</span>

    <a class="code" href="class_o_t_identifier.html">OTIdentifier</a> theFromAgentID;
    <span class="keyword">const</span> <span class="keywordtype">bool</span> bFromAgentID = pFromAgent-&gt;<a class="code" href="class_o_t_agent.html#a7750c7f5840047c5413d95e92ad87578">GetSignerID</a>(theFromAgentID);

    <span class="keywordflow">if</span> ( ! bFromAgentID )
    {
        <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;OTSmartContract::GetAssetTypeIDofAcct: Failed to find FromAgent&#39;s Signer ID: %s \n&quot;</span>,
                      pFromAgent-&gt;<a class="code" href="class_o_t_agent.html#a123d27f05e46977ecdbe0b83de3c119d">GetName</a>().<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>());
        <span class="keywordflow">return</span> str_return_value;
    }
    <span class="comment">// --------------------------------------</span>

    <span class="keywordflow">if</span> (!pFromAcct-&gt;<a class="code" href="class_o_t_party_account.html#aa5e4e0cc77853d08b3708017fe694876">GetAcctID</a>().<a class="code" href="class_o_t_string.html#adf7489cd917d4ae5bf30853a3ad78daf">Exists</a>())
    {
        <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;OTSmartContract::GetAssetTypeIDofAcct: Error: FromAcct has empty AcctID: %s \n&quot;</span>,
                      from_acct_name.c_str());
        <span class="keywordflow">return</span> str_return_value;
    }

    <span class="keyword">const</span> <a class="code" href="class_o_t_identifier.html">OTIdentifier</a> theFromAcctID(pFromAcct-&gt;<a class="code" href="class_o_t_party_account.html#aa5e4e0cc77853d08b3708017fe694876">GetAcctID</a>());
    <span class="comment">//</span>
    <span class="comment">// BELOW THIS POINT, theFromAcctID and theFromAgentID available.</span>
    <span class="comment">// --------------------------------------</span>

    <span class="keyword">const</span> <a class="code" href="class_o_t_identifier.html">OTIdentifier</a>  SERVER_ID(pCron-&gt;<a class="code" href="class_o_t_cron.html#a93b52f56c0de94e53bb05a610830ba4b">GetServerID</a>());
    <span class="keyword">const</span> <a class="code" href="class_o_t_identifier.html">OTIdentifier</a>  SERVER_USER_ID(*pServerNym);

    <span class="keyword">const</span> std::string   str_party_id = pFromParty-&gt;<a class="code" href="class_o_t_party.html#a4aa12384e93bd6c2f6d437cf8ca97dfa">GetPartyID</a>();
    <span class="keyword">const</span> <a class="code" href="class_o_t_string.html">OTString</a>      strPartyID(str_party_id);
    <span class="keyword">const</span> <a class="code" href="class_o_t_identifier.html">OTIdentifier</a>  PARTY_USER_ID(strPartyID);

    <span class="keyword">const</span> <a class="code" href="class_o_t_identifier.html">OTIdentifier</a> PARTY_ACCT_ID(pFromAcct-&gt;<a class="code" href="class_o_t_party_account.html#aa5e4e0cc77853d08b3708017fe694876">GetAcctID</a>());

    <span class="comment">// --------------------------------------------------------</span>
    <span class="comment">// Load up the party&#39;s account and get the asset type.</span>
    <span class="comment">//</span>
    <a class="code" href="class_o_t_account.html">OTAccount</a> * pPartyAssetAcct = <a class="code" href="class_o_t_account.html#a6574057f6e3415546d3a9f7d7e445e4f">OTAccount::LoadExistingAccount</a>(PARTY_ACCT_ID, SERVER_ID);

    <span class="keywordflow">if</span> (NULL == pPartyAssetAcct)
    {
        <a class="code" href="class_o_t_log.html#a1f7549d776ee919dcb6517f611ded015">OTLog::Output</a>(0, <span class="stringliteral">&quot;OTSmartContract::GetAssetTypeIDofAcct: ERROR verifying existence of source account.\n&quot;</span>);
        <a class="code" href="class_o_t_cron_item.html#a34c87380d2f8cd419c9a5cfec86427b4">FlagForRemoval</a>(); <span class="comment">// Remove it from future Cron processing, please.</span>
        <span class="keywordflow">return</span> str_return_value;
    }
    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!pPartyAssetAcct-&gt;VerifySignature(*pServerNym))
    {
        <a class="code" href="class_o_t_log.html#a1f7549d776ee919dcb6517f611ded015">OTLog::Output</a>(0, <span class="stringliteral">&quot;OTSmartContract::GetAssetTypeIDofAcct: ERROR failed to verify the server&#39;s signature on the party&#39;s account.\n&quot;</span>);
        <a class="code" href="class_o_t_cron_item.html#a34c87380d2f8cd419c9a5cfec86427b4">FlagForRemoval</a>(); <span class="comment">// Remove it from future Cron processing, please.</span>
        <span class="keywordflow">return</span> str_return_value;
    }
    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!pPartyAssetAcct-&gt;VerifyOwnerByID(PARTY_USER_ID))
    {
        <a class="code" href="class_o_t_log.html#a1f7549d776ee919dcb6517f611ded015">OTLog::Output</a>(0, <span class="stringliteral">&quot;OTSmartContract::GetAssetTypeIDofAcct: ERROR failed to verify party user ownership of party account.\n&quot;</span>);
        <a class="code" href="class_o_t_cron_item.html#a34c87380d2f8cd419c9a5cfec86427b4">FlagForRemoval</a>(); <span class="comment">// Remove it from future Cron processing, please.</span>
        <span class="keywordflow">return</span> str_return_value;
    }
    <span class="comment">// Past this point we know pPartyAssetAcct is good and will clean itself up.</span>
    <a class="code" href="class_o_t_cleanup.html">OTCleanup&lt;OTAccount&gt;</a>    theSourceAcctSmrtPtr(*pPartyAssetAcct);
    <span class="comment">// -----------------------------------------------------------------</span>

    <span class="keyword">const</span> <a class="code" href="class_o_t_string.html">OTString</a> strAssetTypeID(pPartyAssetAcct-&gt;GetAssetTypeID());
    str_return_value = strAssetTypeID.<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>();

    <span class="keywordflow">return</span> str_return_value;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a3a9a2325c23aa03f4e6ce03fec6f69f7"></a><!-- doxytag: member="OTSmartContract::GetClosingNumber" ref="a3a9a2325c23aa03f4e6ce03fec6f69f7" args="(const OTIdentifier &amp;theAcctID) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t <a class="el" href="class_o_t_smart_contract.html#a3a9a2325c23aa03f4e6ce03fec6f69f7">OTSmartContract::GetClosingNumber</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_t_identifier.html">OTIdentifier</a> &amp;&#160;</td>
          <td class="paramname"><em>theAcctID</em></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="class_o_t_cron_item.html#acb5f09af7950df9591c267031745a3e7">OTCronItem</a>.</p>

<p>Definition at line <a class="el" href="_o_t_smart_contract_8cpp_source.html#l00867">867</a> of file <a class="el" href="_o_t_smart_contract_8cpp_source.html">OTSmartContract.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
    <a class="code" href="class_o_t_party_account.html">OTPartyAccount</a>  * pPartyAcct = this-&gt;<a class="code" href="class_o_t_scriptable.html#ae4abf1800fd193dc93835b777f40019c">GetPartyAccountByID</a>(theAcctID); <span class="comment">// from OTScriptable.</span>

    <span class="keywordflow">if</span> (NULL != pPartyAcct)
    {
        <span class="keywordflow">return</span> pPartyAcct-&gt;<a class="code" href="class_o_t_party_account.html#add572c3b200be9265d9dcc4a1b1f4185">GetClosingTransNo</a>();
    }

    <span class="keywordflow">return</span> 0;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a400c4164f6dbced28ae4155864dcf496"></a><!-- doxytag: member="OTSmartContract::GetCountStashAccts" ref="a400c4164f6dbced28ae4155864dcf496" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t <a class="el" href="class_o_t_smart_contract.html#a400c4164f6dbced28ae4155864dcf496">OTSmartContract::GetCountStashAccts</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_o_t_smart_contract_8cpp_source.html#l04822">4822</a> of file <a class="el" href="_o_t_smart_contract_8cpp_source.html">OTSmartContract.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordflow">return</span> m_StashAccts.<a class="code" href="class_o_t_acct_list.html#af511014ed6540bbf9b04728d3dea211c">GetCountAccountIDs</a>();
}
</pre></div>
</div>
</div>
<a class="anchor" id="a24f1bc0f448832aaee8f9b665f2eec1e"></a><!-- doxytag: member="OTSmartContract::GetCountStashes" ref="a24f1bc0f448832aaee8f9b665f2eec1e" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t <a class="el" href="class_o_t_smart_contract.html#a24f1bc0f448832aaee8f9b665f2eec1e">OTSmartContract::GetCountStashes</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_o_t_smart_contract_8cpp_source.html#l04816">4816</a> of file <a class="el" href="_o_t_smart_contract_8cpp_source.html">OTSmartContract.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span>int32_t<span class="keyword">&gt;</span> (m_mapStashes.size());
}
</pre></div>
</div>
</div>
<a class="anchor" id="a3493a6e50d526fd228d71eb3d571fda1"></a><!-- doxytag: member="OTSmartContract::GetLastRecipientAcctID" ref="a3493a6e50d526fd228d71eb3d571fda1" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_o_t_string.html">OTString</a>&amp; <a class="el" href="class_o_t_smart_contract.html#a3493a6e50d526fd228d71eb3d571fda1">OTSmartContract::GetLastRecipientAcctID</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_o_t_smart_contract_8hpp_source.html#l00234">234</a> of file <a class="el" href="_o_t_smart_contract_8hpp_source.html">OTSmartContract.hpp</a>.</p>
<div class="fragment"><pre class="fragment">{ <span class="keywordflow">return</span> m_strLastRecipientAcct; }
</pre></div>
</div>
</div>
<a class="anchor" id="a5e4cc7155d92196c3031a725fd199230"></a><!-- doxytag: member="OTSmartContract::GetLastRecipientUserID" ref="a5e4cc7155d92196c3031a725fd199230" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_o_t_string.html">OTString</a>&amp; <a class="el" href="class_o_t_smart_contract.html#a5e4cc7155d92196c3031a725fd199230">OTSmartContract::GetLastRecipientUserID</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_o_t_smart_contract_8hpp_source.html#l00233">233</a> of file <a class="el" href="_o_t_smart_contract_8hpp_source.html">OTSmartContract.hpp</a>.</p>
<div class="fragment"><pre class="fragment">{ <span class="keywordflow">return</span> m_strLastRecipientUser; }
</pre></div>
</div>
</div>
<a class="anchor" id="af1cf6cb6b4d53612f587f5cf5fa70c2d"></a><!-- doxytag: member="OTSmartContract::GetLastSenderAcctID" ref="af1cf6cb6b4d53612f587f5cf5fa70c2d" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_o_t_string.html">OTString</a>&amp; <a class="el" href="class_o_t_smart_contract.html#af1cf6cb6b4d53612f587f5cf5fa70c2d">OTSmartContract::GetLastSenderAcctID</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_o_t_smart_contract_8hpp_source.html#l00232">232</a> of file <a class="el" href="_o_t_smart_contract_8hpp_source.html">OTSmartContract.hpp</a>.</p>
<div class="fragment"><pre class="fragment">{ <span class="keywordflow">return</span> m_strLastSenderAcct; }
</pre></div>
</div>
</div>
<a class="anchor" id="aeb06c37756e2188d2f05eb3a2102a14a"></a><!-- doxytag: member="OTSmartContract::GetLastSenderUserID" ref="aeb06c37756e2188d2f05eb3a2102a14a" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_o_t_string.html">OTString</a>&amp; <a class="el" href="class_o_t_smart_contract.html#aeb06c37756e2188d2f05eb3a2102a14a">OTSmartContract::GetLastSenderUserID</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_o_t_smart_contract_8hpp_source.html#l00231">231</a> of file <a class="el" href="_o_t_smart_contract_8hpp_source.html">OTSmartContract.hpp</a>.</p>
<div class="fragment"><pre class="fragment">{ <span class="keywordflow">return</span> m_strLastSenderUser; }
</pre></div>
</div>
</div>
<a class="anchor" id="a16737b147030f0aaaedc53f798c35a50"></a><!-- doxytag: member="OTSmartContract::GetNextProcessDate" ref="a16737b147030f0aaaedc53f798c35a50" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="_o_t_common_8hpp.html#ad28ff0a3eda18840f6bda5872819167f">time64_t</a>&amp; <a class="el" href="class_o_t_smart_contract.html#a16737b147030f0aaaedc53f798c35a50">OTSmartContract::GetNextProcessDate</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_o_t_smart_contract_8hpp_source.html#l00220">220</a> of file <a class="el" href="_o_t_smart_contract_8hpp_source.html">OTSmartContract.hpp</a>.</p>
<div class="fragment"><pre class="fragment">{ <span class="keywordflow">return</span> m_tNextProcessDate; }
</pre></div>
</div>
</div>
<a class="anchor" id="a2bb8a0f8a1ff8ddf637e5d87d5935e51"></a><!-- doxytag: member="OTSmartContract::GetOpeningNumber" ref="a2bb8a0f8a1ff8ddf637e5d87d5935e51" args="(const OTIdentifier &amp;theNymID) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t <a class="el" href="class_o_t_smart_contract.html#a2bb8a0f8a1ff8ddf637e5d87d5935e51">OTSmartContract::GetOpeningNumber</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_t_identifier.html">OTIdentifier</a> &amp;&#160;</td>
          <td class="paramname"><em>theNymID</em></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="class_o_t_cron_item.html#a8f59139b6000733ec3c1df6d1dbc7632">OTCronItem</a>.</p>

<p>Definition at line <a class="el" href="_o_t_smart_contract_8cpp_source.html#l00852">852</a> of file <a class="el" href="_o_t_smart_contract_8cpp_source.html">OTSmartContract.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
    <a class="code" href="class_o_t_agent.html">OTAgent</a> * pAgent = NULL;
    <a class="code" href="class_o_t_party.html">OTParty</a> * pParty = this-&gt;<a class="code" href="class_o_t_scriptable.html#af0eddbe4b88394bcc113d9333d8e0a97">FindPartyBasedOnNymIDAsAgent</a>(theNymID, &amp;pAgent);

    <span class="keywordflow">if</span> (NULL != pParty)
    {
        <a class="code" href="_o_t_assert_8hpp.html#a033b133f48e61f2b227c52ad2be0c882">OT_ASSERT_MSG</a>(NULL != pAgent, <span class="stringliteral">&quot;OT_ASSERT: NULL != pAgent in OTSmartContract::GetOpeningNumber.\n&quot;</span>);
        <span class="keywordflow">return</span> pParty-&gt;<a class="code" href="class_o_t_party.html#aa11f990dfe9743dd1d8e34af8bfd693a">GetOpeningTransNo</a>();
    }

    <span class="keywordflow">return</span> 0;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a71f505b723bbb56e75a46b9836c3949c"></a><!-- doxytag: member="OTSmartContract::GetRemainingTimer" ref="a71f505b723bbb56e75a46b9836c3949c" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="class_o_t_smart_contract.html#a71f505b723bbb56e75a46b9836c3949c">OTSmartContract::GetRemainingTimer</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_o_t_smart_contract_8cpp_source.html#l00912">912</a> of file <a class="el" href="_o_t_smart_contract_8cpp_source.html">OTSmartContract.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keyword">const</span> <a class="code" href="_o_t_common_8hpp.html#ad28ff0a3eda18840f6bda5872819167f">time64_t</a> tNextDate    = <a class="code" href="class_o_t_smart_contract.html#a16737b147030f0aaaedc53f798c35a50">GetNextProcessDate</a>();
    <span class="keyword">const</span> <a class="code" href="_o_t_common_8hpp.html#ad28ff0a3eda18840f6bda5872819167f">time64_t</a> tCurrent = <a class="code" href="_o_t_common_8hpp.html#a1163606b2546b160d50c5f0a5afe479a">OTTimeGetCurrentTime</a>();

    <a class="code" href="class_o_t_string.html">OTString</a> strReturnVal(<span class="stringliteral">&quot;0&quot;</span>); <span class="comment">// the default return value is &quot;0&quot;.</span>

    <span class="keywordflow">if</span> (tNextDate &gt; <a class="code" href="_o_t_common_8hpp.html#af4ca9fa2c7c290d647dd18de0a9ac25f">OT_TIME_ZERO</a>)
    {
        <span class="keyword">const</span> int64_t tSecondsLeft = <a class="code" href="_o_t_common_8hpp.html#a4c78edddfcabfde278fafe43149f027e">OTTimeGetTimeInterval</a>(tNextDate, tCurrent);
        strReturnVal.Format(<span class="stringliteral">&quot;%&quot;</span> PRId64<span class="stringliteral">&quot;&quot;</span>, tSecondsLeft);
    }

    <span class="keywordflow">return</span> strReturnVal.Get();
}
</pre></div>
</div>
</div>
<a class="anchor" id="af7305d13e0ac4c2bef284658bdd9ec67"></a><!-- doxytag: member="OTSmartContract::GetStash" ref="af7305d13e0ac4c2bef284658bdd9ec67" args="(const std::string str_stash_name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_t_stash.html">OTStash</a> * <a class="el" href="class_o_t_smart_contract.html#af7305d13e0ac4c2bef284658bdd9ec67">OTSmartContract::GetStash</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>str_stash_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_o_t_smart_contract_8cpp_source.html#l04715">4715</a> of file <a class="el" href="_o_t_smart_contract_8cpp_source.html">OTSmartContract.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
    mapOfStashes::iterator it = m_mapStashes.find(str_stash_name);

    <span class="keywordflow">if</span> (m_mapStashes.end() == it) <span class="comment">// It&#39;s not there. Create it.</span>
    {
        <a class="code" href="class_o_t_stash.html">OTStash</a> * pStash = <span class="keyword">new</span> <a class="code" href="class_o_t_stash.html">OTStash</a> (str_stash_name);
        <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != pStash);

        m_mapStashes.insert(std::pair&lt;std::string, OTStash *&gt;(str_stash_name, pStash));
        <span class="keywordflow">return</span> pStash;
    }

    <a class="code" href="class_o_t_stash.html">OTStash</a> * pStash = (*it).second;
    <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != pStash);

    <span class="keywordflow">return</span> pStash;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a2a92d021daf88edba58aabba629d90e5"></a><!-- doxytag: member="OTSmartContract::GetStashBalance" ref="a2a92d021daf88edba58aabba629d90e5" args="(const std::string stash_name, const std::string asset_type_id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="class_o_t_smart_contract.html#a2a92d021daf88edba58aabba629d90e5">OTSmartContract::GetStashBalance</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>stash_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>asset_type_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_o_t_smart_contract_8cpp_source.html#l01391">1391</a> of file <a class="el" href="_o_t_smart_contract_8cpp_source.html">OTSmartContract.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
    <a class="code" href="class_o_t_cron.html">OTCron</a> * pCron  = <a class="code" href="class_o_t_cron_item.html#af734ad5d309fcc9b4a60d40d6c30f55a">GetCron</a>();
    <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != pCron);
    <span class="comment">// ----------------------------------</span>
    <a class="code" href="class_o_t_pseudonym.html">OTPseudonym</a> * pServerNym = pCron-&gt;<a class="code" href="class_o_t_cron.html#a7756d0dcc047209ca87632939dc11db3">GetServerNym</a>();
    <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != pServerNym);
    <span class="comment">// ---------------------------------------------------</span>
    <span class="comment">// Below this point, these are all good:</span>
    <span class="comment">//</span>
    <span class="comment">//      pServerNym, pCron.</span>
    <span class="comment">//</span>
    <span class="comment">// ---------------------------------------------------</span>
    <span class="keywordflow">if</span> (from_stash_name.size() &lt;= 0)
    {
        <a class="code" href="class_o_t_log.html#a5acd90ac91c2618f395b0ff37ad4f8ee">OTLog::Error</a>(<span class="stringliteral">&quot;OTSmartContract::GetStashBalance: error: from_stash_name is non-existent.\n&quot;</span>);
        <span class="keywordflow">return</span> 0;
    }
    <span class="keywordflow">if</span> (asset_type_id.size() &lt;= 0)
    {
        <a class="code" href="class_o_t_log.html#a5acd90ac91c2618f395b0ff37ad4f8ee">OTLog::Error</a>(<span class="stringliteral">&quot;OTSmartContract::GetStashBalance: error: asset_type_id is non-existent.\n&quot;</span>);
        <span class="keywordflow">return</span> 0;
    }
    <span class="comment">// ---------------------------------------------------</span>
    <span class="comment">// Below this point, these are all good:</span>
    <span class="comment">//</span>
    <span class="comment">//      from_stash_name,</span>
    <span class="comment">//      asset_type_id</span>
    <span class="comment">//      pServerNym, pCron.</span>
    <span class="comment">//</span>
    <span class="comment">// ---------------------------------------------------</span>

    <a class="code" href="class_o_t_stash.html">OTStash</a> * pStash = this-&gt;<a class="code" href="class_o_t_smart_contract.html#af7305d13e0ac4c2bef284658bdd9ec67">GetStash</a>(from_stash_name); <span class="comment">// This ALWAYS succeeds. (It will OT_ASSERT() if failure.)</span>

    <span class="comment">// ---------------------------------------------------</span>
    <span class="comment">//</span>
    <span class="comment">// Below this point, these are all good:</span>
    <span class="comment">//</span>
    <span class="comment">//      pStash,     from_stash_name,</span>
    <span class="comment">//      asset_type_id</span>
    <span class="comment">//      pServerNym, pCron.</span>
    <span class="comment">//</span>
    <span class="comment">// ****************************************************************************</span>
    <a class="code" href="class_o_t_string.html">OTString</a> strBalance;
    strBalance.<a class="code" href="class_o_t_string.html#af1c861f21033a1d583b3cb12f952422e">Format</a>(<span class="stringliteral">&quot;%lld&quot;</span>, pStash-&gt;<a class="code" href="class_o_t_stash.html#ab89b0a67cc8308afa8b77e399ac368a4">GetAmount</a>(asset_type_id));
    <span class="keywordflow">return</span> strBalance.<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>();
}
</pre></div>
</div>
</div>
<a class="anchor" id="a40befd7381c6c5e68e7d1042c9a7f2d3"></a><!-- doxytag: member="OTSmartContract::HarvestClosingNumbers" ref="a40befd7381c6c5e68e7d1042c9a7f2d3" args="(OTPseudonym &amp;theNym)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_o_t_smart_contract.html#a40befd7381c6c5e68e7d1042c9a7f2d3">OTSmartContract::HarvestClosingNumbers</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_t_pseudonym.html">OTPseudonym</a> &amp;&#160;</td>
          <td class="paramname"><em>theNym</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="class_o_t_cron_item.html#aeeaf2e2f8c54e7eb3e072336d07b2879">OTCronItem</a>.</p>

<p>Definition at line <a class="el" href="_o_t_smart_contract_8cpp_source.html#l04497">4497</a> of file <a class="el" href="_o_t_smart_contract_8cpp_source.html">OTSmartContract.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">// We do NOT call the parent version.</span>
<span class="comment">//  OTCronItem::HarvestClosingNumbers(theNym);</span>

    <span class="comment">// For payment plan, the parent (OTCronItem) grabs the sender&#39;s #s, and then the subclass&#39;s</span>
    <span class="comment">// override (OTAgreement::HarvestClosingNumbers) grabs the recipient&#39;s #s. But with SMART</span>
    <span class="comment">// CONTRACTS, there are only &quot;the parties&quot; and they ALL burned an opening #, plus they can</span>
    <span class="comment">// ALL harvest their closing #s if activation failed. In fact, done: might as well send them</span>
    <span class="comment">// all a notification if it fails, so they can all AUTOMATICALLY remove said numbers from</span>
    <span class="comment">// their future balance agreements.</span>
    <span class="comment">//</span>
    <span class="comment">// ----------------------------------</span>
    <span class="keyword">const</span> <a class="code" href="class_o_t_string.html">OTString</a> strServerID(<a class="code" href="class_o_t_instrument.html#a878dd8998f7b131b85c082575e255375">GetServerID</a>());
    <span class="keyword">const</span> int32_t nTransNumCount = theNym.<a class="code" href="class_o_t_pseudonym.html#adee7eef0a51e8e94522c43ac898c2308">GetTransactionNumCount</a>(<a class="code" href="class_o_t_instrument.html#a878dd8998f7b131b85c082575e255375">GetServerID</a>()); <span class="comment">// save this to see if it changed, later.</span>

    <a class="code" href="_o_t_storage_8hpp.html#aa135ed03585fa4b246d7907afbd5873d">FOR_EACH</a>(<a class="code" href="_o_t_party_8hpp.html#a029bc6921acd4516530e26201cf595f2">mapOfParties</a>, <a class="code" href="class_o_t_scriptable.html#a6a7e4ef3e0ed95f90d950b1718f815ab">m_mapParties</a>)
    {
        <a class="code" href="class_o_t_party.html">OTParty</a> * pParty = (*it).second;
        <a class="code" href="_o_t_assert_8hpp.html#a033b133f48e61f2b227c52ad2be0c882">OT_ASSERT_MSG</a>(NULL != pParty, <span class="stringliteral">&quot;Unexpected NULL pointer in party map.&quot;</span>);
        <span class="comment">// --------------------------------------------</span>
        pParty-&gt;<a class="code" href="class_o_t_party.html#a35c3abd49e3b7b59606b6a8ac52dcb0b">HarvestClosingNumbers</a>(theNym, strServerID);
    }
    <span class="comment">// ------------------------</span>
    <span class="comment">// It changed, so let&#39;s save it.</span>
    <span class="keywordflow">if</span> (nTransNumCount != theNym.<a class="code" href="class_o_t_pseudonym.html#adee7eef0a51e8e94522c43ac898c2308">GetTransactionNumCount</a>(<a class="code" href="class_o_t_instrument.html#a878dd8998f7b131b85c082575e255375">GetServerID</a>()))
        theNym.<a class="code" href="class_o_t_pseudonym.html#a5d08ef86097db038c2c4fd30034f5dc8">SaveSignedNymfile</a>(theNym);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a6dc75e512f2cab9acaecf39489f31e6c"></a><!-- doxytag: member="OTSmartContract::HarvestClosingNumbers" ref="a6dc75e512f2cab9acaecf39489f31e6c" args="(OTPseudonym *pSignerNym=NULL, std::set&lt; OTParty * &gt; *pFailedParties=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_o_t_smart_contract.html#a40befd7381c6c5e68e7d1042c9a7f2d3">OTSmartContract::HarvestClosingNumbers</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_t_pseudonym.html">OTPseudonym</a> *&#160;</td>
          <td class="paramname"><em>pSignerNym</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; <a class="el" href="class_o_t_party.html">OTParty</a> * &gt; *&#160;</td>
          <td class="paramname"><em>pFailedParties</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_o_t_smart_contract_8cpp_source.html#l04451">4451</a> of file <a class="el" href="_o_t_smart_contract_8cpp_source.html">OTSmartContract.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keyword">const</span> <a class="code" href="class_o_t_string.html">OTString</a> strServerID(<a class="code" href="class_o_t_instrument.html#a878dd8998f7b131b85c082575e255375">GetServerID</a>());
    <span class="comment">// -------------------------------------------------------</span>
    <a class="code" href="_o_t_storage_8hpp.html#aa135ed03585fa4b246d7907afbd5873d">FOR_EACH</a>(<a class="code" href="_o_t_party_8hpp.html#a029bc6921acd4516530e26201cf595f2">mapOfParties</a>, <a class="code" href="class_o_t_scriptable.html#a6a7e4ef3e0ed95f90d950b1718f815ab">m_mapParties</a>)
    {
        <span class="keyword">const</span> std::string str_party_name = it-&gt;first;
        <a class="code" href="class_o_t_party.html">OTParty</a> * pParty = (*it).second;
        <a class="code" href="_o_t_assert_8hpp.html#a033b133f48e61f2b227c52ad2be0c882">OT_ASSERT_MSG</a>(NULL != pParty, <span class="stringliteral">&quot;OTSmartContract::HarvestClosingNumbers: Unexpected NULL pointer in party map.&quot;</span>);
        <span class="comment">// --------------------------------------------</span>
        <span class="comment">// If certain parties failed verification, then OTSmartContract::VerifySmartContract() is smart enough</span>
        <span class="comment">// not to bother verifying the accounts of those parties. Thus, the closing numbers for those accounts</span>
        <span class="comment">// could NOT have been marked as &quot;used&quot; (since they were skipped). So we passed that same set of failed</span>
        <span class="comment">// parties into this function here, so that we can skip them here as well, when harvesting the closing</span>
        <span class="comment">// numbers back again.</span>
        <span class="comment">//</span>
        <span class="keywordflow">if</span> (NULL != pFailedParties) <span class="comment">// There are failed parties.</span>
        {
            <span class="comment">// --------------------------------------------</span>
            <span class="comment">// Skip failed parties...</span>
            <span class="comment">//</span>
            std::set&lt;OTParty *&gt;::iterator it_failed = pFailedParties-&gt;find(pParty);

            <span class="keywordflow">if</span> (pFailedParties-&gt;end() != it_failed) <span class="comment">// this means pParty was found on the FAILED list. (So we can skip it here.)</span>
            {
                <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(0, <span class="stringliteral">&quot;%s: FYI, at least one party (%s) has failed verification, so right now I&#39;m skipping harvesting of his &quot;</span>
                               <span class="stringliteral">&quot;closing transaction numbers. (Since he failed, we never verified his accounts, so we never grabbed those closing &quot;</span>
                               <span class="stringliteral">&quot;numbers in the first place, so there&#39;s no need to grab them back now.)\n&quot;</span>, __FUNCTION__, str_party_name.c_str());
                <span class="keywordflow">continue</span>;
            }
        }
        <span class="comment">// -----------------</span>
        <span class="comment">// For all non-failed parties, now we harvest the closing transaction numbers:</span>
        <span class="comment">//</span>
        pParty-&gt;<a class="code" href="class_o_t_party.html#a35c3abd49e3b7b59606b6a8ac52dcb0b">HarvestClosingNumbers</a>(strServerID,  <span class="comment">// &lt;==============  (THE HARVEST.)</span>
                                      <span class="keyword">true</span>,         <span class="comment">// bSave=true</span>
                                      pSignerNym);
    } <span class="comment">// FOR_EACH ---------------------------------------------</span>
}
</pre></div>
</div>
</div>
<a class="anchor" id="a6eaf2a458eb665dae9e25f026db27f8f"></a><!-- doxytag: member="OTSmartContract::HarvestOpeningNumber" ref="a6eaf2a458eb665dae9e25f026db27f8f" args="(OTPseudonym &amp;theNym)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_o_t_smart_contract.html#a6eaf2a458eb665dae9e25f026db27f8f">OTSmartContract::HarvestOpeningNumber</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_t_pseudonym.html">OTPseudonym</a> &amp;&#160;</td>
          <td class="paramname"><em>theNym</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="class_o_t_cron_item.html#ab4adba19339e539c05bba94717c481cc">OTCronItem</a>.</p>

<p>Definition at line <a class="el" href="_o_t_smart_contract_8cpp_source.html#l04533">4533</a> of file <a class="el" href="_o_t_smart_contract_8cpp_source.html">OTSmartContract.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">// We do NOT call the parent version.</span>
<span class="comment">//  OTCronItem::HarvestOpeningNumber(theNym);</span>

    <span class="comment">// For payment plan, the parent (OTCronItem) grabs the sender&#39;s #s, and then the subclass&#39;s</span>
    <span class="comment">// override (OTAgreement::HarvestClosingNumbers) grabs the recipient&#39;s #s. But with SMART</span>
    <span class="comment">// CONTRACTS, there are only &quot;the parties&quot; and they ALL burned an opening #, plus they can</span>
    <span class="comment">// ALL harvest their closing #s if activation failed. In fact, todo: might as well send them</span>
    <span class="comment">// all a notification if it fails, so they can all AUTOMATICALLY remove said numbers from</span>
    <span class="comment">// their future balance agreements.</span>
    <span class="comment">//</span>
    <span class="comment">// ----------------------------------</span>
    <span class="keyword">const</span> <a class="code" href="class_o_t_string.html">OTString</a> strServerID(<a class="code" href="class_o_t_instrument.html#a878dd8998f7b131b85c082575e255375">GetServerID</a>());
    <span class="keyword">const</span> int32_t nTransNumCount = theNym.<a class="code" href="class_o_t_pseudonym.html#adee7eef0a51e8e94522c43ac898c2308">GetTransactionNumCount</a>(<a class="code" href="class_o_t_instrument.html#a878dd8998f7b131b85c082575e255375">GetServerID</a>()); <span class="comment">// save this to see if it changed, later.</span>

    <a class="code" href="_o_t_storage_8hpp.html#aa135ed03585fa4b246d7907afbd5873d">FOR_EACH</a>(<a class="code" href="_o_t_party_8hpp.html#a029bc6921acd4516530e26201cf595f2">mapOfParties</a>, <a class="code" href="class_o_t_scriptable.html#a6a7e4ef3e0ed95f90d950b1718f815ab">m_mapParties</a>)
    {
        <a class="code" href="class_o_t_party.html">OTParty</a> * pParty = (*it).second;
        <a class="code" href="_o_t_assert_8hpp.html#a033b133f48e61f2b227c52ad2be0c882">OT_ASSERT_MSG</a>(NULL != pParty, <span class="stringliteral">&quot;Unexpected NULL pointer in party map.&quot;</span>);
        <span class="comment">// --------------------------------------------</span>
        pParty-&gt;<a class="code" href="class_o_t_party.html#ab97bb5511eae5e5702694d2c3b61eeee">HarvestOpeningNumber</a>(theNym, strServerID);
    }
    <span class="comment">// ------------------------</span>
    <span class="comment">// It changed, so let&#39;s save it.</span>
    <span class="keywordflow">if</span> (nTransNumCount != theNym.<a class="code" href="class_o_t_pseudonym.html#adee7eef0a51e8e94522c43ac898c2308">GetTransactionNumCount</a>(<a class="code" href="class_o_t_instrument.html#a878dd8998f7b131b85c082575e255375">GetServerID</a>()))
        theNym.<a class="code" href="class_o_t_pseudonym.html#a5d08ef86097db038c2c4fd30034f5dc8">SaveSignedNymfile</a>(theNym);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a1952403bb15765cab19f435186b6c362"></a><!-- doxytag: member="OTSmartContract::HasTransactionNum" ref="a1952403bb15765cab19f435186b6c362" args="(const int64_t &amp;lInput) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_o_t_smart_contract.html#a1952403bb15765cab19f435186b6c362">OTSmartContract::HasTransactionNum</a> </td>
          <td>(</td>
          <td class="paramtype">const int64_t &amp;&#160;</td>
          <td class="paramname"><em>lInput</em></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="class_o_t_trackable.html#a7f0e0f97f77da9cf7f49c0ce1be1b6db">OTTrackable</a>.</p>

<p>Definition at line <a class="el" href="_o_t_smart_contract_8cpp_source.html#l00825">825</a> of file <a class="el" href="_o_t_smart_contract_8cpp_source.html">OTSmartContract.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
    <a class="code" href="_o_t_storage_8hpp.html#a804eb881e96b7e1846d130a55a94f716">FOR_EACH_CONST</a>(<a class="code" href="_o_t_party_8hpp.html#a029bc6921acd4516530e26201cf595f2">mapOfParties</a>, <a class="code" href="class_o_t_scriptable.html#a6a7e4ef3e0ed95f90d950b1718f815ab">m_mapParties</a>)
    {
        <span class="keyword">const</span> <a class="code" href="class_o_t_party.html">OTParty</a> * pParty = (*it).second;
        <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != pParty);
        <span class="comment">// ----------------------------------</span>
        <span class="keywordflow">if</span> (pParty-&gt;<a class="code" href="class_o_t_party.html#add612bb3dc7fdc8a9a5bc014fd42104e">HasTransactionNum</a>(lInput))
            <span class="keywordflow">return</span> <span class="keyword">true</span>;
    }
    <span class="comment">// -------------------</span>
    <span class="keywordflow">return</span> <span class="keyword">false</span>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a6ce8a031a27a75a43275dde21919d0cd"></a><!-- doxytag: member="OTSmartContract::InitSmartContract" ref="a6ce8a031a27a75a43275dde21919d0cd" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_o_t_smart_contract.html#a6ce8a031a27a75a43275dde21919d0cd">OTSmartContract::InitSmartContract</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_o_t_smart_contract_8cpp_source.html#l04768">4768</a> of file <a class="el" href="_o_t_smart_contract_8cpp_source.html">OTSmartContract.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
    <a class="code" href="class_o_t_contract.html#ac523dac7d72b72e54b1ebb5b3a3b21cc">m_strContractType</a> = <span class="stringliteral">&quot;SMARTCONTRACT&quot;</span>;

    <a class="code" href="class_o_t_cron_item.html#a7d801b85690f539433e0ccf187f57d99">SetProcessInterval</a>(<a class="code" href="_o_t_smart_contract_8cpp.html#a07c91258ac71240a2059fd34c9cf5d89">SMART_CONTRACT_PROCESS_INTERVAL</a>); <span class="comment">// Smart contracts current default is 30 seconds. Actual default will probably be configurable in config file, and most contracts will also probably override this.</span>
}
</pre></div>
</div>
</div>
<a class="anchor" id="aa5a554f7a5ca7c9a0d0d2377860ef8c2"></a><!-- doxytag: member="OTSmartContract::IsValidOpeningNumber" ref="aa5a554f7a5ca7c9a0d0d2377860ef8c2" args="(const int64_t &amp;lOpeningNum) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_o_t_smart_contract.html#aa5a554f7a5ca7c9a0d0d2377860ef8c2">OTSmartContract::IsValidOpeningNumber</a> </td>
          <td>(</td>
          <td class="paramtype">const int64_t &amp;&#160;</td>
          <td class="paramname"><em>lOpeningNum</em></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="class_o_t_cron_item.html#a9fd34100c4c79adf325c61ba268008ef">OTCronItem</a>.</p>

<p>Definition at line <a class="el" href="_o_t_smart_contract_8cpp_source.html#l00805">805</a> of file <a class="el" href="_o_t_smart_contract_8cpp_source.html">OTSmartContract.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{

    <a class="code" href="_o_t_storage_8hpp.html#a804eb881e96b7e1846d130a55a94f716">FOR_EACH_CONST</a>(<a class="code" href="_o_t_party_8hpp.html#a029bc6921acd4516530e26201cf595f2">mapOfParties</a>, <a class="code" href="class_o_t_scriptable.html#a6a7e4ef3e0ed95f90d950b1718f815ab">m_mapParties</a>)
    {
        <a class="code" href="class_o_t_party.html">OTParty</a> * pParty = (*it).second;
        <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != pParty);
        <span class="comment">// -----------------------------</span>

        <span class="keywordflow">if</span> (pParty-&gt;<a class="code" href="class_o_t_party.html#aa11f990dfe9743dd1d8e34af8bfd693a">GetOpeningTransNo</a>() == lOpeningNum)
            <span class="keywordflow">return</span> <span class="keyword">true</span>;
    }

    <span class="keywordflow">return</span> <span class="keyword">false</span>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="abd37d88f1828402ae7313aa130ccbe9f"></a><!-- doxytag: member="OTSmartContract::LoadEditable" ref="abd37d88f1828402ae7313aa130ccbe9f" args="(const OTString &amp;strName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_o_t_smart_contract.html#abd37d88f1828402ae7313aa130ccbe9f">OTSmartContract::LoadEditable</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_t_string.html">OTString</a> &amp;&#160;</td>
          <td class="paramname"><em>strName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_o_t_smart_contract_8cpp_source.html#l05011">5011</a> of file <a class="el" href="_o_t_smart_contract_8cpp_source.html">OTSmartContract.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordflow">if</span> (!strName.<a class="code" href="class_o_t_string.html#adf7489cd917d4ae5bf30853a3ad78daf">Exists</a>())
    {
        <a class="code" href="class_o_t_log.html#a5acd90ac91c2618f395b0ff37ad4f8ee">OTLog::Error</a>(<span class="stringliteral">&quot;OTSmartContract::LoadEditable: Empty name passed in. (Returning false.)\n&quot;</span>);
        <span class="keywordflow">return</span> <span class="keyword">false</span>;
    }

    <span class="keyword">const</span> <a class="code" href="class_o_t_string.html">OTString</a> strServerID(<a class="code" href="class_o_t_instrument.html#a878dd8998f7b131b85c082575e255375">GetServerID</a>());
    <span class="comment">// --------------------------------------</span>
    <span class="keyword">const</span> <a class="code" href="class_o_t_a_s_c_i_i_armor.html">OTASCIIArmor</a> ascName(strName); <span class="comment">// Filename (base64-encoded)</span>
    std::string str_contract;

    <span class="keywordflow">if</span> (!<a class="code" href="namespace_o_t_d_b.html#a73e39a590dfb64f63065821c6bbcd4c6">OTDB::Exists</a>(<a class="code" href="class_o_t_folders.html#a698b8fd86486783a1b21ec54e1d0867e">OTFolders::SmartContracts</a>().Get(),
                     strServerID.<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>(),
                     <span class="stringliteral">&quot;editing&quot;</span>,     <span class="comment">// todo hardcoding. The folder where smart contracts are edited.</span>
                     ascName.Get()))
    {
        <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(2, <span class="stringliteral">&quot;OTSmartContract::LoadEditable: File doesn&#39;t exist: %s%s%s%s%s%s%s\n&quot;</span>,
                       <a class="code" href="class_o_t_folders.html#a698b8fd86486783a1b21ec54e1d0867e">OTFolders::SmartContracts</a>().Get(), <a class="code" href="class_o_t_log.html#a42d3c91ff84ecae0690e34efb4619a77">OTLog::PathSeparator</a>(),
                       strServerID.Get(), <a class="code" href="class_o_t_log.html#a42d3c91ff84ecae0690e34efb4619a77">OTLog::PathSeparator</a>(), <span class="stringliteral">&quot;editing&quot;</span>,
                       <a class="code" href="class_o_t_log.html#a42d3c91ff84ecae0690e34efb4619a77">OTLog::PathSeparator</a>(), ascName.Get());
        <span class="keywordflow">return</span> <span class="keyword">false</span>;
    }
    <span class="keywordflow">else</span>
        str_contract = <a class="code" href="namespace_o_t_d_b.html#a921d6f538de00f4e4297c25cf679f00a">OTDB::QueryPlainString</a>(<a class="code" href="class_o_t_folders.html#a698b8fd86486783a1b21ec54e1d0867e">OTFolders::SmartContracts</a>().Get(),
                                              strServerID.<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>(),
                                              <span class="stringliteral">&quot;editing&quot;</span>, <span class="comment">// todo stop hardcoding.</span>
                                              ascName.Get());
    <span class="keywordflow">if</span> (str_contract.size() &lt; 1)
    {
        <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;OTSmartContract::LoadEditable: Failed loading: %s%s%s%s%s%s%s\n&quot;</span>,
                      <a class="code" href="class_o_t_folders.html#a698b8fd86486783a1b21ec54e1d0867e">OTFolders::SmartContracts</a>().Get(), <a class="code" href="class_o_t_log.html#a42d3c91ff84ecae0690e34efb4619a77">OTLog::PathSeparator</a>(),
                      strServerID.Get(), <a class="code" href="class_o_t_log.html#a42d3c91ff84ecae0690e34efb4619a77">OTLog::PathSeparator</a>(), <span class="stringliteral">&quot;editing&quot;</span>,
                      <a class="code" href="class_o_t_log.html#a42d3c91ff84ecae0690e34efb4619a77">OTLog::PathSeparator</a>(), ascName.Get());
    }
    <span class="keywordflow">else</span>
    {
        <span class="keyword">const</span> <a class="code" href="class_o_t_string.html">OTString</a> strSmartContract(str_contract.c_str());

        <span class="keywordflow">if</span> (<span class="keyword">false</span> == this-&gt;<a class="code" href="class_o_t_contract.html#a36300e34dcd94ed7006d98b392d46815">LoadContractFromString</a>(strSmartContract)) <span class="comment">// Handles OT ARMORED file formats.</span>
        {
            <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;OTSmartContract::LoadEditable: Failed attempt to load (editable), smart contract from storage: %s \n&quot;</span>,
                          strName.<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>());
        }
        <span class="keywordflow">return</span> <span class="keyword">true</span>;
    }

    <span class="keywordflow">return</span> <span class="keyword">false</span>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a180d318d02a58976aaf8e8dc1ee729ab"></a><!-- doxytag: member="OTSmartContract::LoadTemplate" ref="a180d318d02a58976aaf8e8dc1ee729ab" args="(const OTIdentifier &amp;SERVER_ID, const OTIdentifier &amp;CONTRACT_ID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_o_t_smart_contract.html#a180d318d02a58976aaf8e8dc1ee729ab">OTSmartContract::LoadTemplate</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_t_identifier.html">OTIdentifier</a> &amp;&#160;</td>
          <td class="paramname"><em>SERVER_ID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_o_t_identifier.html">OTIdentifier</a> &amp;&#160;</td>
          <td class="paramname"><em>CONTRACT_ID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_o_t_smart_contract_8cpp_source.html#l05195">5195</a> of file <a class="el" href="_o_t_smart_contract_8cpp_source.html">OTSmartContract.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordflow">if</span> (!<a class="code" href="class_o_t_contract.html#ab1e11693a38a1673037b1f29c9d84010">m_strFoldername</a>.<a class="code" href="class_o_t_string.html#adf7489cd917d4ae5bf30853a3ad78daf">Exists</a>())
        <a class="code" href="class_o_t_contract.html#ab1e11693a38a1673037b1f29c9d84010">m_strFoldername</a>.<a class="code" href="class_o_t_string.html#aa5db620fe8e60c849585d741975db991">Set</a>(<a class="code" href="class_o_t_folders.html#a698b8fd86486783a1b21ec54e1d0867e">OTFolders::SmartContracts</a>().<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>());

    <span class="keyword">const</span> <a class="code" href="class_o_t_string.html">OTString</a> strServerID(SERVER_ID), strContractID(CONTRACT_ID);

    <span class="keywordflow">if</span> (!<a class="code" href="class_o_t_contract.html#ab7ab1f1fe7ff7e52f2c126404a8f4f92">m_strFilename</a>.<a class="code" href="class_o_t_string.html#adf7489cd917d4ae5bf30853a3ad78daf">Exists</a>())
    {
        <a class="code" href="class_o_t_contract.html#ab7ab1f1fe7ff7e52f2c126404a8f4f92">m_strFilename</a>.<a class="code" href="class_o_t_string.html#af1c861f21033a1d583b3cb12f952422e">Format</a>(<span class="stringliteral">&quot;%s%s%s&quot;</span>, strServerID.Get(), <a class="code" href="class_o_t_log.html#a42d3c91ff84ecae0690e34efb4619a77">OTLog::PathSeparator</a>(), strContractID.Get());
    }
    <span class="comment">// --------------------------------------------------------------------</span>

    <span class="keyword">const</span> <span class="keywordtype">char</span> * szFolder1name  = <a class="code" href="class_o_t_folders.html#a698b8fd86486783a1b21ec54e1d0867e">OTFolders::SmartContracts</a>().<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>();    <span class="comment">// &quot;smartcontracts&quot;</span>
    <span class="keyword">const</span> <span class="keywordtype">char</span> * szFolder2name  = strServerID.Get();                <span class="comment">// &quot;smartcontracts/SERVER_ID&quot;</span>
    <span class="keyword">const</span> <span class="keywordtype">char</span> * szFilename     = strContractID.Get();              <span class="comment">// &quot;smartcontracts/SERVER_ID/CONTRACT_ID&quot;</span>

    <span class="comment">// --------------------------------------------------------------------</span>

    <span class="keywordflow">if</span> (<span class="keyword">false</span> == <a class="code" href="namespace_o_t_d_b.html#a73e39a590dfb64f63065821c6bbcd4c6">OTDB::Exists</a>(szFolder1name, szFolder2name, szFilename))
    {
        <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(0, <span class="stringliteral">&quot;OTSmartContract::LoadTemplate: File does not exist: %s%s%s%s%s\n&quot;</span>,
                       szFolder1name, <a class="code" href="class_o_t_log.html#a42d3c91ff84ecae0690e34efb4619a77">OTLog::PathSeparator</a>(), szFolder2name, <a class="code" href="class_o_t_log.html#a42d3c91ff84ecae0690e34efb4619a77">OTLog::PathSeparator</a>(), szFilename);
        <span class="keywordflow">return</span> <span class="keyword">false</span>;
    }
    <span class="comment">// --------------------------------------------------------------------</span>
    <span class="comment">//</span>
    std::string strFileContents(<a class="code" href="namespace_o_t_d_b.html#a921d6f538de00f4e4297c25cf679f00a">OTDB::QueryPlainString</a>(szFolder1name, szFolder2name, szFilename)); <span class="comment">// &lt;=== LOADING FROM DATA STORE.</span>

    <span class="keywordflow">if</span> (strFileContents.length() &lt; 2)
    {
        <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;OTSmartContract::LoadTemplate: Error reading file: %s%s%s%s%s\n&quot;</span>,
                      szFolder1name, <a class="code" href="class_o_t_log.html#a42d3c91ff84ecae0690e34efb4619a77">OTLog::PathSeparator</a>(), szFolder2name, <a class="code" href="class_o_t_log.html#a42d3c91ff84ecae0690e34efb4619a77">OTLog::PathSeparator</a>(), szFilename);
        <span class="keywordflow">return</span> <span class="keyword">false</span>;
    }
    <span class="comment">// --------------------------------------------------------------------</span>

    <a class="code" href="class_o_t_string.html">OTString</a> strRawFile(strFileContents.c_str());

    <span class="keywordtype">bool</span> bSuccess = <a class="code" href="class_o_t_contract.html#a36300e34dcd94ed7006d98b392d46815">LoadContractFromString</a>(strRawFile); <span class="comment">// Handles OT ARMORED file formats...</span>

    <span class="keywordflow">return</span> bSuccess;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ae10051f961745a06753f5e22d9a699f1"></a><!-- doxytag: member="OTSmartContract::MoveAcctFundsStr" ref="ae10051f961745a06753f5e22d9a699f1" args="(const std::string from_acct_name, const std::string to_acct_name, const std::string str_Amount)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_o_t_smart_contract.html#ae10051f961745a06753f5e22d9a699f1">OTSmartContract::MoveAcctFundsStr</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>from_acct_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>to_acct_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>str_Amount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_o_t_smart_contract_8cpp_source.html#l02794">2794</a> of file <a class="el" href="_o_t_smart_contract_8cpp_source.html">OTSmartContract.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
    <a class="code" href="class_o_t_cron.html">OTCron</a> * pCron  = <a class="code" href="class_o_t_cron_item.html#af734ad5d309fcc9b4a60d40d6c30f55a">GetCron</a>();
    <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != pCron);
    <span class="comment">// ----------------------------------</span>
    <a class="code" href="class_o_t_pseudonym.html">OTPseudonym</a> * pServerNym = pCron-&gt;<a class="code" href="class_o_t_cron.html#a7756d0dcc047209ca87632939dc11db3">GetServerNym</a>();
    <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != pServerNym);
    <span class="comment">// ---------------------------------------------------</span>
    <span class="comment">// Below this point, these are all good:</span>
    <span class="comment">//</span>
    <span class="comment">//      pServerNym, pCron.</span>
    <span class="comment">//</span>
    <span class="comment">// ---------------------------------------------------</span>
    <span class="keywordflow">if</span> (str_Amount.size() &lt; 1)
    {
        <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(0, <span class="stringliteral">&quot;OTSmartContract::MoveAcctFunds: Error: empty amount.\n&quot;</span>);
        <span class="keywordflow">return</span> <span class="keyword">false</span>;
    }

    <span class="keyword">const</span> int64_t lAmount =  atol(str_Amount.c_str());

    <span class="keywordflow">if</span> (lAmount &lt;= 0)
    {
        <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(0, <span class="stringliteral">&quot;OTSmartContract::MoveAcctFunds: Error: lAmount cannot be 0 or &lt;0. (Value passed in was %lld.)\n&quot;</span>,
                       lAmount);
        <span class="keywordflow">return</span> <span class="keyword">false</span>;
    }
    <span class="comment">// -----------------------------</span>
    <span class="keywordflow">if</span> (from_acct_name.size() &lt;= 0)
    {
        <a class="code" href="class_o_t_log.html#a5acd90ac91c2618f395b0ff37ad4f8ee">OTLog::Error</a>(<span class="stringliteral">&quot;OTSmartContract::MoveAcctFunds: error: from_acct_name is non-existent.\n&quot;</span>);
        <span class="keywordflow">return</span> <span class="keyword">false</span>;
    }
    <span class="keywordflow">if</span> (to_acct_name.size() &lt;= 0)
    {
        <a class="code" href="class_o_t_log.html#a5acd90ac91c2618f395b0ff37ad4f8ee">OTLog::Error</a>(<span class="stringliteral">&quot;OTSmartContract::MoveAcctFunds: error: to_acct_name is non-existent.\n&quot;</span>);
        <span class="keywordflow">return</span> <span class="keyword">false</span>;
    }
    <span class="comment">// ---------------------------------------------------</span>
    <span class="comment">// Below this point, these are all good:</span>
    <span class="comment">//</span>
    <span class="comment">//      from_acct_name,</span>
    <span class="comment">//      to_acct_name,</span>
    <span class="comment">//      pServerNym, pCron.</span>
    <span class="comment">//</span>
    <span class="comment">// ---------------------------------------------------</span>

    <a class="code" href="class_o_t_party_account.html">OTPartyAccount</a>  * pFromAcct = this-&gt;<a class="code" href="class_o_t_scriptable.html#a94c9e55f78357e04e4b9781ab662370f">GetPartyAccount</a>(from_acct_name);
    <a class="code" href="class_o_t_party_account.html">OTPartyAccount</a>  * pToAcct   = this-&gt;<a class="code" href="class_o_t_scriptable.html#a94c9e55f78357e04e4b9781ab662370f">GetPartyAccount</a>(to_acct_name);

    <span class="keywordflow">if</span> (NULL == pFromAcct)
    {
        <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(0, <span class="stringliteral">&quot;OTSmartContract::MoveAcctFunds: error: from_acct (%s) not found on any party.\n&quot;</span>,
                      from_acct_name.c_str());
        <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(0, <span class="stringliteral">&quot;FULL CONTRACT:  \n%s \n\n&quot;</span>, <a class="code" href="class_o_t_contract.html#a087fc09cfa4b2fd9076088360a5e5039">m_xmlUnsigned</a>.<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>());
        <span class="keywordflow">return</span> <span class="keyword">false</span>;
    }
    <span class="keywordflow">if</span> (NULL == pToAcct)
    {
        <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(0, <span class="stringliteral">&quot;OTSmartContract::MoveAcctFunds: error: to_acct (%s) not found on any party.\n&quot;</span>,
                      to_acct_name.c_str());
        <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(0, <span class="stringliteral">&quot;FULL CONTRACT:  \n%s \n\n&quot;</span>, <a class="code" href="class_o_t_contract.html#a087fc09cfa4b2fd9076088360a5e5039">m_xmlUnsigned</a>.<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>());

        <span class="keywordflow">return</span> <span class="keyword">false</span>;
    }
    <span class="comment">// ---------------------------------------------------</span>
    <span class="comment">//</span>
    <span class="comment">// Below this point, these are all good:</span>
    <span class="comment">//</span>
    <span class="comment">//      pFromAcct,  from_acct_name,</span>
    <span class="comment">//      pToAcct,    to_acct_name,</span>
    <span class="comment">//      pServerNym, pCron.</span>
    <span class="comment">//</span>
    <span class="comment">// ---------------------------------------------------</span>

    <a class="code" href="class_o_t_agent.html">OTAgent</a> * pFromAgent    = pFromAcct-&gt;   GetAuthorizedAgent(); <span class="comment">// This searches the account&#39;s party for the account&#39;s authorized agent.</span>
    <a class="code" href="class_o_t_agent.html">OTAgent</a> * pToAgent      = pToAcct-&gt;     GetAuthorizedAgent(); <span class="comment">// (That way it&#39;s impossible to get an agent for any other party.)</span>

    <span class="keywordflow">if</span> (NULL == pFromAgent)
    {
        <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(0, <span class="stringliteral">&quot;OTSmartContract::MoveAcctFunds: error: authorized agent (%s) not found for from_acct (%s) on acct&#39;s party.\n&quot;</span>,
                      pFromAcct-&gt;<a class="code" href="class_o_t_party_account.html#a86975046b18ac6d6c5841f5ba0befe69">GetAgentName</a>().<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>(), from_acct_name.c_str());
        <span class="keywordflow">return</span> <span class="keyword">false</span>;
    }
    <span class="keywordflow">if</span> (NULL == pToAgent)
    {
        <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(0, <span class="stringliteral">&quot;OTSmartContract::MoveAcctFunds: error: authorized agent (%s) not found for to_acct (%s) on acct&#39;s party.\n&quot;</span>,
                      pToAcct-&gt;<a class="code" href="class_o_t_party_account.html#a86975046b18ac6d6c5841f5ba0befe69">GetAgentName</a>().<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>(), to_acct_name.c_str());
        <span class="keywordflow">return</span> <span class="keyword">false</span>;
    }
    <span class="comment">// ---------</span>
    <span class="keywordflow">if</span> (<span class="keyword">false</span> == pFromAgent-&gt;<a class="code" href="class_o_t_agent.html#a1969e4f8a5f13ee34ba0a68d8f082956">IsAnIndividual</a>())
    {
        <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(0, <span class="stringliteral">&quot;OTSmartContract::MoveAcctFunds: error: authorized agent (%s) for from_acct (%s) is not an active agent.\n&quot;</span>,
                      pFromAcct-&gt;<a class="code" href="class_o_t_party_account.html#a86975046b18ac6d6c5841f5ba0befe69">GetAgentName</a>().<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>(), from_acct_name.c_str());
        <span class="keywordflow">return</span> <span class="keyword">false</span>;
    }
    <span class="keywordflow">if</span> (<span class="keyword">false</span> == pToAgent-&gt;<a class="code" href="class_o_t_agent.html#a1969e4f8a5f13ee34ba0a68d8f082956">IsAnIndividual</a>())
    {
        <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(0, <span class="stringliteral">&quot;OTSmartContract::MoveAcctFunds: error: authorized agent (%s) for to_acct (%s) is not an active agent.\n&quot;</span>,
                      pToAcct-&gt;<a class="code" href="class_o_t_party_account.html#a86975046b18ac6d6c5841f5ba0befe69">GetAgentName</a>().<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>(), to_acct_name.c_str());
        <span class="keywordflow">return</span> <span class="keyword">false</span>;
    }
    <span class="comment">//</span>
    <span class="comment">// Below this point, these are all good:</span>
    <span class="comment">//</span>
    <span class="comment">//      pFromAcct,  from_acct_name, pFromAgent,</span>
    <span class="comment">//      pToAcct,    to_acct_name,   pToAgent,</span>
    <span class="comment">//      pServerNym, pCron.</span>
    <span class="comment">//</span>
    <span class="comment">// ---------------------------------------------------</span>

    <a class="code" href="class_o_t_party.html">OTParty</a> * pFromParty    = pFromAgent-&gt;<a class="code" href="class_o_t_agent.html#a929a2489984f5487bd1819ed6d8862f2">GetParty</a>();
    <a class="code" href="class_o_t_party.html">OTParty</a> * pToParty      = pToAgent-&gt;<a class="code" href="class_o_t_agent.html#a929a2489984f5487bd1819ed6d8862f2">GetParty</a>();

    <span class="keywordflow">if</span> (NULL == pFromParty)
    {
        <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;OTSmartContract::MoveAcctFunds: error: Party pointer NULL on authorized agent (%s) for from_acct (%s).\n&quot;</span>,
                      pFromAcct-&gt;<a class="code" href="class_o_t_party_account.html#a86975046b18ac6d6c5841f5ba0befe69">GetAgentName</a>().<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>(), from_acct_name.c_str());
        <span class="keywordflow">return</span> <span class="keyword">false</span>;
    }
    <span class="keywordflow">if</span> (NULL == pToParty)
    {
        <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;OTSmartContract::MoveAcctFunds: error: Party pointer NULL on authorized agent (%s) for to_acct (%s).\n&quot;</span>,
                      pToAcct-&gt;<a class="code" href="class_o_t_party_account.html#a86975046b18ac6d6c5841f5ba0befe69">GetAgentName</a>().<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>(), to_acct_name.c_str());
        <span class="keywordflow">return</span> <span class="keyword">false</span>;
    }
    <span class="comment">//</span>
    <span class="comment">// Below this point, these are all good:</span>
    <span class="comment">//</span>
    <span class="comment">//      pFromAcct,  from_acct_name, pFromAgent, pFromParty,</span>
    <span class="comment">//      pToAcct,    to_acct_name,   pToAgent,   pToParty,</span>
    <span class="comment">//      pServerNym, pCron.</span>
    <span class="comment">//</span>
    <span class="comment">// ---------------------------------------------------</span>


    <span class="comment">// Done: I can see that THIS VERIFICATION CODE WILL GET CALLED EVERY SINGLE TIME THE SCRIPT</span>
    <span class="comment">// CALLS MOVE FUNDS.  Maybe that&#39;s good, but since technically this only needs to be verified before the</span>
    <span class="comment">// first call, and not for EVERY call during any of a script&#39;s runs, I should probably move this verification</span>
    <span class="comment">// higher, such as each time the OTCronItem triggers, plus each time a party triggers a clause directly</span>
    <span class="comment">// through the API (server message). As long as those are covered, I will be able to remove it from here</span>
    <span class="comment">// which should be a significant improvement for performance.</span>
    <span class="comment">// It will be at the bottom of those same functions that &quot;ClearTemporaryPointers()&quot; should finally be called.</span>
    <span class="comment">//</span>
    <span class="comment">// FINAL DECISION: Redundant.  See comment in OTSmartContract::StashAcctFunds()</span>
    <span class="comment">//</span>
<span class="comment">//  const OTString strServerID(GetServerID());</span>
<span class="comment">//</span>
<span class="comment">//  mapOfNyms   map_Nyms_Already_Loaded;</span>
<span class="comment">//  this-&gt;RetrieveNymPointers(map_Nyms_Already_Loaded);</span>
<span class="comment">//  // --------------------------------------------------</span>
<span class="comment">//</span>
<span class="comment">//  if (false == this-&gt;VerifyPartyAuthorization(*pFromParty, *pServerNym, strServerID, &amp;map_Nyms_Already_Loaded))</span>
<span class="comment">//  {</span>
<span class="comment">//      OTLog::vError(&quot;OTSmartContract::MoveAcctFunds: error: &#39;From&#39; Party (%s) not authorized for this contract.\n&quot;,</span>
<span class="comment">//                   pFromParty-&gt;GetPartyName().c_str());</span>
<span class="comment">//      return false;</span>
<span class="comment">//  }</span>
<span class="comment">//  // --------------------------------------------------</span>
<span class="comment">//</span>
<span class="comment">//  if (false == this-&gt;VerifyPartyAuthorization(*pToParty, *pServerNym, strServerID, &amp;map_Nyms_Already_Loaded))</span>
<span class="comment">//  {</span>
<span class="comment">//      OTLog::vError(&quot;OTSmartContract::MoveAcctFunds: error: &#39;To&#39; Party (%s) not authorized for this contract.\n&quot;,</span>
<span class="comment">//                   pToParty-&gt;GetPartyName().c_str());</span>
<span class="comment">//      return false;</span>
<span class="comment">//  }</span>
    <span class="comment">// *****************************************************************************</span>

    <span class="comment">// A party might have many agents who are only voting groups, and cannot actually sign for things</span>
    <span class="comment">// the way that nyms can. But at least ONE of those agents IS a Nym -- because there must have been</span>
    <span class="comment">// an authorizing agent who initially signed to accept the agreement, and who fronted the opening</span>
    <span class="comment">// transaction number that activated it.</span>
    <span class="comment">//</span>
    <span class="comment">// Similarly, the authorized agent for any given party&#39;s account (each account has its own authorized</span>
    <span class="comment">// agent) MUST be an active agent (an active agent is one with a Nym--whether that Nym is representing</span>
    <span class="comment">// himself as the party, or whether representing some entity as an employee in a role). Why MUST the</span>
    <span class="comment">// authorized agent be an active agent? Because when funds are moved, that Nym must be loaded since</span>
    <span class="comment">// the account must show that Nym as a legal owner/agent. The MoveFunds will cause a paymentReceipt to</span>
    <span class="comment">// drop into the Inbox for the relevant asset accounts, and that paymentReceipt can ONLY be accepted</span>
    <span class="comment">// by that same Nym, who must use a transaction # that he signed for previously and received through</span>
    <span class="comment">// his nymbox. There is actually no justification at all to take funds from that account, since the</span>
    <span class="comment">// new balance has not yet been signed, UNLESS THE PAYMENTRECEIPT CONTAINS A VALID, SIGNED AUTHORIZATION</span>
    <span class="comment">// FROM THE ACCOUNT HOLDER. *That* is why the authorizing agent must either be the Party&#39;s Owner himself</span>
    <span class="comment">// (representing himself as an agent, which most will do) in which case he will appear as the valid</span>
    <span class="comment">// owner of the account, OR he MUST be a Nym working in a Valid Role for an Entity, where said Entity is</span>
    <span class="comment">// the valid owner on the account in question. Either OT, it will be possible in OT for him to sign for</span>
    <span class="comment">// the paymentReceipts when they come in, and impossible for him to escape liability for them.</span>
    <span class="comment">// (That&#39;s the idea anyway.)</span>
    <span class="comment">//</span>
    <span class="comment">// Since we know that the Authorized Agent for an account must be an ACTIVE agent (one way or the other)</span>
    <span class="comment">// then we can error out here if he&#39;s not.  We can then pass in his Nym ID</span>
    <span class="comment">//</span>

    <a class="code" href="class_o_t_identifier.html">OTIdentifier</a> theFromAgentID, theToAgentID;
    <span class="keyword">const</span> <span class="keywordtype">bool</span> bFromAgentID = pFromAgent-&gt;<a class="code" href="class_o_t_agent.html#a7750c7f5840047c5413d95e92ad87578">GetSignerID</a>(theFromAgentID);
    <span class="keyword">const</span> <span class="keywordtype">bool</span> bToAgentID   = pToAgent-&gt;<a class="code" href="class_o_t_agent.html#a7750c7f5840047c5413d95e92ad87578">GetSignerID</a>(theToAgentID);

    <span class="keywordflow">if</span> ( ! bFromAgentID )
    {
        <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;OTSmartContract::MoveAcctFunds: Failed to find FromAgent&#39;s Signer ID: %s \n&quot;</span>,
                      pFromAgent-&gt;<a class="code" href="class_o_t_agent.html#a123d27f05e46977ecdbe0b83de3c119d">GetName</a>().<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>());
        <span class="keywordflow">return</span> <span class="keyword">false</span>;
    }
    <span class="keywordflow">if</span> ( ! bToAgentID )
    {
        <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;OTSmartContract::MoveAcctFunds: Failed to find ToAgent&#39;s Signer ID: %s \n&quot;</span>,
                      pToAgent-&gt;<a class="code" href="class_o_t_agent.html#a123d27f05e46977ecdbe0b83de3c119d">GetName</a>().<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>());
        <span class="keywordflow">return</span> <span class="keyword">false</span>;
    }
    <span class="comment">// --------------------------------------</span>

    <span class="keywordflow">if</span> (!pFromAcct-&gt;<a class="code" href="class_o_t_party_account.html#aa5e4e0cc77853d08b3708017fe694876">GetAcctID</a>().<a class="code" href="class_o_t_string.html#adf7489cd917d4ae5bf30853a3ad78daf">Exists</a>())
    {
        <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;OTSmartContract::MoveAcctFunds: Error: FromAcct has empty AcctID: %s \n&quot;</span>, from_acct_name.c_str());
        <span class="keywordflow">return</span> <span class="keyword">false</span>;
    }
    <span class="keywordflow">if</span> (!pToAcct-&gt;<a class="code" href="class_o_t_party_account.html#aa5e4e0cc77853d08b3708017fe694876">GetAcctID</a>().<a class="code" href="class_o_t_string.html#adf7489cd917d4ae5bf30853a3ad78daf">Exists</a>())
    {
        <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;OTSmartContract::MoveAcctFunds: Error: ToAcct has empty AcctID: %s \n&quot;</span>, to_acct_name.c_str());
        <span class="keywordflow">return</span> <span class="keyword">false</span>;
    }

    <span class="keyword">const</span> <a class="code" href="class_o_t_identifier.html">OTIdentifier</a> theFromAcctID(pFromAcct-&gt;<a class="code" href="class_o_t_party_account.html#aa5e4e0cc77853d08b3708017fe694876">GetAcctID</a>()), theToAcctID(pToAcct-&gt;<a class="code" href="class_o_t_party_account.html#aa5e4e0cc77853d08b3708017fe694876">GetAcctID</a>());
    <span class="comment">//</span>
    <span class="comment">// BELOW THIS POINT, theFromAcctID, theFromAgentID, theToAcctID, and theToAgentID are all available.</span>
    <span class="comment">// --------------------------------------</span>

<span class="comment">//   bool OTCronItem::MoveFunds(</span>
<span class="comment">//                              const mapOfNyms     &amp;   map_NymsAlreadyLoaded,</span>
<span class="comment">//                              const int64_t           &amp;   lAmount,</span>
<span class="comment">//                              const OTIdentifier &amp;    SOURCE_ACCT_ID,     // GetSenderAcctID();</span>
<span class="comment">//                              const OTIdentifier &amp;    SENDER_USER_ID,     // GetSenderUserID();</span>
<span class="comment">//                              const OTIdentifier &amp;    RECIPIENT_ACCT_ID,  // GetRecipientAcctID();</span>
<span class="comment">//                              const OTIdentifier &amp;    RECIPIENT_USER_ID)  // GetRecipientUserID();</span>


    <span class="comment">// ----------------------------------------------------------</span>
    <span class="comment">// WE SET THESE HERE SO THE RECEIPT SHOWS, SUCCESS OR FAIL,</span>
    <span class="comment">// WHO THE INTENDED SENDER / RECIPIENT ARE FOR THAT RECEIPT.</span>
    <span class="comment">//</span>
    <a class="code" href="class_o_t_smart_contract.html#a09de789ac2e616e2119feb9ddf416c9d">ReleaseLastSenderRecipientIDs</a>();
    <span class="comment">// -------------------------</span>
    theFromAgentID.<a class="code" href="class_o_t_identifier.html#a4bccb30446b4b515d9d6016b86b260bb">GetString</a>(m_strLastSenderUser);  <span class="comment">// This is the last User ID of a party who SENT money.</span>
    theFromAcctID.GetString(m_strLastSenderAcct);   <span class="comment">// This is the last Acct ID of a party who SENT money.</span>
    theToAgentID.<a class="code" href="class_o_t_identifier.html#a4bccb30446b4b515d9d6016b86b260bb">GetString</a>(m_strLastRecipientUser); <span class="comment">// This is the last User ID of a party who RECEIVED money.</span>
    theToAcctID.GetString(m_strLastRecipientAcct);  <span class="comment">// This is the last Acct ID of a party who RECEIVED money.</span>
    <span class="comment">// ----------------------------------------------------------</span>

    <a class="code" href="_o_t_agent_8hpp.html#ac89892658f6bc83e354078647b704e8f">mapOfNyms</a>   map_Nyms_Already_Loaded;
    this-&gt;<a class="code" href="class_o_t_scriptable.html#a9e41bb939fd5dbfe1f2442e5919a5079">RetrieveNymPointers</a>(map_Nyms_Already_Loaded);

    <span class="keywordtype">bool</span> bMoved = this-&gt;<a class="code" href="class_o_t_cron_item.html#a45b93f38aa36e1b0e4c3ab01e1682119">MoveFunds</a>(map_Nyms_Already_Loaded,
                                  lAmount,
                                  theFromAcctID,    theFromAgentID,
                                  theToAcctID,      theToAgentID);
    <span class="keywordflow">if</span> (!bMoved)
    {
        <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(0, <span class="stringliteral">&quot;OTSmartContract::MoveAcctFunds: Failed in call to MoveFunds. from_acct: %s   to_acct: %s\n&quot;</span>,
                      from_acct_name.c_str(), to_acct_name.c_str());
        <span class="keywordflow">return</span> <span class="keyword">false</span>;
    }

    <span class="keywordflow">return</span> <span class="keyword">true</span>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a986e939aa9f6e838afc66426cbc0eb12"></a><!-- doxytag: member="OTSmartContract::onActivate" ref="a986e939aa9f6e838afc66426cbc0eb12" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_o_t_smart_contract.html#a986e939aa9f6e838afc66426cbc0eb12">OTSmartContract::onActivate</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="class_o_t_cron_item.html#a6d5314654e6544ce8d724a89691965fa">OTCronItem</a>.</p>

<p>Definition at line <a class="el" href="_o_t_smart_contract_8cpp_source.html#l00945">945</a> of file <a class="el" href="_o_t_smart_contract_8cpp_source.html">OTSmartContract.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
    <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != <a class="code" href="class_o_t_cron_item.html#af734ad5d309fcc9b4a60d40d6c30f55a">GetCron</a>());
    <span class="comment">// -----------------------------------------------------------------------------</span>
    <span class="keywordflow">if</span> (<a class="code" href="class_o_t_cron_item.html#af734ad5d309fcc9b4a60d40d6c30f55a">GetCron</a>()-&gt;GetTransactionCount() &lt; 1)
    {
        <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(0, <span class="stringliteral">&quot;%s: Failed to process smart contract %lld: Out of transaction numbers for receipts! Flagging for removal.\n&quot;</span>,
                       __FUNCTION__, <a class="code" href="class_o_t_trackable.html#a2594d320e3b24f3210bd38a08de66a70">GetTransactionNum</a>());
        <a class="code" href="class_o_t_cron_item.html#a34c87380d2f8cd419c9a5cfec86427b4">FlagForRemoval</a>();
        <span class="keywordflow">return</span>;
    }

    <span class="comment">// *****************************************************************************</span>
    <span class="comment">//</span>
    <span class="comment">// Execute the scripts (clauses) that have registered for this hook.</span>

    <span class="keyword">const</span> std::string   str_HookName(<a class="code" href="_o_t_smart_contract_8cpp.html#aa3eadb54e95be5d2dbb367f6c359c469">SMARTCONTRACT_HOOK_ON_ACTIVATE</a>);
    <a class="code" href="_o_t_clause_8hpp.html#a40c16432fa9c16826c026b74351425ad">mapOfClauses</a>        theMatchingClauses;

    <span class="keywordflow">if</span> (this-&gt;<a class="code" href="class_o_t_scriptable.html#a298d8fdb0982df3c36e8ae194f228009">GetHooks</a>(str_HookName, theMatchingClauses))
    {
        <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(0, <span class="stringliteral">&quot;Cron: Processing smart contract clauses for hook: %s \n&quot;</span>, <a class="code" href="_o_t_smart_contract_8cpp.html#aa3eadb54e95be5d2dbb367f6c359c469">SMARTCONTRACT_HOOK_ON_ACTIVATE</a>);

        this-&gt;<a class="code" href="class_o_t_smart_contract.html#a83282de7074313974d0db0f50b3b6e09">ExecuteClauses</a>(theMatchingClauses); <span class="comment">// &lt;============================================</span>
    }
    <span class="comment">//</span>
    <span class="comment">// *****************************************************************************</span>
}
</pre></div>
</div>
</div>
<a class="anchor" id="ac956b09210f8037018cd06f11f965df4"></a><!-- doxytag: member="OTSmartContract::onFinalReceipt" ref="ac956b09210f8037018cd06f11f965df4" args="(OTCronItem &amp;theOrigCronItem, const int64_t &amp;lNewTransactionNumber, OTPseudonym &amp;theOriginator, OTPseudonym *pRemover)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_o_t_smart_contract.html#ac956b09210f8037018cd06f11f965df4">OTSmartContract::onFinalReceipt</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_t_cron_item.html">OTCronItem</a> &amp;&#160;</td>
          <td class="paramname"><em>theOrigCronItem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int64_t &amp;&#160;</td>
          <td class="paramname"><em>lNewTransactionNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_t_pseudonym.html">OTPseudonym</a> &amp;&#160;</td>
          <td class="paramname"><em>theOriginator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_t_pseudonym.html">OTPseudonym</a> *&#160;</td>
          <td class="paramname"><em>pRemover</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="class_o_t_cron_item.html#ac24d58b1aec6a6471a79f30146e7a300">OTCronItem</a>.</p>

<p>Definition at line <a class="el" href="_o_t_smart_contract_8cpp_source.html#l03066">3066</a> of file <a class="el" href="_o_t_smart_contract_8cpp_source.html">OTSmartContract.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
    <a class="code" href="class_o_t_cron.html">OTCron</a> * pCron  = <a class="code" href="class_o_t_cron_item.html#af734ad5d309fcc9b4a60d40d6c30f55a">GetCron</a>();
    <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != pCron);

    <span class="comment">// ----------------------------------</span>

    <a class="code" href="class_o_t_pseudonym.html">OTPseudonym</a> * pServerNym = pCron-&gt;<a class="code" href="class_o_t_cron.html#a7756d0dcc047209ca87632939dc11db3">GetServerNym</a>();
    <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != pServerNym);
    <span class="comment">// ------------------------------------------</span>
    <span class="keyword">const</span> <a class="code" href="class_o_t_string.html">OTString</a> strServerID(<a class="code" href="class_o_t_instrument.html#a878dd8998f7b131b85c082575e255375">GetServerID</a>());

    <span class="comment">// -------------------------------------------------</span>

    <span class="comment">// The finalReceipt Item&#39;s ATTACHMENT contains the UPDATED Cron Item.</span>
    <span class="comment">// (With the SERVER&#39;s signature on it!)</span>
    <span class="comment">//</span>
    <a class="code" href="class_o_t_string.html">OTString</a> strUpdatedCronItem(*<span class="keyword">this</span>);
    <a class="code" href="class_o_t_string.html">OTString</a> * pstrAttachment=&amp;strUpdatedCronItem;

    <span class="keyword">const</span> <a class="code" href="class_o_t_string.html">OTString</a> strOrigCronItem(theOrigCronItem);
    <span class="comment">// -----------------------------------------------------------------</span>

    <span class="comment">// IF server is originator and/or remover then swap it in for it/them so I don&#39;t load it twice.</span>
    <span class="comment">// (already handled before this function is called.)</span>
    <span class="comment">// ----------------------------------------</span>
    <span class="comment">// THIS FUNCTION:</span>
    <span class="comment">//</span>
    <span class="comment">//</span>
    <span class="comment">// LOOP through all parties.</span>
    <span class="comment">// For each party:</span>
    <span class="comment">// If party is server or originator or ActingNym, etc then set pointer appropriately for that party.</span>
    <span class="comment">// Find opening and closing numbers for that party.</span>
    <span class="comment">// Drop finalReceipt to Inboxes for each asset account, using closing numbers.</span>
    <span class="comment">// Drop finalReceipt to Nymbox for that party, using opening number.</span>
    <span class="comment">//</span>
    <span class="comment">// A similar process should happen whenever ANY contract action occurs. (Not just finalReceipt)</span>
    <span class="comment">// We loop through all the parties and give them a receipt in the relevant accounts.</span>
    <span class="comment">// And perhaps all notices should be numbered (similar to request number) so that</span>
    <span class="comment">// people can prove which notices they have received.</span>
    <span class="comment">// Receipts are given based on?</span>
    <span class="comment">// The asset accounts that are CHANGED should definitely get an agreementReceipt for the</span>
    <span class="comment">// balance change.  + All Nymboxes should receive a notice at that time. They should receive</span>
    <span class="comment">// additional notice for any change in any variable as well. Maybe let parties register for</span>
    <span class="comment">// various notices.</span>
    <span class="comment">// What about if a clause processes, but no asset accounts are changed, (no inbox notice)</span>
    <span class="comment">// and no other variables are changed (no nymbox notices at all...) In that case,</span>
    <span class="comment">// no other receipts are dropped, right? There will be some standard by which DIRTY flags</span>
    <span class="comment">// are set onto the various parties and asset accounts, and then notices will be sent based</span>
    <span class="comment">// upon those.</span>
    <span class="comment">//</span>
    <span class="comment">// For those, instead of:</span>
    <span class="comment">// &quot;theOriginator&quot; (GetSenderUserID()) and &quot;pRemover&quot; and pRecipient,</span>
    <span class="comment">//</span>
    <span class="comment">// We would have:</span>
    <span class="comment">// &quot;theOriginator&quot; (GetSenderUserID()) and &quot;pActingNym&quot; and pParty / pPartyNym (FOR_EACH Party[0..n])</span>
    <span class="comment">//</span>
    <span class="comment">// Just like here:</span>
    <span class="comment">//</span>

    <a class="code" href="_o_t_storage_8hpp.html#aa135ed03585fa4b246d7907afbd5873d">FOR_EACH</a>(<a class="code" href="_o_t_party_8hpp.html#a029bc6921acd4516530e26201cf595f2">mapOfParties</a>, <a class="code" href="class_o_t_scriptable.html#a6a7e4ef3e0ed95f90d950b1718f815ab">m_mapParties</a>)
    {
        <a class="code" href="class_o_t_party.html">OTParty</a> * pParty = (*it).second;
        <a class="code" href="_o_t_assert_8hpp.html#a033b133f48e61f2b227c52ad2be0c882">OT_ASSERT_MSG</a>(NULL != pParty, <span class="stringliteral">&quot;Unexpected NULL pointer in party map.&quot;</span>);
        <span class="comment">// --------------------------------------------</span>

        <span class="comment">// The Nym who is actively requesting to remove a cron item will be passed in as pActingNym.</span>
        <span class="comment">// However, sometimes there is no Nym... perhaps it just expired and pActingNym is NULL.</span>
        <span class="comment">// The originating Nym (if different than pActingNym) is loaded up. Otherwise theOriginator</span>
        <span class="comment">// just points to *pActingNym also.</span>
        <span class="comment">//</span>
        <a class="code" href="class_o_t_pseudonym.html">OTPseudonym</a> * pPartyNym = NULL;
        <a class="code" href="class_o_t_cleanup.html">OTCleanup&lt;OTPseudonym&gt;</a> thePartyNymAngel; <span class="comment">// In case we have to allocate.</span>

        <span class="comment">// ---------------------------</span>

        <span class="comment">// See if the serverNym is an agent on this party.</span>
        <span class="comment">//</span>
        <span class="keywordflow">if</span> (pParty-&gt;<a class="code" href="class_o_t_party.html#aa34fe1901531ed5056633b99fade0f93">HasAuthorizingAgent</a>(*pServerNym)) <span class="comment">// This should set the temp nym ptr inside the agent also, so I don&#39;t have to search twice.</span>
        {
            pPartyNym = pServerNym; <span class="comment">// Just in case the party&#39;s agent&#39;s Nym is also the server Nym.</span>
        }
        <span class="comment">// *******************************************************</span>
        <span class="comment">//</span>
        <span class="comment">// If pActingNym is NOT NULL, and HE is an agent on this party...</span>
        <span class="comment">// then set the pointer accordingly.</span>
        <span class="comment">//</span>
        <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((NULL != pActingNym) &amp;&amp; pParty-&gt;<a class="code" href="class_o_t_party.html#aa34fe1901531ed5056633b99fade0f93">HasAuthorizingAgent</a>(*pActingNym)) <span class="comment">// There is only one authorizing agent per party.</span>
        {
            pPartyNym = pActingNym; <span class="comment">// &lt;======== now both pointers are set (to same Nym). DONE!</span>
        }
        <span class="comment">// --------------------------------------------------------------------------------------------------</span>

        <span class="comment">// Still not found?</span>
        <span class="keywordflow">if</span> (NULL == pPartyNym)
        {
            <span class="comment">// Of all of a party&#39;s Agents, the &quot;authorizing agent&quot; is the one who originally activated</span>
            <span class="comment">// the agreement for this party (and fronted the opening trans#.) If we&#39;re ending the agreement,</span>
            <span class="comment">// Then we need to free that number from him. (Even if he was since fired from the role!)</span>
            <span class="comment">//</span>
            <span class="comment">// Perhaps need to figure out if the Role itself stores the opening number, and if so, treat</span>
            <span class="comment">// the Nym&#39;s signature as the role&#39;s, even though the Nym himself doesn&#39;t actually store the #.</span>
            <span class="comment">// Anyway, I&#39;ll deal with that when I get to entities and roles. Todo.</span>
            <span class="comment">//</span>
            pPartyNym = pParty-&gt;<a class="code" href="class_o_t_party.html#a01988fe0bfd917703214f7f7bf3ba66f">LoadAuthorizingAgentNym</a>(*pServerNym);

            <span class="keywordflow">if</span> (NULL != pPartyNym)
                thePartyNymAngel.<a class="code" href="class_o_t_cleanup.html#a00a399db45f730439d2263d4429d00c1">SetCleanupTarget</a>(*pPartyNym);
        }

        <span class="comment">// Every party SHOULD have an authorizing agent (otherwise how did that party sign on in the first</span>
        <span class="comment">// place??) So this should never fail. That&#39;s why there&#39;s an error message below if it&#39;s still NULL.</span>
        <span class="comment">//</span>
        <span class="comment">// ***********************************************</span>

        <span class="keywordflow">if</span> ((NULL != pPartyNym) &amp;&amp;
            (pParty-&gt;<a class="code" href="class_o_t_party.html#aa11f990dfe9743dd1d8e34af8bfd693a">GetOpeningTransNo</a>() &gt; 0) &amp;&amp;
            <span class="comment">// Todo: once entities and roles are added, Parties should have their OWN &quot;verify&quot; function</span>
            <span class="comment">// (Instead of me having to directly find the Nym and verify it myself.)</span>
            <span class="comment">//</span>
            pPartyNym-&gt;<a class="code" href="class_o_t_pseudonym.html#a66cf3b97f1769f9d422bad8787a6c1a0">VerifyIssuedNum</a>(strServerID, pParty-&gt;<a class="code" href="class_o_t_party.html#aa11f990dfe9743dd1d8e34af8bfd693a">GetOpeningTransNo</a>()) <span class="comment">// &lt;=====================</span>
            )
        {
            <span class="comment">// The Nym (server side) stores a list of all opening and closing cron #s.</span>
            <span class="comment">// So when the number is released from the Nym, we also take it off that list.</span>
            <span class="comment">//</span>
            std::set&lt;int64_t&gt; &amp; theIDSet = pPartyNym-&gt;<a class="code" href="class_o_t_pseudonym.html#a92abc7a6b6253681f3379f135597f5a9">GetSetOpenCronItems</a>();
            theIDSet.erase(pParty-&gt;<a class="code" href="class_o_t_party.html#aa11f990dfe9743dd1d8e34af8bfd693a">GetOpeningTransNo</a>());

            <span class="comment">// the RemoveIssued call means the original transaction# (to find this cron item on cron) is now CLOSED.</span>
            <span class="comment">// But the Transaction itself is still OPEN. How? Because the CLOSING number is still signed out.</span>
            <span class="comment">// The closing number is also USED, since the smart contract was initially activated, but it remains</span>
            <span class="comment">// ISSUED, until the final receipt itself is accepted during a process inbox.</span>
            <span class="comment">//</span>
            pPartyNym-&gt;<a class="code" href="class_o_t_pseudonym.html#a17f25f5eb52440cc3ffc139dcbff75fe">RemoveIssuedNum</a>(*pServerNym, strServerID, pParty-&gt;<a class="code" href="class_o_t_party.html#aa11f990dfe9743dd1d8e34af8bfd693a">GetOpeningTransNo</a>(), <span class="keyword">false</span>); <span class="comment">//bSave=false</span>
            pPartyNym-&gt;<a class="code" href="class_o_t_pseudonym.html#a5d08ef86097db038c2c4fd30034f5dc8">SaveSignedNymfile</a>(*pServerNym);
        }
        <span class="keywordflow">else</span>
        {
            <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;OTSmartContract::%s: Failed verifying &quot;</span>
                          <span class="stringliteral">&quot;pPartyNym != NULL &amp;&amp; pParty-&gt;GetOpeningTransNo() &gt; 0 &amp;&amp;  &quot;</span>
                          <span class="stringliteral">&quot;pPartyNym-&gt;VerifyIssuedNum(pParty-&gt;GetOpeningTransNo())\n&quot;</span>, __FUNCTION__);
        }
        <span class="comment">// -------------------------</span>
        <span class="comment">//</span>
        <span class="comment">// NOTIFY ALL AGENTS for this party, with a copy of the finalReceipt in their Nymbox.</span>
        <span class="comment">//</span>
        <span class="comment">// TOdo: if the above block fails, should I still go dropping these receipts?</span>
        <span class="comment">//</span>
        <span class="keywordflow">if</span> ((<span class="keyword">false</span> == pParty-&gt;<a class="code" href="class_o_t_party.html#a6a98b5bb7fb58bd31fa3aa94b53023f6">DropFinalReceiptToNymboxes</a>(lNewTransactionNumber, <span class="comment">// new, owned by the server. For notices.</span>
                                                         strOrigCronItem,
                                                         NULL,
                                                         pstrAttachment,
                                                         pPartyNym)))
        {
            <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;OTSmartContract::%s: Failure dropping final receipt into nymbox for even a single agent.\n&quot;</span>,
                          __FUNCTION__);
        }

        <span class="comment">// -----------------------------------------------------------------</span>
        <span class="comment">// So the same Nym doesn&#39;t get loaded twice on accident. (We pass in pointers to nyms that</span>
        <span class="comment">// are already loaded, so the called function can use them instead of loading, if it came</span>
        <span class="comment">// to that.)</span>
        <span class="comment">//</span>
<span class="comment">//      typedef std::map    &lt;std::string, OTPseudonym *&gt;    mapOfNyms;</span>

        <a class="code" href="_o_t_agent_8hpp.html#ac89892658f6bc83e354078647b704e8f">mapOfNyms</a>   nym_map;

        <span class="comment">// -----------------------------------------------------------------------------------------</span>
        <span class="comment">// pServerNym</span>
        {
            <span class="keyword">const</span> <a class="code" href="class_o_t_identifier.html">OTIdentifier</a>  theServerNymID (*pServerNym);
            <span class="keyword">const</span> <a class="code" href="class_o_t_string.html">OTString</a>      strServerNymID (theServerNymID); <span class="comment">// &lt;--</span>

            mapOfNyms::iterator iiii = nym_map.find(strServerNymID.Get());

            <span class="keywordflow">if</span> ( nym_map.end() == iiii) <span class="comment">// wasn&#39;t already there</span>
                nym_map.insert(std::pair&lt;std::string, OTPseudonym *&gt;(strServerNymID.Get(), pServerNym));
        }
        <span class="comment">// -----------------------------------------------------------------------------------------</span>
        <span class="comment">// theOriginator</span>
        {
            <span class="keyword">const</span> <a class="code" href="class_o_t_identifier.html">OTIdentifier</a>  theOriginatorNymID (theOriginator);
            <span class="keyword">const</span> <a class="code" href="class_o_t_string.html">OTString</a>      strOriginatorNymID (theOriginatorNymID); <span class="comment">// &lt;--</span>

            mapOfNyms::iterator iiii = nym_map.find(strOriginatorNymID.Get());

            <span class="keywordflow">if</span> ( nym_map.end() ==  iiii)<span class="comment">// wasn&#39;t already there</span>
                nym_map.insert(std::pair&lt;std::string, OTPseudonym *&gt;(strOriginatorNymID.Get(), &amp;theOriginator));
        }
        <span class="comment">// -----------------------------------------------------------------------------------------</span>
        <span class="keywordflow">if</span> (NULL != pActingNym)
        {
            <span class="keyword">const</span> <a class="code" href="class_o_t_identifier.html">OTIdentifier</a>  theActingNymID (*pActingNym);
            <span class="keyword">const</span> <a class="code" href="class_o_t_string.html">OTString</a>      strActingNymID (theActingNymID); <span class="comment">// &lt;--</span>

            mapOfNyms::iterator iiii = nym_map.find(strActingNymID.Get());

            <span class="keywordflow">if</span> ( nym_map.end() ==  iiii) <span class="comment">// wasn&#39;t already there</span>
                nym_map.insert(std::pair&lt;std::string, OTPseudonym *&gt;(strActingNymID.Get(), pActingNym));
        }
        <span class="comment">// -----------------------------------------------------------------------------------------</span>
        <span class="keywordflow">if</span> (NULL != pPartyNym)
        {
            <span class="keyword">const</span> <a class="code" href="class_o_t_identifier.html">OTIdentifier</a>  thePartyNymID (*pPartyNym);
            <span class="keyword">const</span> <a class="code" href="class_o_t_string.html">OTString</a>      strPartyNymID (thePartyNymID); <span class="comment">// &lt;--</span>


            mapOfNyms::iterator iiii = nym_map.find(strPartyNymID.Get());

            <span class="keywordflow">if</span> ( nym_map.end() ==  iiii)<span class="comment">// wasn&#39;t already there</span>
                nym_map.insert(std::pair&lt;std::string, OTPseudonym *&gt;(strPartyNymID.Get(), pPartyNym));
        }
        <span class="comment">// -----------------------------------------------------------------------------------------</span>

        <span class="comment">//</span>
        <span class="comment">// NOTIFY the agent for EACH ACCOUNT listed by this party,</span>
        <span class="comment">// with a copy of the finalReceipt in the Inbox for each asset acct.</span>
        <span class="comment">//</span>
        <span class="comment">// Also for each, if he has a Nym (HE SHOULD), and if</span>
        <span class="comment">// (CLOSING_NUMBER_HERE &gt; 0), then call:</span>
        <span class="comment">//</span>
        <span class="comment">// pNym-&gt;VerifyIssuedNum(strServerID, lClosingNumber)</span>
        <span class="comment">// (This happens in OTAgent::DropFinalReceipt, FYI.)</span>
        <span class="comment">//</span>

        <span class="keywordflow">if</span> (<span class="keyword">false</span> == pParty-&gt;<a class="code" href="class_o_t_party.html#a8144d9376f00f992e0df6f4cfd3a31f1">DropFinalReceiptToInboxes</a>(&amp;nym_map,    <span class="comment">// contains any Nyms who might already be loaded, mapped by ID.</span>
                                                       strServerID,
                                                       *pServerNym,
                                                       lNewTransactionNumber,
                                                       strOrigCronItem,
                                                       NULL,
                                                       pstrAttachment))
        {
            <a class="code" href="class_o_t_log.html#a5acd90ac91c2618f395b0ff37ad4f8ee">OTLog::Error</a>(<span class="stringliteral">&quot;OTSmartContract::onFinalReceipt: Failure dropping final receipt into all inboxes. (Missed at least one.)\n&quot;</span>);
        }

        <span class="comment">// -----------------------------------------------------------------</span>

        pParty-&gt;<a class="code" href="class_o_t_party.html#a41a428ded2f0477cf8752648cbe51e4e">ClearTemporaryPointers</a>();

    } <span class="comment">// FOR_EACH m_mapParties</span>
}
</pre></div>
</div>
</div>
<a class="anchor" id="ad0ed5c23badda402c9493b86bef7542e"></a><!-- doxytag: member="OTSmartContract::onRemovalFromCron" ref="ad0ed5c23badda402c9493b86bef7542e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_o_t_smart_contract.html#ad0ed5c23badda402c9493b86bef7542e">OTSmartContract::onRemovalFromCron</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="class_o_t_cron_item.html#ad7aa9b289746ab01661997a19b1335b1">OTCronItem</a>.</p>

<p>Definition at line <a class="el" href="_o_t_smart_contract_8cpp_source.html#l00929">929</a> of file <a class="el" href="_o_t_smart_contract_8cpp_source.html">OTSmartContract.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">// Not much needed here.  Done, I guess.</span>

    <a class="code" href="class_o_t_log.html#a5acd90ac91c2618f395b0ff37ad4f8ee">OTLog::Error</a>(<span class="stringliteral">&quot;FYI:  OTSmartContract::onRemovalFromCron was just called. \n&quot;</span>);

    <span class="comment">// Trigger a script maybe.</span>
    <span class="comment">// OR maybe it&#39;s too late for scripts.</span>
    <span class="comment">// I give myself an onRemoval() here in C++, but perhaps I cut</span>
    <span class="comment">// off the SCRIPTS after onFinalReceipt(). I think that&#39;s best.</span>
}
</pre></div>
</div>
</div>
<a class="anchor" id="afd41dba13f15554183828bd79f0cbb3f"></a><!-- doxytag: member="OTSmartContract::PrepareToActivate" ref="afd41dba13f15554183828bd79f0cbb3f" args="(const int64_t &amp;lOpeningTransNo, const int64_t &amp;lClosingTransNo, const OTIdentifier &amp;theUserID, const OTIdentifier &amp;theAcctID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_o_t_smart_contract.html#afd41dba13f15554183828bd79f0cbb3f">OTSmartContract::PrepareToActivate</a> </td>
          <td>(</td>
          <td class="paramtype">const int64_t &amp;&#160;</td>
          <td class="paramname"><em>lOpeningTransNo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int64_t &amp;&#160;</td>
          <td class="paramname"><em>lClosingTransNo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_o_t_identifier.html">OTIdentifier</a> &amp;&#160;</td>
          <td class="paramname"><em>theUserID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_o_t_identifier.html">OTIdentifier</a> &amp;&#160;</td>
          <td class="paramname"><em>theAcctID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_o_t_smart_contract_8cpp_source.html#l05312">5312</a> of file <a class="el" href="_o_t_smart_contract_8cpp_source.html">OTSmartContract.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
    <a class="code" href="class_o_t_trackable.html#a6ef06e21f2ad3616ab6b3a303662846d">SetTransactionNum</a>(lOpeningTransNo);

    <a class="code" href="class_o_t_cron_item.html#a3941f19ac62239dbeee9a300d9f8c2b1">ClearClosingNumbers</a>(); <span class="comment">// Just in case. Should be unnecessary, but you never know how people might screw around.</span>
    <a class="code" href="class_o_t_cron_item.html#a310153e4e82ec7fbc887e93c4d12220d">AddClosingTransactionNo</a>(lClosingTransNo);

    <span class="comment">// -------------------------------------</span>

    <a class="code" href="class_o_t_trackable.html#a689cca3d471d7e85bec084d302f3cd83">SetSenderUserID</a>(theUserID); <span class="comment">// This is the activator of the contract. (NOT the actual &quot;sender&quot; of any single payment, in the case of smart contracts anyway.)</span>
    <a class="code" href="class_o_t_trackable.html#a75814babcec8eb5cfed15047d4dfb4f6">SetSenderAcctID</a>(theAcctID); <span class="comment">// This is an account provided by the activator so a closing number and final receipt are guaranteed for this smart contract.</span>

    <span class="comment">// -------------------------------------</span>

    <a class="code" href="class_o_t_smart_contract.html#a09de789ac2e616e2119feb9ddf416c9d">ReleaseLastSenderRecipientIDs</a>(); <span class="comment">// These should be blank starting out anyway.</span>

    <span class="comment">// -------------------------------------</span>
    <span class="comment">// You shouldn&#39;t have any of these anyway; the server only creates</span>
    <span class="comment">// them after a smart contract is activated.</span>
    <span class="comment">//</span>
    <a class="code" href="class_o_t_smart_contract.html#a5e2972487aa71cb86d51393ed749f341">ReleaseStashes</a>();
}
</pre></div>
</div>
</div>
<a class="anchor" id="a717de2aa486b22c8ccde06c25bbb64f5"></a><!-- doxytag: member="OTSmartContract::ProcessCron" ref="a717de2aa486b22c8ccde06c25bbb64f5" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_o_t_smart_contract.html#a717de2aa486b22c8ccde06c25bbb64f5">OTSmartContract::ProcessCron</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="class_o_t_cron_item.html#afe5c6a9af86b637fd8b2b3459825565b">OTCronItem</a>.</p>

<p>Definition at line <a class="el" href="_o_t_smart_contract_8cpp_source.html#l03316">3316</a> of file <a class="el" href="_o_t_smart_contract_8cpp_source.html">OTSmartContract.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
    <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != <a class="code" href="class_o_t_cron_item.html#af734ad5d309fcc9b4a60d40d6c30f55a">GetCron</a>());

    <span class="comment">// -----------------------------------------------------------------</span>
    <span class="comment">// Right now Cron is called 10 times per second.</span>
    <span class="comment">// I&#39;m going to slow down all trades so they are once every GetProcessInterval()</span>
    <span class="comment">// Todo: Create separate lists in Cron.  10*/sec list, 1/second list, 1 min list, 1 hour, 1 day, 1 month.</span>
    <span class="comment">// That way I&#39;m not looping through ALL cron items 10*/second, but only the ones who are paying for those</span>
    <span class="comment">// kinds of resources. (Different lists will cost different server fees.)</span>
    <span class="comment">//</span>
    <span class="keywordflow">if</span> (<a class="code" href="class_o_t_cron_item.html#ad8f19edf794a54644ed4822d0bc120a4">GetLastProcessDate</a>() &gt; <a class="code" href="_o_t_common_8hpp.html#af4ca9fa2c7c290d647dd18de0a9ac25f">OT_TIME_ZERO</a>)
    {
        <span class="comment">// Default ProcessInternal is 1 second, but Trades will use 10 seconds, and Payment</span>
        <span class="comment">// Plans will use an hour or day. Smart contracts are currently 30 seconds. (For testing.)</span>
        <span class="comment">//</span>
        <span class="keywordflow">if</span> (<a class="code" href="_o_t_common_8hpp.html#a4c78edddfcabfde278fafe43149f027e">OTTimeGetTimeInterval</a>(<a class="code" href="_o_t_common_8hpp.html#a1163606b2546b160d50c5f0a5afe479a">OTTimeGetCurrentTime</a>(), <a class="code" href="class_o_t_cron_item.html#ad8f19edf794a54644ed4822d0bc120a4">GetLastProcessDate</a>()) &lt;= <a class="code" href="class_o_t_cron_item.html#a39dce8a744a7dc6914e130bdde334a97">GetProcessInterval</a>())
            <span class="keywordflow">return</span> <span class="keyword">true</span>;
    }
    <span class="comment">// Keep a record of the last time this was processed.</span>
    <span class="comment">// (NOT saved to storage, only used while the software is running.)</span>
    <span class="comment">// (Thus no need to release signatures, sign contract, save contract, etc.)</span>
    <a class="code" href="class_o_t_cron_item.html#aac4ad32d864f5b6e8ce07a28432bf1ef">SetLastProcessDate</a>(<a class="code" href="_o_t_common_8hpp.html#a1163606b2546b160d50c5f0a5afe479a">OTTimeGetCurrentTime</a>());
    <span class="comment">// -----------------------------------------------------------------</span>

    <span class="comment">// END DATE --------------------------------</span>
    <span class="comment">// First call the parent&#39;s version (which this overrides) so it has</span>
    <span class="comment">// a chance to check its stuff.</span>
    <span class="comment">// Currently it calls IsExpired().</span>
    <span class="comment">//</span>
    <span class="keywordflow">if</span> (<span class="keyword">false</span> == <a class="code" href="class_o_t_cron_item.html#afe5c6a9af86b637fd8b2b3459825565b">ot_super::ProcessCron</a>())
    {
        <a class="code" href="class_o_t_log.html#a1f7549d776ee919dcb6517f611ded015">OTLog::Output</a>(3, <span class="stringliteral">&quot;Cron job has expired.\n&quot;</span>);
        <span class="keywordflow">return</span> <span class="keyword">false</span>;   <span class="comment">// It&#39;s expired or flagged for removal--remove it from Cron.</span>
    }

    <span class="comment">// START DATE --------------------------------</span>
    <span class="comment">// Okay, so it&#39;s not expired. But might not have reached START DATE yet...</span>
    <span class="keywordflow">if</span> (!<a class="code" href="class_o_t_instrument.html#a8a90b4e37984058d8e6fb836311c5dd9">VerifyCurrentDate</a>())
        <span class="keywordflow">return</span> <span class="keyword">true</span>;    <span class="comment">// The Payment Plan is not yet valid, so we return. BUT, we also</span>
    <span class="comment">// return TRUE, so it will STAY on Cron until it BECOMES valid.</span>

    <span class="comment">// -----------------------------------------------------------------------------</span>
    <span class="comment">// Make sure there are transaction numbers available in Cron.</span>
    <span class="comment">// (Can&#39;t do anything without those....)</span>
    <span class="comment">//</span>
    <span class="keywordflow">if</span> (<a class="code" href="class_o_t_cron_item.html#af734ad5d309fcc9b4a60d40d6c30f55a">GetCron</a>()-&gt;GetTransactionCount() &lt; 1)
    {
        <a class="code" href="class_o_t_log.html#a1f7549d776ee919dcb6517f611ded015">OTLog::Output</a>(0, <span class="stringliteral">&quot;Failed to process smart contract: Cron is out of transaction numbers!\n&quot;</span>);
        <span class="keywordflow">return</span> <span class="keyword">true</span>;
    }

    <span class="comment">// -----------------------------------------------------------------------------</span>
    <span class="comment">// Make sure, if the script set a timer, that we don&#39;t process Cron until that timer</span>
    <span class="comment">// is reached. (If the timer&#39;s not set, then we go ahead and process every time.)</span>
    <span class="comment">//</span>
    <span class="keyword">const</span> <a class="code" href="_o_t_common_8hpp.html#ad28ff0a3eda18840f6bda5872819167f">time64_t</a> tNextProcessDate = <a class="code" href="class_o_t_smart_contract.html#a16737b147030f0aaaedc53f798c35a50">GetNextProcessDate</a>();

    <span class="keywordflow">if</span> (tNextProcessDate &gt; <a class="code" href="_o_t_common_8hpp.html#af4ca9fa2c7c290d647dd18de0a9ac25f">OT_TIME_ZERO</a>) <span class="comment">// IF there is a timer set (as to when the next &quot;onProcess&quot; should occur)...</span>
    {
        <span class="keywordflow">if</span> (<a class="code" href="_o_t_common_8hpp.html#a1163606b2546b160d50c5f0a5afe479a">OTTimeGetCurrentTime</a>() &lt;= tNextProcessDate) <span class="comment">// AND if the current time has NOT YET reached that date (the date in the timer)...</span>
        {
            <span class="comment">// ...Then RETURN (since the timer hasn&#39;t popped yet)</span>
            <span class="comment">// But return TRUE, so that this cron item stays active for now.</span>
            <span class="comment">//</span>
            <span class="keywordflow">return</span> <span class="keyword">true</span>;
        }
        <span class="keywordflow">else</span> <span class="comment">// else it HAS now reached the official timer date...</span>
        {
            <a class="code" href="class_o_t_smart_contract.html#a0c0ffa47dacaa8fa79304317f8e04544">SetNextProcessDate</a>(<a class="code" href="_o_t_common_8hpp.html#af4ca9fa2c7c290d647dd18de0a9ac25f">OT_TIME_ZERO</a>);   <span class="comment">// Therefore timer has triggered, so we will continue processing.</span>
        }                           <span class="comment">// We also reset timer to 0 again since it has now &quot;binged&quot;.</span>
    }   <span class="comment">// Continuing on....</span>
    <span class="comment">// *****************************************************************************</span>
    <span class="comment">//</span>
    <span class="comment">// Execute the scripts (clauses) that have registered for this hook.</span>

    <span class="keyword">const</span> std::string   str_HookName(<a class="code" href="_o_t_smart_contract_8cpp.html#a3620c2b37a2cef094ecadcc890af8383">SMARTCONTRACT_HOOK_ON_PROCESS</a>);
    <a class="code" href="_o_t_clause_8hpp.html#a40c16432fa9c16826c026b74351425ad">mapOfClauses</a>        theMatchingClauses;

    <span class="keywordflow">if</span> (this-&gt;<a class="code" href="class_o_t_scriptable.html#a298d8fdb0982df3c36e8ae194f228009">GetHooks</a>(str_HookName, theMatchingClauses))
    {
        <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(0, <span class="stringliteral">&quot;Cron: Processing smart contract clauses for hook: %s \n&quot;</span>, <a class="code" href="_o_t_smart_contract_8cpp.html#a3620c2b37a2cef094ecadcc890af8383">SMARTCONTRACT_HOOK_ON_PROCESS</a>);

        this-&gt;<a class="code" href="class_o_t_smart_contract.html#a83282de7074313974d0db0f50b3b6e09">ExecuteClauses</a>(theMatchingClauses); <span class="comment">// &lt;============================================</span>
    }
    <span class="comment">//</span>
    <span class="comment">// *****************************************************************************</span>


    <span class="keywordflow">if</span> (<a class="code" href="class_o_t_cron_item.html#a5fd32eb6600ee9740e5e99acebcaa2d8">IsFlaggedForRemoval</a>())
    {
        <a class="code" href="class_o_t_log.html#a1f7549d776ee919dcb6517f611ded015">OTLog::Output</a>(3, <span class="stringliteral">&quot;OTSmartContract::ProcessCron: Removing smart contract from cron processing...\n&quot;</span>);
        <span class="keywordflow">return</span> <span class="keyword">false</span>; <span class="comment">// false means &quot;remove this cron item from cron&quot;</span>
    }

    <span class="keywordflow">return</span> <span class="keyword">true</span>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a8524c56a7469d39a895bed4b18671972"></a><!-- doxytag: member="OTSmartContract::ProcessXMLNode" ref="a8524c56a7469d39a895bed4b18671972" args="(irr::io::IrrXMLReader *&amp;xml)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t <a class="el" href="class_o_t_smart_contract.html#a8524c56a7469d39a895bed4b18671972">OTSmartContract::ProcessXMLNode</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceirr_1_1io.html#a1628edbb9d5d53f18c82d2a92b0ad27e">irr::io::IrrXMLReader</a> *&amp;&#160;</td>
          <td class="paramname"><em>xml</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="class_o_t_cron_item.html#a6b7eec23353a8ed49ee40a742c391aa3">OTCronItem</a>.</p>

<p>Definition at line <a class="el" href="_o_t_smart_contract_8cpp_source.html#l05338">5338</a> of file <a class="el" href="_o_t_smart_contract_8cpp_source.html">OTSmartContract.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keyword">const</span> <a class="code" href="class_o_t_string.html">OTString</a> strNodeName(xml-&gt;getNodeName());


<span class="comment">//    OTLog::vError(&quot;-- CALLING SUPER CLASS -- OTSmartContract::ProcessXMLNode. strNodeName: %s \n&quot;,</span>
<span class="comment">//                  strNodeName.Get());</span>

    int32_t nReturnVal = 0;

    <span class="comment">// Here we call the parent class first.</span>
    <span class="comment">// If the node is found there, or there is some error,</span>
    <span class="comment">// then we just return either way.  But if it comes back</span>
    <span class="comment">// as &#39;0&#39;, then nothing happened, and we&#39;ll continue executing.</span>
    <span class="comment">//</span>
    <span class="comment">// OTSmartContract::ProcessXMLNode calls OTCronItem::ProcessXMLNode,</span>
    <span class="comment">// which calls OTScriptable... Meaning:</span>
    <span class="comment">//</span>
    <span class="comment">// NO NEED to explicitly load OTScriptable stuff here!</span>
    <span class="comment">//</span>
    nReturnVal = <a class="code" href="class_o_t_cron_item.html#a6b7eec23353a8ed49ee40a742c391aa3">ot_super::ProcessXMLNode</a>(xml);

    <span class="keywordflow">if</span> (0 != (nReturnVal))
    {
<span class="comment">//        if ((-1) == nReturnVal)</span>
<span class="comment">//            OTLog::vError(&quot;**** ERROR**** in superclass...\n &quot;);</span>

        <span class="keywordflow">return</span> nReturnVal;
    }
    <span class="comment">// -------------------------------------------------</span>



<span class="comment">//    OTLog::vError(&quot;-- FINISHED CALLING SUPER CLASS -- OTSmartContract::ProcessXMLNode:  strNodeName: %s \n&quot;, strNodeName.Get());</span>



    <span class="keywordflow">if</span> (strNodeName.Compare(<span class="stringliteral">&quot;smartContract&quot;</span>))
    {
        <a class="code" href="class_o_t_contract.html#aa0d889e0e1670b56fedca245041a5ed3">m_strVersion</a>    = xml-&gt;getAttributeValue(<span class="stringliteral">&quot;version&quot;</span>);

        <span class="keyword">const</span> <a class="code" href="class_o_t_string.html">OTString</a>  strServerID       (xml-&gt;getAttributeValue(<span class="stringliteral">&quot;serverID&quot;</span>));
        <span class="keyword">const</span> <a class="code" href="class_o_t_string.html">OTString</a>  strActivatorUserID(xml-&gt;getAttributeValue(<span class="stringliteral">&quot;activatorUserID&quot;</span>));
        <span class="keyword">const</span> <a class="code" href="class_o_t_string.html">OTString</a>  strActivatorAcctID(xml-&gt;getAttributeValue(<span class="stringliteral">&quot;activatorAcctID&quot;</span>));
        <span class="keyword">const</span> <a class="code" href="class_o_t_string.html">OTString</a>  strCanceled       (xml-&gt;getAttributeValue(<span class="stringliteral">&quot;canceled&quot;</span>));
        <span class="keyword">const</span> <a class="code" href="class_o_t_string.html">OTString</a>  strCancelerUserID (xml-&gt;getAttributeValue(<span class="stringliteral">&quot;cancelerUserID&quot;</span>));

        <span class="keywordflow">if</span> (strServerID.Exists())
        {
            <span class="keyword">const</span> <a class="code" href="class_o_t_identifier.html">OTIdentifier</a>  SERVER_ID(strServerID);
            <a class="code" href="class_o_t_instrument.html#a80fc5560fdedf911ec0c184ab9fbb5b7">SetServerID</a>(SERVER_ID);
        }
        <span class="keywordflow">if</span> (strActivatorUserID.Exists())
        {
            <span class="keyword">const</span> <a class="code" href="class_o_t_identifier.html">OTIdentifier</a>  ACTIVATOR_USER_ID(strActivatorUserID);
            <a class="code" href="class_o_t_trackable.html#a689cca3d471d7e85bec084d302f3cd83">SetSenderUserID</a>(ACTIVATOR_USER_ID);
        }
        <span class="keywordflow">if</span> (strActivatorAcctID.Exists())
        {
            <span class="keyword">const</span> <a class="code" href="class_o_t_identifier.html">OTIdentifier</a>  ACTIVATOR_ACCT_ID(strActivatorAcctID);
            <a class="code" href="class_o_t_trackable.html#a75814babcec8eb5cfed15047d4dfb4f6">SetSenderAcctID</a>(ACTIVATOR_ACCT_ID);
        }

        <span class="comment">// ----------------------</span>
        <span class="keywordflow">if</span> (strCanceled.Exists() &amp;&amp; strCanceled.Compare(<span class="stringliteral">&quot;true&quot;</span>))
        {
            <a class="code" href="class_o_t_cron_item.html#abe9ce5c7b4d2fe652908e1f81f2f3b67">m_bCanceled</a> = <span class="keyword">true</span>;

            <span class="keywordflow">if</span> (strCancelerUserID.Exists())
                <a class="code" href="class_o_t_cron_item.html#af7bb48c16e16f664b938a7f235d2872d">m_pCancelerNymID</a>-&gt;<a class="code" href="class_o_t_identifier.html#ae29aa1245d3831a207aabc9b8a493bfc">SetString</a>(strCancelerUserID);
            <span class="comment">// else log</span>
        }
        <span class="keywordflow">else</span>
        {
            <a class="code" href="class_o_t_cron_item.html#abe9ce5c7b4d2fe652908e1f81f2f3b67">m_bCanceled</a> = <span class="keyword">false</span>;
            <a class="code" href="class_o_t_cron_item.html#af7bb48c16e16f664b938a7f235d2872d">m_pCancelerNymID</a>-&gt;<a class="code" href="class_o_t_data.html#aab9a5758e85597ef1d7250bcf2cc56a6">Release</a>();
        }
        <span class="comment">// ----------------------------------------------------------------------------</span>
        <span class="keyword">const</span> <a class="code" href="class_o_t_string.html">OTString</a> strTransNum = xml-&gt;getAttributeValue(<span class="stringliteral">&quot;transactionNum&quot;</span>);

        <a class="code" href="class_o_t_trackable.html#a6ef06e21f2ad3616ab6b3a303662846d">SetTransactionNum</a>( strTransNum.<a class="code" href="class_o_t_string.html#adf7489cd917d4ae5bf30853a3ad78daf">Exists</a>() ? atol(strTransNum.<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>()) : 0 );
        <span class="comment">// ----------------------------------------------------------------------------</span>
        <span class="keyword">const</span> <a class="code" href="class_o_t_string.html">OTString</a> str_valid_from   = xml-&gt;getAttributeValue(<span class="stringliteral">&quot;validFrom&quot;</span>);
        <span class="keyword">const</span> <a class="code" href="class_o_t_string.html">OTString</a> str_valid_to     = xml-&gt;getAttributeValue(<span class="stringliteral">&quot;validTo&quot;</span>);
        <span class="keyword">const</span> <a class="code" href="class_o_t_string.html">OTString</a> str_creation     = xml-&gt;getAttributeValue(<span class="stringliteral">&quot;creationDate&quot;</span>);
        <span class="keyword">const</span> <a class="code" href="class_o_t_string.html">OTString</a> str_next_process = xml-&gt;getAttributeValue(<span class="stringliteral">&quot;nextProcessDate&quot;</span>);
        <span class="comment">// ----------------------------------------------------------------------------</span>
        int64_t tValidFrom   = str_valid_from.<a class="code" href="class_o_t_string.html#a18ca8f42f6e90ab7801c019611d9dca8">ToLong</a>();
        int64_t tValidTo     = str_valid_to.<a class="code" href="class_o_t_string.html#a18ca8f42f6e90ab7801c019611d9dca8">ToLong</a>();
        int64_t tCreation    = str_creation.<a class="code" href="class_o_t_string.html#a18ca8f42f6e90ab7801c019611d9dca8">ToLong</a>();
        int64_t tNextProcess = str_next_process.<a class="code" href="class_o_t_string.html#a18ca8f42f6e90ab7801c019611d9dca8">ToLong</a>();
        <span class="comment">// ----------------------------------------------------------------------------</span>
        <a class="code" href="class_o_t_instrument.html#af8e356f6956ad222a1766435edca8374">SetValidFrom</a>(<a class="code" href="_o_t_common_8hpp.html#a5c0893ffd83818f1c3c6b3b7ae92da13">OTTimeGetTimeFromSeconds</a>(tValidFrom));
        <a class="code" href="class_o_t_instrument.html#a5baef9beffaf6627cd9d5277fdbb14c3">SetValidTo</a>(<a class="code" href="_o_t_common_8hpp.html#a5c0893ffd83818f1c3c6b3b7ae92da13">OTTimeGetTimeFromSeconds</a>(tValidTo));
        <a class="code" href="class_o_t_cron_item.html#a7668dc44368861c09a47de0f420cf2fa">SetCreationDate</a>(<a class="code" href="_o_t_common_8hpp.html#a5c0893ffd83818f1c3c6b3b7ae92da13">OTTimeGetTimeFromSeconds</a>(tCreation));
        <a class="code" href="class_o_t_smart_contract.html#a0c0ffa47dacaa8fa79304317f8e04544">SetNextProcessDate</a>(<a class="code" href="_o_t_common_8hpp.html#a5c0893ffd83818f1c3c6b3b7ae92da13">OTTimeGetTimeFromSeconds</a>(tNextProcess));
        <span class="comment">// ----------------------------------------------------------------------------</span>
        <span class="comment">// These are stored for RECEIPTS, so if there is an inbox receipt with an amount,</span>
        <span class="comment">// we will know who was sending and receiving.  If sender or receiver is blank, that</span>
        <span class="comment">// means the source/destination was a STASH instead of an account. FYI.</span>
        <span class="comment">//</span>
        m_strLastSenderUser     = xml-&gt;getAttributeValue(<span class="stringliteral">&quot;lastSenderUserID&quot;</span>);    <span class="comment">// Last User ID of a party who SENT money.</span>
        m_strLastSenderAcct     = xml-&gt;getAttributeValue(<span class="stringliteral">&quot;lastSenderAcctID&quot;</span>);    <span class="comment">// Last Acct ID of a party who SENT money.</span>
        m_strLastRecipientUser  = xml-&gt;getAttributeValue(<span class="stringliteral">&quot;lastRecipientUserID&quot;</span>); <span class="comment">// Last User ID of a party who RECEIVED money.</span>
        m_strLastRecipientAcct  = xml-&gt;getAttributeValue(<span class="stringliteral">&quot;lastRecipientAcctID&quot;</span>); <span class="comment">// Last Acct ID of a party who RECEIVED money.</span>
        <span class="comment">// ----------------------------------------------------------------------------</span>
        <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(1, <span class="stringliteral">&quot;\n\n Smartcontract. Transaction Number: %lld\n&quot;</span>, <a class="code" href="class_o_t_trackable.html#a90bc18f9b5d6b3c8059a83685b86674e">m_lTransactionNum</a>);

        <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(2,
                       <span class="stringliteral">&quot; Creation Date: %&quot;</span> PRId64<span class="stringliteral">&quot;   Valid From: %&quot;</span> PRId64<span class="stringliteral">&quot;\n Valid To: %&quot;</span> PRId64<span class="stringliteral">&quot;\n&quot;</span>
                       <span class="stringliteral">&quot; ServerID: %s\n&quot;</span>
                       <span class="stringliteral">&quot; activatorUserID: %s\n &quot;</span>,
                       tCreation, tValidFrom, tValidTo,
                       strServerID.Get(),
                       strActivatorUserID.Get());

        nReturnVal = 1;
    }

    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strNodeName.Compare(<span class="stringliteral">&quot;accountList&quot;</span>)) <span class="comment">// the stash reserve account IDs.</span>
    {
        <span class="keyword">const</span> <a class="code" href="class_o_t_string.html">OTString</a> strAcctType  = xml-&gt;getAttributeValue(<span class="stringliteral">&quot;type&quot;</span>);
        <span class="keyword">const</span> <a class="code" href="class_o_t_string.html">OTString</a> strAcctCount = xml-&gt;getAttributeValue(<span class="stringliteral">&quot;count&quot;</span>);

        <span class="keywordflow">if</span> ((-1) == m_StashAccts.<a class="code" href="class_o_t_acct_list.html#ab821444a5a7e7cc453182e755d5a00dc">ReadFromXMLNode</a>(xml, strAcctType, strAcctCount))
        {
            <a class="code" href="class_o_t_log.html#a5acd90ac91c2618f395b0ff37ad4f8ee">OTLog::Error</a>(<span class="stringliteral">&quot;OTSmartContract::ProcessXMLNode: Error loading stash accountList.\n&quot;</span>);
            nReturnVal = (-1);
        }
        <span class="keywordflow">else</span>
            nReturnVal = 1;
    }

    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strNodeName.Compare(<span class="stringliteral">&quot;stash&quot;</span>)) <span class="comment">// the actual stashes.</span>
    {
        <span class="keyword">const</span> <a class="code" href="class_o_t_string.html">OTString</a> strStashName = xml-&gt;getAttributeValue(<span class="stringliteral">&quot;name&quot;</span>);
        <span class="keyword">const</span> <a class="code" href="class_o_t_string.html">OTString</a> strItemCount = xml-&gt;getAttributeValue(<span class="stringliteral">&quot;count&quot;</span>);

        <span class="keyword">const</span> std::string str_stash_name = strStashName.<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>();
        <a class="code" href="class_o_t_stash.html">OTStash</a> * pStash = <span class="keyword">new</span> <a class="code" href="class_o_t_stash.html">OTStash</a>(str_stash_name);
        <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != pStash);

        <span class="keywordflow">if</span> ((-1) == pStash-&gt;<a class="code" href="class_o_t_stash.html#a71923cb44bd1c4273b77ba760ebd4067">ReadFromXMLNode</a>(xml, strStashName, strItemCount))
        {
            <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;OTSmartContract::ProcessXMLNode: Error loading stash: %s\n&quot;</span>,
                          strStashName.<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>());
            <span class="keyword">delete</span> pStash;
            nReturnVal = (-1);
        }
        <span class="keywordflow">else</span>
        {
            <span class="comment">// Success</span>
            <span class="comment">//</span>
            m_mapStashes.insert(std::pair&lt;std::string, OTStash *&gt;(strStashName.<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>(), pStash));

            nReturnVal = 1;
        }
    }

<span class="comment">//    OTLog::vError(&quot;-- FINALLY -- OTSmartContract::ProcessXMLNode:  nReturnVal: %d  strNodeName: %s \n&quot;,</span>
<span class="comment">//                  nReturnVal, strNodeName.Get());</span>

    <span class="keywordflow">return</span> nReturnVal;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ad79350fe9df32d0e129e1a8b5fe28a04"></a><!-- doxytag: member="OTSmartContract::RegisterOTNativeCallsWithScript" ref="ad79350fe9df32d0e129e1a8b5fe28a04" args="(OTScript &amp;theScript)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_o_t_smart_contract.html#ad79350fe9df32d0e129e1a8b5fe28a04">OTSmartContract::RegisterOTNativeCallsWithScript</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_t_script.html">OTScript</a> &amp;&#160;</td>
          <td class="paramname"><em>theScript</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="class_o_t_scriptable.html#ad469b542209e1c73905d2094bb561793">OTScriptable</a>.</p>

<p>Definition at line <a class="el" href="_o_t_smart_contract_8cpp_source.html#l00671">671</a> of file <a class="el" href="_o_t_smart_contract_8cpp_source.html">OTSmartContract.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">// CALL THE PARENT</span>
    <a class="code" href="class_o_t_smart_contract.html#ad79350fe9df32d0e129e1a8b5fe28a04">OTScriptable::RegisterOTNativeCallsWithScript</a>(theScript);
    <span class="comment">// --------------------------------</span>

<span class="preprocessor">#ifdef OT_USE_SCRIPT_CHAI</span>
<span class="preprocessor"></span>    <span class="keyword">using namespace </span>chaiscript;

    OTScriptChai * pScript = <span class="keyword">dynamic_cast&lt;</span>OTScriptChai *<span class="keyword">&gt;</span> (&amp;theScript);

    <span class="comment">// *******************************************************************</span>
    <span class="keywordflow">if</span> (NULL != pScript)
    {
        <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != pScript-&gt;chai)
        <span class="comment">// ---------------------------------------------------------</span>
        <span class="comment">// OT NATIVE FUNCTIONS</span>
        <span class="comment">// (These functions can be called from INSIDE the scripted clauses.)</span>
        <span class="comment">//                                                                                      // Parameters must match as described below. Return value will be as described below.</span>
        <span class="comment">//                                                                                      // -------------------------------------------------------------</span>
<span class="comment">//      pScript-&gt;chai-&gt;add(base_class&lt;OTScriptable, OTSmartContract&gt;());</span>

        pScript-&gt;chai-&gt;add(fun&lt;<a class="code" href="_o_t_smart_contract_8cpp.html#a6727e3e80e655754aacd7b5380f8fb00">OT_SM_RetBool_ThrStr</a>&gt;(&amp;<a class="code" href="class_o_t_smart_contract.html">OTSmartContract</a>::<a class="code" href="class_o_t_smart_contract.html#ae10051f961745a06753f5e22d9a699f1">MoveAcctFundsStr</a>,        this), &quot;move_funds&quot;);   <span class="comment">// bool MoveAcctFunds(const std::string from_acct_name, const std::string to_acct_name, const std::string str_Amount); // calls OTCronItem::MoveFunds()</span>
<span class="comment">//      pScript-&gt;chai-&gt;add(fun&lt;OT_SM_RetBool_TwoStr_OneL&gt;(&amp;OTSmartContract::MoveAcctFundsL, this), &quot;move_funds_L&quot;);     // static bool s_MoveAcctFunds(const std::string from_acct_name, const std::string to_acct_name, const int64_t&amp; lAmount); // calls OTCronItem::MoveFunds()</span>
<span class="comment">//      pScript-&gt;chai-&gt;add(fun&lt;OT_SM_RetBool_ThrStr&gt;(&amp;OTSmartContract::MoveAcctFundsStr,        this), &quot;move_funds_Str&quot;);   // static bool s_MoveAcctFunds(const std::string from_acct_name, const std::string to_acct_name, const std::string str_Amount); // calls OTCronItem::MoveFunds()</span>
<span class="comment">//      pScript-&gt;chai-&gt;add(fun&lt;OT_SM_RetBool_TwoStr_OneL&gt;(&amp;g_MoveAcctFundsL,    this), &quot;move_funds_L&quot;);     // global bool s_MoveAcctFunds(const std::string from_acct_name, const std::string to_acct_name, const int64_t&amp; lAmount); // calls OTCronItem::MoveFunds()</span>
<span class="comment">//      pScript-&gt;chai-&gt;add(fun&lt;OT_SM_RetBool_ThrStr&gt;(&amp;g_MoveAcctFundsStr,   this), &quot;move_funds_Str&quot;);   // global bool s_MoveAcctFunds(const std::string from_acct_name, const std::string to_acct_name, const std::string str_Amount); // calls OTCronItem::MoveFunds()</span>

        pScript-&gt;chai-&gt;add(fun(&amp;<a class="code" href="class_o_t_smart_contract.html">OTSmartContract</a>::<a class="code" href="class_o_t_smart_contract.html#a7d4c35453914e75a252a1f4eac3ce855">StashAcctFunds</a>,                this), &quot;stash_funds&quot;);      <span class="comment">// bool StashAcctFunds(const std::string from_acct_name, const std::string to_stash_name, const std::string str_Amount); // calls StashFunds()</span>
        pScript-&gt;chai-&gt;add(fun(&amp;<a class="code" href="class_o_t_smart_contract.html">OTSmartContract</a>::<a class="code" href="class_o_t_smart_contract.html#a7be637de24a11ebd872822b84952c21a">UnstashAcctFunds</a>,          this), &quot;unstash_funds&quot;);    <span class="comment">// bool UnstashAcctFunds(const std::string to_acct_name, const std::string from_stash_name, const std::string str_Amount); // calls StashFunds( lAmount * (-1) )</span>

        pScript-&gt;chai-&gt;add(fun(&amp;<a class="code" href="class_o_t_smart_contract.html">OTSmartContract</a>::<a class="code" href="class_o_t_smart_contract.html#af6c9cbe669cea11256dc7fd2a6fdddf4">GetAcctBalance</a>,                this), &quot;get_acct_balance&quot;); <span class="comment">// std::string GetAcctBalance(const std::string acct_name);</span>
        pScript-&gt;chai-&gt;add(fun(&amp;<a class="code" href="class_o_t_smart_contract.html">OTSmartContract</a>::<a class="code" href="class_o_t_smart_contract.html#aef2b64b4870a325f36df1e634f744ce9">GetAssetTypeIDofAcct</a>,      this), &quot;get_acct_asset_type_id&quot;); <span class="comment">// std::string OTSmartContract::GetAssetTypeIDofAcct(const std::string from_acct_name)</span>
        pScript-&gt;chai-&gt;add(fun(&amp;<a class="code" href="class_o_t_smart_contract.html">OTSmartContract</a>::<a class="code" href="class_o_t_smart_contract.html#a2a92d021daf88edba58aabba629d90e5">GetStashBalance</a>,           this), &quot;get_stash_balance&quot;);    <span class="comment">// std::string GetStashBalance(const std::string stash_name, const std::string asset_type_id);</span>

        pScript-&gt;chai-&gt;add(fun(&amp;<a class="code" href="class_o_t_smart_contract.html">OTSmartContract</a>::<a class="code" href="class_o_t_smart_contract.html#a72762c0413197f084b36e2d0fce59e4f">SendNoticeToParty</a>,         this), &quot;send_notice&quot;);              <span class="comment">// bool SendNoticeToParty(const std::string party_name);</span>
        pScript-&gt;chai-&gt;add(fun(&amp;<a class="code" href="class_o_t_smart_contract.html">OTSmartContract</a>::<a class="code" href="class_o_t_smart_contract.html#a63aa006565fab757f33d28215b1f5e0c">SendANoticeToAllParties</a>,   this), &quot;send_notice_to_parties&quot;);   <span class="comment">// bool SendANoticeToAllParties();</span>

        pScript-&gt;chai-&gt;add(fun(&amp;<a class="code" href="class_o_t_smart_contract.html">OTSmartContract</a>::<a class="code" href="class_o_t_smart_contract.html#ab039e15191e3294e6a09eaa6f5be8923">SetRemainingTimer</a>,         this), &quot;set_seconds_until_timer&quot;);  <span class="comment">// void SetNextProcessTime(const std::string str_seconds_from_now) // if this is &lt;=0, then it sets next process date to 0.</span>
        pScript-&gt;chai-&gt;add(fun(&amp;<a class="code" href="class_o_t_smart_contract.html">OTSmartContract</a>::<a class="code" href="class_o_t_smart_contract.html#a71f505b723bbb56e75a46b9836c3949c">GetRemainingTimer</a>,         this), &quot;get_remaining_timer&quot;);  <span class="comment">// std::string GetRemainingTimer() const</span>

        pScript-&gt;chai-&gt;add(fun(&amp;<a class="code" href="class_o_t_smart_contract.html">OTSmartContract</a>::<a class="code" href="class_o_t_smart_contract.html#ac9ad18ccba9bb19d1ff2568d10386524">DeactivateSmartContract</a>,   this), &quot;deactivate_contract&quot;);  <span class="comment">// void DeactivateSmartContract();</span>
        <span class="comment">// ---------------------------------------------------------</span>
        <span class="comment">// CALLBACKS</span>
        <span class="comment">// (Called by OT at key moments) todo security: What if these are recursive? Need to lock down, put the smack down, on these smart contracts.</span>
        <span class="comment">//</span>
<span class="comment">//FYI:  pScript-&gt;chai-&gt;add(fun(&amp;(OTScriptable::CanExecuteClause),           (*this)), &quot;party_may_execute_clause&quot;);  // From OTScriptable (FYI) param_party_name and param_clause_name will be available inside script. Script must return bool.</span>
<span class="comment">//FYI:  #define SCRIPTABLE_CALLBACK_PARTY_MAY_EXECUTE   &quot;callback_party_may_execute_clause&quot;   &lt;=== THE CALLBACK WITH THIS NAME must be connected to a script clause, and then the clause will trigger when the callback is needed.</span>

        pScript-&gt;chai-&gt;add(fun(&amp;<a class="code" href="class_o_t_smart_contract.html">OTSmartContract</a>::<a class="code" href="class_o_t_smart_contract.html#a77a75cea50a6d4e8a2b199204dc8c7a6">CanCancelContract</a>,         this), &quot;party_may_cancel_contract&quot;); <span class="comment">// param_party_name will be available inside script. Script must return bool.</span>
<span class="comment">//FYI:  #define SMARTCONTRACT_CALLBACK_PARTY_MAY_CANCEL &quot;callback_party_may_cancel_contract&quot;  &lt;=== THE CALLBACK WITH THIS NAME must be connected to a script clause, and then the clause will trigger when the callback is needed.</span>

        <span class="comment">// Callback USAGE:  Your clause, in your smart contract, may have whatever name you want. (Within limits.)</span>
        <span class="comment">//                  There must be a callback entry in the smart contract, linking your clause the the appropriate callback.</span>
        <span class="comment">//                  The CALLBACK ENTRY uses the names &quot;callback_party_may_execute_clause&quot; and &quot;callback_party_may_cancel_contract&quot;.</span>
        <span class="comment">//                  If you want to call these from INSIDE YOUR SCRIPT, then use the names &quot;party_may_execute_clause&quot; and &quot;party_may_cancel_contract&quot;.</span>

        <span class="comment">// ---------------------------------------------------------</span>
        <span class="comment">// HOOKS:</span>
        <span class="comment">//</span>
        <span class="comment">// Hooks are not native calls needing to be registered with the script. (Like the above functions are.)</span>
        <span class="comment">// Rather, hooks are SCRIPT CLAUSES, that you have a CHOICE to provide inside your SMART CONTRACT.</span>
        <span class="comment">// *IF* you have provided those clauses, then OT *WILL* call them, at the appropriate times. (When</span>
        <span class="comment">// specific events occur.) Specifically, Hook entries must be in your smartcontract, linking the below</span>
        <span class="comment">// standard hooks to your clauses.</span>
        <span class="comment">//</span>
<span class="comment">//FYI:  #define SMARTCONTRACT_HOOK_ON_PROCESS       &quot;cron_process&quot;      // Called regularly in OTSmartContract::ProcessCron() based on SMART_CONTRACT_PROCESS_INTERVAL.</span>
<span class="comment">//FYI:  #define SMARTCONTRACT_HOOK_ON_ACTIVATE      &quot;cron_activate&quot;     // Done. This is called when the contract is first activated.</span>
    }
    <span class="comment">// *******************************************************************</span>
<span class="comment">//  else if (NULL != (pScript = dynamic_cast&lt;OTScriptSomeOtherScriptingLanguageSubClass_GOES_HERE *&gt; (&amp;theScript)) )</span>
<span class="comment">//  { }</span>
    <span class="comment">// *******************************************************************</span>
    else
<span class="preprocessor">#endif // OT_USE_SCRIPT_CHAI</span>
<span class="preprocessor"></span>    {
        <a class="code" href="class_o_t_log.html#a5acd90ac91c2618f395b0ff37ad4f8ee">OTLog::Error</a>(<span class="stringliteral">&quot;OTSmartContract::RegisterOTNativeCallsWithScript: Failed dynamic casting OTScript to OTScriptChai \n&quot;</span>);
    }
    <span class="comment">// *******************************************************************</span>
} <span class="comment">// void function</span>
</pre></div>
</div>
</div>
<a class="anchor" id="a335f903820d3128716c7f7b93200b5ac"></a><!-- doxytag: member="OTSmartContract::Release" ref="a335f903820d3128716c7f7b93200b5ac" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_o_t_smart_contract.html#a335f903820d3128716c7f7b93200b5ac">OTSmartContract::Release</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="class_o_t_cron_item.html#a11e9851acefc9162bb5f107a1952ffb7">OTCronItem</a>.</p>

<p>Definition at line <a class="el" href="_o_t_smart_contract_8cpp_source.html#l04805">4805</a> of file <a class="el" href="_o_t_smart_contract_8cpp_source.html">OTSmartContract.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
    <a class="code" href="class_o_t_smart_contract.html#a5673ded692d238c80fa6b854feaa68f4">Release_SmartContract</a>();
    <span class="comment">// -------------------------------------</span>
    <a class="code" href="class_o_t_cron_item.html#a11e9851acefc9162bb5f107a1952ffb7">ot_super::Release</a>(); <span class="comment">// since I&#39;ve overridden the base class, I call it now...</span>
    <span class="comment">// -------------------------------------</span>
    <span class="comment">// Then I call this to re-initialize everything</span>
    <a class="code" href="class_o_t_smart_contract.html#a6ce8a031a27a75a43275dde21919d0cd">InitSmartContract</a>();
}
</pre></div>
</div>
</div>
<a class="anchor" id="a5673ded692d238c80fa6b854feaa68f4"></a><!-- doxytag: member="OTSmartContract::Release_SmartContract" ref="a5673ded692d238c80fa6b854feaa68f4" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_o_t_smart_contract.html#a5673ded692d238c80fa6b854feaa68f4">OTSmartContract::Release_SmartContract</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_o_t_smart_contract_8cpp_source.html#l04795">4795</a> of file <a class="el" href="_o_t_smart_contract_8cpp_source.html">OTSmartContract.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">// -------------------------------------</span>

    <a class="code" href="class_o_t_smart_contract.html#a5e2972487aa71cb86d51393ed749f341">ReleaseStashes</a>();

    <span class="comment">// -------------------------------------</span>
}
</pre></div>
</div>
</div>
<a class="anchor" id="a09de789ac2e616e2119feb9ddf416c9d"></a><!-- doxytag: member="OTSmartContract::ReleaseLastSenderRecipientIDs" ref="a09de789ac2e616e2119feb9ddf416c9d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_o_t_smart_contract.html#a09de789ac2e616e2119feb9ddf416c9d">OTSmartContract::ReleaseLastSenderRecipientIDs</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_o_t_smart_contract_8cpp_source.html#l05299">5299</a> of file <a class="el" href="_o_t_smart_contract_8cpp_source.html">OTSmartContract.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
    m_strLastSenderUser.<a class="code" href="class_o_t_string.html#abef4b21b2170468705c58d64212d7257">Release</a>();      <span class="comment">// This is the last User ID of a party who SENT money.</span>
    m_strLastSenderAcct.<a class="code" href="class_o_t_string.html#abef4b21b2170468705c58d64212d7257">Release</a>();      <span class="comment">// This is the last Acct ID of a party who SENT money.</span>
    m_strLastRecipientUser.<a class="code" href="class_o_t_string.html#abef4b21b2170468705c58d64212d7257">Release</a>();   <span class="comment">// This is the last User ID of a party who RECEIVED money.</span>
    m_strLastRecipientAcct.<a class="code" href="class_o_t_string.html#abef4b21b2170468705c58d64212d7257">Release</a>();   <span class="comment">// This is the last Acct ID of a party who RECEIVED money.</span>
}
</pre></div>
</div>
</div>
<a class="anchor" id="a5e2972487aa71cb86d51393ed749f341"></a><!-- doxytag: member="OTSmartContract::ReleaseStashes" ref="a5e2972487aa71cb86d51393ed749f341" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_o_t_smart_contract.html#a5e2972487aa71cb86d51393ed749f341">OTSmartContract::ReleaseStashes</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_o_t_smart_contract_8cpp_source.html#l04776">4776</a> of file <a class="el" href="_o_t_smart_contract_8cpp_source.html">OTSmartContract.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">// -------------------------------------</span>
    <span class="keywordflow">while</span> (!m_mapStashes.empty())
    {
        <a class="code" href="class_o_t_stash.html">OTStash</a> * pStash = m_mapStashes.begin()-&gt;second;
        <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != pStash);

        <span class="keyword">delete</span> pStash;
        pStash = NULL;

        m_mapStashes.erase(m_mapStashes.begin());
    }
    <span class="comment">// -------------------------------------</span>
    m_StashAccts.<a class="code" href="class_o_t_acct_list.html#ac4946577265a5a735c27814be3fdfe30">Release</a>();
    <span class="comment">// -------------------------------------</span>
}
</pre></div>
</div>
</div>
<a class="anchor" id="aa39d672a40e0778c205ed308b86c6927"></a><!-- doxytag: member="OTSmartContract::SaveContractWallet" ref="aa39d672a40e0778c205ed308b86c6927" args="(std::ofstream &amp;ofs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_o_t_smart_contract.html#aa39d672a40e0778c205ed308b86c6927">OTSmartContract::SaveContractWallet</a> </td>
          <td>(</td>
          <td class="paramtype">std::ofstream &amp;&#160;</td>
          <td class="paramname"><em>ofs</em></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="class_o_t_trackable.html#a85b7622124dd3d103cb50498cddac2b2">OTTrackable</a>.</p>

<p>Definition at line <a class="el" href="_o_t_smart_contract_8cpp_source.html#l05504">5504</a> of file <a class="el" href="_o_t_smart_contract_8cpp_source.html">OTSmartContract.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordflow">return</span> <span class="keyword">true</span>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="acaa73a3c0357768583a129612d8ebb91"></a><!-- doxytag: member="OTSmartContract::SaveEditable" ref="acaa73a3c0357768583a129612d8ebb91" args="(const OTString &amp;strName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_o_t_smart_contract.html#acaa73a3c0357768583a129612d8ebb91">OTSmartContract::SaveEditable</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_t_string.html">OTString</a> &amp;&#160;</td>
          <td class="paramname"><em>strName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_o_t_smart_contract_8cpp_source.html#l05063">5063</a> of file <a class="el" href="_o_t_smart_contract_8cpp_source.html">OTSmartContract.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
    <a class="code" href="class_o_t_d_b_1_1_string_map.html">OTDB::StringMap</a> * pList = NULL;

    <span class="keywordflow">if</span> (!strName.<a class="code" href="class_o_t_string.html#adf7489cd917d4ae5bf30853a3ad78daf">Exists</a>())
    {
        <a class="code" href="class_o_t_log.html#a5acd90ac91c2618f395b0ff37ad4f8ee">OTLog::Error</a>(<span class="stringliteral">&quot;OTSmartContract::SaveEditable: Empty name passed in. (Returning false.)\n&quot;</span>);
        <span class="keywordflow">return</span> <span class="keyword">false</span>;
    }

    <span class="keyword">const</span> <a class="code" href="class_o_t_string.html">OTString</a> strServerID(<a class="code" href="class_o_t_instrument.html#a878dd8998f7b131b85c082575e255375">GetServerID</a>());
    <span class="comment">// --------------------------------------</span>
    <span class="keyword">const</span> <a class="code" href="class_o_t_a_s_c_i_i_armor.html">OTASCIIArmor</a> ascName(strName); <span class="comment">// Filename (base64-encoded)</span>

    <span class="keywordflow">if</span> (<a class="code" href="namespace_o_t_d_b.html#a73e39a590dfb64f63065821c6bbcd4c6">OTDB::Exists</a>(<a class="code" href="class_o_t_folders.html#a698b8fd86486783a1b21ec54e1d0867e">OTFolders::SmartContracts</a>().Get(),
                     strServerID.<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>(),
                     <span class="stringliteral">&quot;editing&quot;</span>,     <span class="comment">// todo hardcoding. The folder where smart contracts are edited.</span>
                     <span class="stringliteral">&quot;list.dat&quot;</span>))
        pList = <span class="keyword">dynamic_cast&lt;</span><a class="code" href="class_o_t_d_b_1_1_string_map.html">OTDB::StringMap</a> *<span class="keyword">&gt;</span>(<a class="code" href="namespace_o_t_d_b.html#aaf0caee055f843a828e3bac094321886">OTDB::QueryObject</a>(<a class="code" href="namespace_o_t_d_b.html#abce432e500285dde333e6f76f6fbde82acc03e85e0f615881a2abe9ca12628330">OTDB::STORED_OBJ_STRING_MAP</a>,
                                                                  <a class="code" href="class_o_t_folders.html#a698b8fd86486783a1b21ec54e1d0867e">OTFolders::SmartContracts</a>().Get(),
                                                                  strServerID.<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>(),
                                                                  <span class="stringliteral">&quot;editing&quot;</span>, <span class="comment">// todo stop hardcoding.</span>
                                                                  <span class="stringliteral">&quot;list.dat&quot;</span>));
    <span class="keywordflow">if</span> (NULL == pList)
    {
        <a class="code" href="class_o_t_log.html#a1f7549d776ee919dcb6517f611ded015">OTLog::Output</a>(2, <span class="stringliteral">&quot;OTSmartContract::SaveEditable: Creating storage list of editable smart contracts.\n&quot;</span>);
        pList = <span class="keyword">dynamic_cast&lt;</span><a class="code" href="class_o_t_d_b_1_1_string_map.html">OTDB::StringMap</a> *<span class="keyword">&gt;</span>(<a class="code" href="namespace_o_t_d_b.html#a67b35ca5812604fb3e1eae2b659f66ee">OTDB::CreateObject</a>(<a class="code" href="namespace_o_t_d_b.html#abce432e500285dde333e6f76f6fbde82acc03e85e0f615881a2abe9ca12628330">OTDB::STORED_OBJ_STRING_MAP</a>));
    }
    <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != pList);
    <a class="code" href="class_o_t_cleanup.html">OTCleanup&lt;OTDB::StringMap&gt;</a> theListAngel(*pList);

    <span class="keyword">const</span> std::string str_asc_name(ascName.Get()), str_name(strName.<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>()); <span class="comment">// encoded name and normal name.</span>

    pList-&gt;<a class="code" href="class_o_t_d_b_1_1_string_map.html#a62d93725398feb9c58fe618b8798485a">SetValue</a>(str_asc_name, str_name); <span class="comment">// Add the filename to the map of filenames.</span>

    <span class="keywordflow">if</span> (<span class="keyword">false</span> == <a class="code" href="namespace_o_t_d_b.html#a394420b02f48d3ebdfebb75d92a4d6dd">OTDB::StoreObject</a>(*pList,
                                    <a class="code" href="class_o_t_folders.html#a698b8fd86486783a1b21ec54e1d0867e">OTFolders::SmartContracts</a>().Get(),
                                    strServerID.<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>(),
                                    <span class="stringliteral">&quot;editing&quot;</span>, <span class="comment">// todo stop hardcoding.</span>
                                    <span class="stringliteral">&quot;list.dat&quot;</span>))
    {
        <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;OTSmartContract::SaveEditable: Failed saving %s%s%s%s%s%s%s\n&quot;</span>,
                      <a class="code" href="class_o_t_folders.html#a698b8fd86486783a1b21ec54e1d0867e">OTFolders::SmartContracts</a>().Get(), <a class="code" href="class_o_t_log.html#a42d3c91ff84ecae0690e34efb4619a77">OTLog::PathSeparator</a>(),
                      strServerID.Get(), <a class="code" href="class_o_t_log.html#a42d3c91ff84ecae0690e34efb4619a77">OTLog::PathSeparator</a>(), <span class="stringliteral">&quot;editing&quot;</span>,
                      <a class="code" href="class_o_t_log.html#a42d3c91ff84ecae0690e34efb4619a77">OTLog::PathSeparator</a>(), <span class="stringliteral">&quot;list.dat&quot;</span>);
    }
    <span class="keywordflow">else</span>    <span class="comment">// We saved the list of filenames -- now save the contract itself.</span>
    {
        <span class="keywordflow">if</span> (<a class="code" href="class_o_t_contract.html#a90c53743214bc0f0025ad63c3ace7bf2">m_strRawFile</a>.<a class="code" href="class_o_t_string.html#adf7489cd917d4ae5bf30853a3ad78daf">Exists</a>())
        {
            <a class="code" href="class_o_t_string.html">OTString</a> strFinal;
            <a class="code" href="class_o_t_a_s_c_i_i_armor.html">OTASCIIArmor</a> ascTemp(<a class="code" href="class_o_t_contract.html#a90c53743214bc0f0025ad63c3ace7bf2">m_strRawFile</a>);

            <span class="keywordflow">if</span> (<span class="keyword">false</span> == ascTemp.WriteArmoredString(strFinal, <a class="code" href="class_o_t_contract.html#ac523dac7d72b72e54b1ebb5b3a3b21cc">m_strContractType</a>.<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>()))
            {
                <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;OTSmartContract::SaveEditable: Error saving editable smart contract (failed writing armored string):\n%s%s%s%s%s%s%s\n&quot;</span>,
                              <a class="code" href="class_o_t_folders.html#a698b8fd86486783a1b21ec54e1d0867e">OTFolders::SmartContracts</a>().Get(), <a class="code" href="class_o_t_log.html#a42d3c91ff84ecae0690e34efb4619a77">OTLog::PathSeparator</a>(),
                              strServerID.Get(), <a class="code" href="class_o_t_log.html#a42d3c91ff84ecae0690e34efb4619a77">OTLog::PathSeparator</a>(), <span class="stringliteral">&quot;editing&quot;</span>,
                              <a class="code" href="class_o_t_log.html#a42d3c91ff84ecae0690e34efb4619a77">OTLog::PathSeparator</a>(), str_asc_name.c_str());
                <span class="keywordflow">return</span> <span class="keyword">false</span>;
            }
            <span class="comment">// ----------------------------------------------------</span>
            <span class="keywordflow">if</span>  (<span class="keyword">false</span> == <a class="code" href="namespace_o_t_d_b.html#a7ec0a905bba2c1c8ba5b1e873e12eab4">OTDB::StorePlainString</a>(strFinal.<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>(),
                                                 <a class="code" href="class_o_t_folders.html#a698b8fd86486783a1b21ec54e1d0867e">OTFolders::SmartContracts</a>().<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>(),
                                                 strServerID.Get(),
                                                 <span class="stringliteral">&quot;editing&quot;</span>, <span class="comment">// todo stop hardcoding.</span>
                                                 str_asc_name)) <span class="comment">// encoded version of name.</span>
            {
                <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;OTSmartContract::SaveEditable: Failed saving (editable) smart contract: %s \n to path: %s%s%s%s%s%s%s&quot;</span>,
                              str_name.c_str(), <a class="code" href="class_o_t_folders.html#a698b8fd86486783a1b21ec54e1d0867e">OTFolders::SmartContracts</a>().<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>(), <a class="code" href="class_o_t_log.html#a42d3c91ff84ecae0690e34efb4619a77">OTLog::PathSeparator</a>(),
                              strServerID.Get(), <a class="code" href="class_o_t_log.html#a42d3c91ff84ecae0690e34efb4619a77">OTLog::PathSeparator</a>(), <span class="stringliteral">&quot;editing&quot;</span>,
                              <a class="code" href="class_o_t_log.html#a42d3c91ff84ecae0690e34efb4619a77">OTLog::PathSeparator</a>(), str_asc_name.c_str());
            }
            <span class="keywordflow">else</span>
            {
                <span class="keywordflow">return</span> <span class="keyword">true</span>;
            }
        }
        <span class="keywordflow">else</span>
        {
            <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;OTSmartContract::SaveEditable: Failed attempt to save empty (unsigned?), editable, smart contract: %s \n&quot;</span>,
                          str_name.c_str());
        }
    }

    <span class="keywordflow">return</span> <span class="keyword">false</span>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a61617c4df9db720a7b7167f9b92bd750"></a><!-- doxytag: member="OTSmartContract::SaveTemplate" ref="a61617c4df9db720a7b7167f9b92bd750" args="(const OTIdentifier &amp;SERVER_ID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_o_t_smart_contract.html#a61617c4df9db720a7b7167f9b92bd750">OTSmartContract::SaveTemplate</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_t_identifier.html">OTIdentifier</a> &amp;&#160;</td>
          <td class="paramname"><em>SERVER_ID</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_o_t_smart_contract_8cpp_source.html#l05240">5240</a> of file <a class="el" href="_o_t_smart_contract_8cpp_source.html">OTSmartContract.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordflow">if</span> (!<a class="code" href="class_o_t_contract.html#ab1e11693a38a1673037b1f29c9d84010">m_strFoldername</a>.<a class="code" href="class_o_t_string.html#adf7489cd917d4ae5bf30853a3ad78daf">Exists</a>())
        <a class="code" href="class_o_t_contract.html#ab1e11693a38a1673037b1f29c9d84010">m_strFoldername</a>.<a class="code" href="class_o_t_string.html#aa5db620fe8e60c849585d741975db991">Set</a>(<a class="code" href="class_o_t_folders.html#a698b8fd86486783a1b21ec54e1d0867e">OTFolders::SmartContracts</a>().<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>());

    <a class="code" href="class_o_t_identifier.html">OTIdentifier</a> theContractID;
    <a class="code" href="class_o_t_scriptable.html#ac1c6d838f350141b461420004bb8834b">CalculateContractID</a>(theContractID);

    <span class="keyword">const</span> <a class="code" href="class_o_t_string.html">OTString</a> strServerID(SERVER_ID), strContractID(theContractID);

    <span class="keywordflow">if</span> (!<a class="code" href="class_o_t_contract.html#ab7ab1f1fe7ff7e52f2c126404a8f4f92">m_strFilename</a>.<a class="code" href="class_o_t_string.html#adf7489cd917d4ae5bf30853a3ad78daf">Exists</a>())
    {
        <a class="code" href="class_o_t_contract.html#ab7ab1f1fe7ff7e52f2c126404a8f4f92">m_strFilename</a>.<a class="code" href="class_o_t_string.html#af1c861f21033a1d583b3cb12f952422e">Format</a>(<span class="stringliteral">&quot;%s%s%s&quot;</span>, strServerID.Get(), <a class="code" href="class_o_t_log.html#a42d3c91ff84ecae0690e34efb4619a77">OTLog::PathSeparator</a>(), strContractID.Get());
    }

    <span class="keyword">const</span> <span class="keywordtype">char</span> * szFolder1name  = <a class="code" href="class_o_t_folders.html#a698b8fd86486783a1b21ec54e1d0867e">OTFolders::SmartContracts</a>().<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>();
    <span class="keyword">const</span> <span class="keywordtype">char</span> * szFolder2name  = strServerID.Get();
    <span class="keyword">const</span> <span class="keywordtype">char</span> * szFilename     = strContractID.Get();

    <span class="comment">// --------------------------------------------------------------------</span>

    <a class="code" href="class_o_t_string.html">OTString</a> strRawFile;

    <span class="keywordflow">if</span> (!<a class="code" href="class_o_t_contract.html#a5fd00cded794a6f96ba80d8d4081d591">SaveContractRaw</a>(strRawFile))
    {
        <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;OTSmartContract::SaveTemplate: Error saving smart contract template (to string):\n%s%s%s%s%s\n&quot;</span>,
                      szFolder1name, <a class="code" href="class_o_t_log.html#a42d3c91ff84ecae0690e34efb4619a77">OTLog::PathSeparator</a>(), szFolder2name, <a class="code" href="class_o_t_log.html#a42d3c91ff84ecae0690e34efb4619a77">OTLog::PathSeparator</a>(), szFilename);
        <span class="keywordflow">return</span> <span class="keyword">false</span>;
    }
    <span class="comment">// --------------------------------------------------------------------</span>
    <span class="comment">//</span>
    <a class="code" href="class_o_t_string.html">OTString</a> strFinal;
    <a class="code" href="class_o_t_a_s_c_i_i_armor.html">OTASCIIArmor</a> ascTemp(strRawFile);

    <span class="keywordflow">if</span> (<span class="keyword">false</span> == ascTemp.WriteArmoredString(strFinal, <a class="code" href="class_o_t_contract.html#ac523dac7d72b72e54b1ebb5b3a3b21cc">m_strContractType</a>.<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>()))
    {
        <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;OTSmartContract::SaveTemplate: Error saving smart contract template (failed writing armored string):\n%s%s%s%s%s\n&quot;</span>,
                      szFolder1name, <a class="code" href="class_o_t_log.html#a42d3c91ff84ecae0690e34efb4619a77">OTLog::PathSeparator</a>(), szFolder2name, <a class="code" href="class_o_t_log.html#a42d3c91ff84ecae0690e34efb4619a77">OTLog::PathSeparator</a>(), szFilename);
        <span class="keywordflow">return</span> <span class="keyword">false</span>;
    }
    <span class="comment">// --------------------------------------------------------------------</span>
    <span class="comment">//</span>
    <span class="keywordtype">bool</span> bSaved = <a class="code" href="namespace_o_t_d_b.html#a7ec0a905bba2c1c8ba5b1e873e12eab4">OTDB::StorePlainString</a>(strFinal.<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>(), szFolder1name,
                                         szFolder2name, szFilename); <span class="comment">// &lt;=== SAVING TO DATA STORE.</span>

    <span class="keywordflow">if</span> (!bSaved)
    {
        <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;OTSmartContract::SaveTemplate: Error writing to file: %s%s%s%s%s\n&quot;</span>, szFolder1name,
                      <a class="code" href="class_o_t_log.html#a42d3c91ff84ecae0690e34efb4619a77">OTLog::PathSeparator</a>(), szFolder2name, <a class="code" href="class_o_t_log.html#a42d3c91ff84ecae0690e34efb4619a77">OTLog::PathSeparator</a>(), szFilename);

        <span class="keywordflow">return</span> <span class="keyword">false</span>;
    }
    <span class="comment">// --------------------------------------------------------------------</span>

    <span class="keywordflow">return</span> <span class="keyword">true</span>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a63aa006565fab757f33d28215b1f5e0c"></a><!-- doxytag: member="OTSmartContract::SendANoticeToAllParties" ref="a63aa006565fab757f33d28215b1f5e0c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_o_t_smart_contract.html#a63aa006565fab757f33d28215b1f5e0c">OTSmartContract::SendANoticeToAllParties</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_o_t_smart_contract_8cpp_source.html#l01443">1443</a> of file <a class="el" href="_o_t_smart_contract_8cpp_source.html">OTSmartContract.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
    <a class="code" href="class_o_t_cron.html">OTCron</a> * pCron  = <a class="code" href="class_o_t_cron_item.html#af734ad5d309fcc9b4a60d40d6c30f55a">GetCron</a>();
    <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != pCron);
    <span class="comment">// ----------------------------------</span>
    <a class="code" href="class_o_t_pseudonym.html">OTPseudonym</a> * pServerNym = pCron-&gt;<a class="code" href="class_o_t_cron.html#a7756d0dcc047209ca87632939dc11db3">GetServerNym</a>();
    <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != pServerNym);
    <span class="comment">// ---------------------------------------------------</span>
    <span class="comment">// Below this point, these are all good:</span>
    <span class="comment">//</span>
    <span class="comment">//      pServerNym, pCron.</span>
    <span class="comment">//</span>
    <span class="comment">// ---------------------------------------------------</span>
    <span class="keyword">const</span> int64_t lNewTransactionNumber = pCron-&gt;<a class="code" href="class_o_t_cron.html#a22822e0aeced441b6404cd8a2c8e00da">GetNextTransactionNumber</a>();
    <span class="keywordtype">bool</span> bDroppedNotice = <span class="keyword">false</span>;

<span class="comment">//  OT_ASSERT(lNewTransactionNumber &gt; 0); // this can be my reminder.</span>
    <span class="keywordflow">if</span> (0 == lNewTransactionNumber)
    {
        <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;%s: ** ERROR: Notice not sent to parties, since no transaction numbers were available!\n&quot;</span>);
    }
    <span class="keywordflow">else</span>
    {
        this-&gt;<a class="code" href="class_o_t_contract.html#aae54340526fbd8eb8a18de27a4b97c83">ReleaseSignatures</a>();
        this-&gt;<a class="code" href="class_o_t_contract.html#abd60037fe655ee8cae9a3ece5d1e2ea6">SignContract</a>(*pServerNym);
        this-&gt;<a class="code" href="class_o_t_contract.html#a363ae430d4fd9256ab8364dbafb95444">SaveContract</a>();

        <span class="keyword">const</span> <a class="code" href="class_o_t_string.html">OTString</a> strReference(*<span class="keyword">this</span>);
        bDroppedNotice = this-&gt;<a class="code" href="class_o_t_scriptable.html#a03d724ec348f2dc140c9ed45d6133429">SendNoticeToAllParties</a>(<span class="keyword">true</span>, <span class="comment">// bSuccessMsg=true</span>
                                                      *pServerNym, <a class="code" href="class_o_t_instrument.html#a878dd8998f7b131b85c082575e255375">GetServerID</a>(), lNewTransactionNumber,
                                                      <span class="comment">//GetTransactionNum(), // each party has its own opening number.</span>
                                                      strReference); <span class="comment">// pstrNote and pstrAttachment aren&#39;t used in this case.</span>

        <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(0, <span class="stringliteral">&quot;%s: Dropping notifications into all parties&#39; nymboxes: %s\n&quot;</span>,
                       __FUNCTION__, bDroppedNotice ? <span class="stringliteral">&quot;Success&quot;</span> : <span class="stringliteral">&quot;Failure&quot;</span>);
    }
    <span class="comment">// ---------------------------------------------------</span>

    <span class="keywordflow">return</span> bDroppedNotice;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a72762c0413197f084b36e2d0fce59e4f"></a><!-- doxytag: member="OTSmartContract::SendNoticeToParty" ref="a72762c0413197f084b36e2d0fce59e4f" args="(const std::string party_name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_o_t_smart_contract.html#a72762c0413197f084b36e2d0fce59e4f">OTSmartContract::SendNoticeToParty</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>party_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_o_t_smart_contract_8cpp_source.html#l01488">1488</a> of file <a class="el" href="_o_t_smart_contract_8cpp_source.html">OTSmartContract.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
    <a class="code" href="class_o_t_cron.html">OTCron</a> * pCron  = <a class="code" href="class_o_t_cron_item.html#af734ad5d309fcc9b4a60d40d6c30f55a">GetCron</a>();
    <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != pCron);
    <span class="comment">// ----------------------------------</span>
    <a class="code" href="class_o_t_pseudonym.html">OTPseudonym</a> * pServerNym = pCron-&gt;<a class="code" href="class_o_t_cron.html#a7756d0dcc047209ca87632939dc11db3">GetServerNym</a>();
    <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != pServerNym);
    <span class="comment">// ---------------------------------------------------</span>
    <span class="comment">// Below this point, these are all good:</span>
    <span class="comment">//</span>
    <span class="comment">//      pServerNym, pCron.</span>
    <span class="comment">//</span>
    <span class="comment">// ---------------------------------------------------</span>
    <a class="code" href="class_o_t_party.html">OTParty</a> * pParty = this-&gt;<a class="code" href="class_o_t_scriptable.html#acd0f8e884ed00f1d082fa498323d8894">GetParty</a>(party_name);

    <span class="keywordflow">if</span> (NULL == pParty)
    {
        <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(0, <span class="stringliteral">&quot;%s: Unable to find this party: %s\n&quot;</span>,
                       __FUNCTION__, party_name.c_str());
        <span class="keywordflow">return</span> <span class="keyword">false</span>;
    }
    <span class="comment">// Below this point, pParty is good.</span>
    <span class="comment">// ------------------------------------------------</span>

    <span class="comment">// ...This WILL check to see if pParty has its Opening number verified as issued.</span>
    <span class="comment">// (If the opening number is &gt; 0 then VerifyPartyAuthorization() is smart enough to verify it.)</span>
    <span class="comment">//</span>
    <span class="comment">// To KNOW that a party has the right to even ASK the script to cancel a contract, MEANS that</span>
    <span class="comment">// (1) The party is listed as a party on the contract. (2) The party&#39;s copy of that contract</span>
    <span class="comment">// is signed by the authorizing agent for that party. and (3) The opening transaction number for</span>
    <span class="comment">// that party is verified as issued for authorizing agent. (2 and 3 are both performed at the same</span>
    <span class="comment">// time, in VerifyPartyAuthorization(), since the agent may need to be loaded in order to verify</span>
    <span class="comment">// them.) 1 is already done by this point, as it&#39;s performed above.</span>
    <span class="comment">//</span>
    <span class="comment">// Done: notice this code appears in CanCancelContract() (this function) as well as</span>
    <span class="comment">// OTScriptable::CanExecuteClause.</span>
    <span class="comment">// Therefore I can see that THIS VERIFICATION CODE WILL GET CALLED EVERY SINGLE TIME THE SCRIPT</span>
    <span class="comment">// CALLS ANY CLAUSE OR OT NATIVE FUNCTION.  Since technically this only needs to be verified before the</span>
    <span class="comment">// first call, and not for EVERY call during any of a script&#39;s runs, I should probably move this verification</span>
    <span class="comment">// higher, such as each time the OTCronItem triggers, plus each time a party triggers a clause directly</span>
    <span class="comment">// through the API (server message). As long as those are covered, I will be able to remove it from here</span>
    <span class="comment">// which should be a significant improvement for performance.</span>
    <span class="comment">// It will be at the bottom of those same functions that &quot;ClearTemporaryPointers()&quot; should finally be called.</span>
    <span class="comment">//</span>
    <span class="comment">// Also todo:  Need to implement MOVE CONSTRUCTORS and MOVE COPY CONSTRUCTORS all over the place,</span>
    <span class="comment">// once I&#39;m sure C++0x build environments are available for all of the various OT platforms. That should</span>
    <span class="comment">// be another great performance boost!</span>
    <span class="comment">//</span>
    <span class="comment">//  FINAL DECISION: See longer comment in OTSmartContract::StashAcctFunds(). This is redundant and was</span>
    <span class="comment">//  removed. It expects itself to be executed only upon the initial activation of a smart contract, and</span>
    <span class="comment">//  not again after. (For example, it disallows stashes, which cannot exist prior to activation.)</span>
    <span class="comment">//</span>
<span class="comment">//  const OTString strServerID(GetServerID());</span>
<span class="comment">//</span>
<span class="comment">//  mapOfNyms   map_Nyms_Already_Loaded;</span>
<span class="comment">//  this-&gt;RetrieveNymPointers(map_Nyms_Already_Loaded);</span>
<span class="comment">//</span>
<span class="comment">//  bool bVerifiedAuthorization =</span>
<span class="comment">//      this-&gt;VerifyPartyAuthorization(*pParty, *pServerNym, strServerID, &amp;map_Nyms_Already_Loaded);</span>
<span class="comment">//</span>
<span class="comment">//  if (!bVerifiedAuthorization)</span>
<span class="comment">//  {</span>
<span class="comment">//      OTLog::vOutput(0, &quot;OTSmartContract::SendNoticeToParty: Unable to verify this party: %s\n&quot;,</span>
<span class="comment">//                     party_name.c_str());</span>
<span class="comment">//      return false;</span>
<span class="comment">//  }</span>

    <span class="comment">// *****************************************************************************</span>

            <span class="keywordtype">bool</span> bDroppedNotice         = <span class="keyword">false</span>;
    <span class="keyword">const</span>   int64_t lNewTransactionNumber   = pCron-&gt;<a class="code" href="class_o_t_cron.html#a22822e0aeced441b6404cd8a2c8e00da">GetNextTransactionNumber</a>();

<span class="comment">//  OT_ASSERT(lNewTransactionNumber &gt; 0); // this can be my reminder.</span>
    <span class="keywordflow">if</span> (0 == lNewTransactionNumber)
    {
        <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;%s: ** ERROR: Notice not sent to party, since no transaction numbers were available!\n&quot;</span>,
                      __FUNCTION__);
    }
    <span class="keywordflow">else</span>
    {
        this-&gt;<a class="code" href="class_o_t_contract.html#aae54340526fbd8eb8a18de27a4b97c83">ReleaseSignatures</a>();
        this-&gt;<a class="code" href="class_o_t_contract.html#abd60037fe655ee8cae9a3ece5d1e2ea6">SignContract</a>(*pServerNym);
        this-&gt;<a class="code" href="class_o_t_contract.html#a363ae430d4fd9256ab8364dbafb95444">SaveContract</a>();

        <span class="keyword">const</span> <a class="code" href="class_o_t_string.html">OTString</a> strReference(*<span class="keyword">this</span>);

        bDroppedNotice = pParty-&gt;<a class="code" href="class_o_t_party.html#a7419b9a17e72819156005dd976b2dd1e">SendNoticeToParty</a>(<span class="keyword">true</span>, <span class="comment">//bSuccessMsg=true. True in general means &quot;success&quot; and false means &quot;failure.&quot;</span>
                                                   *pServerNym, <a class="code" href="class_o_t_instrument.html#a878dd8998f7b131b85c082575e255375">GetServerID</a>(), lNewTransactionNumber,
                                                   <span class="comment">//GetTransactionNum(), // each party has its own opening trans # and supplies it internally.</span>
                                                   strReference);

        <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(0, <span class="stringliteral">&quot;%s: %s dropping notification into party&#39;s nymbox: %s\n&quot;</span>, __FUNCTION__,
                       bDroppedNotice ? <span class="stringliteral">&quot;Success&quot;</span> : <span class="stringliteral">&quot;Failure&quot;</span>, pParty-&gt;<a class="code" href="class_o_t_party.html#ad823a9d89b3d8d0d87bc85114eefcead">GetPartyName</a>().c_str());
    }
    <span class="comment">// ---------------------------------------------------</span>

    <span class="keywordflow">return</span> bDroppedNotice;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a0724be6ceeab338be3d9ea1469e82114"></a><!-- doxytag: member="OTSmartContract::SetDisplayLabel" ref="a0724be6ceeab338be3d9ea1469e82114" args="(const std::string *pstrLabel=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_o_t_smart_contract.html#a0724be6ceeab338be3d9ea1469e82114">OTSmartContract::SetDisplayLabel</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string *&#160;</td>
          <td class="paramname"><em>pstrLabel</em> = <code>NULL</code></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="class_o_t_scriptable.html#a7590c450a8a079eb388fd4fc378b3b40">OTScriptable</a>.</p>

<p>Definition at line <a class="el" href="_o_t_smart_contract_8cpp_source.html#l03416">3416</a> of file <a class="el" href="_o_t_smart_contract_8cpp_source.html">OTSmartContract.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
    <a class="code" href="class_o_t_scriptable.html#a9e1d9c7e46bab582ea1922026a21b357">m_strLabel</a>.<a class="code" href="class_o_t_string.html#af1c861f21033a1d583b3cb12f952422e">Format</a>(<span class="stringliteral">&quot;smartcontract trans# %lld, clause: %s&quot;</span>,
                              <a class="code" href="class_o_t_trackable.html#a2594d320e3b24f3210bd38a08de66a70">GetTransactionNum</a>(),
                              (NULL != pstrLabel) ? pstrLabel-&gt;c_str() : <span class="stringliteral">&quot;&quot;</span>);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a0c0ffa47dacaa8fa79304317f8e04544"></a><!-- doxytag: member="OTSmartContract::SetNextProcessDate" ref="a0c0ffa47dacaa8fa79304317f8e04544" args="(const time64_t &amp;tNEXT_DATE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_o_t_smart_contract.html#a0c0ffa47dacaa8fa79304317f8e04544">OTSmartContract::SetNextProcessDate</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_o_t_common_8hpp.html#ad28ff0a3eda18840f6bda5872819167f">time64_t</a> &amp;&#160;</td>
          <td class="paramname"><em>tNEXT_DATE</em></td><td>)</td>
          <td><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_o_t_smart_contract_8hpp_source.html#l00219">219</a> of file <a class="el" href="_o_t_smart_contract_8hpp_source.html">OTSmartContract.hpp</a>.</p>
<div class="fragment"><pre class="fragment">{ m_tNextProcessDate = tNEXT_DATE; }
</pre></div>
</div>
</div>
<a class="anchor" id="ab039e15191e3294e6a09eaa6f5be8923"></a><!-- doxytag: member="OTSmartContract::SetRemainingTimer" ref="ab039e15191e3294e6a09eaa6f5be8923" args="(const std::string str_seconds_from_now)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_o_t_smart_contract.html#ab039e15191e3294e6a09eaa6f5be8923">OTSmartContract::SetRemainingTimer</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>str_seconds_from_now</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_o_t_smart_contract_8cpp_source.html#l00893">893</a> of file <a class="el" href="_o_t_smart_contract_8cpp_source.html">OTSmartContract.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordflow">if</span> (str_seconds_from_now.size() &lt;= 0) <span class="comment">// string length...</span>
    {
        <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(0, <span class="stringliteral">&quot;OTSmartContract::%s: blank input (str_seconds_from_now).\n&quot;</span>,
                       __FUNCTION__);
    }
    <span class="keywordflow">else</span>
    {
        <span class="keyword">const</span> int64_t tPlus = <a class="code" href="class_o_t_string.html#a3f2489a8c996db1df14479d36af3b76b">OTString::StringToLong</a>(str_seconds_from_now);

        <span class="keywordflow">if</span> (tPlus &gt; 0)
            <a class="code" href="class_o_t_smart_contract.html#a0c0ffa47dacaa8fa79304317f8e04544">SetNextProcessDate</a>(<a class="code" href="_o_t_common_8hpp.html#a38e4e4253c3dd158ea40e6312586e6c9">OTTimeAddTimeInterval</a>(<a class="code" href="_o_t_common_8hpp.html#a1163606b2546b160d50c5f0a5afe479a">OTTimeGetCurrentTime</a>(), tPlus));
        <span class="keywordflow">else</span>
            <a class="code" href="class_o_t_smart_contract.html#a0c0ffa47dacaa8fa79304317f8e04544">SetNextProcessDate</a>(<a class="code" href="_o_t_common_8hpp.html#af4ca9fa2c7c290d647dd18de0a9ac25f">OT_TIME_ZERO</a>); <span class="comment">// This way, you can deactivate the timer, by setting the next process date to 0.</span>
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="aa4d0e2f242f874a9a594a31d8af26533"></a><!-- doxytag: member="OTSmartContract::SetServerIDIfEmpty" ref="aa4d0e2f242f874a9a594a31d8af26533" args="(const OTIdentifier &amp;theID)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_o_t_smart_contract.html#aa4d0e2f242f874a9a594a31d8af26533">OTSmartContract::SetServerIDIfEmpty</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_t_identifier.html">OTIdentifier</a> &amp;&#160;</td>
          <td class="paramname"><em>theID</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_o_t_smart_contract_8cpp_source.html#l00794">794</a> of file <a class="el" href="_o_t_smart_contract_8cpp_source.html">OTSmartContract.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="keywordflow">if</span> (this-&gt;<a class="code" href="class_o_t_instrument.html#a878dd8998f7b131b85c082575e255375">GetServerID</a>().IsEmpty())
    {
        this-&gt;<a class="code" href="class_o_t_instrument.html#a80fc5560fdedf911ec0c184ab9fbb5b7">SetServerID</a>(theID);
        <span class="keywordflow">return</span> <span class="keyword">true</span>;
    }
    <span class="keywordflow">return</span> <span class="keyword">false</span>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a7d4c35453914e75a252a1f4eac3ce855"></a><!-- doxytag: member="OTSmartContract::StashAcctFunds" ref="a7d4c35453914e75a252a1f4eac3ce855" args="(const std::string from_acct_name, const std::string to_stash_name, const std::string str_Amount)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_o_t_smart_contract.html#a7d4c35453914e75a252a1f4eac3ce855">OTSmartContract::StashAcctFunds</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>from_acct_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>to_stash_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>str_Amount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_o_t_smart_contract_8cpp_source.html#l01600">1600</a> of file <a class="el" href="_o_t_smart_contract_8cpp_source.html">OTSmartContract.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
    <a class="code" href="class_o_t_cron.html">OTCron</a> * pCron  = <a class="code" href="class_o_t_cron_item.html#af734ad5d309fcc9b4a60d40d6c30f55a">GetCron</a>();
    <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != pCron);
    <span class="comment">// ----------------------------------</span>
    <a class="code" href="class_o_t_pseudonym.html">OTPseudonym</a> * pServerNym = pCron-&gt;<a class="code" href="class_o_t_cron.html#a7756d0dcc047209ca87632939dc11db3">GetServerNym</a>();
    <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != pServerNym);
    <span class="comment">// ---------------------------------------------------</span>
    <span class="comment">// Below this point, these are all good:</span>
    <span class="comment">//</span>
    <span class="comment">//      pServerNym, pCron.</span>
    <span class="comment">//</span>
    <span class="comment">// ---------------------------------------------------</span>
    <span class="keywordflow">if</span> (str_Amount.size() &lt; 1)
    {
        <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(0, <span class="stringliteral">&quot;OTSmartContract::StashAcctFunds: Error: empty amount.\n&quot;</span>);
        <span class="keywordflow">return</span> <span class="keyword">false</span>;
    }

    <span class="keyword">const</span> int64_t lAmount =  atol(str_Amount.c_str());

    <span class="keywordflow">if</span> (lAmount &lt;= 0)
    {
        <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(0, <span class="stringliteral">&quot;OTSmartContract::StashAcctFunds: Error: lAmount cannot be 0 or &lt;0. (Value passed in was %lld.)\n&quot;</span>,
                       lAmount);
        <span class="keywordflow">return</span> <span class="keyword">false</span>;
    }
    <span class="comment">// -----------------------------</span>
    <span class="keywordflow">if</span> (from_acct_name.size() &lt;= 0)
    {
        <a class="code" href="class_o_t_log.html#a5acd90ac91c2618f395b0ff37ad4f8ee">OTLog::Error</a>(<span class="stringliteral">&quot;OTSmartContract::StashAcctFunds: error: from_acct_name is non-existent.\n&quot;</span>);
        <span class="keywordflow">return</span> <span class="keyword">false</span>;
    }
    <span class="keywordflow">if</span> (to_stash_name.size() &lt;= 0)
    {
        <a class="code" href="class_o_t_log.html#a5acd90ac91c2618f395b0ff37ad4f8ee">OTLog::Error</a>(<span class="stringliteral">&quot;OTSmartContract::StashAcctFunds: error: to_stash_name is non-existent.\n&quot;</span>);
        <span class="keywordflow">return</span> <span class="keyword">false</span>;
    }
    <span class="comment">// ---------------------------------------------------</span>
    <span class="comment">// Below this point, these are all good:</span>
    <span class="comment">//</span>
    <span class="comment">//      from_acct_name,</span>
    <span class="comment">//      to_stash_name,</span>
    <span class="comment">//      pServerNym, pCron.</span>
    <span class="comment">//</span>
    <span class="comment">// ---------------------------------------------------</span>

    <a class="code" href="class_o_t_party_account.html">OTPartyAccount</a>  * pFromAcct = this-&gt;<a class="code" href="class_o_t_scriptable.html#a94c9e55f78357e04e4b9781ab662370f">GetPartyAccount</a>(from_acct_name);
    <a class="code" href="class_o_t_stash.html">OTStash</a>         * pStash    = this-&gt;<a class="code" href="class_o_t_smart_contract.html#af7305d13e0ac4c2bef284658bdd9ec67">GetStash</a>(to_stash_name); <span class="comment">// This ALWAYS succeeds. (It will OT_ASSERT() if failure.)</span>

    <span class="keywordflow">if</span> (NULL == pFromAcct)
    {
        <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(0, <span class="stringliteral">&quot;OTSmartContract::StashAcctFunds: error: from_acct (%s) not found on any party.\n&quot;</span>,
                       from_acct_name.c_str());
        <span class="keywordflow">return</span> <span class="keyword">false</span>;
    }
    <span class="comment">// ---------------------------------------------------</span>
    <span class="comment">//</span>
    <span class="comment">// Below this point, these are all good:</span>
    <span class="comment">//</span>
    <span class="comment">//      pFromAcct,  from_acct_name,</span>
    <span class="comment">//      pStash,     to_stash_name,</span>
    <span class="comment">//      pServerNym, pCron.</span>
    <span class="comment">//</span>
    <span class="comment">// ---------------------------------------------------</span>

    <a class="code" href="class_o_t_agent.html">OTAgent</a> * pFromAgent    = pFromAcct-&gt;   GetAuthorizedAgent(); <span class="comment">// This searches the account&#39;s party for the account&#39;s authorized agent.</span>
    <span class="comment">// (That way it&#39;s impossible to get an agent for any other party.)</span>

    <span class="keywordflow">if</span> (NULL == pFromAgent)
    {
        <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(0, <span class="stringliteral">&quot;OTSmartContract::StashAcctFunds: error: authorized agent (%s) not found for from_acct (%s) on acct&#39;s party.\n&quot;</span>,
                       pFromAcct-&gt;<a class="code" href="class_o_t_party_account.html#a86975046b18ac6d6c5841f5ba0befe69">GetAgentName</a>().<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>(), from_acct_name.c_str());
        <span class="keywordflow">return</span> <span class="keyword">false</span>;
    }
    <span class="comment">// ---------</span>
    <span class="keywordflow">if</span> (<span class="keyword">false</span> == pFromAgent-&gt;<a class="code" href="class_o_t_agent.html#a1969e4f8a5f13ee34ba0a68d8f082956">IsAnIndividual</a>())
    {
        <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(0, <span class="stringliteral">&quot;OTSmartContract::StashAcctFunds: error: authorized agent (%s) for from_acct (%s) is not an active agent.\n&quot;</span>,
                       pFromAcct-&gt;<a class="code" href="class_o_t_party_account.html#a86975046b18ac6d6c5841f5ba0befe69">GetAgentName</a>().<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>(), from_acct_name.c_str());
        <span class="keywordflow">return</span> <span class="keyword">false</span>;
    }
    <span class="comment">//</span>
    <span class="comment">// Below this point, these are all good:</span>
    <span class="comment">//</span>
    <span class="comment">//      pFromAcct,  from_acct_name, pFromAgent,</span>
    <span class="comment">//      pStash,     to_stash_name,</span>
    <span class="comment">//      pServerNym, pCron.</span>
    <span class="comment">//</span>
    <span class="comment">// ---------------------------------------------------</span>

    <a class="code" href="class_o_t_party.html">OTParty</a> * pFromParty    = pFromAgent-&gt;<a class="code" href="class_o_t_agent.html#a929a2489984f5487bd1819ed6d8862f2">GetParty</a>();

    <span class="keywordflow">if</span> (NULL == pFromParty)
    {
        <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;OTSmartContract::StashAcctFunds: error: Party pointer NULL on authorized agent (%s) for from_acct (%s).\n&quot;</span>,
                      pFromAcct-&gt;<a class="code" href="class_o_t_party_account.html#a86975046b18ac6d6c5841f5ba0befe69">GetAgentName</a>().<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>(), from_acct_name.c_str());
        <span class="keywordflow">return</span> <span class="keyword">false</span>;
    }
    <span class="comment">//</span>
    <span class="comment">// Below this point, these are all good:</span>
    <span class="comment">//</span>
    <span class="comment">//      pFromAcct,  from_acct_name, pFromAgent, pFromParty,</span>
    <span class="comment">//      pStash,     to_stash_name,</span>
    <span class="comment">//      pServerNym, pCron.</span>
    <span class="comment">//</span>
    <span class="comment">// ---------------------------------------------------</span>


    <span class="comment">// DONE: Problem: I can see that THIS VERIFICATION CODE WILL GET CALLED EVERY SINGLE TIME THE SCRIPT</span>
    <span class="comment">// CALLS MOVE FUNDS.  Maybe that&#39;s good, but since technically this only needs to be verified before the</span>
    <span class="comment">// first call, and not for EVERY call during any of a script&#39;s runs, I should probably move this verification</span>
    <span class="comment">// higher, such as each time the OTCronItem triggers, plus each time a party triggers a clause directly</span>
    <span class="comment">// through the API (server message). As long as those are covered, I will be able to remove it from here</span>
    <span class="comment">// which should be a significant improvement for performance.</span>
    <span class="comment">// It will be at the bottom of those same functions that &quot;ClearTemporaryPointers()&quot; should finally be called.</span>
    <span class="comment">//</span>
    <span class="comment">//</span>
<span class="comment">//  const OTString strServerID(GetServerID());</span>

<span class="comment">//  mapOfNyms   map_Nyms_Already_Loaded;</span>
<span class="comment">//  this-&gt;RetrieveNymPointers(map_Nyms_Already_Loaded);</span>
    <span class="comment">// --------------------------------------------------</span>

    <span class="comment">// FINAL DECISION: Since this verification is already done for the smart contract to have been activated onto</span>
    <span class="comment">// cron in the first place, it is redundant to have it here.</span>
    <span class="comment">// Furthermore, what if a single clause calls stash_funds 30 times in a loop? Does that mean we need to verify</span>
    <span class="comment">// all the parties and accounts 30 times, every single time we call that clause? CLearly such is redundant, and</span>
    <span class="comment">// would be targeted in any optimization effort.</span>
    <span class="comment">// Furthermore, since actually running the software, it&#39;s become apparent that it is no longer even appropriate</span>
    <span class="comment">// to Verify anymore, since stashes can exist after a smartcontract has been activated, while this function</span>
    <span class="comment">// specifically verifies that no stashes exist, since it presumes that it is only called during the initial</span>
    <span class="comment">// activation of the cron item, when no stashes SHOULD exist (since they are only created after activation, by</span>
    <span class="comment">// the server itself, at the behest of the scripts.)</span>

<span class="comment">//  if (false == this-&gt;VerifyPartyAuthorization(*pFromParty, *pServerNym, strServerID, &amp;map_Nyms_Already_Loaded))</span>
<span class="comment">//  {</span>
<span class="comment">//      OTLog::vError(&quot;OTSmartContract::StashAcctFunds: error: &#39;From&#39; Party (%s) not authorized for this contract.\n&quot;,</span>
<span class="comment">//                    pFromParty-&gt;GetPartyName().c_str());</span>
<span class="comment">//      return false;</span>
<span class="comment">//  }</span>
    <span class="comment">// *****************************************************************************</span>

    <span class="comment">// A party might have many agents who are only voting groups, and cannot actually sign for things</span>
    <span class="comment">// the way that nyms can. But at least ONE of those agents IS a Nym -- because there must have been</span>
    <span class="comment">// an authorizing agent who initially signed to accept the agreement, and who fronted the opening</span>
    <span class="comment">// transaction number that activated it.</span>
    <span class="comment">//</span>
    <span class="comment">// Similarly, the authorized agent for any given party&#39;s account (each account has its own authorized</span>
    <span class="comment">// agent) MUST be an active agent (an active agent is one with a Nym--whether that Nym is representing</span>
    <span class="comment">// himself as the party, or whether representing some entity as an employee in a role). Why MUST the</span>
    <span class="comment">// authorized agent be an active agent? Because when funds are moved, that Nym must be loaded since</span>
    <span class="comment">// the account must show that Nym as a legal owner/agent. The MoveFunds will cause a paymentReceipt to</span>
    <span class="comment">// drop into the Inbox for the relevant asset accounts, and that paymentReceipt can ONLY be accepted</span>
    <span class="comment">// by that same Nym, who must use a transaction # that he signed for previously and received through</span>
    <span class="comment">// his nymbox. There is actually no justification at all to take funds from that account, since the</span>
    <span class="comment">// new balance has not yet been signed, UNLESS THE PAYMENTRECEIPT CONTAINS A VALID, SIGNED AUTHORIZATION</span>
    <span class="comment">// FROM THE ACCOUNT HOLDER. *That* is why the authorizing agent must either be the Party&#39;s Owner himself</span>
    <span class="comment">// (representing himself as an agent, which most will do) in which case he will appear as the valid</span>
    <span class="comment">// owner of the account, OR he MUST be a Nym working in a Valid Role for an Entity, where said Entity is</span>
    <span class="comment">// the valid owner on the account in question. Either OT, it will be possible in OT for him to sign for</span>
    <span class="comment">// the paymentReceipts when they come in, and impossible for him to escape liability for them.</span>
    <span class="comment">// (That&#39;s the idea anyway.)</span>
    <span class="comment">//</span>
    <span class="comment">// Since we know that the Authorized Agent for an account must be an ACTIVE agent (one way or the other)</span>
    <span class="comment">// then we can error out here if he&#39;s not.  We can then pass in his Nym ID.</span>
    <span class="comment">//</span>

    <a class="code" href="class_o_t_identifier.html">OTIdentifier</a> theFromAgentID;
    <span class="keyword">const</span> <span class="keywordtype">bool</span> bFromAgentID = pFromAgent-&gt;<a class="code" href="class_o_t_agent.html#a7750c7f5840047c5413d95e92ad87578">GetSignerID</a>(theFromAgentID);

    <span class="keywordflow">if</span> ( ! bFromAgentID )
    {
        <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;OTSmartContract::StashAcctFunds: Failed to find FromAgent&#39;s Signer ID: %s \n&quot;</span>,
                      pFromAgent-&gt;<a class="code" href="class_o_t_agent.html#a123d27f05e46977ecdbe0b83de3c119d">GetName</a>().<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>());
        <span class="keywordflow">return</span> <span class="keyword">false</span>;
    }
    <span class="comment">// --------------------------------------</span>

    <span class="keywordflow">if</span> (!pFromAcct-&gt;<a class="code" href="class_o_t_party_account.html#aa5e4e0cc77853d08b3708017fe694876">GetAcctID</a>().<a class="code" href="class_o_t_string.html#adf7489cd917d4ae5bf30853a3ad78daf">Exists</a>())
    {
        <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;OTSmartContract::StashAcctFunds: Error: FromAcct has empty AcctID: %s \n&quot;</span>,
                      from_acct_name.c_str());
        <span class="keywordflow">return</span> <span class="keyword">false</span>;
    }

    <span class="keyword">const</span> <a class="code" href="class_o_t_identifier.html">OTIdentifier</a> theFromAcctID(pFromAcct-&gt;<a class="code" href="class_o_t_party_account.html#aa5e4e0cc77853d08b3708017fe694876">GetAcctID</a>());
    <span class="comment">//</span>
    <span class="comment">// BELOW THIS POINT, theFromAcctID and theFromAgentID available.</span>
    <span class="comment">// --------------------------------------</span>

    <span class="comment">// WE SET THESE HERE SO THE RECEIPT SHOWS, SUCCESS OR FAIL,</span>
    <span class="comment">// WHO THE INTENDED SENDER / RECIPIENT ARE FOR THAT RECEIPT.</span>
    <span class="comment">//</span>
    <a class="code" href="class_o_t_smart_contract.html#a09de789ac2e616e2119feb9ddf416c9d">ReleaseLastSenderRecipientIDs</a>();
    <span class="comment">// -------------------------</span>
    theFromAgentID.<a class="code" href="class_o_t_identifier.html#a4bccb30446b4b515d9d6016b86b260bb">GetString</a>(m_strLastSenderUser);  <span class="comment">// This is the last User ID of a party who SENT money.</span>
    theFromAcctID.GetString(m_strLastSenderAcct);   <span class="comment">// This is the last Acct ID of a party who SENT money.</span>
<span class="comment">//  theToAgentID.GetString(m_strLastRecipientUser); // This is the last User ID of a party who RECEIVED money.</span>
<span class="comment">//  theToAcctID.GetString(m_strLastRecipientAcct);  // This is the last Acct ID of a party who RECEIVED money.</span>
    <span class="comment">// Above: the ToAgent and ToAcct are commented out,</span>
    <span class="comment">// since the funds are going into a stash.</span>
    <span class="comment">// ----------------------------------------------------------</span>

    <a class="code" href="_o_t_agent_8hpp.html#ac89892658f6bc83e354078647b704e8f">mapOfNyms</a>   map_Nyms_Already_Loaded;
    this-&gt;<a class="code" href="class_o_t_scriptable.html#a9e41bb939fd5dbfe1f2442e5919a5079">RetrieveNymPointers</a>(map_Nyms_Already_Loaded);


<span class="comment">//  OTLog::vError(&quot;OTSmartContract::StashAcctFunds: DEBUGGING: lAmount is %lld.\n&quot;, lAmount);</span>


    <span class="keywordtype">bool</span> bMoved = this-&gt;<a class="code" href="class_o_t_smart_contract.html#abaebc7e1d2416290139c883698c91025">StashFunds</a>(map_Nyms_Already_Loaded,
                                   lAmount,
                                   theFromAcctID,   theFromAgentID,
                                   *pStash);
    <span class="keywordflow">if</span> (!bMoved)
    {
        <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(0, <span class="stringliteral">&quot;OTSmartContract::StashAcctFunds: Failed in final call. Values: from_acct: %s, to_stash: %s, lAmount: %lld. \n&quot;</span>,
                       from_acct_name.c_str(), to_stash_name.c_str(), lAmount);
        <span class="keywordflow">return</span> <span class="keyword">false</span>;
    }

    <span class="keywordflow">return</span> <span class="keyword">true</span>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="abaebc7e1d2416290139c883698c91025"></a><!-- doxytag: member="OTSmartContract::StashFunds" ref="abaebc7e1d2416290139c883698c91025" args="(const mapOfNyms &amp;map_NymsAlreadyLoaded, const int64_t &amp;lAmount, const OTIdentifier &amp;PARTY_ACCT_ID, const OTIdentifier &amp;PARTY_USER_ID, OTStash &amp;theStash)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_o_t_smart_contract.html#abaebc7e1d2416290139c883698c91025">OTSmartContract::StashFunds</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="_o_t_agent_8hpp.html#ac89892658f6bc83e354078647b704e8f">mapOfNyms</a> &amp;&#160;</td>
          <td class="paramname"><em>map_NymsAlreadyLoaded</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int64_t &amp;&#160;</td>
          <td class="paramname"><em>lAmount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_o_t_identifier.html">OTIdentifier</a> &amp;&#160;</td>
          <td class="paramname"><em>PARTY_ACCT_ID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_o_t_identifier.html">OTIdentifier</a> &amp;&#160;</td>
          <td class="paramname"><em>PARTY_USER_ID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_t_stash.html">OTStash</a> &amp;&#160;</td>
          <td class="paramname"><em>theStash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_o_t_smart_contract_8cpp_source.html#l02062">2062</a> of file <a class="el" href="_o_t_smart_contract_8cpp_source.html">OTSmartContract.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
    <a class="code" href="class_o_t_cron.html">OTCron</a> * pCron = <a class="code" href="class_o_t_cron_item.html#af734ad5d309fcc9b4a60d40d6c30f55a">GetCron</a>();
    <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != pCron);

    <a class="code" href="class_o_t_pseudonym.html">OTPseudonym</a> * pServerNym = pCron-&gt;<a class="code" href="class_o_t_cron.html#a7756d0dcc047209ca87632939dc11db3">GetServerNym</a>();
    <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != pServerNym);
    <span class="comment">// --------------------------------------------------------</span>
    <span class="keywordflow">if</span> (0 == lAmount)
    {
        <a class="code" href="class_o_t_log.html#a1f7549d776ee919dcb6517f611ded015">OTLog::Output</a>(0, <span class="stringliteral">&quot;OTSmartContract::StashFunds: a zero amount is not allowed.\n&quot;</span>);
        <span class="keywordflow">return</span> <span class="keyword">false</span>;
    }
    <span class="comment">// --------------------------------------------------------</span>
    <span class="keyword">const</span> <a class="code" href="class_o_t_identifier.html">OTIdentifier</a>  SERVER_ID(pCron-&gt;<a class="code" href="class_o_t_cron.html#a93b52f56c0de94e53bb05a610830ba4b">GetServerID</a>());
    <span class="keyword">const</span> <a class="code" href="class_o_t_identifier.html">OTIdentifier</a>  SERVER_USER_ID(*pServerNym);
    <span class="comment">// --------------------------------------------------------</span>
    <span class="comment">// Load up the party&#39;s account and get the asset type, so we know which stash to get off the stash.</span>
    <span class="comment">//</span>
    <a class="code" href="class_o_t_account.html">OTAccount</a> * pPartyAssetAcct = <a class="code" href="class_o_t_account.html#a6574057f6e3415546d3a9f7d7e445e4f">OTAccount::LoadExistingAccount</a>(PARTY_ACCT_ID, SERVER_ID);

    <span class="keywordflow">if</span> (NULL == pPartyAssetAcct)
    {
        <a class="code" href="class_o_t_log.html#a1f7549d776ee919dcb6517f611ded015">OTLog::Output</a>(0, <span class="stringliteral">&quot;OTSmartContract::StashFunds: ERROR verifying existence of source account.\n&quot;</span>);
        <a class="code" href="class_o_t_cron_item.html#a34c87380d2f8cd419c9a5cfec86427b4">FlagForRemoval</a>(); <span class="comment">// Remove it from future Cron processing, please.</span>
        <span class="keywordflow">return</span> <span class="keyword">false</span>;
    }
    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!pPartyAssetAcct-&gt;<a class="code" href="class_o_t_contract.html#a38f51d593b6dfc8a75d1c5a535965392">VerifySignature</a>(*pServerNym))
    {
        <a class="code" href="class_o_t_log.html#a1f7549d776ee919dcb6517f611ded015">OTLog::Output</a>(0, <span class="stringliteral">&quot;OTSmartContract::StashFunds: ERROR failed to verify the server&#39;s signature on the party&#39;s account.\n&quot;</span>);
        <a class="code" href="class_o_t_cron_item.html#a34c87380d2f8cd419c9a5cfec86427b4">FlagForRemoval</a>(); <span class="comment">// Remove it from future Cron processing, please.</span>
        <span class="keywordflow">return</span> <span class="keyword">false</span>;
    }
    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!pPartyAssetAcct-&gt;<a class="code" href="class_o_t_account.html#a4b6aa9e72c2ad3e395f9fe6cea00dd4d">VerifyOwnerByID</a>(PARTY_USER_ID))
    {
        <a class="code" href="class_o_t_log.html#a1f7549d776ee919dcb6517f611ded015">OTLog::Output</a>(0, <span class="stringliteral">&quot;OTSmartContract::StashFunds: ERROR failed to verify party user ownership of party account.\n&quot;</span>);
        <a class="code" href="class_o_t_cron_item.html#a34c87380d2f8cd419c9a5cfec86427b4">FlagForRemoval</a>(); <span class="comment">// Remove it from future Cron processing, please.</span>
        <span class="keywordflow">return</span> <span class="keyword">false</span>;
    }
    <span class="comment">// Past this point we know pPartyAssetAcct is good and will clean itself up.</span>
    <a class="code" href="class_o_t_cleanup.html">OTCleanup&lt;OTAccount&gt;</a>    theSourceAcctSmrtPtr(*pPartyAssetAcct);
    <span class="comment">// -----------------------------------------------------------------</span>
    <span class="comment">//</span>
    <span class="comment">// There could be many stashes, each with a name. (One was passed in here...)</span>
    <span class="comment">// And inside each one is a stash for each asset type. So let&#39;s get the one</span>
    <span class="comment">// for the asset type matching the party&#39;s account.</span>
    <span class="comment">//</span>
    <span class="keyword">const</span> <a class="code" href="class_o_t_string.html">OTString</a>          strAssetTypeID(pPartyAssetAcct-&gt;<a class="code" href="class_o_t_account.html#a3b933b8c929e071a68ec4a29ad5797d6">GetAssetTypeID</a>());
    <span class="keyword">const</span> std::string       str_asset_type_id = strAssetTypeID.<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>();

    <a class="code" href="class_o_t_stash_item.html">OTStashItem</a> * pStashItem = theStash.<a class="code" href="class_o_t_stash.html#a21bdce4995350ae964704ad6662a0035">GetStash</a>(str_asset_type_id);
    <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != pStashItem); <span class="comment">// should never happen. Creates if non-existent.</span>
    <span class="comment">// -----------------------------------------------------------------------</span>
    <span class="comment">// Below this point, pStashItem is good, and has the right asset_type_id.</span>
    <span class="comment">// --------------------------------------------------------</span>
    <span class="comment">//</span>
    <span class="keyword">const</span> <span class="keywordtype">bool</span> bUnstashing      = (lAmount &lt; 0); <span class="comment">// If the amount is negative, then we&#39;re UNSTASHING.</span>
    <span class="keyword">const</span> int64_t lAbsoluteAmount   = bUnstashing ? (lAmount*(-1)) : lAmount;   <span class="comment">// NEGATIVE AMOUNT SHOULD BEHAVE AS &quot;UNSTASH FUNDS&quot; !!</span>

    <span class="comment">// Normally if you stash 10 clams, then your account is -10 clams, and your stash is +10 clams.</span>
    <span class="comment">// Therefore if you unstash 5 gg, then your gg acct is +5 grams and your stash is -5 grams.</span>
    <span class="comment">//</span>
    <span class="comment">// Thus if lAmount is &gt; 0, as normal, that amount should be DEBITED from the Party Acct, and CREDITED to the Stash Acct.</span>
    <span class="comment">// Whereas if lAmount were &lt; 0, then that amount should be DEBITED from the Stash Acct, and CREDITED to the Party Acct.</span>
    <span class="comment">// ------------------------------------------------------------------</span>

    <span class="comment">// Below this point, lAbsoluteAmount is always a positive number.</span>
    <span class="comment">// Whereas if lAmount &lt; 0, that means we are doing an UNSTASH in this function.</span>
    <span class="comment">//</span>
    <span class="comment">// -------------------------------</span>

    <span class="comment">// Whether the funds are coming from the party&#39;s acct, or from the stash, WHEREVER they</span>
    <span class="comment">// are coming from, is that source LARGE enough to accommodate the amount we&#39;re trying to move?</span>
    <span class="comment">//</span>

    <span class="keyword">const</span> int64_t lPartyAssetBalance    = pPartyAssetAcct-&gt;<a class="code" href="class_o_t_account.html#a77fbaae9496caec7cd899721971a89c0">GetBalance</a>();
    <span class="keyword">const</span> int64_t lStashItemAmount      = pStashItem-&gt;<a class="code" href="class_o_t_stash_item.html#a74c88fa90fafada9e6e44c46174381dd">GetAmount</a>();

    <span class="keyword">const</span> int64_t lSourceAmount = bUnstashing ? lStashItemAmount : lPartyAssetBalance;

    <span class="comment">// If the source, minus amount, is less than 0, then it CANNOT accommodate the action.</span>
    <span class="comment">//</span>
    <span class="keywordflow">if</span> ((lSourceAmount - lAbsoluteAmount) &lt; 0)
    {
        <a class="code" href="class_o_t_log.html#a1f7549d776ee919dcb6517f611ded015">OTLog::Output</a>(0, <span class="stringliteral">&quot;OTSmartContract::StashFunds: Not enough funds available in the source to accommodate this action.\n&quot;</span>);
        <span class="keywordflow">return</span> <span class="keyword">false</span>;
    }
    <span class="comment">// ------------------------------------------------------</span>
    <span class="comment">// Load up the actual Stash ACCOUNT</span>
    <span class="comment">//</span>
<span class="preprocessor">#ifndef OT_USE_TR1</span>
<span class="preprocessor"></span>    _SharedPtr&lt;OTAccount&gt; pStashAccount(NULL);
<span class="preprocessor">#else</span>
<span class="preprocessor"></span>    _SharedPtr&lt;OTAccount&gt; pStashAccount;
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>
    <span class="keywordtype">bool</span> bWasAcctCreated = <span class="keyword">false</span>;   <span class="comment">// GetOrCreateAccount() will verifyContractID and verifySignature on the account internally.</span>
    pStashAccount = m_StashAccts.<a class="code" href="class_o_t_acct_list.html#ad525fafc311107c6a158030c3d429538">GetOrCreateAccount</a>(*pServerNym, SERVER_USER_ID, pPartyAssetAcct-&gt;<a class="code" href="class_o_t_account.html#a3b933b8c929e071a68ec4a29ad5797d6">GetAssetTypeID</a>(),
                                                    SERVER_ID, bWasAcctCreated, <a class="code" href="class_o_t_trackable.html#a2594d320e3b24f3210bd38a08de66a70">GetTransactionNum</a>());

    <span class="keywordflow">if</span> (!pStashAccount) { <a class="code" href="_o_t_assert_8hpp.html#aa86aeed4e57eecded96d5955b5cc23c5">OT_FAIL_MSG</a>(<span class="stringliteral">&quot;ASSERT in OTSmartContract::StashFunds: returned NULL pointer (should never happen.)\n&quot;</span>); }

    <span class="keywordflow">if</span> (bWasAcctCreated)
    {
        <a class="code" href="class_o_t_string.html">OTString</a> strAcctID;
        pStashAccount-&gt;GetIdentifier(strAcctID);

        <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(0, <span class="stringliteral">&quot;OTSmartContract::StashFunds: Successfully created stash account ID: %s\n (Stash acct has Asset Type ID: %s) \n&quot;</span>,
                       strAcctID.<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>(), strAssetTypeID.Get());

        <span class="comment">// Todo: Some kind of save here?</span>
        <span class="comment">// It&#39;s kind of unnecessary, since I&#39;ve already verified that there&#39;s enough funds at the source</span>
        <span class="comment">// to successfully do the transfer, AND I will already save at the end of this call, since funds are</span>
        <span class="comment">// being moved.</span>
    }

    <span class="keywordflow">if</span> (!pStashAccount) { <a class="code" href="_o_t_assert_8hpp.html#aa86aeed4e57eecded96d5955b5cc23c5">OT_FAIL_MSG</a>(<span class="stringliteral">&quot;ASSERT in OTSmartContract::StashFunds: returned NULL pointer (should never happen.)\n&quot;</span>); }

    <span class="comment">// ------------------------------------------------------------</span>
    <span class="comment">//</span>
    <span class="comment">// This code is similar to above, but it checks the stash ACCT itself instead of the stash entry.</span>
    <span class="comment">//</span>
    <span class="comment">// Whether the funds are coming from the party&#39;s acct, or from the stash acct, WHEREVER they</span>
    <span class="comment">// are coming from, is that source LARGE enough to accommodate the amount we&#39;re trying to move?</span>
    <span class="comment">//</span>
    <span class="keyword">const</span> int64_t lSourceAmount2 = bUnstashing ? pStashAccount-&gt;GetBalance() : pPartyAssetAcct-&gt;<a class="code" href="class_o_t_account.html#a77fbaae9496caec7cd899721971a89c0">GetBalance</a>();


    <span class="comment">// If the source, minus amount, is less than 0, then it CANNOT accommodate the action.</span>
    <span class="comment">//</span>
    <span class="keywordflow">if</span> ((lSourceAmount2 - lAbsoluteAmount) &lt; 0)
    {
        <a class="code" href="class_o_t_log.html#a1f7549d776ee919dcb6517f611ded015">OTLog::Output</a>(0, <span class="stringliteral">&quot;OTSmartContract::StashFunds: Not enough funds available in the stash acct to accommodate this action.\n&quot;</span>);
        <span class="keywordflow">return</span> <span class="keyword">false</span>;   <span class="comment">// THIS SHOULD NEVER HAPPEN, SINCE WE ALREADY VERIFIED THE AMOUNT BEFORE LOADING THE ACCOUNT. FYI.</span>
    }
    <span class="comment">// ------------------------------------------------------</span>
    <span class="comment">//</span>
    <span class="comment">// Make sure they&#39;re not the same Account IDs ...</span>
    <span class="comment">// Otherwise we would have to take care not to load them twice, like with the Nyms below.</span>
    <span class="comment">// (Instead I just disallow it entirely. After all, even if I DID allow the account to transfer</span>
    <span class="comment">// to itself, there would be no difference in balance than disallowing it.)</span>
    <span class="comment">//</span>
    <span class="keyword">const</span> <a class="code" href="class_o_t_identifier.html">OTIdentifier</a> STASH_ACCT_ID (pStashAccount-&gt;GetRealAccountID());

    <span class="keywordflow">if</span> (PARTY_ACCT_ID == STASH_ACCT_ID)
    {
        <a class="code" href="class_o_t_log.html#a5acd90ac91c2618f395b0ff37ad4f8ee">OTLog::Error</a>(<span class="stringliteral">&quot;OTSmartContract::StashFunds: ERROR: both account IDs were identical.\n&quot;</span>);
        <a class="code" href="class_o_t_cron_item.html#a34c87380d2f8cd419c9a5cfec86427b4">FlagForRemoval</a>(); <span class="comment">// Remove from Cron</span>
        <span class="keywordflow">return</span> <span class="keyword">false</span>; <span class="comment">// TODO: should have a &quot;Validate Scripts&quot; function that weeds this crap out before we even get here. (There are other examples...)</span>
    }
    <span class="comment">// -----------------------------------------------------------------</span>
    <span class="comment">// SHOULD NEVER HAPPEN</span>
    <span class="keywordflow">if</span> (pPartyAssetAcct-&gt;<a class="code" href="class_o_t_account.html#a3b933b8c929e071a68ec4a29ad5797d6">GetAssetTypeID</a>() != pStashAccount-&gt;GetAssetTypeID())
    {
        <a class="code" href="class_o_t_log.html#a5acd90ac91c2618f395b0ff37ad4f8ee">OTLog::Error</a>(<span class="stringliteral">&quot;OTSmartContract::StashFunds: Aborted stash: Asset type ID doesn&#39;t match. THIS SHOULD NEVER HAPPEN.\n&quot;</span>);
        <a class="code" href="class_o_t_cron_item.html#a34c87380d2f8cd419c9a5cfec86427b4">FlagForRemoval</a>(); <span class="comment">// Remove from Cron</span>
        <span class="keywordflow">return</span> <span class="keyword">false</span>;
    }
    <span class="comment">// -----------------------------------------------------------------</span>

    <span class="keywordflow">if</span> (!pStashAccount-&gt;VerifyOwnerByID(SERVER_USER_ID))
    {
        <a class="code" href="class_o_t_log.html#a5acd90ac91c2618f395b0ff37ad4f8ee">OTLog::Error</a>(<span class="stringliteral">&quot;OTSmartContract::StashFunds: Error: Somehow the stash account isn&#39;t server-nym owned.\n&quot;</span>);
        <a class="code" href="class_o_t_cron_item.html#a34c87380d2f8cd419c9a5cfec86427b4">FlagForRemoval</a>(); <span class="comment">// Remove from Cron</span>
        <span class="keywordflow">return</span> <span class="keyword">false</span>;
    }
    <span class="keyword">const</span> <a class="code" href="class_o_t_identifier.html">OTIdentifier</a> STASH_USER_ID (pStashAccount-&gt;GetUserID());
    <span class="comment">// ---------------------------------------------------</span>

    <span class="keywordtype">bool</span>        bSuccess = <span class="keyword">false</span>;   <span class="comment">// The return value.</span>
    <span class="comment">// --------------------------------------------------------</span>

    <a class="code" href="class_o_t_string.html">OTString</a>    strPartyUserID(PARTY_USER_ID), strStashUserID(STASH_USER_ID),
                strPartyAcctID(PARTY_ACCT_ID), strStashAcctID(STASH_ACCT_ID),
                strServerNymID(SERVER_USER_ID);

    <span class="comment">// Need to load up the ORIGINAL VERSION OF THIS SMART CONTRACT</span>
    <span class="comment">// Will need to verify the party&#39;s signature, as well as attach a copy of it to the receipt.</span>

    <a class="code" href="class_o_t_cron_item.html">OTCronItem</a> * pOrigCronItem  = NULL;

    <span class="comment">// OTCronItem::LoadCronReceipt loads the original version with the user&#39;s signature.</span>
    <span class="comment">// (Updated versions, as processing occurs, are signed by the server.)</span>
    pOrigCronItem   = <a class="code" href="class_o_t_cron_item.html#a368603ca2196ecb8817d42a24138f5d7">OTCronItem::LoadCronReceipt</a>(<a class="code" href="class_o_t_trackable.html#a2594d320e3b24f3210bd38a08de66a70">GetTransactionNum</a>());

    <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != pOrigCronItem);   <span class="comment">// How am I processing it now if the receipt wasn&#39;t saved in the first place??</span>
    <span class="comment">// TODO: Decide global policy for handling situations where the hard drive stops working, etc.</span>

    <span class="comment">// When theOrigPlanGuardian goes out of scope, pOrigCronItem gets deleted automatically.</span>
    <a class="code" href="class_o_t_cleanup.html">OTCleanup&lt;OTCronItem&gt;</a>   theOrigPlanGuardian(*pOrigCronItem);

    <span class="comment">// strOrigPlan is a String copy (a PGP-signed XML file, in string form) of the original smart contract activation request...</span>
    <a class="code" href="class_o_t_string.html">OTString</a> strOrigPlan(*pOrigCronItem); <span class="comment">// &lt;====== Farther down in the code, I attach this string to the receipts.</span>


    <span class="comment">// -------------- Make sure have both nyms loaded and checked out. --------------------------------------------------</span>
    <span class="comment">// WARNING: The party&#39;s Nym could be also the Server Nym. But the Stash Nym is ALWAYS the server.</span>
    <span class="comment">// In all of those different cases, I don&#39;t want to load the same file twice and overwrite it with itself, losing</span>
    <span class="comment">// half of all my changes. I have to check all three IDs carefully and set the pointers accordingly, and then operate</span>
    <span class="comment">// using the pointers from there.</span>

    <a class="code" href="class_o_t_pseudonym.html">OTPseudonym</a> thePartyNym;

    <span class="comment">// Find out if party Nym is actually also the server nym.</span>
    <span class="keyword">const</span> <span class="keywordtype">bool</span> bPartyNymIsServerNym = ((PARTY_USER_ID   == SERVER_USER_ID) ? <span class="keyword">true</span> : <span class="keyword">false</span>);

    <span class="comment">// -----------------------------------------------------</span>

    <a class="code" href="class_o_t_pseudonym.html">OTPseudonym</a> * pPartyNym         = NULL;
<span class="comment">//  OTPseudonym * pStashNym         = pServerNym;</span>
    <span class="comment">// --------------------------</span>
    <span class="keyword">const</span> std::string           str_party_id = strPartyUserID.Get();
    mapOfNyms::const_iterator   it_party     = map_NymsAlreadyLoaded.find(str_party_id);

    <span class="keywordflow">if</span> (map_NymsAlreadyLoaded.end() != it_party) <span class="comment">// found the party in list of Nyms that are already loaded.</span>
    {
        pPartyNym = (*it_party).second;
        <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>((NULL != pPartyNym) &amp;&amp; (pPartyNym-&gt;<a class="code" href="class_o_t_pseudonym.html#a5ec9340b8d1d0fcd32f754ea63f9915a">CompareID</a>(PARTY_USER_ID)));
    }
    <span class="comment">// ------------------</span>

    <span class="comment">// Figure out if party Nym is also Server Nym.</span>
    <span class="keywordflow">if</span> (bPartyNymIsServerNym)
    {
        <span class="comment">// If the First Nym is the server, then just point to that.</span>
        pPartyNym = pServerNym;
    }
    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (NULL == pPartyNym) <span class="comment">// Else load the First Nym from storage, if still not found.</span>
    {
        thePartyNym.<a class="code" href="class_o_t_pseudonym.html#a4b5f98378bb2ff1c48c5410f7283aff6">SetIdentifier</a>(PARTY_USER_ID);  <span class="comment">// thePartyNym is pPartyNym</span>

        <span class="keywordflow">if</span> (<span class="keyword">false</span> == thePartyNym.<a class="code" href="class_o_t_pseudonym.html#aeb1c675ec72d6450e5c151d1f3eb95bf">LoadPublicKey</a>())
        {
            <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;OTSmartContract::StashFunds: Failure loading party Nym public key: %s\n&quot;</span>,
                          strPartyUserID.Get());
            <a class="code" href="class_o_t_cron_item.html#a34c87380d2f8cd419c9a5cfec86427b4">FlagForRemoval</a>(); <span class="comment">// Remove it from future Cron processing, please.</span>
            <span class="keywordflow">return</span> <span class="keyword">false</span>;
        }

        <span class="keywordflow">if</span> (thePartyNym.<a class="code" href="class_o_t_pseudonym.html#aae8a707c7799efb6944d485be31a7c3e">VerifyPseudonym</a>()   &amp;&amp;
            thePartyNym.<a class="code" href="class_o_t_pseudonym.html#ad24db39caa89399f659f414b19903f90">LoadSignedNymfile</a>(*pServerNym)) <span class="comment">// ServerNym here is not thePartyNym&#39;s identity, but merely the signer on this file.</span>
        {
            <a class="code" href="class_o_t_log.html#a1f7549d776ee919dcb6517f611ded015">OTLog::Output</a>(1, <span class="stringliteral">&quot;OTSmartContract::StashFunds: Loading party Nym, since he apparently wasn&#39;t already loaded.\n&quot;</span>
                          <span class="stringliteral">&quot;(On a cron item processing, this is normal. But if you triggered a clause directly, then your Nym SHOULD be already loaded...)\n&quot;</span>);
            pPartyNym = &amp;thePartyNym; <span class="comment">//  &lt;=====</span>
        }
        <span class="keywordflow">else</span>
        {
            <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;OTSmartContract::StashFunds: Failure loading or verifying party Nym public key: %s\n&quot;</span>,
                          strPartyUserID.Get());
            <a class="code" href="class_o_t_cron_item.html#a34c87380d2f8cd419c9a5cfec86427b4">FlagForRemoval</a>(); <span class="comment">// Remove it from future Cron processing, please.</span>
            <span class="keywordflow">return</span> <span class="keyword">false</span>;
        }
    }
    <span class="comment">// Below this point, both Nyms are loaded and good-to-go.</span>
    <span class="comment">// -----------------------------------------------------------------</span>

    <a class="code" href="_o_t_agent_8hpp.html#ac89892658f6bc83e354078647b704e8f">mapOfNyms</a> map_ALREADY_LOADED; <span class="comment">// I know I passed in one of these, but now I have processed the Nym pointers (above) and have better data here now.</span>
    mapOfNyms::iterator it_temp;

    map_ALREADY_LOADED.insert(std::pair&lt;std::string,OTPseudonym*&gt;(strServerNymID.Get(), pServerNym));  <span class="comment">// Add Server Nym to list of Nyms already loaded.</span>

    it_temp = map_ALREADY_LOADED.find(strPartyUserID.Get());
    <span class="keywordflow">if</span> (map_ALREADY_LOADED.end() == it_temp)
        map_ALREADY_LOADED.insert(std::pair&lt;std::string,OTPseudonym*&gt;(strPartyUserID.Get(), pPartyNym));  <span class="comment">// Add party Nym to list of Nyms already loaded.</span>

    <span class="comment">// In this function, pStashNym and pServerNym are always the same.</span>
    <span class="comment">//</span>
    <span class="comment">// ------------------------------------------</span>
    <span class="comment">//</span>
    <span class="keywordflow">if</span> (!pOrigCronItem-&gt;<a class="code" href="class_o_t_scriptable.html#a242f30ff4c6deccf285930efa15638eb">VerifyNymAsAgent</a>(*pPartyNym, *pServerNym,
                                         <span class="comment">// In case it needs to load the AUTHORIZING agent, and that agent is already loaded, it will have access here.</span>
                                         &amp;map_ALREADY_LOADED))
    {
        <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;OTSmartContract::StashFunds: Failed authorization for party Nym: %s\n&quot;</span>, strPartyUserID.Get());
        <a class="code" href="class_o_t_cron_item.html#a34c87380d2f8cd419c9a5cfec86427b4">FlagForRemoval</a>(); <span class="comment">// Remove it from Cron.</span>
        <span class="keywordflow">return</span> <span class="keyword">false</span>;
    }

    <span class="comment">// AT THIS POINT, I have:   pServerNym, pPartyNym, and pStashNym,</span>
    <span class="comment">// PLUS:                    pStashAccount and pPartyAssetAcct</span>
    <span class="comment">// -----------------------------------------------------------------</span>
    <span class="comment">// VerifySignature, VerifyContractID, and VerifyOwner have all been called already</span>
    <span class="comment">// by this point. This is new:</span>
    <span class="comment">// (They might fall away in favor of this, once I start building.)</span>
    <span class="comment">//</span>
    <span class="keywordflow">if</span> (!this-&gt;<a class="code" href="class_o_t_scriptable.html#a844de5b0eb2560a28bf795c2c4da3f3b">VerifyNymAsAgentForAccount</a>(*pPartyNym, *pPartyAssetAcct) )
    {
        <a class="code" href="class_o_t_log.html#a1f7549d776ee919dcb6517f611ded015">OTLog::Output</a>(0, <span class="stringliteral">&quot;OTSmartContract::StashFunds: ERROR verifying ownership on source account.\n&quot;</span>);
        <a class="code" href="class_o_t_cron_item.html#a34c87380d2f8cd419c9a5cfec86427b4">FlagForRemoval</a>(); <span class="comment">// Remove it from future Cron processing, please.</span>
        <span class="keywordflow">return</span> <span class="keyword">false</span>;
    }
    <span class="comment">// -------------------------------------------------------------------------</span>

    <span class="keywordflow">else</span>
    {
        <span class="comment">// Okay then, everything checks out. Let&#39;s add a receipt to the party&#39;s inbox.</span>
        <span class="comment">// (No need for the stash&#39;s inbox -- the server owns it.)</span>

        <span class="comment">// Load the inbox in case it already exists</span>
        <a class="code" href="class_o_t_ledger.html">OTLedger</a>    thePartyInbox   (PARTY_USER_ID, PARTY_ACCT_ID,  SERVER_ID);

        <span class="comment">// ALL inboxes -- no outboxes. All will receive notification of something ALREADY DONE.</span>
        <span class="keywordtype">bool</span> bSuccessLoadingPartyInbox  = thePartyInbox.LoadInbox();
        <span class="comment">// -------------------------------------------------------------------</span>
        <span class="comment">// ...or generate them otherwise...</span>

        <span class="keywordflow">if</span> (<span class="keyword">true</span> == bSuccessLoadingPartyInbox)
            bSuccessLoadingPartyInbox       = thePartyInbox.VerifyAccount(*pServerNym);
        <span class="keywordflow">else</span>
            <a class="code" href="class_o_t_log.html#a5acd90ac91c2618f395b0ff37ad4f8ee">OTLog::Error</a>(<span class="stringliteral">&quot;OTSmartContract::StashFunds: Failed trying to load party&#39;s inbox.\n&quot;</span>);
<span class="comment">//          OT_FAIL_MSG(&quot;ASSERT:  TRYING TO GENERATE INBOX IN STASH FUNDS!!!\n&quot;);</span>
<span class="comment">//          bSuccessLoadingPartyInbox       = thePartyInbox.GenerateLedger(PARTY_ACCT_ID, SERVER_ID, OTLedger::inbox, true); // bGenerateFile=true</span>
        <span class="comment">// --------------------------------------------------------------------</span>

        <span class="keywordflow">if</span> (<span class="keyword">false</span> == bSuccessLoadingPartyInbox)
        {
            <a class="code" href="class_o_t_log.html#a5acd90ac91c2618f395b0ff37ad4f8ee">OTLog::Error</a>(<span class="stringliteral">&quot;OTSmartContract::StashFunds: ERROR loading or generating inbox ledger.\n&quot;</span>);
        }
        <span class="keywordflow">else</span>
        {
            <span class="comment">// Generate new transaction numbers for these new transactions</span>
            int64_t lNewTransactionNumber = pCron-&gt;<a class="code" href="class_o_t_cron.html#a22822e0aeced441b6404cd8a2c8e00da">GetNextTransactionNumber</a>();

<span class="comment">//          OT_ASSERT(lNewTransactionNumber &gt; 0); // this can be my reminder.</span>
            <span class="keywordflow">if</span> (0 == lNewTransactionNumber)
            {
                <a class="code" href="class_o_t_log.html#a1f7549d776ee919dcb6517f611ded015">OTLog::Output</a>(0, <span class="stringliteral">&quot;OTSmartContract::StashFunds: Aborted move: There are no more transaction numbers available in Cron.\n&quot;</span>);
                <span class="comment">// (Here I do NOT flag for removal.)</span>
                <span class="keywordflow">return</span> <span class="keyword">false</span>;
            }

            <a class="code" href="class_o_t_transaction.html">OTTransaction</a> * pTransParty = <a class="code" href="class_o_t_transaction.html#a5bfc7ce34aa67cf9dad96e661e118020">OTTransaction::GenerateTransaction</a>(thePartyInbox,
                                                                             <a class="code" href="class_o_t_transaction.html#af6b54636f1000e09f19d1c7a7886e1f8aac41b416522c9ba6453c787607c6c68d">OTTransaction::paymentReceipt</a>,
                                                                             lNewTransactionNumber);
            <span class="comment">// (No need to OT_ASSERT on the above new transaction since it occurs in GenerateTransaction().)</span>


            <span class="comment">// The party&#39;s inbox will get a receipt with a new transaction ID on it, owned by the server.</span>
            <span class="comment">// It will have a &quot;In reference to&quot; field containing the original signed smart contract.</span>
            <span class="comment">// (with all party&#39;s signatures from their authorizing agents.)</span>

            <span class="comment">// set up the transaction item (each transaction may have multiple items... but not in this case.)</span>
            <span class="comment">//</span>
            <a class="code" href="class_o_t_item.html">OTItem</a> * pItemParty = <a class="code" href="class_o_t_item.html#a2376ee56b6c536a63a59e2bfebada0b3">OTItem::CreateItemFromTransaction</a>(*pTransParty, <a class="code" href="class_o_t_item.html#a03db091faaab100aadc455f4ebe2c5d1abcb18b39d8a5da830bdc9b52a825d47b">OTItem::paymentReceipt</a>);
            <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != pItemParty);  <span class="comment">//  may be unnecessary, I&#39;ll have to check CreateItemFromTransaction. I&#39;ll leave for now.</span>

            pItemParty-&gt;<a class="code" href="class_o_t_item.html#a789aa4148a0add3092e16c4221bf5844">SetStatus</a>(<a class="code" href="class_o_t_item.html#a61e86f5b6c64a518664123907235f376adbeae2ab1504a5ef318da097d21119db">OTItem::rejection</a>); <span class="comment">// the default.</span>
            <span class="comment">// -------------------------------------</span>
<span class="comment">//          const int64_t lPartyTransRefNo  = GetTransactionNum();</span>
            <span class="keyword">const</span> int64_t lPartyTransRefNo  = this-&gt;<a class="code" href="class_o_t_smart_contract.html#a2bb8a0f8a1ff8ddf637e5d87d5935e51">GetOpeningNumber</a>(PARTY_USER_ID);

            <span class="comment">// Here I make sure that each receipt (each inbox notice) references the original</span>
            <span class="comment">// transaction number that was used to set the cron item into place...</span>
            <span class="comment">// This number is used to track all cron items. (All Cron items require a transaction</span>
            <span class="comment">// number from the user in order to add them to Cron in the first place.)</span>
            <span class="comment">//</span>
            <span class="comment">// The number is also used to uniquely identify all other transactions, as you</span>
            <span class="comment">// might guess from its name.</span>
            <span class="comment">//</span>
            <span class="comment">// UPDATE: Notice I&#39;m now looking up a different number based on the UserID.</span>
            <span class="comment">// This is to support smart contracts, which have many parties, agents, and accounts.</span>
            <span class="comment">//</span>
<span class="comment">//          pItemParty-&gt;SetReferenceToNum(lPartyTransRefNo);</span>
            pTransParty-&gt;<a class="code" href="class_o_t_transaction_type.html#ab0f87cd43699c20eddd70b5970c092d1">SetReferenceToNum</a>(lPartyTransRefNo);

            <span class="comment">// The TRANSACTION (a receipt in my inbox) will be sent with &quot;In Reference To&quot; information</span>
            <span class="comment">// containing the ORIGINAL SIGNED SMARTCONTRACT. (With all parties&#39; original signatures on it.)</span>
            <span class="comment">//</span>
            <span class="comment">// Whereas the TRANSACTION ITEM will include an &quot;attachment&quot; containing the UPDATED</span>
            <span class="comment">// SMART CONTRACT (this time with the SERVER&#39;s signature on it.)</span>
            <span class="comment">//</span>
            <span class="comment">// Here&#39;s the original one going onto the transaction:</span>
            <span class="comment">//</span>
            pTransParty-&gt;<a class="code" href="class_o_t_transaction_type.html#a9dd50265579347d2e8fa3ea36ca66320">SetReferenceString</a>(strOrigPlan);


            <span class="comment">// --------------------------------------------------------------------------</span>
            <span class="comment">//</span>
            <span class="comment">// MOVE THE DIGITAL ASSETS FROM ONE ACCOUNT TO ANOTHER...</span>
            <span class="comment">//</span>
            <span class="comment">// Calculate the amount and debit/ credit the accounts</span>
            <span class="comment">// Make sure each Account can afford it, and roll back in case of failure.</span>


            <span class="comment">// Normally if you stash 10 clams, then your account is -10 clams, and your stash is +10 clams.</span>
            <span class="comment">// Therefore if you unstash 5 gg, then your gg acct is +5 grams and your stash is -5 grams.</span>
            <span class="comment">//</span>
            <span class="comment">// Thus if lAmount is &gt; 0, as normal, that amount should be DEBITED from the Party Acct, and CREDITED to the Stash Acct.</span>
            <span class="comment">// Whereas if lAmount were &lt; 0, then that amount should be DEBITED from the Stash Acct, and CREDITED to the Party Acct.</span>

            <span class="keywordtype">bool</span> bMoveParty = <span class="keyword">false</span>;
            <span class="keywordtype">bool</span> bMoveStash = <span class="keyword">false</span>;

            <span class="comment">// ----------------------------------------------------------------------</span>
            <span class="keywordflow">if</span> (bUnstashing)  <span class="comment">//  Debit Stash, Credit Party</span>
            {
                <span class="keywordflow">if</span> (pStashAccount-&gt;GetBalance() &gt;= lAbsoluteAmount)
                {
                    <span class="comment">// Debit the stash account.</span>
                    bMoveStash  = pStashAccount-&gt;Debit(lAbsoluteAmount); <span class="comment">// &lt;====== DEBIT FUNDS</span>

                    <span class="comment">// IF success, credit the party.</span>
                    <span class="keywordflow">if</span> (bMoveStash)
                    {
                        bMoveParty  = pPartyAssetAcct-&gt;<a class="code" href="class_o_t_account.html#a9ae37832775933112ad874a9a9110c8b">Credit</a>(lAbsoluteAmount); <span class="comment">// &lt;=== CREDIT FUNDS</span>

                        <span class="comment">// Okay, we already took it from the stash account.</span>
                        <span class="comment">// But if we FAIL to credit the party, then we need to PUT IT BACK in the stash acct.</span>
                        <span class="comment">// (EVEN THOUGH we&#39;ll just &quot;NOT SAVE&quot; after any failure, so it&#39;s really superfluous.)</span>
                        <span class="comment">//</span>
                        <span class="keywordflow">if</span> (! bMoveParty )
                        {
                            <span class="keywordtype">bool</span> bErr = pStashAccount-&gt;Credit(lAbsoluteAmount); <span class="comment">// put the money back</span>

                            <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;OTSmartContract::StashFunds: While succeeded debiting the stash account, FAILED in: pPartyAssetAcct-&gt;Credit(lAbsoluteAmount); \n&quot;</span>
                                          <span class="stringliteral">&quot;Also, tried to credit stash account back again. Result: %s.\n&quot;</span>, bErr ? <span class="stringliteral">&quot;success&quot;</span> : <span class="stringliteral">&quot;failure&quot;</span>);
                        }
                        <span class="keywordflow">else</span>
                        {   <span class="comment">// SUCCESS!</span>
                            <span class="comment">//</span>
                            <span class="keywordtype">bool</span> bStashSuccess = pStashItem-&gt;<a class="code" href="class_o_t_stash_item.html#a71317c63628ef272f79ccd00a1e77876">DebitStash</a>(lAbsoluteAmount); <span class="comment">// we already verified above that this stash item has enough funds to successfully debit.</span>

                            <span class="keywordflow">if</span> (bStashSuccess)
                                bSuccess = <span class="keyword">true</span>;
                            <span class="keywordflow">else</span>
                                <a class="code" href="class_o_t_log.html#a5acd90ac91c2618f395b0ff37ad4f8ee">OTLog::Error</a>(<span class="stringliteral">&quot;OTSmartContract::StashFunds: ERROR: Debited stash account and credited party account, but &quot;</span>
                                             <span class="stringliteral">&quot;then unable to debit the stash record inside the smart contract itself.\n&quot;</span>);
                        }
                    }
                    <span class="keywordflow">else</span>
                    {
                        <a class="code" href="class_o_t_log.html#a5acd90ac91c2618f395b0ff37ad4f8ee">OTLog::Error</a>(<span class="stringliteral">&quot;OTSmartContract::StashFunds: FAILED in:  pStashAccount-&gt;Debit(lAbsoluteAmount);\n&quot;</span>);
                    }
                }
            }
            <span class="comment">// --------------------------------------------------------------------------</span>
            <span class="keywordflow">else</span> <span class="comment">// Debit party, Credit Stash</span>
            {
                <span class="keywordflow">if</span> (pPartyAssetAcct-&gt;<a class="code" href="class_o_t_account.html#a77fbaae9496caec7cd899721971a89c0">GetBalance</a>() &gt;= lAbsoluteAmount)
                {
                    <span class="comment">// Debit the party account.</span>
                    bMoveParty  = pPartyAssetAcct-&gt;<a class="code" href="class_o_t_account.html#a893c8f197912e9270495f960804b7a5f">Debit</a>(lAbsoluteAmount); <span class="comment">// &lt;====== DEBIT FUNDS</span>

                    <span class="comment">// IF success, credit the Stash.</span>
                    <span class="keywordflow">if</span> (bMoveParty)
                    {
                        bMoveStash  = pStashAccount-&gt;Credit(lAbsoluteAmount); <span class="comment">// &lt;=== CREDIT FUNDS</span>

                        <span class="comment">// Okay, we already took it from the party account.</span>
                        <span class="comment">// But if we FAIL to credit the Stash, then we need to PUT IT BACK in the party acct.</span>
                        <span class="comment">// (EVEN THOUGH we&#39;ll just &quot;NOT SAVE&quot; after any failure, so it&#39;s really superfluous.)</span>
                        <span class="comment">//</span>
                        <span class="keywordflow">if</span> (!bMoveStash)
                        {
                            <span class="keywordtype">bool</span> bErr = pPartyAssetAcct-&gt;<a class="code" href="class_o_t_account.html#a9ae37832775933112ad874a9a9110c8b">Credit</a>(lAbsoluteAmount); <span class="comment">// put the money back</span>

                            <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;OTSmartContract::StashFunds: While succeeded debiting the asset account, FAILED in: pStashAccount-&gt;Credit(lAbsoluteAmount); \n&quot;</span>
                                          <span class="stringliteral">&quot;Also, tried to credit asset account back again. Result: %s.\n&quot;</span>, bErr ? <span class="stringliteral">&quot;success&quot;</span> : <span class="stringliteral">&quot;failure&quot;</span>);
                        }
                        <span class="keywordflow">else</span>
                        {   <span class="comment">// SUCCESS!</span>
                            <span class="comment">//</span>
                            <span class="keywordtype">bool</span> bStashSuccess = pStashItem-&gt;<a class="code" href="class_o_t_stash_item.html#a15a43b1d15d5d924f5f5116ea82d290e">CreditStash</a>(lAbsoluteAmount); <span class="comment">// we already verified above that this stash item has enough funds to successfully debit.</span>

                            <span class="keywordflow">if</span> (bStashSuccess)
                                bSuccess = <span class="keyword">true</span>;
                            <span class="keywordflow">else</span>
                                <a class="code" href="class_o_t_log.html#a5acd90ac91c2618f395b0ff37ad4f8ee">OTLog::Error</a>(<span class="stringliteral">&quot;OTSmartContract::StashFunds: ERROR: Debited party account and credited stash account, but &quot;</span>
                                             <span class="stringliteral">&quot;then unable to credit the stash record inside the smart contract itself.\n&quot;</span>);
                        }
                    }
                    <span class="keywordflow">else</span>
                    {
                        <a class="code" href="class_o_t_log.html#a5acd90ac91c2618f395b0ff37ad4f8ee">OTLog::Error</a>(<span class="stringliteral">&quot;OTSmartContract::StashFunds: FAILED in:  pPartyAssetAcct-&gt;Debit(lAbsoluteAmount);\n&quot;</span>);
                    }
                }
            }
            <span class="comment">// ----------------------------------------------------------------------</span>
            <span class="comment">//</span>
            <span class="comment">// If ANY of these failed, then roll them all back and break.</span>
            <span class="comment">// (In fact we could just be checking bSuccess here, I wager.</span>
            <span class="comment">// Might as well be thorough.)</span>
            <span class="comment">//</span>
            <span class="keywordflow">if</span> (!bMoveParty || !bMoveStash)
            {
                <span class="comment">// No need to roll back pStashItem here, since it is never changed in the</span>
                <span class="comment">// first place unless BOTH of the above bools were successful.</span>

                <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;OTSmartContract::StashFunds: Very strange! Funds were available but &quot;</span>
                              <span class="stringliteral">&quot;debit %s or credit %s failed while performing move.\n&quot;</span>,
                              (bUnstashing) ? <span class="stringliteral">&quot;stash&quot;</span> : <span class="stringliteral">&quot;party&quot;</span>,
                              (bUnstashing) ? <span class="stringliteral">&quot;party&quot;</span> : <span class="stringliteral">&quot;stash&quot;</span>);
                <span class="comment">// We won&#39;t save the files anyway, if this failed.</span>
                bSuccess = <span class="keyword">false</span>;
            }
            <span class="comment">// --------------------------------------------------------------------------</span>
            <span class="comment">//</span>
            <span class="comment">// DO NOT SAVE ACCOUNTS if bSuccess is false.</span>
            <span class="comment">// We only save these accounts if bSuccess == true.</span>
            <span class="comment">// (But we do save the inboxes either way, since payment failures always merit an inbox notice.)</span>
            <span class="comment">//</span>
            <span class="keywordflow">if</span> (<span class="keyword">true</span> == bSuccess) <span class="comment">// The payment succeeded.</span>
            {
                <span class="comment">// The party needs to get a receipt in his inbox.</span>
                <span class="comment">//</span>
                pItemParty-&gt;<a class="code" href="class_o_t_item.html#a789aa4148a0add3092e16c4221bf5844">SetStatus</a>(<a class="code" href="class_o_t_item.html#a61e86f5b6c64a518664123907235f376aa099f14a8a9ef5987b1161b764895cdf">OTItem::acknowledgement</a>); <span class="comment">// pPartyAssetAcct</span>

                <span class="keyword">const</span> int64_t lReceiptAmount = (lAmount*(-1));

<span class="comment">//              pItemParty-&gt;SetAmount(lAmount); // lAmount is already negative or positive by the time it&#39;s passed into this function.</span>
                pItemParty-&gt;<a class="code" href="class_o_t_item.html#a81d53d2910a45fdbb11d92ae680519fb">SetAmount</a>(lReceiptAmount);  <span class="comment">// However, if we are stashing 100, that means my account is -100. Therefore multiply by (-1) EITHER WAY.</span>
<span class="comment">//              pItemParty-&gt;SetAmount(lAbsoluteAmount*(-1));    // &quot;paymentReceipt&quot; is otherwise ambigious about whether you are paying or being paid.</span>
                <span class="comment">// This is also like market receipts, which use negative and positive amounts.</span>

                <a class="code" href="class_o_t_log.html#a1f7549d776ee919dcb6517f611ded015">OTLog::Output</a>(0, <span class="stringliteral">&quot;OTSmartContract::StashFunds: Move performed.\n&quot;</span>);

                <span class="comment">// (I do NOT save m_pCron here, since that already occurs after this function is called.)</span>
            }
            <span class="keywordflow">else</span> <span class="comment">// bSuccess = false.  The payment failed.</span>
            {
                pItemParty-&gt;<a class="code" href="class_o_t_item.html#a789aa4148a0add3092e16c4221bf5844">SetStatus</a>(<a class="code" href="class_o_t_item.html#a61e86f5b6c64a518664123907235f376adbeae2ab1504a5ef318da097d21119db">OTItem::rejection</a>);<span class="comment">// pPartyAssetAcct     // These are already initialized to false.</span>
                pItemParty-&gt;<a class="code" href="class_o_t_item.html#a81d53d2910a45fdbb11d92ae680519fb">SetAmount</a>(0);       <span class="comment">// No money changed hands. Just being explicit.</span>

                <a class="code" href="class_o_t_log.html#a1f7549d776ee919dcb6517f611ded015">OTLog::Output</a>(0, <span class="stringliteral">&quot;OTSmartContract::StashFunds: Move failed.\n&quot;</span>);
            }

            <span class="comment">// Everytime a payment processes, a receipt is put in the user&#39;s inbox, containing a</span>
            <span class="comment">// CURRENT copy of the cron item (which took just money from the user&#39;s acct, or not,</span>
            <span class="comment">// and either way thus updated its status -- so its internal state has changed.)</span>
            <span class="comment">//</span>
            <span class="comment">// It will also contain a copy of the user&#39;s ORIGINAL signed cron item, where the data</span>
            <span class="comment">// has NOT changed, (so the user&#39;s original signature is still good.) Although in the case of</span>
            <span class="comment">// smart contracts, each party stores their own signed copy anyway, so it doesn&#39;t matter as</span>
            <span class="comment">// much.</span>
            <span class="comment">//</span>
            <span class="comment">// In order for it to export the RIGHT VERSION of the CURRENT smart contract, which has just</span>
            <span class="comment">// changed (above), then I need to re-sign it and save it first. (The original version I&#39;ll</span>
            <span class="comment">// load from a separate file using OTSmartContract::LoadCronReceipt(lTransactionNum).</span>
            <span class="comment">//</span>
            <span class="comment">// I should be able to call a method on the original cronitem, where I ask it to verify a certain</span>
            <span class="comment">// nym as being acceptable to that cron item as an agent, based on the signature of the original</span>
            <span class="comment">// authorizing agent for that party. UPDATE: I believe the function described in this paragraph</span>
            <span class="comment">// is now done.</span>
            <span class="comment">//</span>

            this-&gt;<a class="code" href="class_o_t_contract.html#aae54340526fbd8eb8a18de27a4b97c83">ReleaseSignatures</a>();
            this-&gt;<a class="code" href="class_o_t_contract.html#abd60037fe655ee8cae9a3ece5d1e2ea6">SignContract</a>(*pServerNym);
            this-&gt;<a class="code" href="class_o_t_contract.html#a363ae430d4fd9256ab8364dbafb95444">SaveContract</a>();

            <span class="comment">// -----------------------------------------------------------------</span>
            <span class="comment">//</span>
            <span class="comment">// EVERYTHING BELOW is just about notifying the party, by dropping the receipt in his</span>
            <span class="comment">// inbox. The rest is done.  The two accounts and the inbox will all be saved at the same time.</span>
            <span class="comment">//</span>
            <span class="comment">// The Smart Contract is entirely updated and saved by this point, and Cron will</span>
            <span class="comment">// also be saved in the calling function once we return (no matter what.)</span>
            <span class="comment">//</span>
            <span class="comment">// ----------------------------------------------------------------</span>

            <span class="comment">// Basically I load up the INBOX, which is actually a LEDGER, and then I create</span>
            <span class="comment">// a new transaction, with a new transaction item, for that ledger.</span>
            <span class="comment">// (That&#39;s where the receipt information goes.)</span>
            <span class="comment">//</span>
            <span class="comment">// -----------------------------------------------------------------</span>

            <span class="comment">// The TRANSACTION will be sent with &quot;In Reference To&quot; information containing the</span>
            <span class="comment">// ORIGINAL SIGNED SMART CONTRACT. (With both of the users&#39; original signatures on it.)</span>
            <span class="comment">//</span>
            <span class="comment">// Whereas the TRANSACTION ITEM will include an &quot;attachment&quot; containing the UPDATED</span>
            <span class="comment">// SMART CONTRACT (this time with the SERVER&#39;s signature on it.)</span>

            <span class="comment">// (Lucky I just signed and saved the updated smart contract (above), or it would still have</span>
            <span class="comment">// have the old data in it.)</span>

            <span class="comment">// I also already loaded the original smart contact. Remember this from above,</span>
            <span class="comment">// near the top of the function:</span>
            <span class="comment">//  OTSmartContract * pOrigCronItem = NULL;</span>
            <span class="comment">//  OTString strOrigPlan(*pOrigCronItem); // &lt;====== Farther down in the code, I attach this string to the receipts.</span>
            <span class="comment">//  ... then lower down...</span>
            <span class="comment">// pTransParty-&gt;SetReferenceString(strOrigPlan);</span>
            <span class="comment">//</span>
            <span class="comment">// So the original plan is already loaded and copied to the Transaction as the &quot;In Reference To&quot;</span>
            <span class="comment">// Field. Now let&#39;s add the UPDATED plan as an ATTACHMENT on the Transaction ITEM:</span>
            <span class="comment">//</span>
            <span class="comment">// -----------------------------------------------------</span>
            <span class="comment">//</span>

            <a class="code" href="class_o_t_string.html">OTString</a>    strUpdatedCronItem(*<span class="keyword">this</span>);

            <span class="comment">// Set the updated cron item as the attachment on the transaction item.</span>
            <span class="comment">// (With the SERVER&#39;s signature on it!)</span>
            <span class="comment">// (As a receipt for the party, so they can see their smartcontract updating.)</span>
            <span class="comment">//</span>
            pItemParty-&gt;<a class="code" href="class_o_t_item.html#a6e5e9b0c04cb1eca8acaec5b0be1d641">SetAttachment</a>(strUpdatedCronItem);

            <span class="comment">// -----------------------------------------------------------------</span>

            <span class="comment">// Success OR failure, either way I want a receipt in the inbox.</span>
            <span class="comment">// ===&gt; But if FAILURE, I do NOT want to save the Accounts, JUST the inbox!!</span>
            <span class="comment">//</span>
            <span class="comment">// (So the inbox happens either way, but the accounts are saved only on success.)</span>

            <span class="comment">// sign the item</span>
            pItemParty-&gt;<a class="code" href="class_o_t_contract.html#abd60037fe655ee8cae9a3ece5d1e2ea6">SignContract</a>(*pServerNym);
            pItemParty-&gt;<a class="code" href="class_o_t_contract.html#a363ae430d4fd9256ab8364dbafb95444">SaveContract</a>();

            <span class="comment">// the Transaction &quot;owns&quot; the item now and will handle cleaning it up.</span>
            pTransParty-&gt;<a class="code" href="class_o_t_transaction.html#a5abc071b7eeddc40ea151cccd011e4d6">AddItem</a>(*pItemParty);
            pTransParty-&gt;<a class="code" href="class_o_t_contract.html#abd60037fe655ee8cae9a3ece5d1e2ea6">SignContract</a>(*pServerNym);
            pTransParty-&gt;<a class="code" href="class_o_t_contract.html#a363ae430d4fd9256ab8364dbafb95444">SaveContract</a>();

            <span class="comment">// -------------------------------------------</span>
            <span class="comment">// Here, the transaction we just created is actually added to the inbox ledger.</span>
            <span class="comment">// This happens either way, success or fail.</span>

            thePartyInbox.AddTransaction(*pTransParty);

            <span class="comment">// -------------------------------------------</span>
            <span class="comment">// Release any signatures that were there before (They won&#39;t</span>
            <span class="comment">// verify anymore anyway, since the content has changed.)</span>
            <span class="comment">//</span>
            thePartyInbox.ReleaseSignatures();
            thePartyInbox.SignContract(*pServerNym);
            thePartyInbox.SaveContract();
            <span class="comment">// ------------------------------</span>

            pPartyAssetAcct-&gt;<a class="code" href="class_o_t_account.html#a81e503e95310da5ac9c2003cb00d6d2e">SaveInbox</a>(thePartyInbox);

            <span class="comment">// This corresponds to the AddTransaction() call just above.</span>
            <span class="comment">// These are stored in a separate file now.</span>
            <span class="comment">//</span>
            pTransParty-&gt;<a class="code" href="class_o_t_transaction.html#a2f991feb7c6178ffabefc7fef312d26e">SaveBoxReceipt</a>(thePartyInbox);

            <span class="comment">// temp remove todo</span>
<span class="comment">//          OTString strTempDebug(PARTY_ACCT_ID), strTempDebug2(PARTY_USER_ID), strTempDebug3(thePartyInbox);</span>
<span class="comment">//          OTLog::vError(&quot;OTSmartContract::StashFunds: Finished saving Inbox with new receipt %lld (re: trans %lld by way of %lld) in it, for account: %s, user: %s. Status: %s\n&quot;</span>
<span class="comment">//                        &quot;INBOX CONTENTS: \n\n%s\n\n&quot;,</span>
<span class="comment">//                        lNewTransactionNumber, GetTransactionNum(), lPartyTransRefNo, strTempDebug.Get(), strTempDebug2.Get(), bSuccess ? &quot;SUCCESS&quot; : &quot;FAILURE&quot;,</span>
<span class="comment">//                        strTempDebug3.Get());</span>



            <span class="comment">// If success, save the accounts with new balance. (Save inboxes with receipts either way,</span>
            <span class="comment">// and the receipts will contain a rejection or acknowledgment stamped by the Server Nym.)</span>
            <span class="comment">//</span>
            <span class="keywordflow">if</span> (<span class="keyword">true</span> == bSuccess)
            {
                <span class="comment">// SAVE THE ACCOUNTS.</span>
                <span class="comment">// -------------------------------------------</span>
                <span class="comment">// Release any signatures that were there before (They won&#39;t</span>
                <span class="comment">// verify anymore anyway, since the content has changed.)</span>
                <span class="comment">//</span>
                pPartyAssetAcct-&gt;   <a class="code" href="class_o_t_contract.html#aae54340526fbd8eb8a18de27a4b97c83">ReleaseSignatures</a>();
                pStashAccount-&gt;     <a class="code" href="class_o_t_contract.html#aae54340526fbd8eb8a18de27a4b97c83">ReleaseSignatures</a>();

                <span class="comment">// Sign both of them.</span>
                pPartyAssetAcct-&gt;   <a class="code" href="class_o_t_contract.html#abd60037fe655ee8cae9a3ece5d1e2ea6">SignContract</a>(*pServerNym);
                pStashAccount-&gt;     <a class="code" href="class_o_t_contract.html#abd60037fe655ee8cae9a3ece5d1e2ea6">SignContract</a>(*pServerNym);

                <span class="comment">// Save both of them internally</span>
                pPartyAssetAcct-&gt;   <a class="code" href="class_o_t_contract.html#a363ae430d4fd9256ab8364dbafb95444">SaveContract</a>();
                pStashAccount-&gt;     <a class="code" href="class_o_t_contract.html#a363ae430d4fd9256ab8364dbafb95444">SaveContract</a>();

                <span class="comment">// TODO: Better rollback capabilities in case of failures here:</span>

                <span class="comment">// Save both accounts to storage.</span>
                pPartyAssetAcct-&gt;   SaveAccount();
                pStashAccount-&gt;     SaveAccount();
                <span class="comment">// NO NEED TO LOG HERE, since success / failure is already logged above.</span>
            }
        } <span class="comment">// the inbox was successfully loaded or generated.</span>
    } <span class="comment">// By the time we enter this block, accounts and nyms are already loaded. As we begin, inboxes are instantiated.</span>


    <span class="comment">// Either way, Cron should save, since it just updated.</span>
    <span class="comment">// The above function call WILL change this smart contract</span>
    <span class="comment">// and re-sign it and save it, no matter what. So I just</span>
    <span class="comment">// call this here to keep it simple:</span>

    pCron-&gt;<a class="code" href="class_o_t_cron.html#a24df32b4bf36e48867e7afda0955bb72">SaveCron</a>();  <span class="comment">// TODO No need to call this here if I can make sure it&#39;s being called higher up somewhere</span>
                        <span class="comment">// (Imagine a script that has 10 account moves in it -- maybe don&#39;t need to save cron until</span>
                        <span class="comment">// after all 10 are done. Or maybe DO need to do in between. Todo research this. Optimization.)</span>
    <span class="keywordflow">return</span> bSuccess;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a7be637de24a11ebd872822b84952c21a"></a><!-- doxytag: member="OTSmartContract::UnstashAcctFunds" ref="a7be637de24a11ebd872822b84952c21a" args="(const std::string to_acct_name, const std::string from_stash_name, const std::string str_Amount)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_o_t_smart_contract.html#a7be637de24a11ebd872822b84952c21a">OTSmartContract::UnstashAcctFunds</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>to_acct_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>from_stash_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>str_Amount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_o_t_smart_contract_8cpp_source.html#l01838">1838</a> of file <a class="el" href="_o_t_smart_contract_8cpp_source.html">OTSmartContract.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
    <a class="code" href="class_o_t_cron.html">OTCron</a> * pCron  = <a class="code" href="class_o_t_cron_item.html#af734ad5d309fcc9b4a60d40d6c30f55a">GetCron</a>();
    <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != pCron);
    <span class="comment">// ----------------------------------</span>
    <a class="code" href="class_o_t_pseudonym.html">OTPseudonym</a> * pServerNym = pCron-&gt;<a class="code" href="class_o_t_cron.html#a7756d0dcc047209ca87632939dc11db3">GetServerNym</a>();
    <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != pServerNym);
    <span class="comment">// ---------------------------------------------------</span>
    <span class="comment">// Below this point, these are all good:</span>
    <span class="comment">//</span>
    <span class="comment">//      pServerNym, pCron.</span>
    <span class="comment">//</span>
    <span class="comment">// ---------------------------------------------------</span>
    <span class="keywordflow">if</span> (str_Amount.size() &lt; 1)
    {
        <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(0, <span class="stringliteral">&quot;OTSmartContract::UnstashAcctFunds: Error: empty amount.\n&quot;</span>);
        <span class="keywordflow">return</span> <span class="keyword">false</span>;
    }

    <span class="keyword">const</span> int64_t lAmount =  atol(str_Amount.c_str());

    <span class="keywordflow">if</span> (lAmount &lt;= 0)
    {
        <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(0, <span class="stringliteral">&quot;OTSmartContract::UnstashAcctFunds: Error: lAmount cannot be 0 or &lt;0. (Value passed in was %lld.)\n&quot;</span>,
                       lAmount);
        <span class="keywordflow">return</span> <span class="keyword">false</span>;
    }
    <span class="comment">// -----------------------------</span>
    <span class="keywordflow">if</span> (to_acct_name.size() &lt;= 0)
    {
        <a class="code" href="class_o_t_log.html#a5acd90ac91c2618f395b0ff37ad4f8ee">OTLog::Error</a>(<span class="stringliteral">&quot;OTSmartContract::UnstashAcctFunds: error: to_acct_name is non-existent.\n&quot;</span>);
        <span class="keywordflow">return</span> <span class="keyword">false</span>;
    }
    <span class="keywordflow">if</span> (from_stash_name.size() &lt;= 0)
    {
        <a class="code" href="class_o_t_log.html#a5acd90ac91c2618f395b0ff37ad4f8ee">OTLog::Error</a>(<span class="stringliteral">&quot;OTSmartContract::UnstashAcctFunds: error: from_stash_name is non-existent.\n&quot;</span>);
        <span class="keywordflow">return</span> <span class="keyword">false</span>;
    }
    <span class="comment">// ---------------------------------------------------</span>
    <span class="comment">// Below this point, these are all good:</span>
    <span class="comment">//</span>
    <span class="comment">//      to_acct_name,</span>
    <span class="comment">//      from_stash_name,</span>
    <span class="comment">//      pServerNym, pCron.</span>
    <span class="comment">//</span>
    <span class="comment">// ---------------------------------------------------</span>

    <a class="code" href="class_o_t_party_account.html">OTPartyAccount</a>  * pToAcct   = this-&gt;<a class="code" href="class_o_t_scriptable.html#a94c9e55f78357e04e4b9781ab662370f">GetPartyAccount</a>(to_acct_name);
    <a class="code" href="class_o_t_stash.html">OTStash</a>         * pStash    = this-&gt;<a class="code" href="class_o_t_smart_contract.html#af7305d13e0ac4c2bef284658bdd9ec67">GetStash</a>(from_stash_name); <span class="comment">// This ALWAYS succeeds. (It will OT_ASSERT() if failure.)</span>

    <span class="keywordflow">if</span> (NULL == pToAcct)
    {
        <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(0, <span class="stringliteral">&quot;OTSmartContract::UnstashAcctFunds: error: to_acct (%s) not found on any party.\n&quot;</span>,
                       to_acct_name.c_str());
        <span class="keywordflow">return</span> <span class="keyword">false</span>;
    }
    <span class="comment">// ---------------------------------------------------</span>
    <span class="comment">//</span>
    <span class="comment">// Below this point, these are all good:</span>
    <span class="comment">//</span>
    <span class="comment">//      pToAcct,    to_acct_name,</span>
    <span class="comment">//      pStash,     from_stash_name,</span>
    <span class="comment">//      pServerNym, pCron.</span>
    <span class="comment">//</span>
    <span class="comment">// ---------------------------------------------------</span>

    <a class="code" href="class_o_t_agent.html">OTAgent</a> * pToAgent  = pToAcct-&gt; GetAuthorizedAgent(); <span class="comment">// This searches the account&#39;s party for the account&#39;s authorized agent.</span>
    <span class="comment">// (That way it&#39;s impossible to get an agent for any other party.)</span>

    <span class="keywordflow">if</span> (NULL == pToAgent)
    {
        <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(0, <span class="stringliteral">&quot;OTSmartContract::UnstashAcctFunds: error: authorized agent (%s) not found for to_acct (%s) on acct&#39;s party.\n&quot;</span>,
                       pToAcct-&gt;<a class="code" href="class_o_t_party_account.html#a86975046b18ac6d6c5841f5ba0befe69">GetAgentName</a>().<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>(), to_acct_name.c_str());
        <span class="keywordflow">return</span> <span class="keyword">false</span>;
    }
    <span class="comment">// ---------</span>
    <span class="keywordflow">if</span> (<span class="keyword">false</span> == pToAgent-&gt;<a class="code" href="class_o_t_agent.html#a1969e4f8a5f13ee34ba0a68d8f082956">IsAnIndividual</a>())
    {
        <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(0, <span class="stringliteral">&quot;OTSmartContract::UnstashAcctFunds: error: authorized agent (%s) for to_acct (%s) is not an active agent.\n&quot;</span>,
                       pToAcct-&gt;<a class="code" href="class_o_t_party_account.html#a86975046b18ac6d6c5841f5ba0befe69">GetAgentName</a>().<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>(), to_acct_name.c_str());
        <span class="keywordflow">return</span> <span class="keyword">false</span>;
    }
    <span class="comment">//</span>
    <span class="comment">// Below this point, these are all good:</span>
    <span class="comment">//</span>
    <span class="comment">//      pToAcct,    to_acct_name,       pToAgent,</span>
    <span class="comment">//      pStash,     from_stash_name,</span>
    <span class="comment">//      pServerNym, pCron.</span>
    <span class="comment">//</span>
    <span class="comment">// ---------------------------------------------------</span>

    <a class="code" href="class_o_t_party.html">OTParty</a> * pToParty  = pToAgent-&gt;<a class="code" href="class_o_t_agent.html#a929a2489984f5487bd1819ed6d8862f2">GetParty</a>();

    <span class="keywordflow">if</span> (NULL == pToParty)
    {
        <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;OTSmartContract::UnstashAcctFunds: error: Party pointer NULL on authorized agent (%s) for to_acct (%s).\n&quot;</span>,
                      pToAcct-&gt;<a class="code" href="class_o_t_party_account.html#a86975046b18ac6d6c5841f5ba0befe69">GetAgentName</a>().<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>(), to_acct_name.c_str());
        <span class="keywordflow">return</span> <span class="keyword">false</span>;
    }
    <span class="comment">//</span>
    <span class="comment">// Below this point, these are all good:</span>
    <span class="comment">//</span>
    <span class="comment">//      pToAcct,    to_acct_name,       pToAgent,   pToParty,</span>
    <span class="comment">//      pStash,     from_stash_name,</span>
    <span class="comment">//      pServerNym, pCron.</span>
    <span class="comment">//</span>
    <span class="comment">// ---------------------------------------------------</span>


    <span class="comment">// Done: I can see that THIS VERIFICATION CODE WILL GET CALLED EVERY SINGLE TIME THE SCRIPT</span>
    <span class="comment">// CALLS MOVE FUNDS.  Maybe that&#39;s good, but since technically this only needs to be verified before the</span>
    <span class="comment">// first call, and not for EVERY call during any of a script&#39;s runs, I should probably move this verification</span>
    <span class="comment">// higher, such as each time the OTCronItem triggers, plus each time a party triggers a clause directly</span>
    <span class="comment">// through the API (server message). As long as those are covered, I will be able to remove it from here</span>
    <span class="comment">// which should be a significant improvement for performance.</span>
    <span class="comment">// It will be at the bottom of those same functions that &quot;ClearTemporaryPointers()&quot; should finally be called.</span>
    <span class="comment">//</span>
    <span class="comment">// FINAL DECISION: Redundant, removed. See comments in StashAcctFunds().</span>
    <span class="comment">//</span>
<span class="comment">//  const OTString strServerID(GetServerID());</span>
<span class="comment">//</span>
<span class="comment">//  mapOfNyms   map_Nyms_Already_Loaded;</span>
<span class="comment">//  this-&gt;RetrieveNymPointers(map_Nyms_Already_Loaded);</span>
<span class="comment">//  // --------------------------------------------------</span>
<span class="comment">//</span>
<span class="comment">//  if (false == this-&gt;VerifyPartyAuthorization(*pToParty, *pServerNym, strServerID, &amp;map_Nyms_Already_Loaded))</span>
<span class="comment">//  {</span>
<span class="comment">//      OTLog::vError(&quot;OTSmartContract::UnstashAcctFunds: error: &#39;To&#39; Party (%s) not authorized for this contract.\n&quot;,</span>
<span class="comment">//                    pToParty-&gt;GetPartyName().c_str());</span>
<span class="comment">//      return false;</span>
<span class="comment">//  }</span>
    <span class="comment">// *****************************************************************************</span>

    <span class="comment">// A party might have many agents who are only voting groups, and cannot actually sign for things</span>
    <span class="comment">// the way that nyms can. But at least ONE of those agents IS a Nym -- because there must have been</span>
    <span class="comment">// an authorizing agent who initially signed to accept the agreement, and who fronted the opening</span>
    <span class="comment">// transaction number that activated it.</span>
    <span class="comment">//</span>
    <span class="comment">// Similarly, the authorized agent for any given party&#39;s account (each account has its own authorized</span>
    <span class="comment">// agent) MUST be an active agent (an active agent is one with a Nym--whether that Nym is representing</span>
    <span class="comment">// himself as the party, or whether representing some entity as an employee in a role). Why MUST the</span>
    <span class="comment">// authorized agent be an active agent? Because when funds are moved, that Nym must be loaded since</span>
    <span class="comment">// the account must show that Nym as a legal owner/agent. The MoveFunds will cause a paymentReceipt to</span>
    <span class="comment">// drop into the Inbox for the relevant asset accounts, and that paymentReceipt can ONLY be accepted</span>
    <span class="comment">// by that same Nym, who must use a transaction # that he signed for previously and received through</span>
    <span class="comment">// his nymbox. There is actually no justification at all to take funds from that account, since the</span>
    <span class="comment">// new balance has not yet been signed, UNLESS THE PAYMENTRECEIPT CONTAINS A VALID, SIGNED AUTHORIZATION</span>
    <span class="comment">// FROM THE ACCOUNT HOLDER. *That* is why the authorizing agent must either be the Party&#39;s Owner himself</span>
    <span class="comment">// (representing himself as an agent, which most will do) in which case he will appear as the valid</span>
    <span class="comment">// owner of the account, OR he MUST be a Nym working in a Valid Role for an Entity, where said Entity is</span>
    <span class="comment">// the valid owner on the account in question. Either OT, it will be possible in OT for him to sign for</span>
    <span class="comment">// the paymentReceipts when they come in, and impossible for him to escape liability for them.</span>
    <span class="comment">// (That&#39;s the idea anyway.)</span>
    <span class="comment">//</span>
    <span class="comment">// Since we know that the Authorized Agent for an account must be an ACTIVE agent (one way or the other)</span>
    <span class="comment">// then we can error out here if he&#39;s not.  We can then pass in his Nym ID.</span>
    <span class="comment">//</span>

    <a class="code" href="class_o_t_identifier.html">OTIdentifier</a> theToAgentID;
    <span class="keyword">const</span> <span class="keywordtype">bool</span> bToAgentID   = pToAgent-&gt;<a class="code" href="class_o_t_agent.html#a7750c7f5840047c5413d95e92ad87578">GetSignerID</a>(theToAgentID);

    <span class="keywordflow">if</span> ( ! bToAgentID )
    {
        <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;OTSmartContract::UnstashAcctFunds: Failed to find &#39;To&#39; Agent&#39;s Signer ID: %s \n&quot;</span>,
                      pToAgent-&gt;<a class="code" href="class_o_t_agent.html#a123d27f05e46977ecdbe0b83de3c119d">GetName</a>().<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>());
        <span class="keywordflow">return</span> <span class="keyword">false</span>;
    }
    <span class="comment">// --------------------------------------</span>

    <span class="keywordflow">if</span> (!pToAcct-&gt;<a class="code" href="class_o_t_party_account.html#aa5e4e0cc77853d08b3708017fe694876">GetAcctID</a>().<a class="code" href="class_o_t_string.html#adf7489cd917d4ae5bf30853a3ad78daf">Exists</a>())
    {
        <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;OTSmartContract::UnstashAcctFunds: Error: ToAcct has empty AcctID: %s \n&quot;</span>,
                      to_acct_name.c_str());
        <span class="keywordflow">return</span> <span class="keyword">false</span>;
    }

    <span class="keyword">const</span> <a class="code" href="class_o_t_identifier.html">OTIdentifier</a> theToAcctID(pToAcct-&gt;<a class="code" href="class_o_t_party_account.html#aa5e4e0cc77853d08b3708017fe694876">GetAcctID</a>());
    <span class="comment">//</span>
    <span class="comment">// BELOW THIS POINT, theToAcctID and theToAgentID available.</span>
    <span class="comment">// --------------------------------------</span>

    <span class="comment">// WE SET THESE HERE SO THE RECEIPT SHOWS, SUCCESS OR FAIL,</span>
    <span class="comment">// WHO THE INTENDED SENDER / RECIPIENT ARE FOR THAT RECEIPT.</span>
    <span class="comment">//</span>
    <a class="code" href="class_o_t_smart_contract.html#a09de789ac2e616e2119feb9ddf416c9d">ReleaseLastSenderRecipientIDs</a>();
    <span class="comment">// -------------------------</span>
<span class="comment">//  theFromAgentID.GetString(m_strLastSenderUser);  // This is the last User ID of a party who SENT money.</span>
<span class="comment">//  theFromAcctID.GetString(m_strLastSenderAcct);   // This is the last Acct ID of a party who SENT money.</span>
    theToAgentID.<a class="code" href="class_o_t_identifier.html#a4bccb30446b4b515d9d6016b86b260bb">GetString</a>(m_strLastRecipientUser); <span class="comment">// This is the last User ID of a party who RECEIVED money.</span>
    theToAcctID.GetString(m_strLastRecipientAcct);  <span class="comment">// This is the last Acct ID of a party who RECEIVED money.</span>
    <span class="comment">// Above: the FromAgent and FromAcct are commented out,</span>
    <span class="comment">// since the funds are coming from a stash.</span>
    <span class="comment">// ----------------------------------------------------------</span>

    <span class="keyword">const</span> int64_t lNegativeAmount = (lAmount * (-1));

    <a class="code" href="_o_t_agent_8hpp.html#ac89892658f6bc83e354078647b704e8f">mapOfNyms</a>   map_Nyms_Already_Loaded;
    this-&gt;<a class="code" href="class_o_t_scriptable.html#a9e41bb939fd5dbfe1f2442e5919a5079">RetrieveNymPointers</a>(map_Nyms_Already_Loaded);


<span class="comment">//  OTLog::vError(&quot;OTSmartContract::UnstashAcctFunds: DEBUGGING: lAmount is %lld.\n&quot;, lNegativeAmount);</span>


    <span class="keywordtype">bool</span> bMoved = this-&gt;<a class="code" href="class_o_t_smart_contract.html#abaebc7e1d2416290139c883698c91025">StashFunds</a>(map_Nyms_Already_Loaded,
                                   lNegativeAmount,
                                   theToAcctID, theToAgentID,
                                   *pStash);
    <span class="keywordflow">if</span> (!bMoved)
    {
        <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(0, <span class="stringliteral">&quot;OTSmartContract::UnstashAcctFunds: Failed in final call. Values: to_acct: %s, from_stash: %s, lAmount: %lld. \n&quot;</span>,
                      to_acct_name.c_str(), from_stash_name.c_str(), lAmount);
        <span class="keywordflow">return</span> <span class="keyword">false</span>;
    }

    <span class="keywordflow">return</span> <span class="keyword">true</span>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a4804dc10ab81b2bde13fce0a3afb0765"></a><!-- doxytag: member="OTSmartContract::UpdateContents" ref="a4804dc10ab81b2bde13fce0a3afb0765" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_o_t_smart_contract.html#a4804dc10ab81b2bde13fce0a3afb0765">OTSmartContract::UpdateContents</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="class_o_t_trackable.html#ae708d31ab5dca7a4dff24b0534fec889">OTTrackable</a>.</p>

<p>Definition at line <a class="el" href="_o_t_smart_contract_8cpp_source.html#l04893">4893</a> of file <a class="el" href="_o_t_smart_contract_8cpp_source.html">OTSmartContract.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">// I release this because I&#39;m about to repopulate it.</span>
    <a class="code" href="class_o_t_contract.html#a087fc09cfa4b2fd9076088360a5e5039">m_xmlUnsigned</a>.<a class="code" href="class_o_t_string.html#abef4b21b2170468705c58d64212d7257">Release</a>();
    <span class="comment">// -------------------------------------------------------------</span>
    <span class="keyword">const</span> <a class="code" href="class_o_t_string.html">OTString</a>  SERVER_ID           (<a class="code" href="class_o_t_instrument.html#a878dd8998f7b131b85c082575e255375">GetServerID</a>()),
                    ACTIVATOR_USER_ID   (<a class="code" href="class_o_t_trackable.html#aaf5d36407abeeb35eea54f7acb0c3148">GetSenderUserID</a>()),
                    ACTIVATOR_ACCT_ID   (<a class="code" href="class_o_t_trackable.html#a3149b0da54958e8da4cf15d26f47711f">GetSenderAcctID</a>());

    <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != <a class="code" href="class_o_t_cron_item.html#af7bb48c16e16f664b938a7f235d2872d">m_pCancelerNymID</a>);
    <span class="comment">// -------------------------------------------------------------</span>
    <a class="code" href="class_o_t_string.html">OTString</a> strCanceler;

    <span class="keywordflow">if</span> (<a class="code" href="class_o_t_cron_item.html#abe9ce5c7b4d2fe652908e1f81f2f3b67">m_bCanceled</a>)
        <a class="code" href="class_o_t_cron_item.html#af7bb48c16e16f664b938a7f235d2872d">m_pCancelerNymID</a>-&gt;<a class="code" href="class_o_t_identifier.html#a4bccb30446b4b515d9d6016b86b260bb">GetString</a>(strCanceler);

    int64_t tCreation = <a class="code" href="_o_t_common_8hpp.html#a4c31551b478d298d694f7df4915b4302">OTTimeGetSecondsFromTime</a>(<a class="code" href="class_o_t_scriptable.html#a217fc906e2d6475e22913bd8653ffaa2">m_bCalculatingID</a> ? <a class="code" href="_o_t_common_8hpp.html#af4ca9fa2c7c290d647dd18de0a9ac25f">OT_TIME_ZERO</a> : <a class="code" href="class_o_t_cron_item.html#aec36ac68b9f13f874ce6c56940bcec24">GetCreationDate</a>());
    int64_t tValidFrom = <a class="code" href="_o_t_common_8hpp.html#a4c31551b478d298d694f7df4915b4302">OTTimeGetSecondsFromTime</a>(<a class="code" href="class_o_t_scriptable.html#a217fc906e2d6475e22913bd8653ffaa2">m_bCalculatingID</a> ? <a class="code" href="_o_t_common_8hpp.html#af4ca9fa2c7c290d647dd18de0a9ac25f">OT_TIME_ZERO</a> : <a class="code" href="class_o_t_instrument.html#a08eb5f25566832e1a67b3e33c0dcc13f">GetValidFrom</a>());
    int64_t tValidTo = <a class="code" href="_o_t_common_8hpp.html#a4c31551b478d298d694f7df4915b4302">OTTimeGetSecondsFromTime</a>(<a class="code" href="class_o_t_scriptable.html#a217fc906e2d6475e22913bd8653ffaa2">m_bCalculatingID</a> ? <a class="code" href="_o_t_common_8hpp.html#af4ca9fa2c7c290d647dd18de0a9ac25f">OT_TIME_ZERO</a> : <a class="code" href="class_o_t_instrument.html#ab83a62f51692c946ff394408026b0c18">GetValidTo</a>());
    int64_t tNextProcess = <a class="code" href="_o_t_common_8hpp.html#a4c31551b478d298d694f7df4915b4302">OTTimeGetSecondsFromTime</a>(<a class="code" href="class_o_t_scriptable.html#a217fc906e2d6475e22913bd8653ffaa2">m_bCalculatingID</a> ? <a class="code" href="_o_t_common_8hpp.html#af4ca9fa2c7c290d647dd18de0a9ac25f">OT_TIME_ZERO</a> : <a class="code" href="class_o_t_smart_contract.html#a16737b147030f0aaaedc53f798c35a50">GetNextProcessDate</a>());

    <span class="comment">// OTSmartContract</span>
    <a class="code" href="class_o_t_contract.html#a087fc09cfa4b2fd9076088360a5e5039">m_xmlUnsigned</a>.<a class="code" href="class_o_t_string.html#a86e54de385040ff6769d7f2149ce176b">Concatenate</a>(<span class="stringliteral">&quot;&lt;smartContract\n version=\&quot;%s\&quot;\n&quot;</span>
                              <span class="stringliteral">&quot; serverID=\&quot;%s\&quot;\n&quot;</span>
                              <span class="stringliteral">&quot; activatorUserID=\&quot;%s\&quot;\n&quot;</span>
                              <span class="stringliteral">&quot; activatorAcctID=\&quot;%s\&quot;\n&quot;</span>
                              <span class="stringliteral">&quot; lastSenderUserID=\&quot;%s\&quot;\n&quot;</span>
                              <span class="stringliteral">&quot; lastSenderAcctID=\&quot;%s\&quot;\n&quot;</span>
                              <span class="stringliteral">&quot; lastRecipientUserID=\&quot;%s\&quot;\n&quot;</span>
                              <span class="stringliteral">&quot; lastRecipientAcctID=\&quot;%s\&quot;\n&quot;</span>
                              <span class="stringliteral">&quot; canceled=\&quot;%s\&quot;\n&quot;</span>
                              <span class="stringliteral">&quot; cancelerUserID=\&quot;%s\&quot;\n&quot;</span>
                              <span class="stringliteral">&quot; transactionNum=\&quot;%lld\&quot;\n&quot;</span>
                              <span class="stringliteral">&quot; creationDate=\&quot;%&quot;</span> PRId64<span class="stringliteral">&quot;\&quot;\n&quot;</span>
                              <span class="stringliteral">&quot; validFrom=\&quot;%&quot;</span> PRId64<span class="stringliteral">&quot;\&quot;\n&quot;</span>
                              <span class="stringliteral">&quot; validTo=\&quot;%&quot;</span> PRId64<span class="stringliteral">&quot;\&quot;\n&quot;</span>
                              <span class="stringliteral">&quot; nextProcessDate=\&quot;%&quot;</span> PRId64<span class="stringliteral">&quot;\&quot;&quot;</span>
                              <span class="stringliteral">&quot; &gt;\n\n&quot;</span>,
                              <a class="code" href="class_o_t_contract.html#aa0d889e0e1670b56fedca245041a5ed3">m_strVersion</a>.<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>(),
                              <a class="code" href="class_o_t_scriptable.html#a217fc906e2d6475e22913bd8653ffaa2">m_bCalculatingID</a> ? <span class="stringliteral">&quot;&quot;</span> : SERVER_ID.Get(),
                              <a class="code" href="class_o_t_scriptable.html#a217fc906e2d6475e22913bd8653ffaa2">m_bCalculatingID</a> ? <span class="stringliteral">&quot;&quot;</span> : ACTIVATOR_USER_ID.Get(),
                              <a class="code" href="class_o_t_scriptable.html#a217fc906e2d6475e22913bd8653ffaa2">m_bCalculatingID</a> ? <span class="stringliteral">&quot;&quot;</span> : ACTIVATOR_ACCT_ID.Get(),
                              <a class="code" href="class_o_t_scriptable.html#a217fc906e2d6475e22913bd8653ffaa2">m_bCalculatingID</a> ? <span class="stringliteral">&quot;&quot;</span> : m_strLastSenderUser.<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>(),
                              <a class="code" href="class_o_t_scriptable.html#a217fc906e2d6475e22913bd8653ffaa2">m_bCalculatingID</a> ? <span class="stringliteral">&quot;&quot;</span> : m_strLastSenderAcct.<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>(),
                              <a class="code" href="class_o_t_scriptable.html#a217fc906e2d6475e22913bd8653ffaa2">m_bCalculatingID</a> ? <span class="stringliteral">&quot;&quot;</span> : m_strLastRecipientUser.<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>(),
                              <a class="code" href="class_o_t_scriptable.html#a217fc906e2d6475e22913bd8653ffaa2">m_bCalculatingID</a> ? <span class="stringliteral">&quot;&quot;</span> : m_strLastRecipientAcct.<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>(),
                              <a class="code" href="class_o_t_cron_item.html#abe9ce5c7b4d2fe652908e1f81f2f3b67">m_bCanceled</a> ? <span class="stringliteral">&quot;true&quot;</span> : <span class="stringliteral">&quot;false&quot;</span>,
                              <a class="code" href="class_o_t_cron_item.html#abe9ce5c7b4d2fe652908e1f81f2f3b67">m_bCanceled</a> ? strCanceler.<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>() : <span class="stringliteral">&quot;&quot;</span>,
                              <a class="code" href="class_o_t_scriptable.html#a217fc906e2d6475e22913bd8653ffaa2">m_bCalculatingID</a> ? 0 : <a class="code" href="class_o_t_trackable.html#a90bc18f9b5d6b3c8059a83685b86674e">m_lTransactionNum</a>,
                              tCreation,
                              tValidFrom,
                              tValidTo,
                              tNextProcess );
    <span class="comment">// -------------------------------------------------------------</span>
    <span class="comment">// OTCronItem</span>
    <span class="keywordflow">if</span> (!<a class="code" href="class_o_t_scriptable.html#a217fc906e2d6475e22913bd8653ffaa2">m_bCalculatingID</a>)
    {
        <span class="keywordflow">for</span> (int32_t i = 0; i &lt; <a class="code" href="class_o_t_cron_item.html#a96d3ae7898526a317dd503daecbf10af">GetCountClosingNumbers</a>(); i++)
        {
            int64_t lClosingNumber = <a class="code" href="class_o_t_cron_item.html#ab4bd4e606ddbb49d3f36248f18391ec1">GetClosingTransactionNoAt</a>(i);
            <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(lClosingNumber &gt; 0);

            <a class="code" href="class_o_t_contract.html#a087fc09cfa4b2fd9076088360a5e5039">m_xmlUnsigned</a>.<a class="code" href="class_o_t_string.html#a86e54de385040ff6769d7f2149ce176b">Concatenate</a>(<span class="stringliteral">&quot;&lt;closingTransactionNumber value=\&quot;%lld\&quot;/&gt;\n\n&quot;</span>,
                                      lClosingNumber);

            <span class="comment">// For OTSmartContract, this should only contain a single number, from the activator Nym.</span>
            <span class="comment">// I preserved the loop anyway. Call me crazy. But I&#39;m still displaying an error if there&#39;s</span>
            <span class="comment">// more than one.</span>
            <span class="keywordflow">if</span> (i &gt; 0)
                <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;OTSmartContract::%s: ERROR: There&#39;s only ever &quot;</span>
                             <span class="stringliteral">&quot;supposed to be a single closing number here (for smart contracts.)\n&quot;</span>,
                              __FUNCTION__);
        }
    }
    <span class="comment">// -------------------------------------------------------------</span>
    <span class="comment">//</span>
    <span class="comment">// *** OT SCRIPTABLE ***</span>
    <span class="comment">//</span>
    <a class="code" href="class_o_t_scriptable.html#a65ed14652345ef231ad4a3d347d89c3a">UpdateContentsToString</a>(<a class="code" href="class_o_t_contract.html#a087fc09cfa4b2fd9076088360a5e5039">m_xmlUnsigned</a>); <span class="comment">// FYI: this is: void OTScriptable::UpdateContentsToString(OTString &amp;)</span>
    <span class="comment">// -------------------------------------------------------------</span>
    <span class="keywordflow">if</span> (!<a class="code" href="class_o_t_scriptable.html#a217fc906e2d6475e22913bd8653ffaa2">m_bCalculatingID</a>)
    {
        <span class="comment">// -----------------</span>
        <span class="comment">// Save m_StashAccts.</span>
        <span class="comment">//</span>
        <span class="comment">// (This is an object that contains a map of OTAccountIDs, by asset_type_id)</span>
        <span class="comment">//</span>
        m_StashAccts.<a class="code" href="class_o_t_acct_list.html#a3e8b8cf7b31d9f4affb3be6dba3852a8">Serialize</a>(<a class="code" href="class_o_t_contract.html#a087fc09cfa4b2fd9076088360a5e5039">m_xmlUnsigned</a>);

        <span class="comment">// -----------------</span>
        <span class="comment">// This is a map of OTStash&#39;s, by stash_name.</span>
        <span class="comment">// EACH ONE contains a map of OTStashItems, by asset_type_id</span>
        <span class="comment">// -----------------</span>

        <a class="code" href="_o_t_storage_8hpp.html#aa135ed03585fa4b246d7907afbd5873d">FOR_EACH</a>(<a class="code" href="_o_t_stash_8hpp.html#a97aeca3992247240bcbef033b8c0813b">mapOfStashes</a>, m_mapStashes)    <span class="comment">// These stashes are what the scripts interact with. They have names.</span>
        {                                       <span class="comment">// Whereas the stash accts (above) are the actual accountIDs</span>
            <a class="code" href="class_o_t_stash.html">OTStash</a> * pStash = (*it).second;    <span class="comment">// where the actual funds are stored for each asset type.</span>
            <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != pStash);
            <span class="comment">// -------------------------</span>
            pStash-&gt;<a class="code" href="class_o_t_stash.html#a3dc00bfe2c0414b42fe1065a7a28be41">Serialize</a>(<a class="code" href="class_o_t_contract.html#a087fc09cfa4b2fd9076088360a5e5039">m_xmlUnsigned</a>);
        }
    }
    <span class="comment">// -------------------------------------------------------------</span>
    <a class="code" href="class_o_t_contract.html#a087fc09cfa4b2fd9076088360a5e5039">m_xmlUnsigned</a>.<a class="code" href="class_o_t_string.html#a86e54de385040ff6769d7f2149ce176b">Concatenate</a>(<span class="stringliteral">&quot;&lt;/smartContract&gt;\n\n&quot;</span>);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a3b15d58a7c49d3ba2fc8a153bca6af0f"></a><!-- doxytag: member="OTSmartContract::VerifySmartContract" ref="a3b15d58a7c49d3ba2fc8a153bca6af0f" args="(OTPseudonym &amp;theNym, OTAccount &amp;theAcct, OTPseudonym &amp;theServerNym, const bool bBurnTransNo=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_o_t_smart_contract.html#a3b15d58a7c49d3ba2fc8a153bca6af0f">OTSmartContract::VerifySmartContract</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_t_pseudonym.html">OTPseudonym</a> &amp;&#160;</td>
          <td class="paramname"><em>theNym</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_t_account.html">OTAccount</a> &amp;&#160;</td>
          <td class="paramname"><em>theAcct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_t_pseudonym.html">OTPseudonym</a> &amp;&#160;</td>
          <td class="paramname"><em>theServerNym</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>bBurnTransNo</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_o_t_smart_contract_8cpp_source.html#l04017">4017</a> of file <a class="el" href="_o_t_smart_contract_8cpp_source.html">OTSmartContract.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
    <a class="code" href="class_o_t_agent.html">OTAgent</a> * pAuthAgent = NULL;
    <a class="code" href="class_o_t_party.html">OTParty</a> * pAuthParty = <a class="code" href="class_o_t_scriptable.html#a08ff87b0f54ed3139bfcfb362a757778">FindPartyBasedOnNymAsAuthAgent</a>(theNym, &amp;pAuthAgent);

    <span class="keywordflow">if</span> (NULL == pAuthParty)
    {
        <a class="code" href="class_o_t_string.html">OTString</a> strNymID; theNym.<a class="code" href="class_o_t_pseudonym.html#a1775c7aedd0dd25b2faf3f78dcccabe7">GetIdentifier</a>(strNymID);
        <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(0, <span class="stringliteral">&quot;%s: Unable to find a party in this smart contract, based &quot;</span>
                       <span class="stringliteral">&quot;on theNym (%s) as authorizing agent.\n&quot;</span>, __FUNCTION__, strNymID.<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>());
        <span class="keywordflow">return</span> <span class="keyword">false</span>;
    }
    <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != pAuthAgent); <span class="comment">// If it found the party, then it DEFINITELY should have set the agent pointer.</span>
    <span class="comment">// BELOW THIS POINT, pAuthAgent and pAuthParty and both good pointers. Furthermore, we know that theNym</span>
    <span class="comment">// really is the authorizing agent for one of the parties to the contract.</span>
    <span class="comment">// ------------------------------------</span>
    <span class="keyword">const</span> <a class="code" href="class_o_t_string.html">OTString</a>  strServerID(<a class="code" href="class_o_t_instrument.html#a878dd8998f7b131b85c082575e255375">GetServerID</a>()); <span class="comment">// the serverID has already been verified by this time, in OTServer::NotarizeSmartContract()</span>
    <span class="comment">// -------------------------------</span>
    <a class="code" href="_o_t_agent_8hpp.html#ac89892658f6bc83e354078647b704e8f">mapOfNyms</a> map_Nyms_Already_Loaded;          <span class="comment">// The list of Nyms that were already instantiated before this function was called.</span>
    this-&gt;<a class="code" href="class_o_t_scriptable.html#a9e41bb939fd5dbfe1f2442e5919a5079">RetrieveNymPointers</a>(map_Nyms_Already_Loaded); <span class="comment">// now theNym is on this map. (His party already has a pointer to him since he is the activator.)</span>
    <span class="comment">// -------------------------------</span>
    <a class="code" href="_o_t_agent_8hpp.html#ac89892658f6bc83e354078647b704e8f">mapOfNyms</a> map_Nyms_Loaded_In_This_Function; <span class="comment">// The total list of Nyms that were instantiated inside this function (and must be deleted.)</span>
    <span class="comment">// -------------------------------</span>
    <a class="code" href="_o_t_agent_8hpp.html#abd4942716d546c8d42670619a03ef99e">mapOfAccounts</a> map_Accts_Already_Loaded;     <span class="comment">// The list of Accounts that were already instantiated before this function was called.</span>
    <span class="keyword">const</span> <a class="code" href="class_o_t_string.html">OTString</a> strAcctID(theAcct.<a class="code" href="class_o_t_transaction_type.html#ac9b118b7db7ea538d6931dee6c2f34e2">GetRealAccountID</a>());
    map_Accts_Already_Loaded.insert(std::pair&lt;std::string, OTAccount *&gt;(strAcctID.Get(), &amp;theAcct)); <span class="comment">// now theAcct is on this map.</span>
    <span class="comment">// -------------------------------</span>
    <a class="code" href="_o_t_agent_8hpp.html#abd4942716d546c8d42670619a03ef99e">mapOfAccounts</a> map_Accts_Loaded_In_This_Function;     <span class="comment">// The total list of Accts that were instantiated inside this function (and must be deleted.)</span>
    <span class="comment">// -------------------------------</span>
    <span class="keywordtype">bool</span>                bAreAnyInvalidParties = <span class="keyword">false</span>;
    std::set&lt;OTParty *&gt; theFailedParties; <span class="comment">// A set of pointers to parties who failed verification.</span>

    <span class="comment">// LOOP THROUGH ALL PARTIES AND VERIFY THEM.</span>
    <span class="comment">//</span>
    <a class="code" href="_o_t_storage_8hpp.html#a4a94c3435a932ed34e5755f3f472547c">FOR_EACH_IT</a>(<a class="code" href="_o_t_party_8hpp.html#a029bc6921acd4516530e26201cf595f2">mapOfParties</a>, <a class="code" href="class_o_t_scriptable.html#a6a7e4ef3e0ed95f90d950b1718f815ab">m_mapParties</a>, it_party)
    {
        <span class="keyword">const</span> std::string str_party_name    = (*it_party).first;
        <a class="code" href="class_o_t_party.html">OTParty</a> * pParty                    = (*it_party).second;
        <a class="code" href="_o_t_assert_8hpp.html#a033b133f48e61f2b227c52ad2be0c882">OT_ASSERT_MSG</a>(NULL != pParty, <span class="stringliteral">&quot;OTSmartContract::VerifySmartContract: Unexpected NULL pointer in party map.\n&quot;</span>);
        <span class="comment">// --------------------------------------------</span>

        <span class="comment">/*</span>
<span class="comment">         -- Load up the authorizing agent&#39;s Nym, if not already loaded. (Why? To verifySignature. Also, just to have</span>
<span class="comment">            it loaded so I don&#39;t have to load it twice in case it&#39;s needed for verifying one/some of the accts.) So really:</span>
<span class="comment">         -- Verify each party, that the authorizing agent and signature are all good. (I think I have this already...)</span>
<span class="comment">         -- Definitely during this, need to make sure that the contents of the signed version match the contents of the main version, for each signer.</span>
<span class="comment">         -- Verify that the authorizing agent actually has the opening transaction # for the party issued to him. (Do I have this?....)</span>
<span class="comment"></span>
<span class="comment">         -- REMOVE the Opening transaction # for each agent.</span>
<span class="comment">         (leaving it as issued, but no longer as &quot;available to be used on another transaction&quot;.)</span>
<span class="comment"></span>
<span class="comment">         THE ABOVE is all accomplished via VerifyPartyAuthorization()..</span>
<span class="comment"></span>
<span class="comment">         Next:</span>
<span class="comment"></span>
<span class="comment">         -- Loop through all the asset accounts</span>
<span class="comment">         -- For each, get a pointer to the authorized agent and verify the CLOSING number for that asset acct. (I have something like this?...)</span>
<span class="comment"></span>
<span class="comment">         -- Since we&#39;re looping through all the agents, and looping through all the asset accounts, and checking the agent for each asset account,</span>
<span class="comment">         then we might as well make sure that each agent is a legit agent for the party, and that each account has a legit agent lording over it.</span>
<span class="comment">         (Don&#39;t I do something like that already?)</span>
<span class="comment">         */</span>

        <span class="keywordtype">bool</span> bToBurnOrNotToBurn = bBurnTransNo;
        <span class="comment">// ------------------------------------------------</span>
        <span class="comment">// If we&#39;re burning a number, but THIS party has the same opening # as</span>
        <span class="comment">// the smart contract itself, then don&#39;t bother verifying / burning this</span>
        <span class="comment">// specific number (since it&#39;s been done already, higher-up.)</span>
        <span class="comment">//</span>
        <span class="keywordflow">if</span> (bBurnTransNo &amp;&amp;                                             <span class="comment">// If this party&#39;s opening number is the SMART CONTRACT&#39;s opening number, then this party</span>
            (this-&gt;<a class="code" href="class_o_t_trackable.html#a2594d320e3b24f3210bd38a08de66a70">GetTransactionNum</a>() == pParty-&gt;<a class="code" href="class_o_t_party.html#aa11f990dfe9743dd1d8e34af8bfd693a">GetOpeningTransNo</a>())) <span class="comment">// MUST be the ACTIVATOR. (No need to mark his trans# as IN USE since already done earlier.)</span>
        {
            <span class="comment">// In cases where we&#39;re supposed to burn the transaction number, we do that</span>
            <span class="comment">// for ALL parties EXCEPT the one who has the same Opening# as the SmartContract</span>
            <span class="comment">// has for its GetTransactionNum().  Why? Because that one was already burned, when</span>
            <span class="comment">// the activating party (pParty) activated the smart contract. At that time, the normal</span>
            <span class="comment">// transaction system inside OTServer burned the # as part of its process before even</span>
            <span class="comment">// calling NotarizeSmartContract().  Therefore, by this point, we ASSUME that party&#39;s</span>
            <span class="comment">// opening num has already JUST been verified, and we skip it, (continuing to verify</span>
            <span class="comment">// all the others.)</span>

            bToBurnOrNotToBurn = <span class="keyword">false</span>;
        }
        <span class="comment">// ------------------------------------------------------------------</span>
        <a class="code" href="_o_t_agent_8hpp.html#ac89892658f6bc83e354078647b704e8f">mapOfNyms</a>   map_Nyms_NewlyLoaded,
                    map_Nyms_Already_Loaded_AS_OF_NOW;

        map_Nyms_Already_Loaded_AS_OF_NOW.insert(map_Nyms_Already_Loaded.begin(),
                                                 map_Nyms_Already_Loaded.end());
        map_Nyms_Already_Loaded_AS_OF_NOW.insert(map_Nyms_Loaded_In_This_Function.begin(),
                                                 map_Nyms_Loaded_In_This_Function.end());
        <span class="comment">// ------------------------------------------------------------------</span>
        <span class="keyword">const</span>
        <span class="keywordtype">bool</span> bIsPartyAuthorized = this-&gt;<a class="code" href="class_o_t_scriptable.html#a5b20bcf70883ffe7e02f10343b88affc">VerifyPartyAuthorization</a>(*pParty,       <span class="comment">// The party that supposedly is authorized for this supposedly executed agreement.</span>
                                                                 theServerNym,  <span class="comment">// For verifying signature on the authorizing Nym, when loading it</span>
                                                                 strServerID,   <span class="comment">// For verifying issued num, need the serverID the # goes with.</span>
                                                                 &amp;map_Nyms_Already_Loaded_AS_OF_NOW,
                                                                 &amp;map_Nyms_NewlyLoaded,
                                                                 bToBurnOrNotToBurn); <span class="comment">// bBurnTransNo = true  (default is false)</span>

        map_Nyms_Loaded_In_This_Function.insert(map_Nyms_NewlyLoaded.begin(),
                                                map_Nyms_NewlyLoaded.end());
        <span class="comment">// ------------------------------------------------------------------</span>
        <span class="comment">// By this point, we&#39;ve verified that pParty-&gt;GetOpeningTransNo() really is ISSUED to pParty.</span>
        <span class="comment">// After all, you can Verify a Party&#39;s Authorization even after the smart contract has been activated.</span>
        <span class="comment">// But in THIS function we also want to verify TRANSACTION num (not just VerifyIssuedNum()) because</span>
        <span class="comment">// this is where that number is actually being BURNED for each one.</span>
        <span class="comment">// Since VerifyPartyAuthorization() ALREADY has the Nym loaded up for verification, I&#39;m going</span>
        <span class="comment">// to pass in a boolean arg to verify the Transaction Num as well, and burn it. (for this very purpose.)</span>
        <span class="comment">//</span>
        <span class="comment">// Due to this, We don&#39;t want to stop this loop just because one of the parties failed. We want to go ahead</span>
        <span class="comment">// and burn ALL the opening numbers for the remainder of the parties, so that they have a consistent rule (the</span>
        <span class="comment">// opening number is considered burned and gone after a failed activation attempt, though the closing numbers</span>
        <span class="comment">// are salvageable.)  Otherwise they would never know, upon receiving a server failure reply, whether their</span>
        <span class="comment">// opening number was to still be considered valid -- or not.</span>
        <span class="comment">//</span>
        <span class="keywordflow">if</span> (<span class="keyword">false</span> == bIsPartyAuthorized)
        {
            <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(0, <span class="stringliteral">&quot;%s: Party %s does NOT verify as authorized! \n&quot;</span>,
                           __FUNCTION__, str_party_name.c_str());
            bAreAnyInvalidParties = <span class="keyword">true</span>; <span class="comment">// We let them all go through, but we still take notice that at least one failed.</span>
            <span class="comment">// ------------------------------------------------</span>
            theFailedParties.insert(pParty); <span class="comment">// (So we can skip them in the loop below. Meaning THEIR closing #s also don&#39;t get marked as &quot;used&quot;, which is another reason for clients to just harvest the number in that case and consider it as clean, since the server is.)</span>
<span class="comment">//          return false; // see above comment. We still allow all parties to burn their opening #s, to keep things consistent for the client GUI code.</span>
        }
    } <span class="comment">// FOR_EACH (mapOfParties...)</span>
    <span class="comment">// ------------------------------------------------------------------</span>

    <span class="comment">// (MOVED TO FARTHER BELOW.)</span>
    <span class="comment">//</span>
<span class="comment">//  if (bAreAnyInvalidParties)</span>
<span class="comment">//  {</span>
<span class="comment">//      OTLog::Output(0, &quot;OTSmartContract::VerifySmartContract: Failure. There are invalid parties on this contract.\n&quot;);</span>
<span class="comment">//      return false;</span>
<span class="comment">//  }</span>
<span class="comment">//  // ------------------------------------------------------------------</span>
    <span class="comment">// NEXT: THE ACCOUNTS</span>
    <span class="comment">//</span>
    <span class="comment">// We loop through the parties again, now knowing they are all authorized.</span>
    <span class="comment">// For each party, we call pParty-&gt;LoadAndVerifyAgentNyms(). This way, they will</span>
    <span class="comment">// all be loaded up already for when we verify the accounts. Similarly we call</span>
    <span class="comment">// pParty-&gt;LoadAndVerifyAssetAccounts(), so that all the accounts are loaded up</span>
    <span class="comment">// as well. (We at least need to check their signatures...) At that point, all</span>
    <span class="comment">// of the agent nyms AND accounts have been loaded! (And verified internally against</span>
    <span class="comment">// themselves, such as their signature, etc.)</span>
    <span class="comment">//</span>
    <span class="comment">// From there, I need to verify the Party&#39;s Ownership over the account, as well as</span>
    <span class="comment">// verify that the authorized agent listed for each account actually has signer rights</span>
    <span class="comment">// over that account, and verify the closing transaction #s for each account against its</span>
    <span class="comment">// authorized agent.</span>
    <span class="comment">//</span>
    <span class="keywordtype">bool</span> bAreAnyInvalidAccounts = <span class="keyword">false</span>;

    <span class="comment">/*</span>
<span class="comment">     NOTE on syncronicity...</span>
<span class="comment"></span>
<span class="comment">     Above, we burned all the opening numbers for ALL the various nyms, even if there was some failure halfway through</span>
<span class="comment">     the verification process. This in order to make it easy to tell whether, for you, that number is still good or not.</span>
<span class="comment"></span>
<span class="comment">     Similarly, what about the closing numbers (below) ? They are not instantly BURNED just for the ATTEMPT (as the</span>
<span class="comment">     opening numbers were) but they are still marked below as &quot;USED BUT STILL ISSUED.&quot;</span>
<span class="comment"></span>
<span class="comment">     if (bAreAnyInvalidParties) just above insures that the below code will not run if there are any invalid parties.</span>
<span class="comment">     That means that if &quot;the message succeeded but transaction failed&quot; due to invalid parties, then the closing numbers</span>
<span class="comment">     will never be seen by the server and thus never marked as &quot;USED BUT STILL ISSUED.&quot; Instead, they would still be</span>
<span class="comment">     considered &quot;ISSUED AND AVAILABLE.&quot;</span>
<span class="comment"></span>
<span class="comment">     Based on that:</span>
<span class="comment">     If some FAILURE occurs below, as above, it still completes the loop in order to have consistent results for the</span>
<span class="comment">     closing transaction numbers, for all parties. So we know that success or fail, if the below code runs, the closing</span>
<span class="comment">     number is DEFINITELY marked as &quot;USED BUT STILL ISSUED&quot; for ALL parties, whereas if the below code does not run, the</span>
<span class="comment">     closing number for all parties is definitely still marked as &quot;ISSUED AND AVAILABLE&quot; (as far as this message is</span>
<span class="comment">     concerned.)</span>
<span class="comment"></span>
<span class="comment">     Thus, there is still an inconsistency. When a client is later trying to interpret which transaction numbers to &quot;claw</span>
<span class="comment">     back&quot;, he will have to harvest back the closing numbers SOMETIMES, based on WHY the transaction failed verification,</span>
<span class="comment">     and thus he cannot rely on a &quot;transaction failed&quot; state to give him a reliable answer to that question.</span>
<span class="comment"></span>
<span class="comment">     However, we must keep in mind that these CLOSING numbers have NOT been burned -- they ARE still on the client&#39;s local</span>
<span class="comment">     list for his nym as &quot;USED BUT STILL ISSUED.&quot; If the client harvests them back each time consistently, what will happen?</span>
<span class="comment">     The client will look at each closing number, see if it&#39;s on his local &quot;issued&quot; list (which it is) and then will re-add</span>
<span class="comment">     it to his &quot;available&quot; list as well. So is it really available on the server side? The answer is: sometimes.</span>
<span class="comment"></span>
<span class="comment">     SOLUTION?</span>
<span class="comment">     1. Above, cache a list of all the parties who failed verification.</span>
<span class="comment">     2. Allow the code below to run, even if some parties have failed.</span>
<span class="comment">     3. Change the code below to skip failed parties while verifying accounts. (Using afore-mentioned list to make this possible.)</span>
<span class="comment">     4. Move the &quot;if failed parties, return false&quot; block BELOW this loop, in conjunction with the invalid accounts block.</span>
<span class="comment"></span>
<span class="comment">     This will guarantee that closing numbers are consistently marked as &quot;USED BUT STILL ISSUED&quot; on the server side, no matter</span>
<span class="comment">     HOW the transaction has failed. (At least it will then be consistent.)</span>
<span class="comment"></span>
<span class="comment">     However, if the transaction HAS failed, then all those closing numbers, if the clients are to claw them back, must be</span>
<span class="comment">     marked as available once again on the server side, as well! And if the clients are NOT to claw them back for future use,</span>
<span class="comment">     then how will they ever close them out? The server already won&#39;t allow the numbers to be used again, since they were</span>
<span class="comment">     marked as &quot;used but still issued&quot;. But the transaction is ALREADY closed (it failed.)</span>
<span class="comment"></span>
<span class="comment">     SOLUTIONS?</span>
<span class="comment">     -- Server could burn the closing numbers for failed transactions, vs marking them as &quot;used but issued&quot; when the transaction</span>
<span class="comment">        is successful. That way any client getting notice of the failure would DEFINITELY know that those numbers were burned, and</span>
<span class="comment">        could sync himself accordingly. (We definitely need to notice all parties as well, in this case, since they will need</span>
<span class="comment">        to discard the burned numbers after that point, in order to avoid going out-of-sync.)</span>
<span class="comment"></span>
<span class="comment">     -- Server could also, in the event of transaction failure, mark the closing numbers as &quot;available again, like new!&quot;</span>
<span class="comment">        This way clients could clearly determine whether to burn their numbers or mark them as available again, purely based</span>
<span class="comment">        on the transaction&#39;s failure state. (State meaning the message itself is successful, and transaction could be success or fail.)</span>
<span class="comment">        Clients will not go out of sync in this case, if they fail to adjust to match the server. Well, they would be out of</span>
<span class="comment">        sync, but not the kind that prevents you from doing new transactions. (Rather, it&#39;s the kind where you have certain numbers</span>
<span class="comment">        signed out forever and you can never get rid of them.) Therefore, a notice is ALSO needed for this case.</span>
<span class="comment"></span>
<span class="comment">     -- I know notices are already being sent upon activation, but I need to research that more closely now and determine the</span>
<span class="comment">        exact circumstances of these notices. Clearly a notice is REQUIRED, no matter which above option I choose!</span>
<span class="comment"></span>
<span class="comment">     Thought: If notice is REQUIRED either way, perhaps the clients can just assume X unless a notice is received? For example,</span>
<span class="comment">     a client could just ASSUME the closing number is &quot;used but still issued&quot; unless notice is received to the contrary. This IS</span>
<span class="comment">     how the state would be if the transaction were successful, yet if it had failed, or hadn&#39;t been activated yet, the client</span>
<span class="comment">     also wouldn&#39;t experience any syncing issues by making this assumption.</span>
<span class="comment"></span>
<span class="comment">     Clearly the server HAS to, in the event of transaction failure, mark the closing numbers either as &quot;available again, like new!&quot;</span>
<span class="comment">     or it has to mark them as BURNED, but either way, it&#39;s an additional piece the server has to do (up until now it has only</span>
<span class="comment">     marked them as &quot;used but still issued.&quot;) What I can see is the server HAS to do something about those numbers, and it HAS</span>
<span class="comment">     to notify all the parties whether that transaction succeeded or failed, and then those parties HAVE to fix their client-side</span>
<span class="comment">     transaction count BASED on whether that transaciton succeeded or failed.</span>
<span class="comment"></span>
<span class="comment">     Therefore:</span>
<span class="comment"></span>
<span class="comment">     1. Implement the above 4-step solution.</span>
<span class="comment">     2. Do something about all the closing numbers, if activation fails.</span>
<span class="comment">        (Keep the nyms loaded until that is done, so as not to have to load them twice.)</span>
<span class="comment">     3. Make sure the parties are consistently noticed either way.</span>
<span class="comment">     4. Make sure the parties are syncing their numbers properly based on these notices.</span>
<span class="comment"></span>
<span class="comment"></span>
<span class="comment">     WOW, eh?  But I believe that smart contracts are the most complicated case, so this has got to be the worst of it, now handled :-)</span>
<span class="comment"></span>
<span class="comment">     Another note: If we assume the server burns the closing numbers, then the clients will suddenly be out-of-sync and unable</span>
<span class="comment">     to process transactions until they receive and process the notice of this failure. But if we instead assume that the server</span>
<span class="comment">     &quot;makes new&quot; those closing numbers, then the clients will remain in sync regardless of notice, and they only need to harvest</span>
<span class="comment">     the numbers upon notice, just so they can use them again, and they will not experience any &quot;out of sync failures&quot; along the</span>
<span class="comment">     way. Thus, it is preferable for the server to &quot;make those numbers new again!&quot; in the event of activation failure, AND to notice</span>
<span class="comment">     the parties of this so that they can do likewise.</span>
<span class="comment">     One way to notice them is to drop the &quot;message succeeded but transaction failed&quot; server reply into ALL of their Nymboxes,</span>
<span class="comment">     and not just the activator&#39;s. But not sure if that&#39;s safe... hm.</span>
<span class="comment"></span>
<span class="comment">     */</span>

    <a class="code" href="_o_t_storage_8hpp.html#a4a94c3435a932ed34e5755f3f472547c">FOR_EACH_IT</a>(<a class="code" href="_o_t_party_8hpp.html#a029bc6921acd4516530e26201cf595f2">mapOfParties</a>, <a class="code" href="class_o_t_scriptable.html#a6a7e4ef3e0ed95f90d950b1718f815ab">m_mapParties</a>, it_party)
    {
        <span class="keyword">const</span> std::string str_party_name    = (*it_party).first;
        <a class="code" href="class_o_t_party.html">OTParty</a> * pParty                    = (*it_party).second;
        <a class="code" href="_o_t_assert_8hpp.html#a033b133f48e61f2b227c52ad2be0c882">OT_ASSERT_MSG</a>(NULL != pParty, <span class="stringliteral">&quot;Unexpected NULL pointer in party map.&quot;</span>);
        <span class="comment">// --------------------------------------------</span>
        <span class="comment">//</span>
        <span class="comment">// SKIP FAILED PARTIES...</span>
        <span class="comment">//</span>
        std::set&lt;OTParty *&gt;::iterator it_failed = theFailedParties.find(pParty);

        <span class="keywordflow">if</span> (theFailedParties.end() != it_failed) <span class="comment">// this means pParty was found on the FAILED list. (So we can skip it here.)</span>
        {
            <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(0, <span class="stringliteral">&quot;%s: FYI, at least one party (%s) has failed, and right now I&#39;m skipping verification of his &quot;</span>
                           <span class="stringliteral">&quot;asset accounts.\n&quot;</span>, __FUNCTION__, str_party_name.c_str());
            <span class="keywordflow">continue</span>;
        }
        <span class="comment">// ------------------------------------------------------------------</span>
        <a class="code" href="_o_t_agent_8hpp.html#ac89892658f6bc83e354078647b704e8f">mapOfNyms</a>   map_Nyms_NewlyLoaded,
                    map_Nyms_Already_Loaded_AS_OF_NOW;

        map_Nyms_Already_Loaded_AS_OF_NOW.insert(map_Nyms_Already_Loaded.begin(),
                                                 map_Nyms_Already_Loaded.end());
        map_Nyms_Already_Loaded_AS_OF_NOW.insert(map_Nyms_Loaded_In_This_Function.begin(),
                                                 map_Nyms_Loaded_In_This_Function.end());

        <span class="comment">// After calling this, map_Nyms_NewlyLoaded will contain pointers to Nyms that MUST BE CLEANED UP.</span>
        <span class="comment">// LoadAndVerifyAgentNyms will not bother loading any Nyms which appear on map_Nyms_Already_Loaded.</span>
        <span class="comment">//</span>
        <span class="keyword">const</span> <span class="keywordtype">bool</span> bAgentsLoaded = pParty-&gt;<a class="code" href="class_o_t_party.html#a2f9d6c69f58bb85a524f897a70a1dae6">LoadAndVerifyAgentNyms</a>(theServerNym,
                                                                  map_Nyms_Already_Loaded_AS_OF_NOW, <span class="comment">// Nyms it won&#39;t bother loading &#39;cause they are loaded already.</span>
                                                                  map_Nyms_NewlyLoaded);             <span class="comment">// Nyms it had to load itself, and thus that YOU must clean up afterwards.</span>
        map_Nyms_Loaded_In_This_Function.insert(map_Nyms_NewlyLoaded.begin(),
                                                map_Nyms_NewlyLoaded.end());
        <span class="keywordflow">if</span> (<span class="keyword">false</span> == bAgentsLoaded)
        {
            <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(0, <span class="stringliteral">&quot;%s: Failed trying to Load and Verify Agent Nyms for party: %s\n&quot;</span>,
                           __FUNCTION__, str_party_name.c_str());
            bAreAnyInvalidAccounts = <span class="keyword">true</span>; <span class="comment">// We let them all go through, so there is consistent output, but we still take notice that at least one failed.</span>
        }
        <span class="comment">// ------------------------------------------------------------------</span>
        <a class="code" href="_o_t_agent_8hpp.html#abd4942716d546c8d42670619a03ef99e">mapOfAccounts</a>   map_Accts_NewlyLoaded,
                        map_Accts_Already_Loaded_AS_OF_NOW;

        map_Accts_Already_Loaded_AS_OF_NOW.insert(map_Accts_Already_Loaded.begin(),
                                                  map_Accts_Already_Loaded.end());
        map_Accts_Already_Loaded_AS_OF_NOW.insert(map_Accts_Loaded_In_This_Function.begin(),
                                                  map_Accts_Loaded_In_This_Function.end());

        <span class="comment">// After calling this, map_Accts_NewlyLoaded will contain pointers to Accts that MUST BE CLEANED UP.</span>
        <span class="comment">// LoadAndVerifyAssetAccounts will not bother loading any Accts which appear on map_Accts_Already_Loaded.</span>
        <span class="comment">//</span>
        <span class="keyword">const</span> <span class="keywordtype">bool</span> bAcctsLoaded = pParty-&gt;<a class="code" href="class_o_t_party.html#a29151e24141937447c2be93a237e0613">LoadAndVerifyAssetAccounts</a>(theServerNym, strServerID,
                                                                     map_Accts_Already_Loaded_AS_OF_NOW,  <span class="comment">// Accts it won&#39;t bother loading &#39;cause they are loaded already.</span>
                                                                     map_Accts_NewlyLoaded);              <span class="comment">// Accts it had to load itself, and thus that YOU must clean up afterwards.</span>

        map_Accts_Loaded_In_This_Function.insert(map_Accts_NewlyLoaded.begin(),
                                                 map_Accts_NewlyLoaded.end());
        <span class="keywordflow">if</span> (<span class="keyword">false</span> == bAcctsLoaded)
        {
            <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(0, <span class="stringliteral">&quot;%s: Failed trying to Load and Verify Asset Accts for party: %s\n&quot;</span>,
                           __FUNCTION__, str_party_name.c_str());
            bAreAnyInvalidAccounts = <span class="keyword">true</span>; <span class="comment">// We let them all go through, so there is consistent output, but we still take notice that at least one failed.</span>
        }
        <span class="comment">// ------------------------------------------------------------------</span>
        <span class="comment">// BY THIS POINT, FOR THIS PARTY, we have successfully loaded and verified ALL of the Nyms,</span>
        <span class="comment">// for ALL of the party&#39;s agents, and ALL of the asset accounts, for this party. We know the</span>
        <span class="comment">// Party has pointers internally to all of those objects as well. Therefore if we erase any of those objects, we must also clear the pointers!</span>
        <span class="comment">//</span>
        <span class="keyword">const</span> <span class="keywordtype">bool</span> bAreAcctsVerified = pParty-&gt;<a class="code" href="class_o_t_party.html#aa047a5d694ee951edf7bc7fc8a686d82">VerifyAccountsWithTheirAgents</a>(theServerNym, strServerID,
                                                                             bBurnTransNo); <span class="comment">// bBurnTransNo=false by default.</span>
        <span class="keywordflow">if</span> (<span class="keyword">false</span> == bAreAcctsVerified)
        {
            <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(0, <span class="stringliteral">&quot;%s: Failed trying to Verify Asset Accts with their Agents, for party: %s\n&quot;</span>,
                           __FUNCTION__, str_party_name.c_str());
            bAreAnyInvalidAccounts = <span class="keyword">true</span>; <span class="comment">// We let them all go through, so there is consistent output, but we still take notice that at least one failed.</span>
        }
        <span class="comment">// **************************************************************</span>

        <span class="comment">// Now we don&#39;t delete these until AFTER the loop, until after we know if it was a success.</span>
        <span class="comment">// If it failed, then we can fix their closing transaction numbers from &quot;used but still issued&quot; back to</span>
        <span class="comment">// &quot;issued and available for use.&quot; (If it was a success, then we don&#39;t do anything, since the numbers are</span>
        <span class="comment">// already marked appropriately. And we still clean up all the nyms / accounts--just AFTER this loop.)</span>
        <span class="comment">//</span>
<span class="comment">//      pParty-&gt;ClearTemporaryPointers(); // Don&#39;t want any bad pointers floating around after cleanup. (Pointers must be cleared in same scope as whatever they point to...)</span>
<span class="comment">//      OTSmartContract::CleanupNyms (map_Nyms_NewlyLoaded);  // HAVE to do this, or we&#39;ll leak. Even if something returned</span>
<span class="comment">//      OTSmartContract::CleanupAccts(map_Accts_NewlyLoaded); // false, some objects may have been loaded before it failed.</span>
        <span class="comment">// ----------------</span>
    } <span class="comment">// FOR_EACH_IT(mapOfParties, m_mapParties, it_party)</span>
    <span class="comment">// ********************************************************************************</span>

    <span class="keyword">const</span> <span class="keywordtype">bool</span> bSuccess = (!bAreAnyInvalidParties &amp;&amp; !bAreAnyInvalidAccounts);  <span class="comment">// &lt;=== THE RETURN VALUE</span>

    <span class="comment">// --------------------------------------------------------------------------------</span>
    <span class="keywordflow">if</span> (bAreAnyInvalidParties)
        <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(0, <span class="stringliteral">&quot;%s: Failure: There are invalid party(s) on this smart contract.\n&quot;</span>, __FUNCTION__);
    <span class="comment">// --------------------------------------------------------------------------------</span>
    <span class="keywordflow">if</span> (bAreAnyInvalidAccounts)
        <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(0, <span class="stringliteral">&quot;%s: Failure: there are invalid account(s) or authorized agent(s) on this smart contract.\n&quot;</span>, __FUNCTION__);
    <span class="comment">// --------------------------------------------------------------------------------</span>
    <span class="comment">// IF we marked the numbers as IN USE (bBurnTransNo) but then FAILURE occurred,</span>
    <span class="comment">// then we need to CLOSE the opening numbers (RemoveIssuedNum) meaning they are done</span>
    <span class="comment">// and over, and can never be used again, and we also need to HARVEST the CLOSING</span>
    <span class="comment">// numbers, meaning they are available again for use in the future.</span>
    <span class="comment">// (If failure occurred in a case where we did NOT burn the numbers, then we wouldn&#39;t</span>
    <span class="comment">// be worried about putting them back, now would we?)</span>
    <span class="comment">//</span>
    <span class="comment">//</span>
    <span class="keywordflow">if</span> (!bSuccess &amp;&amp;    <span class="comment">// If this function was not a success, overall, and</span>
        bBurnTransNo)   <span class="comment">// if we DID burn (mark as &#39;in use&#39;) the numbers during this function...</span>
    {
        <span class="comment">// CloseoutOpeningNumbers...</span>
        <span class="comment">// This closes the opening numbers for all parties except the activator Nym.</span>
        <span class="comment">// Why not him? Because his is already closed out in NotarizeTransaction, if</span>
        <span class="comment">// the transaction has failed.</span>
        <span class="comment">//</span>
        <span class="comment">// Also, where that happens, his set of open cron items is also updated to</span>
        <span class="comment">// remove the number from that list. (As the below function also does for the rest</span>
        <span class="comment">// of the nyms involved.)</span>
        <span class="comment">//</span>
        this-&gt;<a class="code" href="class_o_t_smart_contract.html#ac49c69ff88ceac23756933c4a915fd60">CloseoutOpeningNumbers</a>(&amp;theServerNym);

        <span class="comment">// Then harvest those closing numbers back again (for ALL Nyms.)</span>
        <span class="comment">// (Not the opening numbers, which are already burned for good by this point.)</span>
        <span class="comment">//</span>
        this-&gt;<a class="code" href="class_o_t_smart_contract.html#a40befd7381c6c5e68e7d1042c9a7f2d3">HarvestClosingNumbers</a>(&amp;theServerNym,      <span class="comment">// theServerNym is the signer, here on the server side.</span>
                                    &amp;theFailedParties); <span class="comment">// Since we skipped marking the closing numbers for these failed parties, then we skip adding those same numbers back again, too.</span>
    }
    <span class="comment">// --------------------------------------------------------------------------------</span>
    <span class="comment">// Now that all potentially-needed harvesting is done, we can clean up.</span>
    <span class="comment">//</span>
    this-&gt;<a class="code" href="class_o_t_scriptable.html#ab9a6cff853b9c71456eaf427caa3ab8b">ClearTemporaryPointers</a>(); <span class="comment">// Don&#39;t want any bad pointers floating around after cleanup.</span>

    <a class="code" href="class_o_t_smart_contract.html#a16209b074a580bc416cf848025e0647e">OTSmartContract::CleanupNyms</a> (map_Nyms_Loaded_In_This_Function);  <span class="comment">// HAVE to do this, or we&#39;ll leak. Even if something returned</span>
    <a class="code" href="class_o_t_smart_contract.html#a11408d45bd120d44b704637ebbc0c971">OTSmartContract::CleanupAccts</a>(map_Accts_Loaded_In_This_Function); <span class="comment">// false, some objects may have been loaded before it failed.</span>

    <span class="comment">// ********************************************************************************</span>

    <span class="comment">// DONE: if the above loop fails halfway through, then we should really PUT BACK the closing</span>
    <span class="comment">// transaction #s that we removed. After all, we have a list of them. Otherwise the only way</span>
    <span class="comment">// to know which parties have their numbers still, and which ones don&#39;t, would be to stick a notice</span>
    <span class="comment">// in their nymbox, like we do for finalReceipt.  Perhaps such a notice should ALWAYS go into the</span>
    <span class="comment">// Nymbox in these cases... *shrug*</span>

    <span class="keywordflow">return</span> bSuccess;
}
</pre></div>
</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/otlib/<a class="el" href="_o_t_smart_contract_8hpp_source.html">OTSmartContract.hpp</a></li>
<li>src/otlib/<a class="el" href="_o_t_smart_contract_8cpp_source.html">OTSmartContract.cpp</a></li>
</ul>
</div><!-- contents -->
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="class_o_t_smart_contract.html">OTSmartContract</a>      </li>

    <li class="footer">Generated on Wed May 21 2014 11:26:16 for Open-Transactions by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1 </li>
   </ul>
 </div>


</body>
</html>
