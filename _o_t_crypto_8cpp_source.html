<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Open-Transactions: src/otlib/OTCrypto.cpp Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Open-Transactions
   &#160;<span id="projectnumber">master/1066fb4910a63ee3f7de8e0807fee3eb663b66c7</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('_o_t_crypto_8cpp.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">src/otlib/OTCrypto.cpp</div>  </div>
</div><!--header-->
<div class="contents">
<a href="_o_t_crypto_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/************************************************************</span>
<a name="l00002"></a>00002 <span class="comment"> *</span>
<a name="l00003"></a>00003 <span class="comment"> *  OTCrypto.cpp</span>
<a name="l00004"></a>00004 <span class="comment"> *</span>
<a name="l00005"></a>00005 <span class="comment"> *  Abstract base class for all crypto code (ideally.)</span>
<a name="l00006"></a>00006 <span class="comment"> *</span>
<a name="l00007"></a>00007 <span class="comment"> *  Plus: initial implementation based on OpenSSL.</span>
<a name="l00008"></a>00008 <span class="comment"> *  (OTCrypto_OpenSSL)</span>
<a name="l00009"></a>00009 <span class="comment"> *</span>
<a name="l00010"></a>00010 <span class="comment"> */</span>
<a name="l00011"></a>00011 
<a name="l00012"></a>00012 <span class="comment">/************************************************************</span>
<a name="l00013"></a>00013 <span class="comment"> -----BEGIN PGP SIGNED MESSAGE-----</span>
<a name="l00014"></a>00014 <span class="comment"> Hash: SHA1</span>
<a name="l00015"></a>00015 <span class="comment"></span>
<a name="l00016"></a>00016 <span class="comment"> *                 OPEN TRANSACTIONS</span>
<a name="l00017"></a>00017 <span class="comment"> *</span>
<a name="l00018"></a>00018 <span class="comment"> *       Financial Cryptography and Digital Cash</span>
<a name="l00019"></a>00019 <span class="comment"> *       Library, Protocol, API, Server, CLI, GUI</span>
<a name="l00020"></a>00020 <span class="comment"> *</span>
<a name="l00021"></a>00021 <span class="comment"> *       -- Anonymous Numbered Accounts.</span>
<a name="l00022"></a>00022 <span class="comment"> *       -- Untraceable Digital Cash.</span>
<a name="l00023"></a>00023 <span class="comment"> *       -- Triple-Signed Receipts.</span>
<a name="l00024"></a>00024 <span class="comment"> *       -- Cheques, Vouchers, Transfers, Inboxes.</span>
<a name="l00025"></a>00025 <span class="comment"> *       -- Basket Currencies, Markets, Payment Plans.</span>
<a name="l00026"></a>00026 <span class="comment"> *       -- Signed, XML, Ricardian-style Contracts.</span>
<a name="l00027"></a>00027 <span class="comment"> *       -- Scripted smart contracts.</span>
<a name="l00028"></a>00028 <span class="comment"> *</span>
<a name="l00029"></a>00029 <span class="comment"> *  Copyright (C) 2010-2013 by &quot;Fellow Traveler&quot; (A pseudonym)</span>
<a name="l00030"></a>00030 <span class="comment"> *</span>
<a name="l00031"></a>00031 <span class="comment"> *  EMAIL:</span>
<a name="l00032"></a>00032 <span class="comment"> *  FellowTraveler@rayservers.net</span>
<a name="l00033"></a>00033 <span class="comment"> *</span>
<a name="l00034"></a>00034 <span class="comment"> *  BITCOIN:  1NtTPVVjDsUfDWybS4BwvHpG2pdS9RnYyQ</span>
<a name="l00035"></a>00035 <span class="comment"> *</span>
<a name="l00036"></a>00036 <span class="comment"> *  KEY FINGERPRINT (PGP Key in license file):</span>
<a name="l00037"></a>00037 <span class="comment"> *  9DD5 90EB 9292 4B48 0484  7910 0308 00ED F951 BB8E</span>
<a name="l00038"></a>00038 <span class="comment"> *</span>
<a name="l00039"></a>00039 <span class="comment"> *  OFFICIAL PROJECT WIKI(s):</span>
<a name="l00040"></a>00040 <span class="comment"> *  https://github.com/FellowTraveler/Moneychanger</span>
<a name="l00041"></a>00041 <span class="comment"> *  https://github.com/FellowTraveler/Open-Transactions/wiki</span>
<a name="l00042"></a>00042 <span class="comment"> *</span>
<a name="l00043"></a>00043 <span class="comment"> *  WEBSITE:</span>
<a name="l00044"></a>00044 <span class="comment"> *  http://www.OpenTransactions.org/</span>
<a name="l00045"></a>00045 <span class="comment"> *</span>
<a name="l00046"></a>00046 <span class="comment"> *  Components and licensing:</span>
<a name="l00047"></a>00047 <span class="comment"> *   -- Moneychanger..A Java client GUI.....LICENSE:.....GPLv3</span>
<a name="l00048"></a>00048 <span class="comment"> *   -- otlib.........A class library.......LICENSE:...LAGPLv3</span>
<a name="l00049"></a>00049 <span class="comment"> *   -- otapi.........A client API..........LICENSE:...LAGPLv3</span>
<a name="l00050"></a>00050 <span class="comment"> *   -- opentxs/ot....Command-line client...LICENSE:...LAGPLv3</span>
<a name="l00051"></a>00051 <span class="comment"> *   -- otserver......Server Application....LICENSE:....AGPLv3</span>
<a name="l00052"></a>00052 <span class="comment"> *  Github.com/FellowTraveler/Open-Transactions/wiki/Components</span>
<a name="l00053"></a>00053 <span class="comment"> *</span>
<a name="l00054"></a>00054 <span class="comment"> *  All of the above OT components were designed and written by</span>
<a name="l00055"></a>00055 <span class="comment"> *  Fellow Traveler, with the exception of Moneychanger, which</span>
<a name="l00056"></a>00056 <span class="comment"> *  was contracted out to Vicky C (bitcointrader4@gmail.com).</span>
<a name="l00057"></a>00057 <span class="comment"> *  The open-source community has since actively contributed.</span>
<a name="l00058"></a>00058 <span class="comment"> *</span>
<a name="l00059"></a>00059 <span class="comment"> *  -----------------------------------------------------</span>
<a name="l00060"></a>00060 <span class="comment"> *</span>
<a name="l00061"></a>00061 <span class="comment"> *   LICENSE:</span>
<a name="l00062"></a>00062 <span class="comment"> *   This program is free software: you can redistribute it</span>
<a name="l00063"></a>00063 <span class="comment"> *   and/or modify it under the terms of the GNU Affero</span>
<a name="l00064"></a>00064 <span class="comment"> *   General Public License as published by the Free Software</span>
<a name="l00065"></a>00065 <span class="comment"> *   Foundation, either version 3 of the License, or (at your</span>
<a name="l00066"></a>00066 <span class="comment"> *   option) any later version.</span>
<a name="l00067"></a>00067 <span class="comment"> *</span>
<a name="l00068"></a>00068 <span class="comment"> *   ADDITIONAL PERMISSION under the GNU Affero GPL version 3</span>
<a name="l00069"></a>00069 <span class="comment"> *   section 7: (This paragraph applies only to the LAGPLv3</span>
<a name="l00070"></a>00070 <span class="comment"> *   components listed above.) If you modify this Program, or</span>
<a name="l00071"></a>00071 <span class="comment"> *   any covered work, by linking or combining it with other</span>
<a name="l00072"></a>00072 <span class="comment"> *   code, such other code is not for that reason alone subject</span>
<a name="l00073"></a>00073 <span class="comment"> *   to any of the requirements of the GNU Affero GPL version 3.</span>
<a name="l00074"></a>00074 <span class="comment"> *   (==&gt; This means if you are only using the OT API, then you</span>
<a name="l00075"></a>00075 <span class="comment"> *   don&#39;t have to open-source your code--only your changes to</span>
<a name="l00076"></a>00076 <span class="comment"> *   Open-Transactions itself must be open source. Similar to</span>
<a name="l00077"></a>00077 <span class="comment"> *   LGPLv3, except it applies to software-as-a-service, not</span>
<a name="l00078"></a>00078 <span class="comment"> *   just to distributing binaries.)</span>
<a name="l00079"></a>00079 <span class="comment"> *</span>
<a name="l00080"></a>00080 <span class="comment"> *   Extra WAIVER for OpenSSL, Lucre, and all other libraries</span>
<a name="l00081"></a>00081 <span class="comment"> *   used by Open Transactions: This program is released under</span>
<a name="l00082"></a>00082 <span class="comment"> *   the AGPL with the additional exemption that compiling,</span>
<a name="l00083"></a>00083 <span class="comment"> *   linking, and/or using OpenSSL is allowed. The same is true</span>
<a name="l00084"></a>00084 <span class="comment"> *   for any other open source libraries included in this</span>
<a name="l00085"></a>00085 <span class="comment"> *   project: complete waiver from the AGPL is hereby granted to</span>
<a name="l00086"></a>00086 <span class="comment"> *   compile, link, and/or use them with Open-Transactions,</span>
<a name="l00087"></a>00087 <span class="comment"> *   according to their own terms, as long as the rest of the</span>
<a name="l00088"></a>00088 <span class="comment"> *   Open-Transactions terms remain respected, with regard to</span>
<a name="l00089"></a>00089 <span class="comment"> *   the Open-Transactions code itself.</span>
<a name="l00090"></a>00090 <span class="comment"> *</span>
<a name="l00091"></a>00091 <span class="comment"> *   Lucre License:</span>
<a name="l00092"></a>00092 <span class="comment"> *   This code is also &quot;dual-license&quot;, meaning that Ben Lau-</span>
<a name="l00093"></a>00093 <span class="comment"> *   rie&#39;s license must also be included and respected, since</span>
<a name="l00094"></a>00094 <span class="comment"> *   the code for Lucre is also included with Open Transactions.</span>
<a name="l00095"></a>00095 <span class="comment"> *   See Open-Transactions/src/otlib/lucre/LUCRE_LICENSE.txt</span>
<a name="l00096"></a>00096 <span class="comment"> *   The Laurie requirements are light, but if there is any</span>
<a name="l00097"></a>00097 <span class="comment"> *   problem with his license, simply remove the Lucre code.</span>
<a name="l00098"></a>00098 <span class="comment"> *   Although there are no other blind token algorithms in Open</span>
<a name="l00099"></a>00099 <span class="comment"> *   Transactions (yet. credlib is coming), the other functions</span>
<a name="l00100"></a>00100 <span class="comment"> *   will continue to operate.</span>
<a name="l00101"></a>00101 <span class="comment"> *   See Lucre on Github:  https://github.com/benlaurie/lucre</span>
<a name="l00102"></a>00102 <span class="comment"> *   -----------------------------------------------------</span>
<a name="l00103"></a>00103 <span class="comment"> *   You should have received a copy of the GNU Affero General</span>
<a name="l00104"></a>00104 <span class="comment"> *   Public License along with this program.  If not, see:</span>
<a name="l00105"></a>00105 <span class="comment"> *   http://www.gnu.org/licenses/</span>
<a name="l00106"></a>00106 <span class="comment"> *</span>
<a name="l00107"></a>00107 <span class="comment"> *   If you would like to use this software outside of the free</span>
<a name="l00108"></a>00108 <span class="comment"> *   software license, please contact FellowTraveler.</span>
<a name="l00109"></a>00109 <span class="comment"> *   (Unfortunately many will run anonymously and untraceably,</span>
<a name="l00110"></a>00110 <span class="comment"> *   so who could really stop them?)</span>
<a name="l00111"></a>00111 <span class="comment"> *</span>
<a name="l00112"></a>00112 <span class="comment"> *   DISCLAIMER:</span>
<a name="l00113"></a>00113 <span class="comment"> *   This program is distributed in the hope that it will be</span>
<a name="l00114"></a>00114 <span class="comment"> *   useful, but WITHOUT ANY WARRANTY; without even the implied</span>
<a name="l00115"></a>00115 <span class="comment"> *   warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR</span>
<a name="l00116"></a>00116 <span class="comment"> *   PURPOSE.  See the GNU Affero General Public License for</span>
<a name="l00117"></a>00117 <span class="comment"> *   more details.</span>
<a name="l00118"></a>00118 <span class="comment"></span>
<a name="l00119"></a>00119 <span class="comment"> -----BEGIN PGP SIGNATURE-----</span>
<a name="l00120"></a>00120 <span class="comment"> Version: GnuPG v1.4.9 (Darwin)</span>
<a name="l00121"></a>00121 <span class="comment"></span>
<a name="l00122"></a>00122 <span class="comment"> iQIcBAEBAgAGBQJRSsfJAAoJEAMIAO35UbuOQT8P/RJbka8etf7wbxdHQNAY+2cC</span>
<a name="l00123"></a>00123 <span class="comment"> vDf8J3X8VI+pwMqv6wgTVy17venMZJa4I4ikXD/MRyWV1XbTG0mBXk/7AZk7Rexk</span>
<a name="l00124"></a>00124 <span class="comment"> KTvL/U1kWiez6+8XXLye+k2JNM6v7eej8xMrqEcO0ZArh/DsLoIn1y8p8qjBI7+m</span>
<a name="l00125"></a>00125 <span class="comment"> aE7lhstDiD0z8mwRRLKFLN2IH5rAFaZZUvj5ERJaoYUKdn4c+RcQVei2YOl4T0FU</span>
<a name="l00126"></a>00126 <span class="comment"> LWND3YLoH8naqJXkaOKEN4UfJINCwxhe5Ke9wyfLWLUO7NamRkWD2T7CJ0xocnD1</span>
<a name="l00127"></a>00127 <span class="comment"> sjAzlVGNgaFDRflfIF4QhBx1Ddl6wwhJfw+d08bjqblSq8aXDkmFA7HeunSFKkdn</span>
<a name="l00128"></a>00128 <span class="comment"> oIEOEgyj+veuOMRJC5pnBJ9vV+7qRdDKQWaCKotynt4sWJDGQ9kWGWm74SsNaduN</span>
<a name="l00129"></a>00129 <span class="comment"> TPMyr9kNmGsfR69Q2Zq/FLcLX/j8ESxU+HYUB4vaARw2xEOu2xwDDv6jt0j3Vqsg</span>
<a name="l00130"></a>00130 <span class="comment"> x7rWv4S/Eh18FDNDkVRChiNoOIilLYLL6c38uMf1pnItBuxP3uhgY6COm59kVaRh</span>
<a name="l00131"></a>00131 <span class="comment"> nyGTYCDYD2TK+fI9o89F1297uDCwEJ62U0Q7iTDp5QuXCoxkPfv8/kX6lS6T3y9G</span>
<a name="l00132"></a>00132 <span class="comment"> M9mqIoLbIQ1EDntFv7/t6fUTS2+46uCrdZWbQ5RjYXdrzjij02nDmJAm2BngnZvd</span>
<a name="l00133"></a>00133 <span class="comment"> kamH0Y/n11lCvo1oQxM+</span>
<a name="l00134"></a>00134 <span class="comment"> =uSzz</span>
<a name="l00135"></a>00135 <span class="comment"> -----END PGP SIGNATURE-----</span>
<a name="l00136"></a>00136 <span class="comment"> **************************************************************/</span>
<a name="l00137"></a>00137 
<a name="l00138"></a>00138 <span class="preprocessor">#include &lt;<a class="code" href="stdafx_8hpp.html">stdafx.hpp</a>&gt;</span>
<a name="l00139"></a>00139 
<a name="l00140"></a>00140 <span class="preprocessor">#include &lt;<a class="code" href="_o_t_crypto_8hpp.html">OTCrypto.hpp</a>&gt;</span>
<a name="l00141"></a>00141 
<a name="l00142"></a>00142 <span class="preprocessor">#include &lt;<a class="code" href="_o_t_paths_8hpp.html">OTPaths.hpp</a>&gt;</span>
<a name="l00143"></a>00143 <span class="preprocessor">#include &lt;<a class="code" href="_o_t_assert_8hpp.html">OTAssert.hpp</a>&gt;</span>
<a name="l00144"></a>00144 <span class="preprocessor">#include &lt;<a class="code" href="_o_t_password_8hpp.html">OTPassword.hpp</a>&gt;</span>
<a name="l00145"></a>00145 <span class="preprocessor">#include &lt;<a class="code" href="_o_t_log_8hpp.html">OTLog.hpp</a>&gt;</span>
<a name="l00146"></a>00146 <span class="preprocessor">#include &lt;<a class="code" href="_o_t_identifier_8hpp.html">OTIdentifier.hpp</a>&gt;</span>
<a name="l00147"></a>00147 <span class="preprocessor">#include &lt;<a class="code" href="_o_t_asymmetric_key_8hpp.html">OTAsymmetricKey.hpp</a>&gt;</span>
<a name="l00148"></a>00148 <span class="preprocessor">#include &lt;<a class="code" href="_o_t_storage_8hpp.html">OTStorage.hpp</a>&gt;</span>
<a name="l00149"></a>00149 <span class="preprocessor">#include &lt;<a class="code" href="_o_t_pseudonym_8hpp.html">OTPseudonym.hpp</a>&gt;</span>
<a name="l00150"></a>00150 <span class="preprocessor">#include &lt;<a class="code" href="_o_t_signature_8hpp.html">OTSignature.hpp</a>&gt;</span>
<a name="l00151"></a>00151 
<a name="l00152"></a>00152 
<a name="l00153"></a>00153 <span class="preprocessor">#include &lt;bigint/BigIntegerLibrary.hh&gt;</span>
<a name="l00154"></a>00154 
<a name="l00155"></a>00155 <span class="preprocessor">#include &lt;vector&gt;</span>
<a name="l00156"></a>00156 
<a name="l00157"></a>00157 <span class="preprocessor">#include &quot;stacktrace.h&quot;</span>
<a name="l00158"></a>00158 
<a name="l00159"></a>00159 <span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span>
<a name="l00160"></a>00160 {
<a name="l00161"></a>00161 <span class="preprocessor">#ifdef _WIN32</span>
<a name="l00162"></a>00162 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00163"></a>00163 <span class="preprocessor"></span><span class="preprocessor">#include &lt;arpa/inet.h&gt;</span>          <span class="comment">// For htonl()</span>
<a name="l00164"></a>00164 <span class="preprocessor">#include &lt;unistd.h&gt;</span>
<a name="l00165"></a>00165 <span class="preprocessor">#include &lt;sys/types.h&gt;</span>
<a name="l00166"></a>00166 <span class="preprocessor">#include &lt;sys/resource.h&gt;</span>
<a name="l00167"></a>00167 <span class="preprocessor">#endif</span>
<a name="l00168"></a>00168 <span class="preprocessor"></span>}
<a name="l00169"></a>00169 
<a name="l00170"></a>00170 
<a name="l00171"></a>00171 <span class="preprocessor">#if defined (OT_CRYPTO_USING_OPENSSL)</span>
<a name="l00172"></a>00172 <span class="preprocessor"></span>
<a name="l00173"></a>00173 <span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span>
<a name="l00174"></a>00174 {
<a name="l00175"></a>00175 <span class="preprocessor">#include &lt;openssl/bio.h&gt;</span>
<a name="l00176"></a>00176 <span class="preprocessor">#include &lt;openssl/buffer.h&gt;</span>
<a name="l00177"></a>00177 <span class="preprocessor">#include &lt;openssl/evp.h&gt;</span>
<a name="l00178"></a>00178 <span class="preprocessor">#include &lt;openssl/pem.h&gt;</span>
<a name="l00179"></a>00179 <span class="preprocessor">#include &lt;openssl/rsa.h&gt;</span>
<a name="l00180"></a>00180 <span class="preprocessor">#include &lt;openssl/dsa.h&gt;</span>
<a name="l00181"></a>00181 <span class="preprocessor">#include &lt;openssl/err.h&gt;</span>
<a name="l00182"></a>00182 <span class="preprocessor">#include &lt;openssl/ui.h&gt;</span>
<a name="l00183"></a>00183 <span class="preprocessor">#include &lt;openssl/rand.h&gt;</span>
<a name="l00184"></a>00184 <span class="preprocessor">#include &lt;openssl/crypto.h&gt;</span>
<a name="l00185"></a>00185 <span class="preprocessor">#include &lt;openssl/asn1.h&gt;</span>
<a name="l00186"></a>00186 <span class="preprocessor">#include &lt;openssl/objects.h&gt;</span>
<a name="l00187"></a>00187 <span class="preprocessor">#include &lt;openssl/ssl.h&gt;</span>
<a name="l00188"></a>00188 <span class="preprocessor">#include &lt;openssl/sha.h&gt;</span>
<a name="l00189"></a>00189 <span class="preprocessor">#include &lt;openssl/conf.h&gt;</span>
<a name="l00190"></a>00190 <span class="preprocessor">#include &lt;openssl/x509v3.h&gt;</span>
<a name="l00191"></a>00191 
<a name="l00192"></a>00192 <span class="preprocessor">#ifndef OPENSSL_NO_ENGINE</span>
<a name="l00193"></a>00193 <span class="preprocessor"></span><span class="preprocessor">#include &lt;openssl/engine.h&gt;</span>
<a name="l00194"></a>00194 <span class="preprocessor">#endif</span>
<a name="l00195"></a>00195 <span class="preprocessor"></span>}
<a name="l00196"></a>00196 
<a name="l00197"></a>00197 <span class="preprocessor">#include &quot;<a class="code" href="_o_t_asymmetric_key___open_s_s_l_privdp_8hpp.html">OTAsymmetricKey_OpenSSLPrivdp.hpp</a>&quot;</span>
<a name="l00198"></a>00198 <span class="preprocessor">#include &quot;<a class="code" href="_open_s_s_l___b_i_o_8hpp.html">OpenSSL_BIO.hpp</a>&quot;</span>
<a name="l00199"></a>00199 
<a name="l00200"></a>00200 
<a name="l00201"></a>00201 <span class="preprocessor">#elif defined (OT_CRYPTO_USING_GPG)</span>
<a name="l00202"></a>00202 <span class="preprocessor"></span>
<a name="l00203"></a>00203 
<a name="l00204"></a>00204 <span class="preprocessor">#else</span>
<a name="l00205"></a>00205 <span class="preprocessor"></span>
<a name="l00206"></a>00206 <span class="preprocessor">#endif</span>
<a name="l00207"></a>00207 <span class="preprocessor"></span>
<a name="l00208"></a>00208 
<a name="l00209"></a>00209 <span class="comment">// OpenSSL / Crypto-lib d-pointer</span>
<a name="l00210"></a>00210 
<a name="l00211"></a>00211 
<a name="l00212"></a>00212 <span class="preprocessor">#if defined (OT_CRYPTO_USING_GPG)</span>
<a name="l00213"></a>00213 <span class="preprocessor"></span>
<a name="l00214"></a>00214 <span class="comment">// Someday    }:-)        OTCrypto_GPG</span>
<a name="l00215"></a>00215 
<a name="l00216"></a>00216 
<a name="l00217"></a>00217 <span class="preprocessor">#elif defined (OT_CRYPTO_USING_OPENSSL)</span>
<a name="l00218"></a>00218 <span class="preprocessor"></span>
<a name="l00219"></a>00219 <span class="keyword">class </span>OTCrypto_OpenSSL::OTCrypto_OpenSSLdp {
<a name="l00220"></a>00220 <span class="keyword">public</span>:
<a name="l00221"></a>00221 <span class="comment">// These are protected because they contain OpenSSL-specific parameters.</span>
<a name="l00222"></a>00222 
<a name="l00223"></a>00223     <span class="keywordtype">bool</span> SignContractDefaultHash(<span class="keyword">const</span> <a class="code" href="class_o_t_string.html">OTString</a>    &amp; strContractUnsigned,
<a name="l00224"></a>00224                                  <span class="keyword">const</span> EVP_PKEY    * pkey,
<a name="l00225"></a>00225                                  <a class="code" href="class_o_t_signature.html">OTSignature</a>       &amp; theSignature, <span class="comment">// output</span>
<a name="l00226"></a>00226                                  <a class="code" href="class_o_t_password_data.html">OTPasswordData</a>    * pPWData=NULL) <span class="keyword">const</span>;
<a name="l00227"></a>00227 
<a name="l00228"></a>00228     <span class="keywordtype">bool</span> VerifyContractDefaultHash(<span class="keyword">const</span> <a class="code" href="class_o_t_string.html">OTString</a>    &amp; strContractToVerify,
<a name="l00229"></a>00229                                    <span class="keyword">const</span> EVP_PKEY    * pkey,
<a name="l00230"></a>00230                                    <span class="keyword">const</span> <a class="code" href="class_o_t_signature.html">OTSignature</a> &amp; theSignature,
<a name="l00231"></a>00231                                    <a class="code" href="class_o_t_password_data.html">OTPasswordData</a>    * pPWData=NULL) <span class="keyword">const</span>;
<a name="l00232"></a>00232     <span class="comment">// ----------------------------------</span>
<a name="l00233"></a>00233     <span class="comment">// Sign or verify using the actual OpenSSL EVP_PKEY</span>
<a name="l00234"></a>00234     <span class="comment">//</span>
<a name="l00235"></a>00235     <span class="keywordtype">bool</span> SignContract(<span class="keyword">const</span> <a class="code" href="class_o_t_string.html">OTString</a>    &amp; strContractUnsigned,
<a name="l00236"></a>00236                       <span class="keyword">const</span> EVP_PKEY    * pkey,
<a name="l00237"></a>00237                       <a class="code" href="class_o_t_signature.html">OTSignature</a>       &amp; theSignature, <span class="comment">// output</span>
<a name="l00238"></a>00238                       <span class="keyword">const</span> <a class="code" href="class_o_t_string.html">OTString</a>    &amp; strHashType,
<a name="l00239"></a>00239                       <a class="code" href="class_o_t_password_data.html">OTPasswordData</a>    * pPWData=NULL) <span class="keyword">const</span>;
<a name="l00240"></a>00240 
<a name="l00241"></a>00241     <span class="keywordtype">bool</span> VerifySignature(<span class="keyword">const</span> <a class="code" href="class_o_t_string.html">OTString</a>    &amp; strContractToVerify,
<a name="l00242"></a>00242                          <span class="keyword">const</span> EVP_PKEY    * pkey,
<a name="l00243"></a>00243                          <span class="keyword">const</span> <a class="code" href="class_o_t_signature.html">OTSignature</a> &amp; theSignature,
<a name="l00244"></a>00244                          <span class="keyword">const</span> <a class="code" href="class_o_t_string.html">OTString</a>    &amp; strHashType,
<a name="l00245"></a>00245                          <a class="code" href="class_o_t_password_data.html">OTPasswordData</a>    * pPWData=NULL) <span class="keyword">const</span>;
<a name="l00246"></a>00246     <span class="comment">// --------------------------------------------------------------</span>
<a name="l00247"></a>00247     <span class="keyword">static</span> <span class="keyword">const</span> EVP_MD * GetOpenSSLDigestByName(<span class="keyword">const</span> <a class="code" href="class_o_t_string.html">OTString</a> &amp; theName);
<a name="l00248"></a>00248 };
<a name="l00249"></a>00249 
<a name="l00250"></a>00250 
<a name="l00251"></a>00251 <span class="preprocessor">#else // Apparently NO crypto engine is defined!</span>
<a name="l00252"></a>00252 <span class="preprocessor"></span>
<a name="l00253"></a>00253 
<a name="l00254"></a>00254 <span class="comment">// Perhaps error out here...</span>
<a name="l00255"></a>00255 
<a name="l00256"></a>00256 
<a name="l00257"></a>00257 <span class="preprocessor">#endif // if defined (OT_CRYPTO_USING_OPENSSL), elif defined (OT_CRYPTO_USING_GPG), else, endif.</span>
<a name="l00258"></a>00258 <span class="preprocessor"></span>
<a name="l00259"></a>00259 
<a name="l00260"></a>00260 <span class="comment">// class OTCrypto</span>
<a name="l00261"></a>00261 <span class="comment">//</span>
<a name="l00262"></a>00262 <span class="comment">// To someday get us to the point where we can easily swap crypto libs.</span>
<a name="l00263"></a>00263 <span class="comment">// For now, just for static init / cleanup functions we can call from</span>
<a name="l00264"></a>00264 <span class="comment">// OTLog Init/Cleanup, and move the more &quot;crypto&quot; related stuff to this file.</span>
<a name="l00265"></a>00265 <span class="comment">//</span>
<a name="l00266"></a>00266 
<a name="l00267"></a>00267 
<a name="l00268"></a>00268 <span class="comment">// todo optimzation maybe this should be 10000 instead of 65535</span>
<a name="l00269"></a>00269 <span class="comment">//</span>
<a name="l00270"></a><a class="code" href="_o_t_crypto_8cpp.html#a52b7ceb3fb4b0d8ccbbd7a63994857a1">00270</a> <span class="preprocessor">#define OT_DEFAULT_ITERATION_COUNT         65535  // in bytes</span>
<a name="l00271"></a><a class="code" href="_o_t_crypto_8cpp.html#a00f922d2585b17acaabe8a507b5f2423">00271</a> <span class="preprocessor"></span><span class="preprocessor">#define OT_DEFAULT_SYMMETRIC_SALT_SIZE     8      // in bytes</span>
<a name="l00272"></a><a class="code" href="_o_t_crypto_8cpp.html#ac76ab2c281d6da22e8f365e530cdabea">00272</a> <span class="preprocessor"></span><span class="preprocessor">#define OT_DEFAULT_SYMMETRIC_KEY_SIZE      16     // in bytes</span>
<a name="l00273"></a><a class="code" href="_o_t_crypto_8cpp.html#a31dee45718638de72fd7851f9af1db22">00273</a> <span class="preprocessor"></span><span class="preprocessor">#define OT_DEFAULT_SYMMETRIC_KEY_SIZE_MAX  64     // in bytes == 512 bits</span>
<a name="l00274"></a><a class="code" href="_o_t_crypto_8cpp.html#ad74c9451cdb80b5dafe5daa8befc14fd">00274</a> <span class="preprocessor"></span><span class="preprocessor">#define OT_DEFAULT_SYMMETRIC_IV_SIZE       16     // in bytes</span>
<a name="l00275"></a><a class="code" href="_o_t_crypto_8cpp.html#a1610edf3455f9e86ca5ec9c8d793b542">00275</a> <span class="preprocessor"></span><span class="preprocessor">#define OT_DEFAULT_SYMMETRIC_BUFFER_SIZE   4096   // in bytes</span>
<a name="l00276"></a><a class="code" href="_o_t_crypto_8cpp.html#a9129f4a0638945f74c6739c6c01c1561">00276</a> <span class="preprocessor"></span><span class="preprocessor">#define OT_DEFAULT_PUBLIC_KEYSIZE          128    // in bytes == 4096 bits</span>
<a name="l00277"></a><a class="code" href="_o_t_crypto_8cpp.html#a62193cbdedc4ad91c47780f5756d5147">00277</a> <span class="preprocessor"></span><span class="preprocessor">#define OT_DEFAULT_PUBLIC_KEYSIZE_MAX      512    // in bytes == 1024 bits</span>
<a name="l00278"></a><a class="code" href="_o_t_crypto_8cpp.html#aeba3f39b1cc2e3ed87c9f8048a0efa2c">00278</a> <span class="preprocessor"></span><span class="preprocessor">#define OT_DEFAULT_DIGEST_1_SIZE           32     // in bytes == 256 bits.</span>
<a name="l00279"></a><a class="code" href="_o_t_crypto_8cpp.html#aa452a44afd65877fa8403a3ce7c4e5f6">00279</a> <span class="preprocessor"></span><span class="preprocessor">#define OT_DEFAULT_DIGEST_2_SIZE           64     // in bytes == 512 bits.</span>
<a name="l00280"></a>00280 <span class="preprocessor"></span>
<a name="l00281"></a><a class="code" href="_o_t_crypto_8cpp.html#ae2ce3d4a87844af8f2725ba6b1958f09">00281</a> <span class="preprocessor">#define OT_KEY_ITERATION_COUNT             &quot;iteration_count&quot;</span>
<a name="l00282"></a><a class="code" href="_o_t_crypto_8cpp.html#a97856e020d7e8a5500ebaa5cf6f0af7b">00282</a> <span class="preprocessor"></span><span class="preprocessor">#define OT_KEY_SYMMETRIC_SALT_SIZE         &quot;symmetric_salt_size&quot;</span>
<a name="l00283"></a><a class="code" href="_o_t_crypto_8cpp.html#a9152f4ea5947128d0d432b7420e802c5">00283</a> <span class="preprocessor"></span><span class="preprocessor">#define OT_KEY_SYMMETRIC_KEY_SIZE          &quot;symmetric_key_size&quot;</span>
<a name="l00284"></a><a class="code" href="_o_t_crypto_8cpp.html#ae405c4159f1774eeb041acbbda8ceae3">00284</a> <span class="preprocessor"></span><span class="preprocessor">#define OT_KEY_SYMMETRIC_KEY_SIZE_MAX      &quot;symmetric_key_size_max&quot;</span>
<a name="l00285"></a><a class="code" href="_o_t_crypto_8cpp.html#a4434cb056853621acd5298f1370ea710">00285</a> <span class="preprocessor"></span><span class="preprocessor">#define OT_KEY_SYMMETRIC_IV_SIZE           &quot;symmetric_iv_size&quot;</span>
<a name="l00286"></a><a class="code" href="_o_t_crypto_8cpp.html#ac459bd301be7a50b649ca2f2b0b43c2f">00286</a> <span class="preprocessor"></span><span class="preprocessor">#define OT_KEY_SYMMETRIC_BUFFER_SIZE       &quot;symmetric_buffer_size&quot;</span>
<a name="l00287"></a><a class="code" href="_o_t_crypto_8cpp.html#a372f28dec03e3436684e559d5b9909ec">00287</a> <span class="preprocessor"></span><span class="preprocessor">#define OT_KEY_PUBLIC_KEYSIZE              &quot;public_keysize&quot;</span>
<a name="l00288"></a><a class="code" href="_o_t_crypto_8cpp.html#a515152f53f212ee8702d114467ed5238">00288</a> <span class="preprocessor"></span><span class="preprocessor">#define OT_KEY_PUBLIC_KEYSIZE_MAX          &quot;public_keysize_max&quot;</span>
<a name="l00289"></a><a class="code" href="_o_t_crypto_8cpp.html#aac6a910353b209a9300887532986ceaf">00289</a> <span class="preprocessor"></span><span class="preprocessor">#define OT_KEY_DIGEST_1_SIZE               &quot;digest_1_size&quot;</span>
<a name="l00290"></a><a class="code" href="_o_t_crypto_8cpp.html#a82db29991cd3499557e9323b840b4a0d">00290</a> <span class="preprocessor"></span><span class="preprocessor">#define OT_KEY_DIGEST_2_SIZE               &quot;digest_2_size&quot;</span>
<a name="l00291"></a>00291 <span class="preprocessor"></span>
<a name="l00292"></a>00292 <span class="keyword">const</span> int32_t * OTCryptoConfig::sp_nIterationCount       = NULL;
<a name="l00293"></a>00293 <span class="keyword">const</span> int32_t * OTCryptoConfig::sp_nSymmetricSaltSize    = NULL;
<a name="l00294"></a>00294 <span class="keyword">const</span> int32_t * OTCryptoConfig::sp_nSymmetricKeySize     = NULL;
<a name="l00295"></a>00295 <span class="keyword">const</span> int32_t * OTCryptoConfig::sp_nSymmetricKeySizeMax  = NULL;
<a name="l00296"></a>00296 <span class="keyword">const</span> int32_t * OTCryptoConfig::sp_nSymmetricIvSize      = NULL;
<a name="l00297"></a>00297 <span class="keyword">const</span> int32_t * OTCryptoConfig::sp_nSymmetricBufferSize  = NULL;
<a name="l00298"></a>00298 <span class="keyword">const</span> int32_t * OTCryptoConfig::sp_nPublicKeysize        = NULL;
<a name="l00299"></a>00299 <span class="keyword">const</span> int32_t * OTCryptoConfig::sp_nPublicKeysizeMax     = NULL;
<a name="l00300"></a>00300 <span class="keyword">const</span> int32_t * OTCryptoConfig::sp_nDigest1Size          = NULL;
<a name="l00301"></a>00301 <span class="keyword">const</span> int32_t * OTCryptoConfig::sp_nDigest2Size          = NULL;
<a name="l00302"></a>00302 
<a name="l00303"></a>00303 
<a name="l00304"></a>00304 <span class="keywordtype">bool</span> OTCryptoConfig::GetSetAll()
<a name="l00305"></a>00305 {
<a name="l00306"></a>00306     <a class="code" href="class_o_t_settings.html">OTSettings</a> config = <a class="code" href="class_o_t_settings.html">OTSettings</a>(<a class="code" href="class_o_t_paths.html#aabd28aebbe926ba547ea13dbdea7b2fd">OTPaths::GlobalConfigFile</a>());
<a name="l00307"></a>00307 
<a name="l00308"></a>00308     config.<a class="code" href="class_o_t_settings.html#a309c91e013b50460890d3f109e357cbf">Reset</a>();
<a name="l00309"></a>00309 
<a name="l00310"></a>00310     <span class="keywordflow">if</span>(!config.Load()) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00311"></a>00311 
<a name="l00312"></a>00312     <span class="keywordflow">if</span>(!GetSetValue(config,<a class="code" href="_o_t_crypto_8cpp.html#ae2ce3d4a87844af8f2725ba6b1958f09">OT_KEY_ITERATION_COUNT</a>,         <a class="code" href="_o_t_crypto_8cpp.html#a52b7ceb3fb4b0d8ccbbd7a63994857a1">OT_DEFAULT_ITERATION_COUNT</a>,         sp_nIterationCount       )) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00313"></a>00313     <span class="keywordflow">if</span>(!GetSetValue(config,<a class="code" href="_o_t_crypto_8cpp.html#a97856e020d7e8a5500ebaa5cf6f0af7b">OT_KEY_SYMMETRIC_SALT_SIZE</a>,     <a class="code" href="_o_t_crypto_8cpp.html#a00f922d2585b17acaabe8a507b5f2423">OT_DEFAULT_SYMMETRIC_SALT_SIZE</a>,     sp_nSymmetricSaltSize    )) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00314"></a>00314     <span class="keywordflow">if</span>(!GetSetValue(config,<a class="code" href="_o_t_crypto_8cpp.html#a9152f4ea5947128d0d432b7420e802c5">OT_KEY_SYMMETRIC_KEY_SIZE</a>,      <a class="code" href="_o_t_crypto_8cpp.html#ac76ab2c281d6da22e8f365e530cdabea">OT_DEFAULT_SYMMETRIC_KEY_SIZE</a>,      sp_nSymmetricKeySize     )) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00315"></a>00315     <span class="keywordflow">if</span>(!GetSetValue(config,<a class="code" href="_o_t_crypto_8cpp.html#ae405c4159f1774eeb041acbbda8ceae3">OT_KEY_SYMMETRIC_KEY_SIZE_MAX</a>,  <a class="code" href="_o_t_crypto_8cpp.html#a31dee45718638de72fd7851f9af1db22">OT_DEFAULT_SYMMETRIC_KEY_SIZE_MAX</a>,  sp_nSymmetricKeySizeMax  )) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00316"></a>00316     <span class="keywordflow">if</span>(!GetSetValue(config,<a class="code" href="_o_t_crypto_8cpp.html#a4434cb056853621acd5298f1370ea710">OT_KEY_SYMMETRIC_IV_SIZE</a>,       <a class="code" href="_o_t_crypto_8cpp.html#ad74c9451cdb80b5dafe5daa8befc14fd">OT_DEFAULT_SYMMETRIC_IV_SIZE</a>,       sp_nSymmetricIvSize      )) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00317"></a>00317     <span class="keywordflow">if</span>(!GetSetValue(config,<a class="code" href="_o_t_crypto_8cpp.html#ac459bd301be7a50b649ca2f2b0b43c2f">OT_KEY_SYMMETRIC_BUFFER_SIZE</a>,   <a class="code" href="_o_t_crypto_8cpp.html#a1610edf3455f9e86ca5ec9c8d793b542">OT_DEFAULT_SYMMETRIC_BUFFER_SIZE</a>,   sp_nSymmetricBufferSize  )) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00318"></a>00318     <span class="keywordflow">if</span>(!GetSetValue(config,<a class="code" href="_o_t_crypto_8cpp.html#a372f28dec03e3436684e559d5b9909ec">OT_KEY_PUBLIC_KEYSIZE</a>,          <a class="code" href="_o_t_crypto_8cpp.html#a9129f4a0638945f74c6739c6c01c1561">OT_DEFAULT_PUBLIC_KEYSIZE</a>,          sp_nPublicKeysize        )) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00319"></a>00319     <span class="keywordflow">if</span>(!GetSetValue(config,<a class="code" href="_o_t_crypto_8cpp.html#a515152f53f212ee8702d114467ed5238">OT_KEY_PUBLIC_KEYSIZE_MAX</a>,      <a class="code" href="_o_t_crypto_8cpp.html#a62193cbdedc4ad91c47780f5756d5147">OT_DEFAULT_PUBLIC_KEYSIZE_MAX</a>,      sp_nPublicKeysizeMax     )) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00320"></a>00320     <span class="keywordflow">if</span>(!GetSetValue(config,<a class="code" href="_o_t_crypto_8cpp.html#aac6a910353b209a9300887532986ceaf">OT_KEY_DIGEST_1_SIZE</a>,           <a class="code" href="_o_t_crypto_8cpp.html#aeba3f39b1cc2e3ed87c9f8048a0efa2c">OT_DEFAULT_DIGEST_1_SIZE</a>,           sp_nDigest1Size          )) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00321"></a>00321     <span class="keywordflow">if</span>(!GetSetValue(config,<a class="code" href="_o_t_crypto_8cpp.html#a82db29991cd3499557e9323b840b4a0d">OT_KEY_DIGEST_2_SIZE</a>,           <a class="code" href="_o_t_crypto_8cpp.html#aa452a44afd65877fa8403a3ce7c4e5f6">OT_DEFAULT_DIGEST_2_SIZE</a>,           sp_nDigest2Size          )) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00322"></a>00322 
<a name="l00323"></a>00323     <span class="keywordflow">if</span>(!config.Save()) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00324"></a>00324 
<a name="l00325"></a>00325     config.<a class="code" href="class_o_t_settings.html#a309c91e013b50460890d3f109e357cbf">Reset</a>();
<a name="l00326"></a>00326 
<a name="l00327"></a>00327     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00328"></a>00328 }
<a name="l00329"></a>00329 
<a name="l00330"></a><a class="code" href="class_o_t_crypto_config.html#a4689bd532160fb559daf7432e022fa9e">00330</a> uint32_t <a class="code" href="class_o_t_crypto_config.html#a4689bd532160fb559daf7432e022fa9e">OTCryptoConfig::IterationCount</a>()       { <span class="keywordflow">return</span> GetValue(sp_nIterationCount); }
<a name="l00331"></a><a class="code" href="class_o_t_crypto_config.html#a8ef27ed3967ca9cc50278997f83d0de4">00331</a> uint32_t <a class="code" href="class_o_t_crypto_config.html#a8ef27ed3967ca9cc50278997f83d0de4">OTCryptoConfig::SymmetricSaltSize</a>()    { <span class="keywordflow">return</span> GetValue(sp_nSymmetricSaltSize); }
<a name="l00332"></a><a class="code" href="class_o_t_crypto_config.html#a835596fd28dc8f14d62e6a141e6b4c11">00332</a> uint32_t <a class="code" href="class_o_t_crypto_config.html#a835596fd28dc8f14d62e6a141e6b4c11">OTCryptoConfig::SymmetricKeySize</a>()     { <span class="keywordflow">return</span> GetValue(sp_nSymmetricKeySize); }
<a name="l00333"></a><a class="code" href="class_o_t_crypto_config.html#a5a057078486934bf436028937bd338c6">00333</a> uint32_t <a class="code" href="class_o_t_crypto_config.html#a5a057078486934bf436028937bd338c6">OTCryptoConfig::SymmetricKeySizeMax</a>()  { <span class="keywordflow">return</span> GetValue(sp_nSymmetricKeySizeMax); }
<a name="l00334"></a><a class="code" href="class_o_t_crypto_config.html#ae6a1a4137bd87e84c342bb4e0149ca56">00334</a> uint32_t <a class="code" href="class_o_t_crypto_config.html#ae6a1a4137bd87e84c342bb4e0149ca56">OTCryptoConfig::SymmetricIvSize</a>()      { <span class="keywordflow">return</span> GetValue(sp_nSymmetricIvSize); }
<a name="l00335"></a><a class="code" href="class_o_t_crypto_config.html#a6fc89263c5ae6042f7cc511e820ef369">00335</a> uint32_t <a class="code" href="class_o_t_crypto_config.html#a6fc89263c5ae6042f7cc511e820ef369">OTCryptoConfig::SymmetricBufferSize</a>()  { <span class="keywordflow">return</span> GetValue(sp_nSymmetricBufferSize); }
<a name="l00336"></a><a class="code" href="class_o_t_crypto_config.html#acfc768d1e95d72cce44d73b7122aac32">00336</a> uint32_t <a class="code" href="class_o_t_crypto_config.html#acfc768d1e95d72cce44d73b7122aac32">OTCryptoConfig::PublicKeysize</a>()        { <span class="keywordflow">return</span> GetValue(sp_nPublicKeysize); }
<a name="l00337"></a><a class="code" href="class_o_t_crypto_config.html#a30aaf4e08e6fa68ed59b458ab3787096">00337</a> uint32_t <a class="code" href="class_o_t_crypto_config.html#a30aaf4e08e6fa68ed59b458ab3787096">OTCryptoConfig::PublicKeysizeMax</a>()     { <span class="keywordflow">return</span> GetValue(sp_nPublicKeysizeMax); }
<a name="l00338"></a><a class="code" href="class_o_t_crypto_config.html#ac643539dd99516aa4205241bd3c922bf">00338</a> uint32_t <a class="code" href="class_o_t_crypto_config.html#ac643539dd99516aa4205241bd3c922bf">OTCryptoConfig::Digest1Size</a>()          { <span class="keywordflow">return</span> GetValue(sp_nDigest1Size); }
<a name="l00339"></a><a class="code" href="class_o_t_crypto_config.html#aa1580b84f8b414f060303194c82b19b8">00339</a> uint32_t <a class="code" href="class_o_t_crypto_config.html#aa1580b84f8b414f060303194c82b19b8">OTCryptoConfig::Digest2Size</a>()          { <span class="keywordflow">return</span> GetValue(sp_nDigest2Size); }
<a name="l00340"></a>00340 
<a name="l00341"></a>00341 
<a name="l00342"></a>00342 <span class="comment">//static</span>
<a name="l00343"></a>00343 int32_t OTCrypto::s_nCount = 0;   <span class="comment">// Instance count, should never exceed 1. (At this point, anyway.)</span>
<a name="l00344"></a>00344 
<a name="l00345"></a>00345 
<a name="l00346"></a><a class="code" href="class_o_t_crypto.html#a03221bb2a741ee44d40520985278fe81">00346</a> <a class="code" href="class_o_t_crypto.html#a03221bb2a741ee44d40520985278fe81">OTCrypto::OTCrypto</a>()   { }
<a name="l00347"></a><a class="code" href="class_o_t_crypto.html#a07fdfa0ce8ec8b105e2855678996fe64">00347</a> <a class="code" href="class_o_t_crypto.html#a07fdfa0ce8ec8b105e2855678996fe64">OTCrypto::~OTCrypto</a>()  { }
<a name="l00348"></a>00348 
<a name="l00349"></a>00349 
<a name="l00350"></a><a class="code" href="class_o_t_crypto.html#aa781ad940ddb0a2e4bdd1235b93e3b8a">00350</a> <span class="keywordtype">bool</span> <a class="code" href="class_o_t_crypto.html#aa781ad940ddb0a2e4bdd1235b93e3b8a">OTCrypto::IsBase62</a>(<span class="keyword">const</span> std::string &amp;str)<span class="keyword"> const</span>
<a name="l00351"></a>00351 <span class="keyword"></span>{
<a name="l00352"></a>00352     <span class="keywordflow">return</span> str.find_first_not_of(<span class="stringliteral">&quot;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span>) == std::string::npos;
<a name="l00353"></a>00353 }
<a name="l00354"></a>00354 
<a name="l00355"></a>00355 
<a name="l00356"></a>00356 <span class="comment">/*</span>
<a name="l00357"></a>00357 <span class="comment">extern &quot;C&quot;</span>
<a name="l00358"></a>00358 <span class="comment">{</span>
<a name="l00359"></a>00359 <span class="comment">void SetStdinEcho(int32_t enable)</span>
<a name="l00360"></a>00360 <span class="comment">{</span>
<a name="l00361"></a>00361 <span class="comment">#ifdef WIN32</span>
<a name="l00362"></a>00362 <span class="comment">    HANDLE hStdin = GetStdHandle(STD_INPUT_HANDLE);</span>
<a name="l00363"></a>00363 <span class="comment">    DWORD mode;</span>
<a name="l00364"></a>00364 <span class="comment">    GetConsoleMode(hStdin, &amp;mode);</span>
<a name="l00365"></a>00365 <span class="comment"></span>
<a name="l00366"></a>00366 <span class="comment">    if( !enable )</span>
<a name="l00367"></a>00367 <span class="comment">        mode &amp;= ~ENABLE_ECHO_INPUT;</span>
<a name="l00368"></a>00368 <span class="comment">    else</span>
<a name="l00369"></a>00369 <span class="comment">        mode |= ENABLE_ECHO_INPUT;</span>
<a name="l00370"></a>00370 <span class="comment"></span>
<a name="l00371"></a>00371 <span class="comment">    SetConsoleMode(hStdin, mode );</span>
<a name="l00372"></a>00372 <span class="comment"></span>
<a name="l00373"></a>00373 <span class="comment">#else</span>
<a name="l00374"></a>00374 <span class="comment">    struct termios tty;</span>
<a name="l00375"></a>00375 <span class="comment">    tcgetattr(STDIN_FILENO, &amp;tty);</span>
<a name="l00376"></a>00376 <span class="comment">    if( !enable )</span>
<a name="l00377"></a>00377 <span class="comment">        tty.c_lflag &amp;= ~ECHO;</span>
<a name="l00378"></a>00378 <span class="comment">    else</span>
<a name="l00379"></a>00379 <span class="comment">        tty.c_lflag |= ECHO;</span>
<a name="l00380"></a>00380 <span class="comment"></span>
<a name="l00381"></a>00381 <span class="comment">    tcsetattr(STDIN_FILENO, TCSANOW, &amp;tty);</span>
<a name="l00382"></a>00382 <span class="comment">#endif</span>
<a name="l00383"></a>00383 <span class="comment">}</span>
<a name="l00384"></a>00384 <span class="comment">}</span>
<a name="l00385"></a>00385 <span class="comment">*/</span>
<a name="l00386"></a>00386 
<a name="l00387"></a>00387 
<a name="l00388"></a>00388 <span class="comment">/*</span>
<a name="l00389"></a>00389 <span class="comment">int32_t _getch( void ); // windows only  #include &lt;conio.h&gt;</span>
<a name="l00390"></a>00390 <span class="comment"></span>
<a name="l00391"></a>00391 <span class="comment">int32_t main()</span>
<a name="l00392"></a>00392 <span class="comment">{</span>
<a name="l00393"></a>00393 <span class="comment">    std::string password;</span>
<a name="l00394"></a>00394 <span class="comment">    char ch;</span>
<a name="l00395"></a>00395 <span class="comment">    const char ENTER = 13;</span>
<a name="l00396"></a>00396 <span class="comment"></span>
<a name="l00397"></a>00397 <span class="comment">    std::cout &lt;&lt; &quot;enter the password: &quot;;</span>
<a name="l00398"></a>00398 <span class="comment"></span>
<a name="l00399"></a>00399 <span class="comment">    while((ch = _getch()) != ENTER)</span>
<a name="l00400"></a>00400 <span class="comment">    {</span>
<a name="l00401"></a>00401 <span class="comment">        bool    addChar(char theChar);</span>
<a name="l00402"></a>00402 <span class="comment">        password += ch;</span>
<a name="l00403"></a>00403 <span class="comment">        std::cout &lt;&lt; &#39;*&#39;;</span>
<a name="l00404"></a>00404 <span class="comment">    }</span>
<a name="l00405"></a>00405 <span class="comment">}</span>
<a name="l00406"></a>00406 <span class="comment">*/</span>
<a name="l00407"></a>00407 
<a name="l00408"></a>00408 
<a name="l00409"></a>00409 <span class="preprocessor">#include &lt;iostream&gt;</span>
<a name="l00410"></a>00410 
<a name="l00411"></a>00411 <span class="preprocessor">#ifndef _PASSWORD_LEN</span>
<a name="l00412"></a><a class="code" href="_o_t_crypto_8cpp.html#af4c84da6262e0f12f9044e518bedc60d">00412</a> <span class="preprocessor"></span><span class="preprocessor">#define _PASSWORD_LEN   128</span>
<a name="l00413"></a>00413 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00414"></a>00414 <span class="preprocessor"></span>
<a name="l00415"></a><a class="code" href="class_o_t_crypto.html#aec77aefc3e722c8ee86b8ee95e3682d9">00415</a> <span class="keywordtype">bool</span> <a class="code" href="class_o_t_crypto.html#aec77aefc3e722c8ee86b8ee95e3682d9">OTCrypto::GetPasswordFromConsoleLowLevel</a>(<a class="code" href="class_o_t_password.html">OTPassword</a> &amp; theOutput, <span class="keyword">const</span> <span class="keywordtype">char</span> * szPrompt)<span class="keyword"> const</span>
<a name="l00416"></a>00416 <span class="keyword"></span>{
<a name="l00417"></a>00417     <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != szPrompt);
<a name="l00418"></a>00418 
<a name="l00419"></a>00419 <span class="preprocessor">#ifdef _WIN32</span>
<a name="l00420"></a>00420 <span class="preprocessor"></span>    {
<a name="l00421"></a>00421         std::cout &lt;&lt; szPrompt;
<a name="l00422"></a>00422 
<a name="l00423"></a>00423         {
<a name="l00424"></a>00424             std::string strPassword = <span class="stringliteral">&quot;&quot;</span>;
<a name="l00425"></a>00425 
<a name="l00426"></a>00426 <span class="preprocessor">#ifdef UNICODE</span>
<a name="l00427"></a>00427 <span class="preprocessor"></span>
<a name="l00428"></a>00428             <span class="keyword">const</span> <span class="keywordtype">wchar_t</span> enter[] = {L<span class="stringliteral">&#39;\x000D&#39;</span>, L<span class="stringliteral">&#39;\x0000&#39;</span>};  <span class="comment">// carrage return</span>
<a name="l00429"></a>00429             <span class="keyword">const</span> std::wstring wstrENTER = enter;
<a name="l00430"></a>00430 
<a name="l00431"></a>00431             std::wstring wstrPass = L<span class="stringliteral">&quot;&quot;</span>;
<a name="l00432"></a>00432 
<a name="l00433"></a>00433             <span class="keywordflow">for</span> (;;) {
<a name="l00434"></a>00434                 <span class="keyword">const</span> <span class="keywordtype">wchar_t</span> ch[] = {_getwch(), L<span class="stringliteral">&#39;\x0000&#39;</span>};
<a name="l00435"></a>00435                 <span class="keyword">const</span> std::wstring wstrCH = ch;
<a name="l00436"></a>00436                 <span class="keywordflow">if</span> (wstrENTER == wstrCH) <span class="keywordflow">break</span>;
<a name="l00437"></a>00437                 wstrPass.append(wstrCH);
<a name="l00438"></a>00438             }
<a name="l00439"></a>00439             strPassword = OTString::ws2s(wstrPass);
<a name="l00440"></a>00440 
<a name="l00441"></a>00441 <span class="preprocessor">#else</span>
<a name="l00442"></a>00442 <span class="preprocessor"></span>
<a name="l00443"></a>00443             <span class="keyword">const</span> <span class="keywordtype">char</span> enter[] = {<span class="stringliteral">&#39;\x0D&#39;</span>, <span class="stringliteral">&#39;\x00&#39;</span>}; <span class="comment">// carrage return</span>
<a name="l00444"></a>00444             <span class="keyword">const</span> std::string strENTER = enter;
<a name="l00445"></a>00445 
<a name="l00446"></a>00446             std::string strPass = <span class="stringliteral">&quot;&quot;</span>;
<a name="l00447"></a>00447 
<a name="l00448"></a>00448             <span class="keywordflow">for</span> (;;) {
<a name="l00449"></a>00449                 <span class="keyword">const</span> <span class="keywordtype">char</span> ch[] = {_getch(), <span class="stringliteral">&#39;\x00&#39;</span>};
<a name="l00450"></a>00450                 <span class="keyword">const</span> std::string strCH = ch;
<a name="l00451"></a>00451                 <span class="keywordflow">if</span> (strENTER == strCH) <span class="keywordflow">break</span>;
<a name="l00452"></a>00452                 strPass.append(strCH);
<a name="l00453"></a>00453             }
<a name="l00454"></a>00454             strPassword = strPass;
<a name="l00455"></a>00455 
<a name="l00456"></a>00456 <span class="preprocessor">#endif</span>
<a name="l00457"></a>00457 <span class="preprocessor"></span>            theOutput.<a class="code" href="class_o_t_password.html#a251ed5100b869ae4b80166453e75e964">setPassword</a>(strPassword.c_str(), <span class="keyword">static_cast&lt;</span>int32_t<span class="keyword">&gt;</span>(strPassword.length() -1));
<a name="l00458"></a>00458         }
<a name="l00459"></a>00459 
<a name="l00460"></a>00460         std::cout &lt;&lt; std::endl; <span class="comment">//new line.</span>
<a name="l00461"></a>00461         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00462"></a>00462     }
<a name="l00463"></a>00463 <span class="preprocessor">#elif defined (OT_CRYPTO_USING_OPENSSL)</span>
<a name="l00464"></a>00464 <span class="preprocessor"></span>    <span class="comment">// todo security: might want to allow to set OTPassword&#39;s size and copy directly into it,</span>
<a name="l00465"></a>00465     <span class="comment">// so that we aren&#39;t using this temp buf in between, which, although we&#39;re zeroing it, could</span>
<a name="l00466"></a>00466     <span class="comment">// technically end up getting swapped to disk.</span>
<a name="l00467"></a>00467     <span class="comment">//</span>
<a name="l00468"></a>00468     {
<a name="l00469"></a>00469         <span class="keywordtype">char</span> buf[<a class="code" href="_o_t_crypto_8cpp.html#af4c84da6262e0f12f9044e518bedc60d">_PASSWORD_LEN</a> + 10] = <span class="stringliteral">&quot;&quot;</span>, buff[<a class="code" href="_o_t_crypto_8cpp.html#af4c84da6262e0f12f9044e518bedc60d">_PASSWORD_LEN</a> + 10] = <span class="stringliteral">&quot;&quot;</span>;
<a name="l00470"></a>00470 
<a name="l00471"></a>00471         int32_t nReadPW = 0;
<a name="l00472"></a>00472 
<a name="l00473"></a>00473         <span class="comment">//  char * szPass = getpass(szPrompt); // &quot;This function is obsolete. Do not use it.&quot;</span>
<a name="l00474"></a>00474         <span class="keywordflow">if</span> ((nReadPW = UI_UTIL_read_pw(buf,buff,<a class="code" href="_o_t_crypto_8cpp.html#af4c84da6262e0f12f9044e518bedc60d">_PASSWORD_LEN</a>,szPrompt,0)) == 0) <span class="comment">// verify=0</span>
<a name="l00475"></a>00475         {
<a name="l00476"></a>00476             <span class="keywordtype">size_t</span> nPassLength = <a class="code" href="class_o_t_string.html#ab5af2359dd0aa0fe00c1cd122ea6643d">OTString::safe_strlen</a>(buf, <a class="code" href="_o_t_crypto_8cpp.html#af4c84da6262e0f12f9044e518bedc60d">_PASSWORD_LEN</a>);
<a name="l00477"></a>00477             theOutput.<a class="code" href="class_o_t_password.html#a3284608f45ab63f567944e014b92895d">setPassword_uint8</a>(reinterpret_cast&lt;uint8_t*&gt;(buf), nPassLength);
<a name="l00478"></a>00478             <a class="code" href="class_o_t_password.html#a3a971b06f42d1c89802167a0ab5330a5">OTPassword::zeroMemory</a>(buf, nPassLength);
<a name="l00479"></a>00479             <a class="code" href="class_o_t_password.html#a3a971b06f42d1c89802167a0ab5330a5">OTPassword::zeroMemory</a>(buff, nPassLength);
<a name="l00480"></a>00480             <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00481"></a>00481         }
<a name="l00482"></a>00482         <span class="keywordflow">else</span>
<a name="l00483"></a>00483             <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00484"></a>00484         <span class="comment">// -----------------------------------------</span>
<a name="l00485"></a>00485     }
<a name="l00486"></a>00486 <span class="preprocessor">#else</span>
<a name="l00487"></a>00487 <span class="preprocessor"></span>    {
<a name="l00488"></a>00488         <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;%s: Open-Transactions is not compiled to collect &quot;</span>
<a name="l00489"></a>00489             <span class="stringliteral">&quot;the passphrase from the console!\n&quot;</span>, __FUNCTION__);
<a name="l00490"></a>00490         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00491"></a>00491     }
<a name="l00492"></a>00492 <span class="preprocessor">#endif</span>
<a name="l00493"></a>00493 <span class="preprocessor"></span>}
<a name="l00494"></a>00494 
<a name="l00495"></a>00495 
<a name="l00496"></a>00496         <span class="comment">// get pass phrase, length &#39;len&#39; into &#39;tmp&#39;</span>
<a name="l00497"></a>00497         <span class="comment">/*</span>
<a name="l00498"></a>00498 <span class="comment">        int32_t len=0;</span>
<a name="l00499"></a>00499 <span class="comment">        char *tmp=NULL;</span>
<a name="l00500"></a>00500 <span class="comment">//      tmp = &quot;test&quot;;</span>
<a name="l00501"></a>00501 <span class="comment">        len = strlen(tmp);</span>
<a name="l00502"></a>00502 <span class="comment"></span>
<a name="l00503"></a>00503 <span class="comment">        if (len &lt;= 0)</span>
<a name="l00504"></a>00504 <span class="comment">            return 0;</span>
<a name="l00505"></a>00505 <span class="comment"></span>
<a name="l00506"></a>00506 <span class="comment">        // if too int64_t, truncate</span>
<a name="l00507"></a>00507 <span class="comment">        if (len &gt; size)</span>
<a name="l00508"></a>00508 <span class="comment">            len = size;</span>
<a name="l00509"></a>00509 <span class="comment"></span>
<a name="l00510"></a>00510 <span class="comment">        memcpy(buf, tmp, len);</span>
<a name="l00511"></a>00511 <span class="comment">        return len;</span>
<a name="l00512"></a>00512 <span class="comment">         */</span>
<a name="l00513"></a>00513 
<a name="l00514"></a>00514 
<a name="l00515"></a><a class="code" href="class_o_t_crypto.html#a21b40a7bdb9d3cd33990f0097f3a5614">00515</a> <span class="keywordtype">bool</span> <a class="code" href="class_o_t_crypto.html#a21b40a7bdb9d3cd33990f0097f3a5614">OTCrypto::GetPasswordFromConsole</a>(<a class="code" href="class_o_t_password.html">OTPassword</a> &amp; theOutput, <span class="keywordtype">bool</span> bRepeat<span class="comment">/*=false*/</span>)<span class="keyword"> const</span>
<a name="l00516"></a>00516 <span class="keyword"></span>{
<a name="l00517"></a>00517     int32_t nAttempts = 0;
<a name="l00518"></a>00518 
<a name="l00519"></a>00519     <span class="keywordflow">for</span>(;;)
<a name="l00520"></a>00520     {
<a name="l00521"></a>00521         theOutput.<a class="code" href="class_o_t_password.html#a3a971b06f42d1c89802167a0ab5330a5">zeroMemory</a>();
<a name="l00522"></a>00522 
<a name="l00523"></a>00523         <span class="keywordflow">if</span> (<a class="code" href="class_o_t_crypto.html#aec77aefc3e722c8ee86b8ee95e3682d9">GetPasswordFromConsoleLowLevel</a>(theOutput, <span class="stringliteral">&quot;(OT) passphrase: &quot;</span>))
<a name="l00524"></a>00524         {
<a name="l00525"></a>00525             <span class="keywordflow">if</span> (!bRepeat)
<a name="l00526"></a>00526             {
<a name="l00527"></a>00527                 std::cout &lt;&lt; std::endl;
<a name="l00528"></a>00528                 <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00529"></a>00529             }
<a name="l00530"></a>00530         }
<a name="l00531"></a>00531         <span class="keywordflow">else</span>
<a name="l00532"></a>00532         {
<a name="l00533"></a>00533             std::cout &lt;&lt; <span class="stringliteral">&quot;Sorry.&quot;</span> &lt;&lt; std::endl;
<a name="l00534"></a>00534             <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00535"></a>00535         }
<a name="l00536"></a>00536         <span class="comment">// -----------------------------------------------</span>
<a name="l00537"></a>00537         <a class="code" href="class_o_t_password.html">OTPassword</a> tempPassword;
<a name="l00538"></a>00538 
<a name="l00539"></a>00539         <span class="keywordflow">if</span> (!<a class="code" href="class_o_t_crypto.html#aec77aefc3e722c8ee86b8ee95e3682d9">GetPasswordFromConsoleLowLevel</a>(tempPassword, <span class="stringliteral">&quot;(Verifying) passphrase again: &quot;</span>))
<a name="l00540"></a>00540         {
<a name="l00541"></a>00541             std::cout &lt;&lt; <span class="stringliteral">&quot;Sorry.&quot;</span> &lt;&lt; std::endl;
<a name="l00542"></a>00542             <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00543"></a>00543         }
<a name="l00544"></a>00544 
<a name="l00545"></a>00545         <span class="keywordflow">if</span> (!tempPassword.<a class="code" href="class_o_t_password.html#a35306a457b2150a2298baa4f2431940d">Compare</a>(theOutput))
<a name="l00546"></a>00546         {
<a name="l00547"></a>00547             <span class="keywordflow">if</span> (++nAttempts &gt;= 3)
<a name="l00548"></a>00548                 <span class="keywordflow">break</span>;
<a name="l00549"></a>00549 
<a name="l00550"></a>00550             std::cout &lt;&lt; <span class="stringliteral">&quot;(Mismatch, try again.)\n&quot;</span> &lt;&lt; std::endl;
<a name="l00551"></a>00551         }
<a name="l00552"></a>00552         <span class="keywordflow">else</span>
<a name="l00553"></a>00553         {
<a name="l00554"></a>00554             std::cout &lt;&lt; std::endl;
<a name="l00555"></a>00555             <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00556"></a>00556         }
<a name="l00557"></a>00557     }
<a name="l00558"></a>00558 
<a name="l00559"></a>00559     std::cout &lt;&lt; <span class="stringliteral">&quot;Sorry.&quot;</span> &lt;&lt; std::endl;
<a name="l00560"></a>00560 
<a name="l00561"></a>00561     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00562"></a>00562 }
<a name="l00563"></a>00563 
<a name="l00564"></a>00564 
<a name="l00565"></a>00565 <span class="comment">//static</span>
<a name="l00566"></a><a class="code" href="class_o_t_crypto.html#af10d51149df4803f79b4b2fed829430b">00566</a> <a class="code" href="class_o_t_crypto.html">OTCrypto</a> * <a class="code" href="class_o_t_crypto.html#af10d51149df4803f79b4b2fed829430b">OTCrypto::It</a>()
<a name="l00567"></a>00567 {
<a name="l00568"></a>00568     <span class="comment">// Todo: someday, swapping the crypto lib should be as easy as changing this</span>
<a name="l00569"></a>00569     <span class="comment">// compile flag to OT_CRYPTO_USING_GPG. We&#39;ll get there.</span>
<a name="l00570"></a>00570     <span class="comment">//</span>
<a name="l00571"></a>00571 <span class="keyword">static</span>
<a name="l00572"></a>00572 <span class="preprocessor">#ifdef OT_CRYPTO_USING_OPENSSL</span>
<a name="l00573"></a>00573 <span class="preprocessor"></span>    OTCrypto_OpenSSL
<a name="l00574"></a>00574 <span class="preprocessor">#endif</span>
<a name="l00575"></a>00575 <span class="preprocessor"></span>    s_theSingleton;    <span class="comment">// For now we&#39;re only allowing a single instance.</span>
<a name="l00576"></a>00576 
<a name="l00577"></a>00577     <span class="keywordflow">return</span> &amp;s_theSingleton;
<a name="l00578"></a>00578 }
<a name="l00579"></a>00579 
<a name="l00580"></a>00580 
<a name="l00581"></a>00581 <span class="comment">// Currently called by OTLog::OT_Init();</span>
<a name="l00582"></a>00582 
<a name="l00583"></a><a class="code" href="class_o_t_crypto.html#ae83b19ae07a5a0ba00780cf031014fcc">00583</a> <span class="keywordtype">void</span> <a class="code" href="class_o_t_crypto.html#ae83b19ae07a5a0ba00780cf031014fcc">OTCrypto::Init</a>()
<a name="l00584"></a>00584 {
<a name="l00585"></a>00585     <span class="comment">// This is only supposed to happen once per run.</span>
<a name="l00586"></a>00586     <span class="comment">//</span>
<a name="l00587"></a>00587     <span class="keywordflow">if</span> (0 == OTCrypto::s_nCount)
<a name="l00588"></a>00588     {
<a name="l00589"></a>00589         ++(OTCrypto::s_nCount);
<a name="l00590"></a>00590         <span class="comment">// -----------------------------</span>
<a name="l00591"></a>00591 
<a name="l00592"></a>00592         <a class="code" href="class_o_t_log.html#a1f7549d776ee919dcb6517f611ded015">OTLog::Output</a>(1, <span class="stringliteral">&quot;OT_Init: Setting up rlimits, and crypto library...\n&quot;</span>);
<a name="l00593"></a>00593 
<a name="l00594"></a>00594         <span class="comment">// Here is a security measure intended to make it more difficult to capture a core</span>
<a name="l00595"></a>00595         <span class="comment">// dump. (Not used in debug mode, obviously.)</span>
<a name="l00596"></a>00596         <span class="comment">//</span>
<a name="l00597"></a>00597 <span class="preprocessor">#if !defined(PREDEF_MODE_DEBUG) &amp;&amp; defined(PREDEF_PLATFORM_UNIX)</span>
<a name="l00598"></a>00598 <span class="preprocessor"></span>        <span class="keyword">struct </span>rlimit rlim;
<a name="l00599"></a>00599         getrlimit(RLIMIT_CORE, &amp;rlim);
<a name="l00600"></a>00600         rlim.rlim_max = rlim.rlim_cur = 0;
<a name="l00601"></a>00601         <span class="keywordflow">if</span> (setrlimit(RLIMIT_CORE, &amp;rlim))
<a name="l00602"></a>00602         {
<a name="l00603"></a>00603             <a class="code" href="_o_t_assert_8hpp.html#aa86aeed4e57eecded96d5955b5cc23c5">OT_FAIL_MSG</a>(<span class="stringliteral">&quot;OTCrypto::Init: ASSERT: setrlimit failed. (Used for preventing core dumps.)\n&quot;</span>);
<a name="l00604"></a>00604         }
<a name="l00605"></a>00605 <span class="preprocessor">#endif</span>
<a name="l00606"></a>00606 <span class="preprocessor"></span>
<a name="l00607"></a>00607         <span class="comment">// -----------------------------</span>
<a name="l00608"></a>00608         this-&gt;<a class="code" href="class_o_t_crypto.html#ae9887af4f759f98cc42067e2c5b203ad">Init_Override</a>();
<a name="l00609"></a>00609     }
<a name="l00610"></a>00610     <span class="keywordflow">else</span>
<a name="l00611"></a>00611         <a class="code" href="class_o_t_log.html#a5acd90ac91c2618f395b0ff37ad4f8ee">OTLog::Error</a>(<span class="stringliteral">&quot;OTCrypto::Init: ERROR: Somehow this erroneously got called more than once! (Doing nothing.)\n&quot;</span>);
<a name="l00612"></a>00612 }
<a name="l00613"></a>00613 
<a name="l00614"></a>00614 
<a name="l00615"></a>00615 <span class="comment">// Currently called by OTLog::OT_Cleanup();</span>
<a name="l00616"></a>00616 
<a name="l00617"></a><a class="code" href="class_o_t_crypto.html#a0b59b9598063be8d46a733bbd3449514">00617</a> <span class="keywordtype">void</span> <a class="code" href="class_o_t_crypto.html#a0b59b9598063be8d46a733bbd3449514">OTCrypto::Cleanup</a>()
<a name="l00618"></a>00618 {
<a name="l00619"></a>00619     <span class="comment">// This is only supposed to happen once per run.</span>
<a name="l00620"></a>00620     <span class="comment">//</span>
<a name="l00621"></a>00621     <span class="keywordflow">if</span> (1 == OTCrypto::s_nCount)
<a name="l00622"></a>00622     {
<a name="l00623"></a>00623         --(OTCrypto::s_nCount);
<a name="l00624"></a>00624         <span class="comment">// -----------------------------</span>
<a name="l00625"></a>00625 
<a name="l00626"></a>00626         <span class="comment">// Any crypto-related cleanup code NOT specific to OpenSSL (which is</span>
<a name="l00627"></a>00627         <span class="comment">// handled in OTCrypto_OpenSSL, a subclass) would go here.</span>
<a name="l00628"></a>00628         <span class="comment">//</span>
<a name="l00629"></a>00629 
<a name="l00630"></a>00630         <span class="comment">// -----------------------------</span>
<a name="l00631"></a>00631         this-&gt;<a class="code" href="class_o_t_crypto.html#a1b725917cf8722c43f0744d6b12e5b9d">Cleanup_Override</a>();
<a name="l00632"></a>00632     }
<a name="l00633"></a>00633     <span class="keywordflow">else</span>
<a name="l00634"></a>00634         <a class="code" href="class_o_t_log.html#a5acd90ac91c2618f395b0ff37ad4f8ee">OTLog::Error</a>(<span class="stringliteral">&quot;OTCrypto::Cleanup: ERROR: Somehow this erroneously got called more than once! (Doing nothing.)\n&quot;</span>);
<a name="l00635"></a>00635 }
<a name="l00636"></a>00636 
<a name="l00637"></a>00637 
<a name="l00638"></a>00638 <span class="comment">//virtual (Should never get called.)</span>
<a name="l00639"></a><a class="code" href="class_o_t_crypto.html#ae9887af4f759f98cc42067e2c5b203ad">00639</a> <span class="keywordtype">void</span> <a class="code" href="class_o_t_crypto.html#ae9887af4f759f98cc42067e2c5b203ad">OTCrypto::Init_Override</a>()
<a name="l00640"></a>00640 {
<a name="l00641"></a>00641     <a class="code" href="class_o_t_log.html#a5acd90ac91c2618f395b0ff37ad4f8ee">OTLog::Error</a>(<span class="stringliteral">&quot;OTCrypto::Init_Override: ERROR: This function should NEVER be called (you should be overriding it...)\n&quot;</span>);
<a name="l00642"></a>00642 }
<a name="l00643"></a>00643 
<a name="l00644"></a>00644 
<a name="l00645"></a>00645 <span class="comment">//virtual (Should never get called.)</span>
<a name="l00646"></a><a class="code" href="class_o_t_crypto.html#a1b725917cf8722c43f0744d6b12e5b9d">00646</a> <span class="keywordtype">void</span> <a class="code" href="class_o_t_crypto.html#a1b725917cf8722c43f0744d6b12e5b9d">OTCrypto::Cleanup_Override</a>()
<a name="l00647"></a>00647 {
<a name="l00648"></a>00648     <a class="code" href="class_o_t_log.html#a5acd90ac91c2618f395b0ff37ad4f8ee">OTLog::Error</a>(<span class="stringliteral">&quot;OTCrypto::Cleanup_Override: ERROR: This function should NEVER be called (you should be overriding it...)\n&quot;</span>);
<a name="l00649"></a>00649 }
<a name="l00650"></a>00650 
<a name="l00651"></a>00651 
<a name="l00652"></a><a class="code" href="class_o_t_crypto.html#a448e54653e46e413a4ebc38ab5bf7b83">00652</a> <span class="keywordtype">bool</span> <a class="code" href="class_o_t_crypto.html#a448e54653e46e413a4ebc38ab5bf7b83">OTCrypto::Base64Encode</a>(<span class="keyword">const</span> <a class="code" href="class_o_t_data.html">OTData</a> &amp; theInput, <a class="code" href="class_o_t_string.html">OTString</a> &amp; strOutput, <span class="keywordtype">bool</span> bLineBreaks<span class="comment">/*=true*/</span>)<span class="keyword"> const</span>
<a name="l00653"></a>00653 <span class="keyword"></span>{
<a name="l00654"></a>00654     <span class="comment">// --------------------------------------</span>
<a name="l00655"></a>00655     <span class="keyword">const</span> uint8_t * pDataIn = <span class="keyword">static_cast&lt;</span><span class="keyword">const </span>uint8_t *<span class="keyword">&gt;</span>(theInput.<a class="code" href="class_o_t_data.html#a649046d86480b41406a8b2d8529378e5">GetPointer</a>());
<a name="l00656"></a>00656           int32_t       nLength = <span class="keyword">static_cast&lt;</span>int32_t<span class="keyword">&gt;</span>            (theInput.<a class="code" href="class_o_t_data.html#a18fd0599061eaf2c031548e030c3112d">GetSize</a>());
<a name="l00657"></a>00657     <span class="comment">// --------------------------------------</span>
<a name="l00658"></a>00658     <a class="code" href="_o_t_assert_8hpp.html#a033b133f48e61f2b227c52ad2be0c882">OT_ASSERT_MSG</a>(nLength &gt;= 0, <span class="stringliteral">&quot;ASSERT!!! nLength is an int32_t, matching the openssl interface, and a size was just attempted that wouldn&#39;t fit into an int32_t, after static casting.\n&quot;</span>);
<a name="l00659"></a>00659     <span class="comment">// --------------------------------------</span>
<a name="l00660"></a>00660     <span class="comment">// Caller is responsible to delete.</span>
<a name="l00661"></a>00661     <span class="keywordtype">char</span> * pChar = this-&gt;<a class="code" href="class_o_t_crypto.html#a448e54653e46e413a4ebc38ab5bf7b83">Base64Encode</a>(pDataIn, nLength, bLineBreaks);
<a name="l00662"></a>00662 
<a name="l00663"></a>00663     <span class="keywordflow">if</span> (NULL == pChar)
<a name="l00664"></a>00664     {
<a name="l00665"></a>00665         <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;%s: Base64Encode returned NULL. (Failure.)\n&quot;</span>, __FUNCTION__);
<a name="l00666"></a>00666         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00667"></a>00667     }
<a name="l00668"></a>00668     <span class="comment">// --------------------------------------</span>
<a name="l00669"></a>00669     <span class="comment">// pChar not NULL, and must be cleaned up.</span>
<a name="l00670"></a>00670     <span class="comment">//</span>
<a name="l00671"></a>00671     strOutput.<a class="code" href="class_o_t_string.html#aa5db620fe8e60c849585d741975db991">Set</a>(pChar);
<a name="l00672"></a>00672     <span class="keyword">delete</span> pChar; pChar = NULL;
<a name="l00673"></a>00673     <span class="comment">// --------------------------------------</span>
<a name="l00674"></a>00674     <span class="keywordflow">return</span> <span class="keyword">true</span>; <span class="comment">// &lt;=== Success.</span>
<a name="l00675"></a>00675 }
<a name="l00676"></a>00676 
<a name="l00677"></a>00677 
<a name="l00678"></a><a class="code" href="class_o_t_crypto.html#a0228014047aab8167490419c439de944">00678</a> <span class="keywordtype">bool</span> <a class="code" href="class_o_t_crypto.html#a0228014047aab8167490419c439de944">OTCrypto::Base64Decode</a>(<span class="keyword">const</span> <a class="code" href="class_o_t_string.html">OTString</a> &amp; strInput, <a class="code" href="class_o_t_data.html">OTData</a> &amp; theOutput, <span class="keywordtype">bool</span> bLineBreaks<span class="comment">/*=true*/</span>)<span class="keyword"> const</span>
<a name="l00679"></a>00679 <span class="keyword"></span>{
<a name="l00680"></a>00680     <span class="comment">// --------------------------------------</span>
<a name="l00681"></a>00681     <span class="keyword">const</span> <span class="keywordtype">char</span> * szInput = strInput.<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>();
<a name="l00682"></a>00682           <span class="keywordtype">size_t</span> theSize = 0;
<a name="l00683"></a>00683     <span class="comment">// --------------------------------------</span>
<a name="l00684"></a>00684     <span class="comment">// Caller is responsible to delete.</span>
<a name="l00685"></a>00685     uint8_t * pOutput = this-&gt;<a class="code" href="class_o_t_crypto.html#a0228014047aab8167490419c439de944">Base64Decode</a>(szInput, &amp;theSize, bLineBreaks);
<a name="l00686"></a>00686 
<a name="l00687"></a>00687     <span class="keywordflow">if</span> (NULL == pOutput)
<a name="l00688"></a>00688     {
<a name="l00689"></a>00689         <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;%s: Base64Decode returned NULL. (Failure.)\n&quot;</span>, __FUNCTION__);
<a name="l00690"></a>00690         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00691"></a>00691     }
<a name="l00692"></a>00692     <span class="comment">// --------------------------------------</span>
<a name="l00693"></a>00693     <span class="comment">// pOutput not NULL, and must be cleaned up.</span>
<a name="l00694"></a>00694     <span class="comment">//</span>
<a name="l00695"></a>00695     <span class="keyword">const</span> <span class="keywordtype">void</span>   * pVoid    = <span class="keyword">reinterpret_cast&lt;</span><span class="keywordtype">void</span> *<span class="keyword">&gt;</span>  (pOutput);
<a name="l00696"></a>00696           uint32_t lNewSize = static_cast     &lt;uint32_t&gt;(theSize);
<a name="l00697"></a>00697 
<a name="l00698"></a>00698     theOutput.<a class="code" href="class_o_t_data.html#a253cd3974cb837ad06980579eb7bc0e4">Assign</a>(pVoid, lNewSize);
<a name="l00699"></a>00699     <span class="keyword">delete</span> pOutput; pOutput = NULL;
<a name="l00700"></a>00700     <span class="comment">// --------------------------------------</span>
<a name="l00701"></a>00701     <span class="keywordflow">return</span> <span class="keyword">true</span>; <span class="comment">// &lt;=== Success.</span>
<a name="l00702"></a>00702 }
<a name="l00703"></a>00703 
<a name="l00704"></a>00704 
<a name="l00705"></a>00705 OTCrypto_Decrypt_Output::OTCrypto_Decrypt_Output() : m_pPassword(NULL), m_pPayload(NULL) {}
<a name="l00706"></a>00706 
<a name="l00707"></a>00707 
<a name="l00708"></a><a class="code" href="class_o_t_crypto___decrypt___output.html#afd5179f31a14f7b64260c1ab4bf3d8af">00708</a> <a class="code" href="class_o_t_crypto___decrypt___output.html#afd5179f31a14f7b64260c1ab4bf3d8af">OTCrypto_Decrypt_Output::~OTCrypto_Decrypt_Output</a>()
<a name="l00709"></a>00709 {
<a name="l00710"></a>00710     <span class="comment">// We don&#39;t own these objects.</span>
<a name="l00711"></a>00711     <span class="comment">// Rather, we own a pointer to ONE of them, since we are a wrapper</span>
<a name="l00712"></a>00712     <span class="comment">// for this one or that.</span>
<a name="l00713"></a>00713     <span class="comment">//</span>
<a name="l00714"></a>00714     m_pPassword = NULL;
<a name="l00715"></a>00715     m_pPayload  = NULL;
<a name="l00716"></a>00716 
<a name="l00717"></a>00717     <span class="comment">// Since this is merely a wrapper class, we don&#39;t actually Release() these things.</span>
<a name="l00718"></a>00718     <span class="comment">// However, we DO have a release function, since the programmatic USER of this class</span>
<a name="l00719"></a>00719     <span class="comment">// MAY wish to Release() whatever it is wrapping.</span>
<a name="l00720"></a>00720     <span class="comment">//</span>
<a name="l00721"></a>00721     <span class="comment">//  Release_Envelope_Decrypt_Output();</span>
<a name="l00722"></a>00722 }
<a name="l00723"></a>00723 
<a name="l00724"></a>00724 
<a name="l00725"></a><a class="code" href="class_o_t_crypto___decrypt___output.html#a58487b4a3194263204421fed766af43e">00725</a> OTCrypto_Decrypt_Output::OTCrypto_Decrypt_Output(<span class="keyword">const</span> <a class="code" href="class_o_t_crypto___decrypt___output.html">OTCrypto_Decrypt_Output</a> &amp; rhs) <span class="comment">// passed</span>
<a name="l00726"></a>00726 : m_pPassword(NULL), m_pPayload(NULL)
<a name="l00727"></a>00727 {
<a name="l00728"></a>00728     m_pPassword = rhs.m_pPassword;
<a name="l00729"></a>00729     m_pPayload  = rhs.m_pPayload;
<a name="l00730"></a>00730 }
<a name="l00731"></a>00731 
<a name="l00732"></a>00732 
<a name="l00733"></a><a class="code" href="class_o_t_crypto___decrypt___output.html#a54db41dc317e64a86fb0acbc5390c607">00733</a> OTCrypto_Decrypt_Output::OTCrypto_Decrypt_Output(<a class="code" href="class_o_t_password.html">OTPassword</a> &amp; thePassword)
<a name="l00734"></a>00734 : m_pPassword(&amp;thePassword), m_pPayload(NULL)
<a name="l00735"></a>00735 {
<a name="l00736"></a>00736 
<a name="l00737"></a>00737 }
<a name="l00738"></a>00738 
<a name="l00739"></a>00739 
<a name="l00740"></a><a class="code" href="class_o_t_crypto___decrypt___output.html#a345c39512e23d44a4d5d971903ab1659">00740</a> OTCrypto_Decrypt_Output::OTCrypto_Decrypt_Output(<a class="code" href="class_o_t_payload.html">OTPayload</a>  &amp; thePayload)
<a name="l00741"></a>00741 : m_pPassword(NULL), m_pPayload(&amp;thePayload)
<a name="l00742"></a>00742 {
<a name="l00743"></a>00743 
<a name="l00744"></a>00744 }
<a name="l00745"></a>00745 
<a name="l00746"></a>00746 
<a name="l00747"></a><a class="code" href="class_o_t_crypto___decrypt___output.html#ac23e4f113a3206fa8412d790f1e39d1c">00747</a> <span class="keywordtype">void</span> <a class="code" href="class_o_t_crypto___decrypt___output.html#ac23e4f113a3206fa8412d790f1e39d1c">OTCrypto_Decrypt_Output::swap</a>(<a class="code" href="class_o_t_crypto___decrypt___output.html">OTCrypto_Decrypt_Output</a> &amp; other) <span class="comment">// the swap member function (should never fail!)</span>
<a name="l00748"></a>00748 {
<a name="l00749"></a>00749     <span class="keywordflow">if</span> (&amp;other != <span class="keyword">this</span>)
<a name="l00750"></a>00750     {
<a name="l00751"></a>00751         <a class="code" href="class_o_t_crypto___decrypt___output.html#ac23e4f113a3206fa8412d790f1e39d1c">std::swap</a>(m_pPassword, other.m_pPassword);
<a name="l00752"></a>00752         <a class="code" href="class_o_t_crypto___decrypt___output.html#ac23e4f113a3206fa8412d790f1e39d1c">std::swap</a>(m_pPayload,  other.m_pPayload);
<a name="l00753"></a>00753     }
<a name="l00754"></a>00754 }
<a name="l00755"></a>00755 
<a name="l00756"></a>00756 
<a name="l00757"></a><a class="code" href="class_o_t_crypto___decrypt___output.html#a7a1d6f4bfa661183d0e4bde397bae84f">00757</a> <a class="code" href="class_o_t_crypto___decrypt___output.html">OTCrypto_Decrypt_Output</a> &amp; <a class="code" href="class_o_t_crypto___decrypt___output.html#a7a1d6f4bfa661183d0e4bde397bae84f">OTCrypto_Decrypt_Output::operator=</a>(<a class="code" href="class_o_t_crypto___decrypt___output.html">OTCrypto_Decrypt_Output</a> other) <span class="comment">// note: argument passed by value!</span>
<a name="l00758"></a>00758 {
<a name="l00759"></a>00759     <span class="comment">// swap this with other</span>
<a name="l00760"></a>00760     this-&gt;<a class="code" href="class_o_t_crypto___decrypt___output.html#ac23e4f113a3206fa8412d790f1e39d1c">swap</a>(other);
<a name="l00761"></a>00761 
<a name="l00762"></a>00762     <span class="comment">// by convention, always return *this</span>
<a name="l00763"></a>00763     <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00764"></a>00764 }
<a name="l00765"></a>00765 
<a name="l00766"></a>00766 
<a name="l00767"></a>00767 <span class="comment">// This is just a wrapper class.</span>
<a name="l00768"></a><a class="code" href="class_o_t_crypto___decrypt___output.html#ad04e66ff30989f0856a1c836ef3f9efb">00768</a> <span class="keywordtype">void</span> <a class="code" href="class_o_t_crypto___decrypt___output.html#ad04e66ff30989f0856a1c836ef3f9efb">OTCrypto_Decrypt_Output::Release</a>()
<a name="l00769"></a>00769 {
<a name="l00770"></a>00770     <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>((m_pPassword != NULL) || (m_pPayload != NULL));
<a name="l00771"></a>00771 
<a name="l00772"></a>00772     <a class="code" href="class_o_t_crypto___decrypt___output.html#ac7e1b52106d12f4251798b1819d77704">Release_Envelope_Decrypt_Output</a>();
<a name="l00773"></a>00773 
<a name="l00774"></a>00774     <span class="comment">// no need to call ot_super::Release here, since this class has no superclass.</span>
<a name="l00775"></a>00775 }
<a name="l00776"></a>00776 
<a name="l00777"></a>00777 
<a name="l00778"></a>00778 <span class="comment">// This is just a wrapper class.</span>
<a name="l00779"></a><a class="code" href="class_o_t_crypto___decrypt___output.html#ac7e1b52106d12f4251798b1819d77704">00779</a> <span class="keywordtype">void</span> <a class="code" href="class_o_t_crypto___decrypt___output.html#ac7e1b52106d12f4251798b1819d77704">OTCrypto_Decrypt_Output::Release_Envelope_Decrypt_Output</a>()
<a name="l00780"></a>00780 {
<a name="l00781"></a>00781     <span class="keywordflow">if</span> (NULL != m_pPassword)
<a name="l00782"></a>00782         m_pPassword-&gt;<a class="code" href="class_o_t_password.html#a3a971b06f42d1c89802167a0ab5330a5">zeroMemory</a>();
<a name="l00783"></a>00783 
<a name="l00784"></a>00784     <span class="keywordflow">if</span> (NULL != m_pPayload)
<a name="l00785"></a>00785         m_pPayload-&gt;<a class="code" href="class_o_t_data.html#aab9a5758e85597ef1d7250bcf2cc56a6">Release</a>();
<a name="l00786"></a>00786 }
<a name="l00787"></a>00787 
<a name="l00788"></a>00788 
<a name="l00789"></a><a class="code" href="class_o_t_crypto___decrypt___output.html#a5659cadb40085d0e30f4ea713ec95402">00789</a> <span class="keywordtype">bool</span> <a class="code" href="class_o_t_crypto___decrypt___output.html#a5659cadb40085d0e30f4ea713ec95402">OTCrypto_Decrypt_Output::Concatenate</a>(<span class="keyword">const</span> <span class="keywordtype">void</span> * pAppendData, uint32_t lAppendSize)
<a name="l00790"></a>00790 {
<a name="l00791"></a>00791     <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>((m_pPassword != NULL) || (m_pPayload != NULL));
<a name="l00792"></a>00792 
<a name="l00793"></a>00793     <span class="keywordflow">if</span> (NULL != m_pPassword)
<a name="l00794"></a>00794     {
<a name="l00795"></a>00795         <span class="keywordflow">if</span> (static_cast&lt;int32_t&gt;(lAppendSize) ==
<a name="l00796"></a>00796             static_cast&lt;int32_t&gt;(m_pPassword-&gt;<a class="code" href="class_o_t_password.html#a75332e6591d69ec8a090fcef54856579">addMemory</a>(pAppendData, static_cast&lt;uint32_t&gt;(lAppendSize))))
<a name="l00797"></a>00797             <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00798"></a>00798         <span class="keywordflow">else</span>
<a name="l00799"></a>00799             <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00800"></a>00800     }
<a name="l00801"></a>00801     <span class="comment">// -------------------------</span>
<a name="l00802"></a>00802     <span class="keywordflow">if</span> (NULL != m_pPayload)
<a name="l00803"></a>00803     {
<a name="l00804"></a>00804         m_pPayload-&gt;<a class="code" href="class_o_t_data.html#a95c6d4d474bb010f504d0f2c7ae75211">Concatenate</a>(pAppendData, lAppendSize);
<a name="l00805"></a>00805         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00806"></a>00806     }
<a name="l00807"></a>00807     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00808"></a>00808 }
<a name="l00809"></a>00809 
<a name="l00810"></a>00810 
<a name="l00811"></a>00811 <span class="preprocessor">#if defined (OT_CRYPTO_USING_OPENSSL)</span>
<a name="l00812"></a>00812 <span class="preprocessor"></span>
<a name="l00813"></a>00813 
<a name="l00814"></a>00814 <span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span>
<a name="l00815"></a>00815 {
<a name="l00816"></a>00816 
<a name="l00817"></a>00817 <span class="preprocessor">#include &lt;openssl/crypto.h&gt;</span>
<a name="l00818"></a>00818 <span class="preprocessor">#include &lt;openssl/asn1.h&gt;</span>
<a name="l00819"></a>00819 <span class="preprocessor">#include &lt;openssl/evp.h&gt;</span>
<a name="l00820"></a>00820 <span class="preprocessor">#include &lt;openssl/objects.h&gt;</span>
<a name="l00821"></a>00821 <span class="preprocessor">#include &lt;openssl/sha.h&gt;</span>
<a name="l00822"></a>00822 <span class="preprocessor">#include &lt;openssl/pem.h&gt;</span>
<a name="l00823"></a>00823 <span class="preprocessor">#include &lt;openssl/rsa.h&gt;</span>
<a name="l00824"></a>00824 <span class="preprocessor">#include &lt;openssl/err.h&gt;</span>
<a name="l00825"></a>00825 <span class="preprocessor">#include &lt;openssl/rand.h&gt;</span>
<a name="l00826"></a>00826 <span class="preprocessor">#include &lt;openssl/ssl.h&gt;</span>
<a name="l00827"></a>00827 <span class="preprocessor">#include &lt;openssl/conf.h&gt;</span>
<a name="l00828"></a>00828 
<a name="l00829"></a>00829 
<a name="l00830"></a>00830 <span class="comment">//#ifndef ANDROID // Android thus far only supports OpenSSL 0.9.8k</span>
<a name="l00831"></a>00831 <span class="preprocessor">#include &lt;openssl/whrlpool.h&gt;</span>
<a name="l00832"></a>00832 
<a name="l00833"></a>00833 <span class="comment">//  // Just trying to get Whirlpool working since they added it to OpenSSL</span>
<a name="l00834"></a>00834 <span class="comment">//  //</span>
<a name="l00835"></a>00835 <span class="comment">//  static int32_t init(EVP_MD_CTX *ctx)</span>
<a name="l00836"></a>00836 <span class="comment">//  { return WHIRLPOOL_Init((WHIRLPOOL_CTX*)ctx-&gt;md_data); }</span>
<a name="l00837"></a>00837 <span class="comment">//</span>
<a name="l00838"></a>00838 <span class="comment">//  static int32_t update(EVP_MD_CTX *ctx,const void *data,size_t count)</span>
<a name="l00839"></a>00839 <span class="comment">//  { return WHIRLPOOL_Update((WHIRLPOOL_CTX*)ctx-&gt;md_data,data,count); }</span>
<a name="l00840"></a>00840 <span class="comment">//</span>
<a name="l00841"></a>00841 <span class="comment">//  static int32_t final(EVP_MD_CTX *ctx,uint8_t *md)</span>
<a name="l00842"></a>00842 <span class="comment">//  { return WHIRLPOOL_Final(md,(WHIRLPOOL_CTX*)ctx-&gt;md_data); }</span>
<a name="l00843"></a>00843 <span class="comment">//</span>
<a name="l00844"></a>00844 <span class="comment">//</span>
<a name="l00845"></a>00845 <span class="comment">//  static const EVP_MD whirlpool_md =</span>
<a name="l00846"></a>00846 <span class="comment">//  {</span>
<a name="l00847"></a>00847 <span class="comment">//      NID_whirlpool,</span>
<a name="l00848"></a>00848 <span class="comment">//      0,</span>
<a name="l00849"></a>00849 <span class="comment">//      WHIRLPOOL_DIGEST_LENGTH,</span>
<a name="l00850"></a>00850 <span class="comment">//      0,</span>
<a name="l00851"></a>00851 <span class="comment">//      init,</span>
<a name="l00852"></a>00852 <span class="comment">//      update,</span>
<a name="l00853"></a>00853 <span class="comment">//      final,</span>
<a name="l00854"></a>00854 <span class="comment">//      NULL,</span>
<a name="l00855"></a>00855 <span class="comment">//      NULL,</span>
<a name="l00856"></a>00856 <span class="comment">//      EVP_PKEY_NULL_method,</span>
<a name="l00857"></a>00857 <span class="comment">//      WHIRLPOOL_BBLOCK/8,</span>
<a name="l00858"></a>00858 <span class="comment">//      sizeof(EVP_MD *)+sizeof(WHIRLPOOL_CTX),</span>
<a name="l00859"></a>00859 <span class="comment">//  };</span>
<a name="l00860"></a>00860 <span class="comment">//#endif // !ANDROID</span>
<a name="l00861"></a>00861     <span class="comment">// -----------------------</span>
<a name="l00862"></a>00862 
<a name="l00863"></a>00863 <span class="preprocessor">#ifndef OPENSSL_THREAD_DEFINES</span>
<a name="l00864"></a>00864 <span class="preprocessor"></span><span class="preprocessor">#define OPENSSL_THREAD_DEFINES</span>
<a name="l00865"></a>00865 <span class="preprocessor"></span><span class="preprocessor">#include &lt;openssl/opensslconf.h&gt;</span>
<a name="l00866"></a>00866 <span class="preprocessor">#endif</span>
<a name="l00867"></a>00867 <span class="preprocessor"></span>
<a name="l00868"></a>00868 <span class="preprocessor">#include &lt;openssl/opensslv.h&gt;</span>
<a name="l00869"></a>00869 }
<a name="l00870"></a>00870 
<a name="l00871"></a>00871 
<a name="l00872"></a>00872 OTCrypto_OpenSSL::OTCrypto_OpenSSL() : <a class="code" href="class_o_t_crypto.html">OTCrypto</a>()  { }
<a name="l00873"></a>00873 
<a name="l00874"></a>00874 
<a name="l00875"></a>00875 OTCrypto_OpenSSL::~OTCrypto_OpenSSL() { }
<a name="l00876"></a>00876 
<a name="l00877"></a>00877 
<a name="l00878"></a>00878 <span class="comment">/*</span>
<a name="l00879"></a>00879 <span class="comment"> #include &lt;openssl/ssl.h&gt;</span>
<a name="l00880"></a>00880 <span class="comment"> void SSL_load_error_strings(void);</span>
<a name="l00881"></a>00881 <span class="comment"></span>
<a name="l00882"></a>00882 <span class="comment"> #include &lt;openssl/err.h&gt;</span>
<a name="l00883"></a>00883 <span class="comment"> void ERR_free_strings(void);</span>
<a name="l00884"></a>00884 <span class="comment"> //void ERR_load_crypto_strings(void);</span>
<a name="l00885"></a>00885 <span class="comment"></span>
<a name="l00886"></a>00886 <span class="comment"></span>
<a name="l00887"></a>00887 <span class="comment"> #include &lt;openssl/ssl.h&gt;</span>
<a name="l00888"></a>00888 <span class="comment"> int32_t SSL_library_init(void);</span>
<a name="l00889"></a>00889 <span class="comment"> //#define OpenSSL_add_ssl_algorithms()    SSL_library_init()</span>
<a name="l00890"></a>00890 <span class="comment"> //#define SSLeay_add_ssl_algorithms()     SSL_library_init()</span>
<a name="l00891"></a>00891 <span class="comment"></span>
<a name="l00892"></a>00892 <span class="comment"></span>
<a name="l00893"></a>00893 <span class="comment"> #include &lt;openssl/evp.h&gt;</span>
<a name="l00894"></a>00894 <span class="comment"> void OpenSSL_add_all_algorithms(void);</span>
<a name="l00895"></a>00895 <span class="comment"> //void OpenSSL_add_all_ciphers(void);</span>
<a name="l00896"></a>00896 <span class="comment"> //void OpenSSL_add_all_digests(void);</span>
<a name="l00897"></a>00897 <span class="comment"> void EVP_cleanup(void);</span>
<a name="l00898"></a>00898 <span class="comment"></span>
<a name="l00899"></a>00899 <span class="comment"></span>
<a name="l00900"></a>00900 <span class="comment"> #include &lt;openssl/conf.h&gt;</span>
<a name="l00901"></a>00901 <span class="comment"> void OPENSSL_config(const char *config_name);</span>
<a name="l00902"></a>00902 <span class="comment"> //void OPENSSL_no_config(void);</span>
<a name="l00903"></a>00903 <span class="comment"> //Applications should free up configuration at application closedown by calling CONF_modules_free().</span>
<a name="l00904"></a>00904 <span class="comment"></span>
<a name="l00905"></a>00905 <span class="comment"> #include &lt;openssl/conf.h&gt;</span>
<a name="l00906"></a>00906 <span class="comment"> void CONF_modules_free(void);</span>
<a name="l00907"></a>00907 <span class="comment"> //void CONF_modules_finish(void);</span>
<a name="l00908"></a>00908 <span class="comment"> //void CONF_modules_unload(int32_t all);</span>
<a name="l00909"></a>00909 <span class="comment"> */</span>
<a name="l00910"></a>00910 
<a name="l00911"></a>00911 <span class="comment">/*</span>
<a name="l00912"></a>00912 <span class="comment">#include &lt;openssl/crypto.h&gt;</span>
<a name="l00913"></a>00913 <span class="comment"></span>
<a name="l00914"></a>00914 <span class="comment">/ Don&#39;t use this structure directly.</span>
<a name="l00915"></a>00915 <span class="comment">typedef struct crypto_threadid_st</span>
<a name="l00916"></a>00916 <span class="comment">        {</span>
<a name="l00917"></a>00917 <span class="comment">        void *ptr;</span>
<a name="l00918"></a>00918 <span class="comment">        uint64_t val;</span>
<a name="l00919"></a>00919 <span class="comment">        } CRYPTO_THREADID;</span>
<a name="l00920"></a>00920 <span class="comment"></span>
<a name="l00921"></a>00921 <span class="comment">// Only use CRYPTO_THREADID_set_[numeric|pointer]() within callbacks</span>
<a name="l00922"></a>00922 <span class="comment">void CRYPTO_THREADID_set_numeric(CRYPTO_THREADID *id, uint64_t val);</span>
<a name="l00923"></a>00923 <span class="comment">void CRYPTO_THREADID_set_pointer(CRYPTO_THREADID *id, void *ptr);</span>
<a name="l00924"></a>00924 <span class="comment"></span>
<a name="l00925"></a>00925 <span class="comment">int32_t CRYPTO_THREADID_set_callback(void (*threadid_func)(CRYPTO_THREADID *));</span>
<a name="l00926"></a>00926 <span class="comment"></span>
<a name="l00927"></a>00927 <span class="comment">void (*CRYPTO_THREADID_get_callback(void))(CRYPTO_THREADID *);</span>
<a name="l00928"></a>00928 <span class="comment"></span>
<a name="l00929"></a>00929 <span class="comment">void CRYPTO_THREADID_current(CRYPTO_THREADID *id);</span>
<a name="l00930"></a>00930 <span class="comment"></span>
<a name="l00931"></a>00931 <span class="comment">int32_t CRYPTO_THREADID_cmp(const CRYPTO_THREADID *a,</span>
<a name="l00932"></a>00932 <span class="comment">                        const CRYPTO_THREADID *b);</span>
<a name="l00933"></a>00933 <span class="comment">void CRYPTO_THREADID_cpy(CRYPTO_THREADID *dest,</span>
<a name="l00934"></a>00934 <span class="comment">                         const CRYPTO_THREADID *src);</span>
<a name="l00935"></a>00935 <span class="comment"></span>
<a name="l00936"></a>00936 <span class="comment"> uint64_t CRYPTO_THREADID_hash(const CRYPTO_THREADID *id);</span>
<a name="l00937"></a>00937 <span class="comment"></span>
<a name="l00938"></a>00938 <span class="comment">int32_t CRYPTO_num_locks(void);</span>
<a name="l00939"></a>00939 <span class="comment"></span>
<a name="l00940"></a>00940 <span class="comment"> Description</span>
<a name="l00941"></a>00941 <span class="comment"></span>
<a name="l00942"></a>00942 <span class="comment"></span>
<a name="l00943"></a>00943 <span class="comment"> OpenSSL can safely be used in multi-threaded applications provided that at least two callback functions are set,</span>
<a name="l00944"></a>00944 <span class="comment"> locking_function and threadid_func.</span>
<a name="l00945"></a>00945 <span class="comment"></span>
<a name="l00946"></a>00946 <span class="comment"> locking_function(int32_t mode, int32_t n, const char *file, int32_t line) is needed to perform locking on shared data structures.</span>
<a name="l00947"></a>00947 <span class="comment"> (Note that OpenSSL uses a number of global data structures that will be implicitly shared whenever multiple threads</span>
<a name="l00948"></a>00948 <span class="comment"> use OpenSSL.) Multi-threaded applications will crash at random if it is not set.</span>
<a name="l00949"></a>00949 <span class="comment"></span>
<a name="l00950"></a>00950 <span class="comment"> locking_function() must be able to handle up to CRYPTO_num_locks() different mutex locks. It sets the n-th lock if</span>
<a name="l00951"></a>00951 <span class="comment"> mode &amp; CRYPTO_LOCK , and releases it otherwise.</span>
<a name="l00952"></a>00952 <span class="comment"></span>
<a name="l00953"></a>00953 <span class="comment"> file and line are the file number of the function setting the lock. They can be useful for debugging.</span>
<a name="l00954"></a>00954 <span class="comment"></span>
<a name="l00955"></a>00955 <span class="comment"> threadid_func( CRYPTO_THREADID *id) is needed to record the currently-executing thread&#39;s identifier into id. The</span>
<a name="l00956"></a>00956 <span class="comment"> implementation of this callback should not fill in id directly, but should use CRYPTO_THREADID_set_numeric() if</span>
<a name="l00957"></a>00957 <span class="comment"> thread IDs are numeric, or CRYPTO_THREADID_set_pointer() if they are pointer-based. If the application does not</span>
<a name="l00958"></a>00958 <span class="comment"> register such a callback using CRYPTO_THREADID_set_callback(), then a default implementation is used - on Windows</span>
<a name="l00959"></a>00959 <span class="comment"> and BeOS this uses the system&#39;s default thread identifying APIs, and on all other platforms it uses the address</span>
<a name="l00960"></a>00960 <span class="comment"> of errno. The latter is satisfactory for thread-safety if and only if the platform has a thread-local error number</span>
<a name="l00961"></a>00961 <span class="comment"> facility.</span>
<a name="l00962"></a>00962 <span class="comment"> */</span>
<a name="l00963"></a>00963 
<a name="l00964"></a>00964 <span class="comment">/*</span>
<a name="l00965"></a>00965 <span class="comment"></span>
<a name="l00966"></a>00966 <span class="comment">// struct CRYPTO_dynlock_value needs to be defined by the user</span>
<a name="l00967"></a>00967 <span class="comment">struct CRYPTO_dynlock_value;</span>
<a name="l00968"></a>00968 <span class="comment"></span>
<a name="l00969"></a>00969 <span class="comment">void CRYPTO_set_dynlock_create_callback(struct CRYPTO_dynlock_value *</span>
<a name="l00970"></a>00970 <span class="comment">       (*dyn_create_function)(char *file, int32_t line));</span>
<a name="l00971"></a>00971 <span class="comment">void CRYPTO_set_dynlock_lock_callback(void (*dyn_lock_function)</span>
<a name="l00972"></a>00972 <span class="comment">       (int32_t mode, struct CRYPTO_dynlock_value *l,</span>
<a name="l00973"></a>00973 <span class="comment">       const char *file, int32_t line));</span>
<a name="l00974"></a>00974 <span class="comment">void CRYPTO_set_dynlock_destroy_callback(void (*dyn_destroy_function)</span>
<a name="l00975"></a>00975 <span class="comment">       (struct CRYPTO_dynlock_value *l, const char *file, int32_t line));</span>
<a name="l00976"></a>00976 <span class="comment"></span>
<a name="l00977"></a>00977 <span class="comment">int32_t CRYPTO_get_new_dynlockid(void);</span>
<a name="l00978"></a>00978 <span class="comment"></span>
<a name="l00979"></a>00979 <span class="comment">void CRYPTO_destroy_dynlockid(int32_t i);</span>
<a name="l00980"></a>00980 <span class="comment"></span>
<a name="l00981"></a>00981 <span class="comment">void CRYPTO_lock(int32_t mode, int32_t n, const char *file, int32_t line);</span>
<a name="l00982"></a>00982 <span class="comment"></span>
<a name="l00983"></a>00983 <span class="comment">#define CRYPTO_w_lock(type)    \</span>
<a name="l00984"></a>00984 <span class="comment">       CRYPTO_lock(CRYPTO_LOCK|CRYPTO_WRITE,type,__FILE__,__LINE__)</span>
<a name="l00985"></a>00985 <span class="comment">#define CRYPTO_w_unlock(type)  \</span>
<a name="l00986"></a>00986 <span class="comment">       CRYPTO_lock(CRYPTO_UNLOCK|CRYPTO_WRITE,type,__FILE__,__LINE__)</span>
<a name="l00987"></a>00987 <span class="comment">#define CRYPTO_r_lock(type)    \</span>
<a name="l00988"></a>00988 <span class="comment">       CRYPTO_lock(CRYPTO_LOCK|CRYPTO_READ,type,__FILE__,__LINE__)</span>
<a name="l00989"></a>00989 <span class="comment">#define CRYPTO_r_unlock(type)  \</span>
<a name="l00990"></a>00990 <span class="comment">       CRYPTO_lock(CRYPTO_UNLOCK|CRYPTO_READ,type,__FILE__,__LINE__)</span>
<a name="l00991"></a>00991 <span class="comment">#define CRYPTO_add(addr,amount,type)   \</span>
<a name="l00992"></a>00992 <span class="comment">       CRYPTO_add_lock(addr,amount,type,__FILE__,__LINE__)</span>
<a name="l00993"></a>00993 <span class="comment"></span>
<a name="l00994"></a>00994 <span class="comment"> */</span>
<a name="l00995"></a>00995 
<a name="l00996"></a>00996 tthread::mutex * OTCrypto_OpenSSL::s_arrayMutex = NULL;
<a name="l00997"></a>00997 
<a name="l00998"></a>00998 
<a name="l00999"></a>00999 <span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span>
<a name="l01000"></a>01000 {
<a name="l01001"></a>01001 <span class="preprocessor">#if OPENSSL_VERSION_NUMBER-0 &lt; 0x10000000L</span>
<a name="l01002"></a>01002 <span class="preprocessor"></span>    <span class="keywordtype">unsigned</span>
<a name="l01003"></a>01003     int64_t  ot_openssl_thread_id(<span class="keywordtype">void</span>);
<a name="l01004"></a>01004 <span class="preprocessor">#else</span>
<a name="l01005"></a>01005 <span class="preprocessor"></span>    <span class="keywordtype">void</span>  ot_openssl_thread_id(CRYPTO_THREADID *);
<a name="l01006"></a>01006 <span class="preprocessor">#endif</span>
<a name="l01007"></a>01007 <span class="preprocessor"></span>
<a name="l01008"></a>01008     <span class="keywordtype">void</span>  ot_openssl_locking_callback( int32_t mode, int32_t type, <span class="keywordtype">char</span> *file, int32_t line);
<a name="l01009"></a>01009 }
<a name="l01010"></a>01010 
<a name="l01011"></a>01011 
<a name="l01012"></a>01012 <span class="comment">// done</span>
<a name="l01013"></a>01013 <span class="comment">/*</span>
<a name="l01014"></a>01014 <span class="comment"> threadid_func( CRYPTO_THREADID *id) is needed to record the currently-executing thread&#39;s identifier into id.</span>
<a name="l01015"></a>01015 <span class="comment"> The implementation of this callback should not fill in id directly, but should use CRYPTO_THREADID_set_numeric()</span>
<a name="l01016"></a>01016 <span class="comment"> if thread IDs are numeric, or CRYPTO_THREADID_set_pointer() if they are pointer-based. If the application does</span>
<a name="l01017"></a>01017 <span class="comment"> not register such a callback using CRYPTO_THREADID_set_callback(), then a default implementation is used - on</span>
<a name="l01018"></a>01018 <span class="comment"> Windows and BeOS this uses the system&#39;s default thread identifying APIs, and on all other platforms it uses the</span>
<a name="l01019"></a>01019 <span class="comment"> address of errno. The latter is satisfactory for thread-safety if and only if the platform has a thread-local</span>
<a name="l01020"></a>01020 <span class="comment"> error number facility.</span>
<a name="l01021"></a>01021 <span class="comment"></span>
<a name="l01022"></a>01022 <span class="comment"> */</span>
<a name="l01023"></a>01023 
<a name="l01024"></a>01024 <span class="preprocessor">#if OPENSSL_VERSION_NUMBER-0 &lt; 0x10000000L</span>
<a name="l01025"></a>01025 <span class="preprocessor"></span>uint64_t ot_openssl_thread_id()
<a name="l01026"></a>01026 {
<a name="l01027"></a>01027     uint64_t ret = this_thread::get_raw_id();
<a name="l01028"></a>01028 
<a name="l01029"></a>01029     <span class="keywordflow">return</span> (ret);
<a name="l01030"></a>01030 }
<a name="l01031"></a>01031 
<a name="l01032"></a>01032 <span class="preprocessor">#else</span>
<a name="l01033"></a>01033 <span class="preprocessor"></span><span class="keywordtype">void</span> ot_openssl_thread_id(CRYPTO_THREADID * <span class="keywordtype">id</span>)
<a name="l01034"></a>01034 {
<a name="l01035"></a>01035     <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != <span class="keywordtype">id</span>);
<a name="l01036"></a>01036 
<a name="l01037"></a>01037     <span class="comment">// TODO: Possibly do this by pointer instead of by uint64_t,</span>
<a name="l01038"></a>01038     <span class="comment">// for certain platforms. (OpenSSL provides functions for both.)</span>
<a name="l01039"></a>01039     <span class="comment">//</span>
<a name="l01040"></a>01040 
<a name="l01041"></a>01041     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> val = tthread::this_thread::get_raw_id();
<a name="l01042"></a>01042 
<a name="l01043"></a>01043 <span class="comment">//    void CRYPTO_THREADID_set_numeric(CRYPTO_THREADID *id, uint64_t val);</span>
<a name="l01044"></a>01044 <span class="comment">//    void CRYPTO_THREADID_set_pointer(CRYPTO_THREADID *id, void *ptr);</span>
<a name="l01045"></a>01045 
<a name="l01046"></a>01046            CRYPTO_THREADID_set_numeric(<span class="keywordtype">id</span>, val);
<a name="l01047"></a>01047 }
<a name="l01048"></a>01048 <span class="preprocessor">#endif</span>
<a name="l01049"></a>01049 <span class="preprocessor"></span>
<a name="l01050"></a>01050 
<a name="l01051"></a>01051 <span class="comment">/*</span>
<a name="l01052"></a>01052 <span class="comment"> locking_function(int32_t mode, int32_t n, const char *file, int32_t line) is needed to perform locking on</span>
<a name="l01053"></a>01053 <span class="comment"> shared data structures. (Note that OpenSSL uses a number of global data structures that will</span>
<a name="l01054"></a>01054 <span class="comment"> be implicitly shared whenever multiple threads use OpenSSL.) Multi-threaded applications will</span>
<a name="l01055"></a>01055 <span class="comment"> crash at random if it is not set.</span>
<a name="l01056"></a>01056 <span class="comment"></span>
<a name="l01057"></a>01057 <span class="comment"> locking_function() must be able to handle up to CRYPTO_num_locks() different mutex locks. It</span>
<a name="l01058"></a>01058 <span class="comment"> sets the n-th lock if mode &amp; CRYPTO_LOCK , and releases it otherwise.</span>
<a name="l01059"></a>01059 <span class="comment"></span>
<a name="l01060"></a>01060 <span class="comment"> file and line are the file number of the function setting the lock. They can be useful for</span>
<a name="l01061"></a>01061 <span class="comment"> debugging.</span>
<a name="l01062"></a>01062 <span class="comment"> */</span>
<a name="l01063"></a>01063 
<a name="l01064"></a>01064 <span class="keywordtype">void</span> ot_openssl_locking_callback(int32_t mode, int32_t type, <span class="keyword">const</span> <span class="keywordtype">char</span> *file, int32_t line)
<a name="l01065"></a>01065 {
<a name="l01066"></a>01066     <span class="keywordflow">if</span> (mode &amp; CRYPTO_LOCK)
<a name="l01067"></a>01067     {
<a name="l01068"></a>01068         OTCrypto_OpenSSL::s_arrayMutex[type].lock();
<a name="l01069"></a>01069     }
<a name="l01070"></a>01070     <span class="keywordflow">else</span>
<a name="l01071"></a>01071     {
<a name="l01072"></a>01072         OTCrypto_OpenSSL::s_arrayMutex[type].unlock();
<a name="l01073"></a>01073     }
<a name="l01074"></a>01074 }
<a name="l01075"></a>01075 
<a name="l01076"></a>01076 
<a name="l01077"></a>01077 <span class="comment">/*</span>
<a name="l01078"></a>01078 <span class="comment"> --- More code for Base64 Decoding using OpenSSL:</span>
<a name="l01079"></a>01079 <span class="comment"></span>
<a name="l01080"></a>01080 <span class="comment"> void base64Decode(uint8_t* pIn, int32_t inLen, uint8_t* pOut,</span>
<a name="l01081"></a>01081 <span class="comment">                  int32_t&amp; outLen)</span>
<a name="l01082"></a>01082 <span class="comment">{</span>
<a name="l01083"></a>01083 <span class="comment">    // create a memory buffer containing base64 encoded data</span>
<a name="l01084"></a>01084 <span class="comment">    OpenSSL_BIO bmem = BIO_new_mem_buf((void*)pIn, inLen);</span>
<a name="l01085"></a>01085 <span class="comment"></span>
<a name="l01086"></a>01086 <span class="comment">    // push a Base64 filter so that reading from buffer decodes it</span>
<a name="l01087"></a>01087 <span class="comment">    OpenSSL_BIO bioCmd = BIO_new(BIO_f_base64());</span>
<a name="l01088"></a>01088 <span class="comment">    // we don&#39;t want newlines</span>
<a name="l01089"></a>01089 <span class="comment">    BIO_set_flags(bioCmd, BIO_FLAGS_BASE64_NO_NL);</span>
<a name="l01090"></a>01090 <span class="comment">    bmem = BIO_push(bioCmd, bmem);</span>
<a name="l01091"></a>01091 <span class="comment"></span>
<a name="l01092"></a>01092 <span class="comment">    int32_t finalLen = BIO_read(bmem, (void*)pOut, outLen);</span>
<a name="l01093"></a>01093 <span class="comment">    outLen = finalLen;</span>
<a name="l01094"></a>01094 <span class="comment">}</span>
<a name="l01095"></a>01095 <span class="comment"></span>
<a name="l01096"></a>01096 <span class="comment">--- Another example of similar code:</span>
<a name="l01097"></a>01097 <span class="comment"></span>
<a name="l01098"></a>01098 <span class="comment">char *unbase64(uint8_t *input, int32_t length)</span>
<a name="l01099"></a>01099 <span class="comment">{</span>
<a name="l01100"></a>01100 <span class="comment">    OpenSSL_BIO b64(NULL), bmem(NULL);</span>
<a name="l01101"></a>01101 <span class="comment"></span>
<a name="l01102"></a>01102 <span class="comment">    char *buffer = (char *)malloc(length);</span>
<a name="l01103"></a>01103 <span class="comment">    memset(buffer, 0, length);</span>
<a name="l01104"></a>01104 <span class="comment"></span>
<a name="l01105"></a>01105 <span class="comment">    b64 = BIO_new(BIO_f_base64());</span>
<a name="l01106"></a>01106 <span class="comment">    bmem = BIO_new_mem_buf(input, length);</span>
<a name="l01107"></a>01107 <span class="comment">    bmem = BIO_push(b64, bmem);</span>
<a name="l01108"></a>01108 <span class="comment"></span>
<a name="l01109"></a>01109 <span class="comment">    BIO_read(bmem, buffer, length);</span>
<a name="l01110"></a>01110 <span class="comment"></span>
<a name="l01111"></a>01111 <span class="comment">    return buffer;</span>
<a name="l01112"></a>01112 <span class="comment">}</span>
<a name="l01113"></a>01113 <span class="comment">*/</span>
<a name="l01114"></a>01114 
<a name="l01115"></a>01115 <span class="comment">/*</span>
<a name="l01116"></a>01116 <span class="comment">// This function will base64 DECODE the string contents</span>
<a name="l01117"></a>01117 <span class="comment">// and return them as a string in strData</span>
<a name="l01118"></a>01118 <span class="comment">// It does NOT handle Uncompression</span>
<a name="l01119"></a>01119 <span class="comment"></span>
<a name="l01120"></a>01120 <span class="comment">bool OTASCIIArmor::GetString(OTString &amp; strData, bool bLineBreaks) const //=true</span>
<a name="l01121"></a>01121 <span class="comment">{</span>
<a name="l01122"></a>01122 <span class="comment">    size_t      outSize = 0;</span>
<a name="l01123"></a>01123 <span class="comment">    uint8_t *   pData   = NULL;</span>
<a name="l01124"></a>01124 <span class="comment"></span>
<a name="l01125"></a>01125 <span class="comment">    pData = base64_decode(Get(), &amp;outSize, (bLineBreaks ? 1 : 0));</span>
<a name="l01126"></a>01126 <span class="comment"></span>
<a name="l01127"></a>01127 <span class="comment">    if (pData)</span>
<a name="l01128"></a>01128 <span class="comment">    {</span>
<a name="l01129"></a>01129 <span class="comment">        strData.Set((const char*)pData, outSize);</span>
<a name="l01130"></a>01130 <span class="comment"></span>
<a name="l01131"></a>01131 <span class="comment">        delete [] pData; pData=NULL;</span>
<a name="l01132"></a>01132 <span class="comment">        return true;</span>
<a name="l01133"></a>01133 <span class="comment">    }</span>
<a name="l01134"></a>01134 <span class="comment">    else {</span>
<a name="l01135"></a>01135 <span class="comment">        return false;</span>
<a name="l01136"></a>01136 <span class="comment">    }</span>
<a name="l01137"></a>01137 <span class="comment">}</span>
<a name="l01138"></a>01138 <span class="comment"></span>
<a name="l01139"></a>01139 <span class="comment"></span>
<a name="l01140"></a>01140 <span class="comment">// This function will base64 ENCODE string stored in strData,</span>
<a name="l01141"></a>01141 <span class="comment">// and then Set() that as the string contents for *this.</span>
<a name="l01142"></a>01142 <span class="comment">// It does NOT handle compression.</span>
<a name="l01143"></a>01143 <span class="comment"></span>
<a name="l01144"></a>01144 <span class="comment">bool OTASCIIArmor::SetString(const OTString &amp; strData, bool bLineBreaks) // =true</span>
<a name="l01145"></a>01145 <span class="comment">{</span>
<a name="l01146"></a>01146 <span class="comment">    char *  pString = NULL;</span>
<a name="l01147"></a>01147 <span class="comment"></span>
<a name="l01148"></a>01148 <span class="comment">    // Now let&#39;s base-64 encode it...                                       // +1 for the null terminator.</span>
<a name="l01149"></a>01149 <span class="comment">    pString = base64_encode((const uint8_t*)strData.Get(), strData.GetLength(), (bLineBreaks ? 1 : 0));</span>
<a name="l01150"></a>01150 <span class="comment">    //  pString = base64_encode((const uint8_t*)strData.Get(), strData.GetLength()+1, (bLineBreaks ? 1 : 0)); // this was before we used compression.</span>
<a name="l01151"></a>01151 <span class="comment"></span>
<a name="l01152"></a>01152 <span class="comment">    if (pString)</span>
<a name="l01153"></a>01153 <span class="comment">    {</span>
<a name="l01154"></a>01154 <span class="comment">        Set(pString);</span>
<a name="l01155"></a>01155 <span class="comment">        delete [] pString; pString=NULL; // I&#39;m using free here because I believe base64_encode is using malloc</span>
<a name="l01156"></a>01156 <span class="comment">        return true;</span>
<a name="l01157"></a>01157 <span class="comment">    }</span>
<a name="l01158"></a>01158 <span class="comment"></span>
<a name="l01159"></a>01159 <span class="comment">    return false;</span>
<a name="l01160"></a>01160 <span class="comment">}</span>
<a name="l01161"></a>01161 <span class="comment">*/</span>
<a name="l01162"></a>01162 
<a name="l01163"></a>01163 <span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span>
<a name="l01164"></a>01164 {
<a name="l01165"></a>01165     <span class="keywordtype">char</span> * ot_openssl_base64_encode(<span class="keyword">const</span> uint8_t * input, int32_t in_len, int32_t bLineBreaks)
<a name="l01166"></a>01166     {
<a name="l01167"></a>01167         <span class="keywordtype">char</span>    * buf  = NULL;
<a name="l01168"></a>01168         BUF_MEM * bptr = NULL;
<a name="l01169"></a>01169 
<a name="l01170"></a>01170         <a class="code" href="_o_t_assert_8hpp.html#a033b133f48e61f2b227c52ad2be0c882">OT_ASSERT_MSG</a>(in_len &gt;= 0, <span class="stringliteral">&quot;OT_base64_encode: Abort: in_len is a negative number!&quot;</span>);
<a name="l01171"></a>01171         <span class="comment">// -------------------------------</span>
<a name="l01172"></a>01172         <a class="code" href="class_open_s_s_l___b_i_o.html">OpenSSL_BIO</a> b64 = BIO_new(BIO_f_base64());
<a name="l01173"></a>01173 
<a name="l01174"></a>01174         <span class="keywordflow">if</span> (!b64)
<a name="l01175"></a>01175             <span class="keywordflow">return</span> buf;
<a name="l01176"></a>01176         <span class="comment">// -------------------------------</span>
<a name="l01177"></a>01177         <span class="keywordflow">if</span> (!bLineBreaks)
<a name="l01178"></a>01178             BIO_set_flags(b64, BIO_FLAGS_BASE64_NO_NL);
<a name="l01179"></a>01179         <span class="comment">// -------------------------------</span>
<a name="l01180"></a>01180         <a class="code" href="class_open_s_s_l___b_i_o.html">OpenSSL_BIO</a> bmem = BIO_new(BIO_s_mem());
<a name="l01181"></a>01181 
<a name="l01182"></a>01182         <span class="keywordflow">if</span> (bmem)
<a name="l01183"></a>01183         {
<a name="l01184"></a>01184             <a class="code" href="class_open_s_s_l___b_i_o.html">OpenSSL_BIO</a> b64join = BIO_push(b64, bmem); b64.<a class="code" href="class_open_s_s_l___b_i_o.html#a641bbca2aa7d30d99b20267cbee9d542">release</a>(); bmem.<a class="code" href="class_open_s_s_l___b_i_o.html#a641bbca2aa7d30d99b20267cbee9d542">release</a>();
<a name="l01185"></a>01185 
<a name="l01186"></a>01186             <span class="keywordflow">if</span> (BIO_write(b64join, input, in_len)==in_len)
<a name="l01187"></a>01187             {
<a name="l01188"></a>01188                 (void)BIO_flush(b64join);
<a name="l01189"></a>01189                 BIO_get_mem_ptr(b64join, &amp;bptr);
<a name="l01190"></a>01190     <span class="comment">//          OTLog::vOutput(5, &quot;DEBUG base64_encode size: %lld,  in_len: %lld\n&quot;, bptr-&gt;length+1, in_len);</span>
<a name="l01191"></a>01191                 buf = <span class="keyword">new</span> <span class="keywordtype">char</span>[bptr-&gt;length+1];
<a name="l01192"></a>01192                 <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != buf);
<a name="l01193"></a>01193                 memcpy(buf, bptr-&gt;data, bptr-&gt;length);  <span class="comment">// Safe.</span>
<a name="l01194"></a>01194                 buf[bptr-&gt;length] = <span class="charliteral">&#39;\0&#39;</span>; <span class="comment">// Forcing null terminator.</span>
<a name="l01195"></a>01195             }
<a name="l01196"></a>01196         }
<a name="l01197"></a>01197         <span class="keywordflow">else</span>
<a name="l01198"></a>01198         {
<a name="l01199"></a>01199             <a class="code" href="_o_t_assert_8hpp.html#aa86aeed4e57eecded96d5955b5cc23c5">OT_FAIL_MSG</a>(<span class="stringliteral">&quot;Failed creating new Bio in base64_encode.\n&quot;</span>);
<a name="l01200"></a>01200         }
<a name="l01201"></a>01201         <span class="comment">// -------------------------------</span>
<a name="l01202"></a>01202         <span class="keywordflow">return</span> buf;
<a name="l01203"></a>01203     }
<a name="l01204"></a>01204 
<a name="l01205"></a>01205     uint8_t * ot_openssl_base64_decode(<span class="keyword">const</span> <span class="keywordtype">char</span> * input, <span class="keywordtype">size_t</span> * out_len, int32_t bLineBreaks)
<a name="l01206"></a>01206     {
<a name="l01207"></a>01207         <span class="comment">// -------------------------------</span>
<a name="l01208"></a>01208         <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != input);
<a name="l01209"></a>01209         <span class="comment">// -------------------------------</span>
<a name="l01210"></a>01210         int32_t             in_len      = <span class="keyword">static_cast&lt;</span>int32_t<span class="keyword">&gt;</span> (strlen(input)); <span class="comment">// todo security (strlen)</span>
<a name="l01211"></a>01211         int32_t             out_max_len = (in_len*6+7)/8;
<a name="l01212"></a>01212         uint8_t * buf         = <span class="keyword">new</span> uint8_t [out_max_len];
<a name="l01213"></a>01213         <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != buf);
<a name="l01214"></a>01214         memset(buf, 0, out_max_len); <span class="comment">// todo security</span>
<a name="l01215"></a>01215         <span class="comment">// -------------------------------</span>
<a name="l01216"></a>01216         <a class="code" href="class_open_s_s_l___b_i_o.html">OpenSSL_BIO</a> b64 = BIO_new(BIO_f_base64());
<a name="l01217"></a>01217 
<a name="l01218"></a>01218         <span class="keywordflow">if</span> (b64)
<a name="l01219"></a>01219         {
<a name="l01220"></a>01220             <span class="keywordflow">if</span> (!bLineBreaks)
<a name="l01221"></a>01221                 BIO_set_flags(b64, BIO_FLAGS_BASE64_NO_NL);
<a name="l01222"></a>01222             <span class="comment">// -------------------------------</span>
<a name="l01223"></a>01223             <a class="code" href="class_open_s_s_l___b_i_o.html">OpenSSL_BIO</a> bmem = BIO_new_mem_buf((<span class="keywordtype">char</span>*)input, in_len); <span class="comment">// todo casting.</span>
<a name="l01224"></a>01224             <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != bmem);
<a name="l01225"></a>01225             <span class="comment">// -------------------------------</span>
<a name="l01226"></a>01226             <a class="code" href="class_open_s_s_l___b_i_o.html">OpenSSL_BIO</a> b64join = BIO_push(b64, bmem); b64.<a class="code" href="class_open_s_s_l___b_i_o.html#a641bbca2aa7d30d99b20267cbee9d542">release</a>(); bmem.<a class="code" href="class_open_s_s_l___b_i_o.html#a641bbca2aa7d30d99b20267cbee9d542">release</a>();
<a name="l01227"></a>01227             <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != b64join);
<a name="l01228"></a>01228             <span class="comment">// -------------------------------</span>
<a name="l01229"></a>01229             *out_len = BIO_read(b64join, buf, out_max_len);
<a name="l01230"></a>01230             <span class="comment">// -------------------------------</span>
<a name="l01231"></a>01231         }
<a name="l01232"></a>01232         <span class="keywordflow">else</span>
<a name="l01233"></a>01233         {
<a name="l01234"></a>01234             <a class="code" href="_o_t_assert_8hpp.html#aa86aeed4e57eecded96d5955b5cc23c5">OT_FAIL_MSG</a>(<span class="stringliteral">&quot;Failed creating new Bio in base64_decode.\n&quot;</span>);
<a name="l01235"></a>01235         }
<a name="l01236"></a>01236 
<a name="l01237"></a>01237         <span class="keywordflow">return</span> buf;
<a name="l01238"></a>01238     }
<a name="l01239"></a>01239 } <span class="comment">// extern &quot;C&quot;</span>
<a name="l01240"></a>01240 
<a name="l01241"></a>01241 
<a name="l01242"></a>01242 <span class="comment">// Caller responsible to delete.</span>
<a name="l01243"></a>01243 <span class="keywordtype">char</span> * OTCrypto_OpenSSL::Base64Encode(<span class="keyword">const</span> uint8_t * input, int32_t in_len, <span class="keywordtype">bool</span> bLineBreaks)<span class="keyword"> const</span>
<a name="l01244"></a>01244 <span class="keyword"></span>{
<a name="l01245"></a>01245     <span class="keywordflow">return</span> ot_openssl_base64_encode(input, in_len, (bLineBreaks ? 1 : 0));
<a name="l01246"></a>01246 }
<a name="l01247"></a>01247 
<a name="l01248"></a>01248 
<a name="l01249"></a>01249 <span class="comment">// Caller responsible to delete.</span>
<a name="l01250"></a>01250 uint8_t * OTCrypto_OpenSSL::Base64Decode(<span class="keyword">const</span> <span class="keywordtype">char</span> * input, <span class="keywordtype">size_t</span> * out_len, <span class="keywordtype">bool</span> bLineBreaks)<span class="keyword"> const</span>
<a name="l01251"></a>01251 <span class="keyword"></span>{
<a name="l01252"></a>01252     <span class="keywordflow">return</span> ot_openssl_base64_decode(input, out_len, (bLineBreaks ? 1 : 0));
<a name="l01253"></a>01253 }
<a name="l01254"></a>01254 
<a name="l01255"></a>01255 
<a name="l01256"></a>01256 <span class="comment">// SET (binary id) FROM BASE62-ENCODED STRING</span>
<a name="l01257"></a>01257 <span class="comment">//</span>
<a name="l01258"></a>01258 <span class="comment">// Using a BigInteger lib I just added.</span>
<a name="l01259"></a>01259 <span class="comment">//</span>
<a name="l01260"></a>01260 <span class="comment">// Hopefully use something like this to replace some of the internals for OTIdentifier.</span>
<a name="l01261"></a>01261 <span class="comment">// I need to get the author to add a &quot;back into data again&quot; function though.</span>
<a name="l01262"></a>01262 <span class="comment">//</span>
<a name="l01263"></a>01263 <span class="keywordtype">void</span> OTCrypto_OpenSSL::SetIDFromBase62String(<span class="keyword">const</span> <a class="code" href="class_o_t_string.html">OTString</a> &amp; strInput, <a class="code" href="class_o_t_identifier.html">OTIdentifier</a> &amp; theOutput)<span class="keyword"> const</span>
<a name="l01264"></a>01264 <span class="keyword"></span>{
<a name="l01265"></a>01265     theOutput.<a class="code" href="class_o_t_data.html#aab9a5758e85597ef1d7250bcf2cc56a6">Release</a>();
<a name="l01266"></a>01266     <span class="comment">// ---------------------------------------</span>
<a name="l01267"></a>01267     <span class="comment">// If it&#39;s short, no validate.</span>
<a name="l01268"></a>01268     <span class="comment">//</span>
<a name="l01269"></a>01269     <span class="keywordflow">if</span> (strInput.<a class="code" href="class_o_t_string.html#a640392dd17a786dab643dbfc7e5a8672">GetLength</a>() &lt; 3)
<a name="l01270"></a>01270         <span class="keywordflow">return</span>;
<a name="l01271"></a>01271     <span class="comment">// ---------------------------------------</span>
<a name="l01272"></a>01272     <span class="comment">// If it&#39;s not base62-encoded, then it doesn&#39;t validate.</span>
<a name="l01273"></a>01273     <span class="comment">//</span>
<a name="l01274"></a>01274     <span class="keyword">const</span> std::string strINPUT = strInput.<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>();
<a name="l01275"></a>01275     <span class="keywordflow">if</span> (<span class="keyword">false</span> == this-&gt;IsBase62(strINPUT))
<a name="l01276"></a>01276         <span class="keywordflow">return</span>;
<a name="l01277"></a>01277 
<a name="l01278"></a>01278     <span class="comment">// Todo there are try/catches in here, so need to handle those at some point.</span>
<a name="l01279"></a>01279     BigInteger bigIntFromBase62 = stringToBigIntegerBase62(strINPUT);
<a name="l01280"></a>01280 
<a name="l01281"></a>01281     <span class="comment">// Now theBaseConverter contains a BigInteger that it read in as base62.</span>
<a name="l01282"></a>01282     <span class="comment">//</span>
<a name="l01283"></a>01283     <span class="comment">// Next step is to output it from that to Hex so I can convert to Binary.</span>
<a name="l01284"></a>01284     <span class="comment">//</span>
<a name="l01285"></a>01285     <span class="comment">// Why not convert it DIRECTLY to binary, you might ask?  TODO.</span>
<a name="l01286"></a>01286     <span class="comment">// In fact this is what we SHOULD be doing. But the BigInteger lib</span>
<a name="l01287"></a>01287     <span class="comment">// I&#39;m using doesn&#39;t have a damned output to binary!  I&#39;m emailing the</span>
<a name="l01288"></a>01288     <span class="comment">// author now.</span>
<a name="l01289"></a>01289     <span class="comment">//</span>
<a name="l01290"></a>01290     <span class="comment">// In the meantime, I had old code from before, that converted hex string to</span>
<a name="l01291"></a>01291     <span class="comment">// binary, which still needs to be removed. But for now, I&#39;ll just convert the</span>
<a name="l01292"></a>01292     <span class="comment">// BigInteger to hex, and then call my old code (below) just to get things running.</span>
<a name="l01293"></a>01293 
<a name="l01294"></a>01294     <span class="comment">// You can convert the other way too.</span>
<a name="l01295"></a>01295     std::string strHEX_VERSION = bigIntegerToStringBase16(bigIntFromBase62);
<a name="l01296"></a>01296 
<a name="l01297"></a>01297     <span class="comment">// I would rather use stringToBigUnsigned and then convert that to data.</span>
<a name="l01298"></a>01298     <span class="comment">// But apparently this class has no conversion back to data, I will contact the author.</span>
<a name="l01299"></a>01299     <span class="comment">//---------------------------------------------------------------</span>
<a name="l01300"></a>01300     BIGNUM * pBigNum = BN_new();
<a name="l01301"></a>01301     <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != pBigNum);
<a name="l01302"></a>01302     <span class="comment">// -----------------------------------------</span>
<a name="l01303"></a>01303     <span class="comment">// Convert from Hex String to BIGNUM.</span>
<a name="l01304"></a>01304     <span class="keyword">const</span> int32_t nToHex = BN_hex2bn(&amp;pBigNum, strHEX_VERSION.c_str());
<a name="l01305"></a>01305     <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a> (0 &lt; nToHex);
<a name="l01306"></a>01306     <span class="comment">// -----------------------------------------</span>
<a name="l01307"></a>01307     <span class="comment">// Convert from Hex String to BigInteger (unwieldy, I know. Future versions will improve.)</span>
<a name="l01308"></a>01308     <span class="comment">//</span>
<a name="l01309"></a>01309     uint32_t nBigNumBytes = BN_num_bytes(pBigNum);
<a name="l01310"></a>01310     theOutput.<a class="code" href="class_o_t_data.html#a61af4b9b5b9ee1c7c825c32caf383542">SetSize</a>(nBigNumBytes);
<a name="l01311"></a>01311     <span class="comment">// ---------------------------------------</span>
<a name="l01312"></a>01312     <span class="keyword">const</span> int32_t nConverted = BN_bn2bin(pBigNum, (uint8_t *)(theOutput.<a class="code" href="class_o_t_data.html#a649046d86480b41406a8b2d8529378e5">GetPointer</a>()) ); <span class="comment">// Todo casting.</span>
<a name="l01313"></a>01313     <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(nConverted);
<a name="l01314"></a>01314     <span class="comment">// ---------------------------------------</span>
<a name="l01315"></a>01315     <span class="comment">// BN_bn2bin() converts the absolute value of param 1 into big-endian form and stores it at param2.</span>
<a name="l01316"></a>01316     <span class="comment">// param2 must point to BN_num_bytes(pBigNum) bytes of memory.</span>
<a name="l01317"></a>01317     <span class="comment">// ---------------------------------------</span>
<a name="l01318"></a>01318     BN_free(pBigNum);
<a name="l01319"></a>01319 }
<a name="l01320"></a>01320 
<a name="l01321"></a>01321 
<a name="l01322"></a>01322 <span class="comment">// GET (binary id) AS BASE62-ENCODED STRING</span>
<a name="l01323"></a>01323 <span class="comment">//</span>
<a name="l01324"></a>01324 <span class="comment">// This Identifier is stored in binary form.</span>
<a name="l01325"></a>01325 <span class="comment">// But what if you want a pretty hex string version of it?</span>
<a name="l01326"></a>01326 <span class="comment">// Just call this function.</span>
<a name="l01327"></a>01327 <span class="comment">// UPDATE: Now Base62 instead of Hex. (More compact.)</span>
<a name="l01328"></a>01328 <span class="comment">// Easy double-click the ID and the entire thing highlights at once.</span>
<a name="l01329"></a>01329 <span class="comment">//</span>
<a name="l01330"></a>01330 <span class="keywordtype">void</span> OTCrypto_OpenSSL::SetBase62StringFromID(<span class="keyword">const</span> <a class="code" href="class_o_t_identifier.html">OTIdentifier</a> &amp; theInput, <a class="code" href="class_o_t_string.html">OTString</a> &amp; strOutput)<span class="keyword"> const</span>
<a name="l01331"></a>01331 <span class="keyword"></span>{
<a name="l01332"></a>01332     strOutput.<a class="code" href="class_o_t_string.html#abef4b21b2170468705c58d64212d7257">Release</a>();
<a name="l01333"></a>01333     <span class="comment">// -----------------------------------------</span>
<a name="l01334"></a>01334     <span class="keywordflow">if</span> (theInput.<a class="code" href="class_o_t_data.html#a947528765516223eb03bee7745eb8c07">IsEmpty</a>())
<a name="l01335"></a>01335         <span class="keywordflow">return</span>;
<a name="l01336"></a>01336     <span class="comment">// -----------------------------------------</span>
<a name="l01337"></a>01337     <span class="comment">// Convert from internal binary format to BIGNUM format.</span>
<a name="l01338"></a>01338     <span class="comment">//</span>
<a name="l01339"></a>01339     BIGNUM * pBigNum = BN_new();
<a name="l01340"></a>01340     <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != pBigNum);
<a name="l01341"></a>01341 
<a name="l01342"></a>01342     BN_bin2bn((uint8_t *)(theInput.<a class="code" href="class_o_t_data.html#a649046d86480b41406a8b2d8529378e5">GetPointer</a>()), theInput.<a class="code" href="class_o_t_data.html#a18fd0599061eaf2c031548e030c3112d">GetSize</a>(), pBigNum); <span class="comment">// todo cast</span>
<a name="l01343"></a>01343     <span class="comment">// -----------------------------------------</span>
<a name="l01344"></a>01344     <span class="comment">// Convert from BIGNUM to Hex String.</span>
<a name="l01345"></a>01345     <span class="comment">//</span>
<a name="l01346"></a>01346     <span class="keywordtype">char</span> * szBigNumInHex = BN_bn2hex(pBigNum);
<a name="l01347"></a>01347     <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(szBigNumInHex != NULL);
<a name="l01348"></a>01348     <span class="comment">// -----------------------------------------</span>
<a name="l01349"></a>01349     <span class="comment">// Convert from Hex String to BigInteger (unwieldy, I know. Future versions will improve.)</span>
<a name="l01350"></a>01350     <span class="comment">//</span>
<a name="l01351"></a>01351     BigInteger theBigInt = stringToBigIntegerBase16(szBigNumInHex);
<a name="l01352"></a>01352     OPENSSL_free(szBigNumInHex); szBigNumInHex = NULL;
<a name="l01353"></a>01353     BN_free(pBigNum);
<a name="l01354"></a>01354     <span class="comment">// -----------------------------------------</span>
<a name="l01355"></a>01355     <span class="comment">// Convert from BigInteger to std::string in Base62 format.</span>
<a name="l01356"></a>01356     <span class="comment">//</span>
<a name="l01357"></a>01357     std::string strBigInt = bigIntegerToStringBase62(theBigInt);
<a name="l01358"></a>01358     <span class="comment">// -----------------------------------------</span>
<a name="l01359"></a>01359     strOutput.<a class="code" href="class_o_t_string.html#aa5db620fe8e60c849585d741975db991">Set</a>(strBigInt.c_str());
<a name="l01360"></a>01360 }
<a name="l01361"></a>01361 
<a name="l01362"></a>01362 
<a name="l01363"></a>01363 <span class="keywordtype">bool</span> OTCrypto_OpenSSL::RandomizeMemory(uint8_t * szDestination, uint32_t nNewSize)<span class="keyword"> const</span>
<a name="l01364"></a>01364 <span class="keyword"></span>{
<a name="l01365"></a>01365     <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != szDestination);
<a name="l01366"></a>01366     <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(nNewSize &gt; 0);
<a name="l01367"></a>01367     <span class="comment">// ---------------------------------</span>
<a name="l01368"></a>01368     <span class="comment">/*</span>
<a name="l01369"></a>01369 <span class="comment">     RAND_bytes() returns 1 on success, 0 otherwise. The error code can be obtained by ERR_get_error(3).</span>
<a name="l01370"></a>01370 <span class="comment">     RAND_pseudo_bytes() returns 1 if the bytes generated are cryptographically strong, 0 otherwise.</span>
<a name="l01371"></a>01371 <span class="comment">     Both functions return -1 if they are not supported by the current RAND method.</span>
<a name="l01372"></a>01372 <span class="comment">     */</span>
<a name="l01373"></a>01373     <span class="keyword">const</span> int32_t nRAND_bytes = RAND_bytes(reinterpret_cast&lt;uint8_t*&gt;(szDestination),
<a name="l01374"></a>01374                                        static_cast&lt;int32_t&gt;(nNewSize));
<a name="l01375"></a>01375 
<a name="l01376"></a>01376     <span class="keywordflow">if</span> ((-1) == nRAND_bytes)
<a name="l01377"></a>01377     {
<a name="l01378"></a>01378         <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;%s: ERROR: RAND_bytes is apparently not supported by the current &quot;</span>
<a name="l01379"></a>01379                       <span class="stringliteral">&quot;RAND method. OpenSSL: %s\n&quot;</span>, __FUNCTION__, ERR_error_string(ERR_get_error(), NULL));
<a name="l01380"></a>01380         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01381"></a>01381     }
<a name="l01382"></a>01382     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (0 == nRAND_bytes)
<a name="l01383"></a>01383     {
<a name="l01384"></a>01384         <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;%s: Failed: The PRNG is apparently not seeded. OpenSSL error: %s\n&quot;</span>,
<a name="l01385"></a>01385                       __FUNCTION__, ERR_error_string(ERR_get_error(), NULL));
<a name="l01386"></a>01386         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01387"></a>01387     }
<a name="l01388"></a>01388     <span class="comment">// --------------------------------------------------</span>
<a name="l01389"></a>01389     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01390"></a>01390 }
<a name="l01391"></a>01391 
<a name="l01392"></a>01392 
<a name="l01393"></a>01393 <span class="comment">// DeriveKey derives a 128-bit symmetric key from a passphrase.</span>
<a name="l01394"></a>01394 <span class="comment">//</span>
<a name="l01395"></a>01395 <span class="comment">// The OTPassword* returned is the actual derived key. (The result.)</span>
<a name="l01396"></a>01396 <span class="comment">//</span>
<a name="l01397"></a>01397 <span class="comment">// However, you would not use it directly for symmetric-key crypto, but</span>
<a name="l01398"></a>01398 <span class="comment">// instead you&#39;d use the OTSymmetricKey class. This is because you still</span>
<a name="l01399"></a>01399 <span class="comment">// need an object to manage everything about the symmetric key. It stores</span>
<a name="l01400"></a>01400 <span class="comment">// the salt and the iteration count, as well as ONLY the ENCRYPTED version</span>
<a name="l01401"></a>01401 <span class="comment">// of the symmetric key, which is a completely random number and is only</span>
<a name="l01402"></a>01402 <span class="comment">// decrypted briefly for specific operations. The derived key (below) is</span>
<a name="l01403"></a>01403 <span class="comment">// what we use for briefly decrypting that actual (random) symmetric key.</span>
<a name="l01404"></a>01404 <span class="comment">//</span>
<a name="l01405"></a>01405 <span class="comment">// Therefore this function is mainly used INSIDE OTSymmetricKey as part of</span>
<a name="l01406"></a>01406 <span class="comment">// its internal operations.</span>
<a name="l01407"></a>01407 <span class="comment">//</span>
<a name="l01408"></a>01408 <span class="comment">// userPassword argument contains the user&#39;s password which is used to</span>
<a name="l01409"></a>01409 <span class="comment">// derive the key. Presumably you already obtained this passphrase...</span>
<a name="l01410"></a>01410 <span class="comment">// Then the derived key is returned, or NULL if failure. CALLER</span>
<a name="l01411"></a>01411 <span class="comment">// IS RESPONSIBLE TO DELETE!</span>
<a name="l01412"></a>01412 <span class="comment">// Todo: return a smart pointer here.</span>
<a name="l01413"></a>01413 <span class="comment">//</span>
<a name="l01414"></a>01414 <a class="code" href="class_o_t_password.html">OTPassword</a> * OTCrypto_OpenSSL::DeriveKey(<span class="keyword">const</span> <a class="code" href="class_o_t_password.html">OTPassword</a> &amp;   userPassword,
<a name="l01415"></a>01415                                          <span class="keyword">const</span> <a class="code" href="class_o_t_payload.html">OTPayload</a>  &amp;   dataSalt,
<a name="l01416"></a>01416                                          <span class="keyword">const</span> uint32_t       uIterations,
<a name="l01417"></a>01417                                          <span class="keyword">const</span> <a class="code" href="class_o_t_payload.html">OTPayload</a>  &amp;   dataCheckHash <span class="comment">/*= OTPayload()*/</span>)<span class="keyword"> const</span>
<a name="l01418"></a>01418 <span class="keyword"></span>{
<a name="l01419"></a>01419     <a class="code" href="class_o_t_payload.html">OTPayload</a> tempPayload = dataCheckHash;
<a name="l01420"></a>01420     <span class="keywordflow">return</span> OTCrypto_OpenSSL::DeriveNewKey(userPassword,dataSalt,uIterations,tempPayload);
<a name="l01421"></a>01421 }
<a name="l01422"></a>01422 
<a name="l01423"></a>01423 
<a name="l01424"></a>01424 <a class="code" href="class_o_t_password.html">OTPassword</a> * OTCrypto_OpenSSL::DeriveNewKey(<span class="keyword">const</span> <a class="code" href="class_o_t_password.html">OTPassword</a> &amp;   userPassword,
<a name="l01425"></a>01425                                             <span class="keyword">const</span> <a class="code" href="class_o_t_payload.html">OTPayload</a>  &amp;   dataSalt,
<a name="l01426"></a>01426                                             <span class="keyword">const</span> uint32_t       uIterations,
<a name="l01427"></a>01427                                                   <a class="code" href="class_o_t_payload.html">OTPayload</a>  &amp;   dataCheckHash)<span class="keyword"> const</span>
<a name="l01428"></a>01428 <span class="keyword"></span>{
<a name="l01429"></a>01429 <span class="comment">//  OT_ASSERT(userPassword.isPassword());</span>
<a name="l01430"></a>01430     <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(!dataSalt.<a class="code" href="class_o_t_data.html#a947528765516223eb03bee7745eb8c07">IsEmpty</a>());
<a name="l01431"></a>01431     <span class="comment">// ------------------------------------</span>
<a name="l01432"></a>01432     <span class="keyword">const</span> <span class="keywordtype">char</span> * szFunc = <span class="stringliteral">&quot;OTCrypto_OpenSSL::DeriveKey&quot;</span>;
<a name="l01433"></a>01433     <span class="comment">// ------------------------------------</span>
<a name="l01434"></a>01434     <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(2, <span class="stringliteral">&quot;%s: Using a text passphrase, salt, and iteration count, &quot;</span>
<a name="l01435"></a>01435                    <span class="stringliteral">&quot;to make a derived key...\n&quot;</span>, szFunc);
<a name="l01436"></a>01436     <span class="comment">// ------------------------------------</span>
<a name="l01437"></a>01437 
<a name="l01438"></a>01438 
<a name="l01439"></a>01439     <a class="code" href="class_o_t_password.html">OTPassword</a> * pDerivedKey(this-&gt;InstantiateBinarySecret()); <span class="comment">// already asserts.</span>
<a name="l01440"></a>01440 
<a name="l01441"></a>01441     <span class="comment">//  pDerivedKey MUST be returned or cleaned-up, below this point.</span>
<a name="l01442"></a>01442     <span class="comment">//</span>
<a name="l01443"></a>01443     <span class="comment">// --------------------------------------------------</span>
<a name="l01444"></a>01444     <span class="comment">// Key derivation in OpenSSL.</span>
<a name="l01445"></a>01445     <span class="comment">//</span>
<a name="l01446"></a>01446     <span class="comment">// int32_t PKCS5_PBKDF2_HMAC_SHA1(const char*, int32_t, const uint8_t*, int32_t, int32_t, int32_t, uint8_t*)</span>
<a name="l01447"></a>01447     <span class="comment">//</span>
<a name="l01448"></a>01448     PKCS5_PBKDF2_HMAC_SHA1(
<a name="l01449"></a>01449         reinterpret_cast&lt;const char *&gt;   <span class="comment">// If is password... supply password, otherwise supply memory.</span>
<a name="l01450"></a>01450         (
<a name="l01451"></a>01451         userPassword.<a class="code" href="class_o_t_password.html#a9ff2880813b81165a350c92e930ba311">isPassword</a>() ? userPassword.<a class="code" href="class_o_t_password.html#a191412ad42e97cd3d36cc4f03068ab68">getPassword_uint8</a>() : userPassword.<a class="code" href="class_o_t_password.html#af3c2834981627910da5408018c588ad1">getMemory_uint8</a>()
<a name="l01452"></a>01452         ),
<a name="l01453"></a>01453         static_cast &lt;const int32_t&gt;             (userPassword.<a class="code" href="class_o_t_password.html#a9ff2880813b81165a350c92e930ba311">isPassword</a>() ? userPassword.<a class="code" href="class_o_t_password.html#a849be9ea50ea9935feba18a9a0919fe5">getPasswordSize</a>() :
<a name="l01454"></a>01454                                              userPassword.<a class="code" href="class_o_t_password.html#a9733667570f4ee91a4c8993d11f198a8">getMemorySize</a>()),         <span class="comment">// Password Length</span>
<a name="l01455"></a>01455         static_cast &lt;const uint8_t *&gt; (dataSalt.<a class="code" href="class_o_t_payload.html#aef8d7f40ba7886f7da16290091681aa9">GetPayloadPointer</a>()),         <span class="comment">// Salt Data</span>
<a name="l01456"></a>01456         static_cast &lt;const int32_t&gt;             (dataSalt.<a class="code" href="class_o_t_data.html#a18fd0599061eaf2c031548e030c3112d">GetSize</a>()),                   <span class="comment">// Salt Length</span>
<a name="l01457"></a>01457         static_cast &lt;const int32_t&gt;             (uIterations),                          <span class="comment">// Number Of Iterations</span>
<a name="l01458"></a>01458         static_cast &lt;<span class="keyword">const</span> int32_t&gt;             (pDerivedKey-&gt;getMemorySize()),         <span class="comment">// Output Length</span>
<a name="l01459"></a>01459         static_cast &lt;uint8_t *&gt;       (pDerivedKey-&gt;getMemoryWritable())      <span class="comment">// Output Key (not const!)</span>
<a name="l01460"></a>01460         );
<a name="l01461"></a>01461 
<a name="l01462"></a>01462     <span class="comment">// For The HashCheck</span>
<a name="l01463"></a>01463     <span class="comment">// -------------------------------------------------------------------------------------------------</span>
<a name="l01464"></a>01464 
<a name="l01465"></a>01465     <span class="keywordtype">bool</span> bHaveCheckHash = !dataCheckHash.<a class="code" href="class_o_t_data.html#a947528765516223eb03bee7745eb8c07">IsEmpty</a>();
<a name="l01466"></a>01466 
<a name="l01467"></a>01467     <a class="code" href="class_o_t_payload.html">OTPayload</a> tmpHashCheck;
<a name="l01468"></a>01468     tmpHashCheck.<a class="code" href="class_o_t_payload.html#a8a6a8221de63686df445f0e77e73f214">SetPayloadSize</a>(<a class="code" href="class_o_t_crypto_config.html#a835596fd28dc8f14d62e6a141e6b4c11">OTCryptoConfig::SymmetricKeySize</a>());
<a name="l01469"></a>01469 
<a name="l01470"></a>01470     <span class="comment">// We take the DerivedKey, and hash it again, then get a &#39;hash-check&#39;</span>
<a name="l01471"></a>01471     <span class="comment">// Compare that with the supplied one, (if there is one).</span>
<a name="l01472"></a>01472     <span class="comment">// If there isn&#39;t one, we return the</span>
<a name="l01473"></a>01473 
<a name="l01474"></a>01474     PKCS5_PBKDF2_HMAC_SHA1(
<a name="l01475"></a>01475         reinterpret_cast&lt;const char *&gt;          (pDerivedKey-&gt;getMemory()),        <span class="comment">// Derived Key</span>
<a name="l01476"></a>01476         static_cast     &lt;const int32_t&gt;             (pDerivedKey-&gt;getMemorySize()),    <span class="comment">// Password Length</span>
<a name="l01477"></a>01477         static_cast     &lt;const uint8_t *&gt; (dataSalt.<a class="code" href="class_o_t_payload.html#aef8d7f40ba7886f7da16290091681aa9">GetPayloadPointer</a>()),    <span class="comment">// Salt Data</span>
<a name="l01478"></a>01478         static_cast     &lt;const int32_t&gt;             (dataSalt.<a class="code" href="class_o_t_data.html#a18fd0599061eaf2c031548e030c3112d">GetSize</a>()),              <span class="comment">// Salt Length</span>
<a name="l01479"></a>01479         static_cast     &lt;const int32_t&gt;             (uIterations),                     <span class="comment">// Number Of Iterations</span>
<a name="l01480"></a>01480         static_cast     &lt;<span class="keyword">const</span> int32_t&gt;             (tmpHashCheck.<a class="code" href="class_o_t_data.html#a18fd0599061eaf2c031548e030c3112d">GetSize</a>()),          <span class="comment">// Output Length</span>
<a name="l01481"></a>01481         const_cast&lt;uint8_t *&gt;(static_cast&lt;const uint8_t *&gt;(tmpHashCheck.<a class="code" href="class_o_t_payload.html#aef8d7f40ba7886f7da16290091681aa9">GetPayloadPointer</a>())))  <span class="comment">// Output Key (not const!)</span>
<a name="l01482"></a>01482         ;
<a name="l01483"></a>01483 
<a name="l01484"></a>01484     <span class="keywordflow">if</span> (bHaveCheckHash)
<a name="l01485"></a>01485     {
<a name="l01486"></a>01486         <a class="code" href="class_o_t_string.html">OTString</a> strDataCheck, strTestCheck;
<a name="l01487"></a>01487         strDataCheck.<a class="code" href="class_o_t_string.html#aa5db620fe8e60c849585d741975db991">Set</a>(static_cast&lt;const char *&gt;(dataCheckHash.<a class="code" href="class_o_t_payload.html#aef8d7f40ba7886f7da16290091681aa9">GetPayloadPointer</a>()),dataCheckHash.<a class="code" href="class_o_t_data.html#a18fd0599061eaf2c031548e030c3112d">GetSize</a>());
<a name="l01488"></a>01488         strTestCheck.<a class="code" href="class_o_t_string.html#aa5db620fe8e60c849585d741975db991">Set</a>(static_cast&lt;const char *&gt;(tmpHashCheck.<a class="code" href="class_o_t_payload.html#aef8d7f40ba7886f7da16290091681aa9">GetPayloadPointer</a>()),tmpHashCheck.<a class="code" href="class_o_t_data.html#a18fd0599061eaf2c031548e030c3112d">GetSize</a>());
<a name="l01489"></a>01489 
<a name="l01490"></a>01490 
<a name="l01491"></a>01491         <span class="keywordflow">if</span> (!strDataCheck.<a class="code" href="class_o_t_string.html#a03401b39fb66d63696342c4f61ea8bf5">Compare</a>(strTestCheck))
<a name="l01492"></a>01492         {
<a name="l01493"></a>01493             dataCheckHash.<a class="code" href="class_o_t_data.html#ad6e1d52647f43ec65069a9aa676d7e26">reset</a>();
<a name="l01494"></a>01494             dataCheckHash = tmpHashCheck;
<a name="l01495"></a>01495             <span class="keywordflow">return</span> NULL; <span class="comment">// failure (but we will return the dataCheckHash we got anyway)</span>
<a name="l01496"></a>01496         }
<a name="l01497"></a>01497     }
<a name="l01498"></a>01498     <span class="keywordflow">else</span>
<a name="l01499"></a>01499     {
<a name="l01500"></a>01500         dataCheckHash.<a class="code" href="class_o_t_data.html#ad6e1d52647f43ec65069a9aa676d7e26">reset</a>();
<a name="l01501"></a>01501         dataCheckHash = tmpHashCheck;
<a name="l01502"></a>01502     }
<a name="l01503"></a>01503 
<a name="l01504"></a>01504     <span class="keywordflow">return</span> pDerivedKey;
<a name="l01505"></a>01505 }
<a name="l01506"></a>01506 
<a name="l01507"></a>01507 
<a name="l01508"></a>01508 <span class="comment">/*</span>
<a name="l01509"></a>01509 <span class="comment"> openssl dgst -sha1 \</span>
<a name="l01510"></a>01510 <span class="comment"> -sign clientkey.pem \</span>
<a name="l01511"></a>01511 <span class="comment"> -out cheesy2.sig \</span>
<a name="l01512"></a>01512 <span class="comment"> cheesy2.xml</span>
<a name="l01513"></a>01513 <span class="comment"></span>
<a name="l01514"></a>01514 <span class="comment"> openssl dgst -sha1 \</span>
<a name="l01515"></a>01515 <span class="comment"> -verify clientcert.pem \</span>
<a name="l01516"></a>01516 <span class="comment"> -signature cheesy2.sig \</span>
<a name="l01517"></a>01517 <span class="comment"> cheesy2.xml</span>
<a name="l01518"></a>01518 <span class="comment"></span>
<a name="l01519"></a>01519 <span class="comment"></span>
<a name="l01520"></a>01520 <span class="comment">openssl x509 -in clientcert.pem -pubkey -noout &gt; clientpub.pem</span>
<a name="l01521"></a>01521 <span class="comment"></span>
<a name="l01522"></a>01522 <span class="comment"> Then verification using the public key works as expected:</span>
<a name="l01523"></a>01523 <span class="comment"></span>
<a name="l01524"></a>01524 <span class="comment">openssl dgst -sha1 -verify clientpub.pem -signature cheesy2.sig  cheesy2.xml</span>
<a name="l01525"></a>01525 <span class="comment"></span>
<a name="l01526"></a>01526 <span class="comment"> Verified OK</span>
<a name="l01527"></a>01527 <span class="comment"></span>
<a name="l01528"></a>01528 <span class="comment"></span>
<a name="l01529"></a>01529 <span class="comment"> openssl enc -base64 -out cheesy2.b64 cheesy2.sig</span>
<a name="l01530"></a>01530 <span class="comment"></span>
<a name="l01531"></a>01531 <span class="comment"> */</span>
<a name="l01532"></a>01532 
<a name="l01533"></a>01533 
<a name="l01534"></a>01534 <span class="comment">//static</span>
<a name="l01535"></a>01535 <span class="keyword">const</span> EVP_MD * OTCrypto_OpenSSL::OTCrypto_OpenSSLdp::GetOpenSSLDigestByName(<span class="keyword">const</span> <a class="code" href="class_o_t_string.html">OTString</a> &amp; theName)
<a name="l01536"></a>01536 {
<a name="l01537"></a>01537     <span class="keywordflow">if</span> (theName.<a class="code" href="class_o_t_string.html#a03401b39fb66d63696342c4f61ea8bf5">Compare</a>(<span class="stringliteral">&quot;SHA1&quot;</span>))
<a name="l01538"></a>01538         <span class="keywordflow">return</span> EVP_sha1();
<a name="l01539"></a>01539     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (theName.<a class="code" href="class_o_t_string.html#a03401b39fb66d63696342c4f61ea8bf5">Compare</a>(<span class="stringliteral">&quot;SHA224&quot;</span>))
<a name="l01540"></a>01540         <span class="keywordflow">return</span> EVP_sha224();
<a name="l01541"></a>01541     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (theName.<a class="code" href="class_o_t_string.html#a03401b39fb66d63696342c4f61ea8bf5">Compare</a>(<span class="stringliteral">&quot;SHA256&quot;</span>))
<a name="l01542"></a>01542         <span class="keywordflow">return</span> EVP_sha256();
<a name="l01543"></a>01543     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (theName.<a class="code" href="class_o_t_string.html#a03401b39fb66d63696342c4f61ea8bf5">Compare</a>(<span class="stringliteral">&quot;SHA384&quot;</span>))
<a name="l01544"></a>01544         <span class="keywordflow">return</span> EVP_sha384();
<a name="l01545"></a>01545     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (theName.<a class="code" href="class_o_t_string.html#a03401b39fb66d63696342c4f61ea8bf5">Compare</a>(<span class="stringliteral">&quot;SHA512&quot;</span>))
<a name="l01546"></a>01546         <span class="keywordflow">return</span> EVP_sha512();
<a name="l01547"></a>01547 <span class="comment">//#ifndef ANDROID</span>
<a name="l01548"></a>01548     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (theName.<a class="code" href="class_o_t_string.html#a03401b39fb66d63696342c4f61ea8bf5">Compare</a>(<span class="stringliteral">&quot;WHIRLPOOL&quot;</span>)) <span class="comment">// Todo: follow up on any cleanup issues related to this. (Are the others dynamically allocated? This one isn&#39;t.)</span>
<a name="l01549"></a>01549         <span class="keywordflow">return</span> EVP_whirlpool();
<a name="l01550"></a>01550 <span class="comment">//#endif</span>
<a name="l01551"></a>01551     <span class="keywordflow">return</span> NULL;
<a name="l01552"></a>01552 }
<a name="l01553"></a>01553 
<a name="l01554"></a>01554 
<a name="l01555"></a>01555 <span class="keywordtype">bool</span> OTCrypto_OpenSSL::CalculateDigest(<span class="keyword">const</span> <a class="code" href="class_o_t_string.html">OTString</a> &amp; strInput, <span class="keyword">const</span> <a class="code" href="class_o_t_string.html">OTString</a> &amp; strHashAlgorithm, <a class="code" href="class_o_t_identifier.html">OTIdentifier</a> &amp; theOutput)<span class="keyword"> const</span>
<a name="l01556"></a>01556 <span class="keyword"></span>{
<a name="l01557"></a>01557     <span class="comment">// ------------------------------------</span>
<a name="l01558"></a>01558     <span class="keyword">const</span> <span class="keywordtype">char</span> * szFunc = <span class="stringliteral">&quot;OTCrypto_OpenSSL::CalculateDigest&quot;</span>;
<a name="l01559"></a>01559     <span class="comment">// ------------------------------------</span>
<a name="l01560"></a>01560     theOutput.<a class="code" href="class_o_t_data.html#aab9a5758e85597ef1d7250bcf2cc56a6">Release</a>();
<a name="l01561"></a>01561 
<a name="l01562"></a>01562     <span class="comment">// Some hash algorithms are handled by other methods.</span>
<a name="l01563"></a>01563     <span class="comment">// If those don&#39;t handle it, then we&#39;ll come back here and use OpenSSL.</span>
<a name="l01564"></a>01564     <span class="keywordflow">if</span> (theOutput.<a class="code" href="class_o_t_identifier.html#a429dfc5afc3854ae51dfb4348b6a3d99">CalculateDigestInternal</a>(strInput, strHashAlgorithm))
<a name="l01565"></a>01565     {
<a name="l01566"></a>01566         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01567"></a>01567     }
<a name="l01568"></a>01568     <span class="comment">// ----------------------------------------------</span>
<a name="l01569"></a>01569     EVP_MD_CTX mdctx;
<a name="l01570"></a>01570     <span class="keyword">const</span> EVP_MD *md = NULL;
<a name="l01571"></a>01571 
<a name="l01572"></a>01572     uint32_t md_len = 0;
<a name="l01573"></a>01573     uint8_t md_value[EVP_MAX_MD_SIZE];  <span class="comment">// I believe this is safe, having just analyzed this function.</span>
<a name="l01574"></a>01574     <span class="comment">// ----------------------------------------------</span>
<a name="l01575"></a>01575     <span class="comment">// Okay, it wasn&#39;t any internal hash algorithm, so then which one was it?</span>
<a name="l01576"></a>01576     <span class="comment">//</span>
<a name="l01577"></a>01577     md = OTCrypto_OpenSSL::OTCrypto_OpenSSLdp::GetOpenSSLDigestByName(strHashAlgorithm); <span class="comment">// todo cleanup?</span>
<a name="l01578"></a>01578 
<a name="l01579"></a>01579     <span class="keywordflow">if</span> (!md)
<a name="l01580"></a>01580     {
<a name="l01581"></a>01581         <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;%s: Unknown message digest algorithm: %s\n&quot;</span>, szFunc,
<a name="l01582"></a>01582                       strHashAlgorithm.<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>());
<a name="l01583"></a>01583         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01584"></a>01584     }
<a name="l01585"></a>01585 
<a name="l01586"></a>01586     EVP_MD_CTX_init(&amp;mdctx);
<a name="l01587"></a>01587     EVP_DigestInit_ex(&amp;mdctx, md, NULL);
<a name="l01588"></a>01588     EVP_DigestUpdate(&amp;mdctx, strInput.<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>(), strInput.<a class="code" href="class_o_t_string.html#a640392dd17a786dab643dbfc7e5a8672">GetLength</a>());
<a name="l01589"></a>01589     EVP_DigestFinal_ex(&amp;mdctx, md_value, &amp;md_len);
<a name="l01590"></a>01590     EVP_MD_CTX_cleanup(&amp;mdctx);
<a name="l01591"></a>01591 
<a name="l01592"></a>01592     theOutput.<a class="code" href="class_o_t_data.html#a253cd3974cb837ad06980579eb7bc0e4">Assign</a>(md_value, md_len);
<a name="l01593"></a>01593 
<a name="l01594"></a>01594     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01595"></a>01595 }
<a name="l01596"></a>01596 
<a name="l01597"></a>01597 
<a name="l01598"></a>01598 <span class="keywordtype">bool</span> OTCrypto_OpenSSL::CalculateDigest(<span class="keyword">const</span> <a class="code" href="class_o_t_data.html">OTData</a> &amp; dataInput, <span class="keyword">const</span> <a class="code" href="class_o_t_string.html">OTString</a> &amp; strHashAlgorithm, <a class="code" href="class_o_t_identifier.html">OTIdentifier</a> &amp; theOutput)<span class="keyword"> const</span>
<a name="l01599"></a>01599 <span class="keyword"></span>{
<a name="l01600"></a>01600     <span class="comment">// ------------------------------------</span>
<a name="l01601"></a>01601     <span class="keyword">const</span> <span class="keywordtype">char</span> * szFunc = <span class="stringliteral">&quot;OTCrypto_OpenSSL::CalculateDigest&quot;</span>;
<a name="l01602"></a>01602     <span class="comment">// ------------------------------------</span>
<a name="l01603"></a>01603     theOutput.<a class="code" href="class_o_t_data.html#aab9a5758e85597ef1d7250bcf2cc56a6">Release</a>();
<a name="l01604"></a>01604 
<a name="l01605"></a>01605     <span class="comment">// Some hash algorithms are handled by other methods.</span>
<a name="l01606"></a>01606     <span class="comment">// If those don&#39;t handle it, then we&#39;ll come back here and use OpenSSL.</span>
<a name="l01607"></a>01607     <span class="keywordflow">if</span> (theOutput.<a class="code" href="class_o_t_identifier.html#a429dfc5afc3854ae51dfb4348b6a3d99">CalculateDigestInternal</a>(dataInput, strHashAlgorithm))
<a name="l01608"></a>01608     {
<a name="l01609"></a>01609         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01610"></a>01610     }
<a name="l01611"></a>01611     <span class="comment">// ----------------------------------------------</span>
<a name="l01612"></a>01612     EVP_MD_CTX mdctx;
<a name="l01613"></a>01613     <span class="keyword">const</span> EVP_MD *md = NULL;
<a name="l01614"></a>01614 
<a name="l01615"></a>01615     uint32_t md_len = 0;
<a name="l01616"></a>01616     uint8_t md_value[EVP_MAX_MD_SIZE];  <span class="comment">// I believe this is safe, shouldn&#39;t ever be larger than MAX SIZE.</span>
<a name="l01617"></a>01617     <span class="comment">// ----------------------------------------------</span>
<a name="l01618"></a>01618     <span class="comment">// Okay, it wasn&#39;t any internal hash algorithm, so then which one was it?</span>
<a name="l01619"></a>01619     <span class="comment">//</span>
<a name="l01620"></a>01620     md = OTCrypto_OpenSSL::OTCrypto_OpenSSLdp::GetOpenSSLDigestByName(strHashAlgorithm); <span class="comment">// todo cleanup ?</span>
<a name="l01621"></a>01621 
<a name="l01622"></a>01622     <span class="keywordflow">if</span> (!md)
<a name="l01623"></a>01623     {
<a name="l01624"></a>01624         <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;%s: Unknown message digest algorithm: %s\n&quot;</span>,
<a name="l01625"></a>01625                 szFunc, strHashAlgorithm.<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>());
<a name="l01626"></a>01626         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01627"></a>01627     }
<a name="l01628"></a>01628 
<a name="l01629"></a>01629     EVP_MD_CTX_init(&amp;mdctx);
<a name="l01630"></a>01630     EVP_DigestInit_ex(&amp;mdctx, md, NULL);
<a name="l01631"></a>01631     EVP_DigestUpdate(&amp;mdctx, dataInput.<a class="code" href="class_o_t_data.html#a649046d86480b41406a8b2d8529378e5">GetPointer</a>(), dataInput.<a class="code" href="class_o_t_data.html#a18fd0599061eaf2c031548e030c3112d">GetSize</a>());
<a name="l01632"></a>01632     EVP_DigestFinal_ex(&amp;mdctx, md_value, &amp;md_len);
<a name="l01633"></a>01633     EVP_MD_CTX_cleanup(&amp;mdctx);
<a name="l01634"></a>01634 
<a name="l01635"></a>01635     theOutput.<a class="code" href="class_o_t_data.html#a253cd3974cb837ad06980579eb7bc0e4">Assign</a>(md_value, md_len);
<a name="l01636"></a>01636 
<a name="l01637"></a>01637     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01638"></a>01638 }
<a name="l01639"></a>01639 
<a name="l01640"></a>01640 
<a name="l01641"></a>01641 <span class="comment">/*</span>
<a name="l01642"></a>01642 <span class="comment"> SHA256_CTX context;</span>
<a name="l01643"></a>01643 <span class="comment"> uint8_t md[SHA256_DIGEST_LENGTH];</span>
<a name="l01644"></a>01644 <span class="comment"></span>
<a name="l01645"></a>01645 <span class="comment"> SHA256_Init(&amp;context);</span>
<a name="l01646"></a>01646 <span class="comment"> SHA256_Update(&amp;context, (uint8_t*)input, length);</span>
<a name="l01647"></a>01647 <span class="comment"> SHA256_Final(md, &amp;context);</span>
<a name="l01648"></a>01648 <span class="comment"> */</span>
<a name="l01649"></a>01649 
<a name="l01650"></a>01650 <span class="comment">// (To instantiate a text secret, just do this:  OTPassword thePassword;)</span>
<a name="l01651"></a>01651 
<a name="l01652"></a>01652 <span class="comment">// Caller MUST delete!</span>
<a name="l01653"></a>01653 <span class="comment">// todo return a smartpointer here.</span>
<a name="l01654"></a>01654 <a class="code" href="class_o_t_password.html">OTPassword</a> * OTCrypto_OpenSSL::InstantiateBinarySecret()<span class="keyword"> const</span>
<a name="l01655"></a>01655 <span class="keyword"></span>{
<a name="l01656"></a>01656     uint8_t *  tmp_data = <span class="keyword">new</span> uint8_t[<a class="code" href="class_o_t_crypto_config.html#a835596fd28dc8f14d62e6a141e6b4c11">OTCryptoConfig::SymmetricKeySize</a>()];
<a name="l01657"></a>01657     <a class="code" href="class_o_t_password.html">OTPassword</a>    * pNewKey = <span class="keyword">new</span> <a class="code" href="class_o_t_password.html">OTPassword</a>(static_cast&lt;void *&gt;(&amp;tmp_data[0]), <a class="code" href="class_o_t_crypto_config.html#a835596fd28dc8f14d62e6a141e6b4c11">OTCryptoConfig::SymmetricKeySize</a>());
<a name="l01658"></a>01658     <a class="code" href="_o_t_assert_8hpp.html#a033b133f48e61f2b227c52ad2be0c882">OT_ASSERT_MSG</a>(NULL != pNewKey, <span class="stringliteral">&quot;pNewKey = new OTPassword&quot;</span>);
<a name="l01659"></a>01659 
<a name="l01660"></a>01660     <span class="keywordflow">if</span> (NULL != tmp_data) { <span class="keyword">delete</span> tmp_data; tmp_data = NULL; } <span class="comment">// clean up tempdata</span>
<a name="l01661"></a>01661     <span class="keywordflow">return</span> pNewKey;
<a name="l01662"></a>01662 }
<a name="l01663"></a>01663 
<a name="l01664"></a>01664 
<a name="l01665"></a>01665 <span class="comment">// done</span>
<a name="l01666"></a>01666 
<a name="l01667"></a>01667 <span class="keywordtype">void</span> OTCrypto_OpenSSL::thread_setup()
<a name="l01668"></a>01668 {
<a name="l01669"></a>01669     OTCrypto_OpenSSL::s_arrayMutex = <span class="keyword">new</span> tthread::mutex[CRYPTO_num_locks()];
<a name="l01670"></a>01670 
<a name="l01671"></a>01671     <span class="comment">// ---------------------------------------</span>
<a name="l01672"></a>01672 
<a name="l01673"></a>01673     <span class="comment">// NOTE: OpenSSL supposedly has some default implementation for the thread_id,</span>
<a name="l01674"></a>01674     <span class="comment">// so we&#39;re going to NOT set that callback here, and see what happens.</span>
<a name="l01675"></a>01675     <span class="comment">//</span>
<a name="l01676"></a>01676     <span class="comment">// UPDATE: Looks like this works &quot;if and only if the local system provides errno&quot;</span>
<a name="l01677"></a>01677     <span class="comment">// and since I already have a supposedly-reliable ID from tinythread++, I&#39;m going</span>
<a name="l01678"></a>01678     <span class="comment">// to just use that one for now and see how it works.</span>
<a name="l01679"></a>01679     <span class="comment">//</span>
<a name="l01680"></a>01680 <span class="preprocessor">#if OPENSSL_VERSION_NUMBER-0 &lt; 0x10000000L</span>
<a name="l01681"></a>01681 <span class="preprocessor"></span>    CRYPTO_set_id_callback       (ot_openssl_thread_id);
<a name="l01682"></a>01682 <span class="preprocessor">#else</span>
<a name="l01683"></a>01683 <span class="preprocessor"></span>    int32_t nResult =
<a name="l01684"></a>01684     CRYPTO_THREADID_set_callback (ot_openssl_thread_id);
<a name="l01685"></a>01685     ++nResult; --nResult;
<a name="l01686"></a>01686 <span class="preprocessor">#endif</span>
<a name="l01687"></a>01687 <span class="preprocessor"></span>    <span class="comment">// ---------------------------------------</span>
<a name="l01688"></a>01688 
<a name="l01689"></a>01689     <span class="comment">// Here we set the locking callback function, which is the same for all versions</span>
<a name="l01690"></a>01690     <span class="comment">// of OpenSSL. (Unlike thread_id function above.)</span>
<a name="l01691"></a>01691     <span class="comment">//</span>
<a name="l01692"></a>01692     CRYPTO_set_locking_callback (ot_openssl_locking_callback);
<a name="l01693"></a>01693 
<a name="l01694"></a>01694 }
<a name="l01695"></a>01695 
<a name="l01696"></a>01696 <span class="comment">// done</span>
<a name="l01697"></a>01697 
<a name="l01698"></a>01698 <span class="keywordtype">void</span> OTCrypto_OpenSSL::thread_cleanup()
<a name="l01699"></a>01699 {
<a name="l01700"></a>01700     CRYPTO_set_locking_callback(NULL);
<a name="l01701"></a>01701 
<a name="l01702"></a>01702     <span class="keywordflow">if</span> (NULL != OTCrypto_OpenSSL::s_arrayMutex)
<a name="l01703"></a>01703     {
<a name="l01704"></a>01704         <span class="keyword">delete</span> [] OTCrypto_OpenSSL::s_arrayMutex;
<a name="l01705"></a>01705     }
<a name="l01706"></a>01706 
<a name="l01707"></a>01707     OTCrypto_OpenSSL::s_arrayMutex = NULL;
<a name="l01708"></a>01708 }
<a name="l01709"></a>01709 
<a name="l01710"></a>01710 
<a name="l01711"></a>01711 <span class="keywordtype">void</span> OTCrypto_OpenSSL::Init_Override()
<a name="l01712"></a>01712 {
<a name="l01713"></a>01713     <span class="keyword">const</span> <span class="keywordtype">char</span> * szFunc = <span class="stringliteral">&quot;OTCrypto_OpenSSL::Init_Override&quot;</span>;
<a name="l01714"></a>01714 
<a name="l01715"></a>01715     <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(1, <span class="stringliteral">&quot;%s: Setting up OpenSSL:  SSL_library_init, error strings and algorithms, and OpenSSL config...\n&quot;</span>,
<a name="l01716"></a>01716                    szFunc);
<a name="l01717"></a>01717 
<a name="l01718"></a>01718     <span class="comment">/*</span>
<a name="l01719"></a>01719 <span class="comment">     OPENSSL_VERSION_NUMBER is a numeric release version identifier:</span>
<a name="l01720"></a>01720 <span class="comment"></span>
<a name="l01721"></a>01721 <span class="comment">     MMNNFFPPS: major minor fix patch status</span>
<a name="l01722"></a>01722 <span class="comment">     The status nibble has one of the values 0 for development, 1 to e for betas 1 to 14, and f for release.</span>
<a name="l01723"></a>01723 <span class="comment"></span>
<a name="l01724"></a>01724 <span class="comment">     for example</span>
<a name="l01725"></a>01725 <span class="comment"></span>
<a name="l01726"></a>01726 <span class="comment">     0x000906000 == 0.9.6 dev</span>
<a name="l01727"></a>01727 <span class="comment">     0x000906023 == 0.9.6b beta 3</span>
<a name="l01728"></a>01728 <span class="comment">     0x00090605f == 0.9.6e release</span>
<a name="l01729"></a>01729 <span class="comment">     Versions prior to 0.9.3 have identifiers &lt; 0x0930. Versions between 0.9.3 and 0.9.5 had a version identifier with this interpretation:</span>
<a name="l01730"></a>01730 <span class="comment"></span>
<a name="l01731"></a>01731 <span class="comment">     MMNNFFRBB major minor fix final beta/patch</span>
<a name="l01732"></a>01732 <span class="comment">     for example</span>
<a name="l01733"></a>01733 <span class="comment"></span>
<a name="l01734"></a>01734 <span class="comment">     0x000904100 == 0.9.4 release</span>
<a name="l01735"></a>01735 <span class="comment">     0x000905000 == 0.9.5 dev</span>
<a name="l01736"></a>01736 <span class="comment">     Version 0.9.5a had an interim interpretation that is like the current one, except the patch level got the highest bit set, to keep continuity. The number was therefore 0x0090581f.</span>
<a name="l01737"></a>01737 <span class="comment"></span>
<a name="l01738"></a>01738 <span class="comment">     For backward compatibility, SSLEAY_VERSION_NUMBER is also defined.</span>
<a name="l01739"></a>01739 <span class="comment"></span>
<a name="l01740"></a>01740 <span class="comment">     */</span>
<a name="l01741"></a>01741 <span class="preprocessor">#if !defined(OPENSSL_VERSION_NUMBER) || OPENSSL_VERSION_NUMBER-0 &lt; 0x10000000L</span>
<a name="l01742"></a>01742 <span class="preprocessor"></span>    <a class="code" href="_o_t_assert_8hpp.html#aa86aeed4e57eecded96d5955b5cc23c5">OT_FAIL_MSG</a>(<span class="stringliteral">&quot;ASSERT: Must use OpenSSL version 1.0.0 or higher.\n&quot;</span>);
<a name="l01743"></a>01743 <span class="preprocessor">#endif</span>
<a name="l01744"></a>01744 <span class="preprocessor"></span>
<a name="l01745"></a>01745 
<a name="l01746"></a>01746     <span class="comment">// *********************************************************************************</span>
<a name="l01747"></a>01747     <span class="comment">/* Todo FYI:</span>
<a name="l01748"></a>01748 <span class="comment">     - One final comment about compiling applications linked to the OpenSSL library.</span>
<a name="l01749"></a>01749 <span class="comment">     - If you don&#39;t use the multithreaded DLL runtime library (/MD option) your</span>
<a name="l01750"></a>01750 <span class="comment">     - program will almost certainly crash because malloc gets confused -- the</span>
<a name="l01751"></a>01751 <span class="comment">     - OpenSSL DLLs are statically linked to one version, the application must</span>
<a name="l01752"></a>01752 <span class="comment">     - not use a different one.  You might be able to work around such problems</span>
<a name="l01753"></a>01753 <span class="comment">     - by adding CRYPTO_malloc_init() to your program before any calls to the</span>
<a name="l01754"></a>01754 <span class="comment">     - OpenSSL libraries: This tells the OpenSSL libraries to use the same</span>
<a name="l01755"></a>01755 <span class="comment">     - malloc(), free() and realloc() as the application.  However there are many</span>
<a name="l01756"></a>01756 <span class="comment">     - standard library functions used by OpenSSL that call malloc() internally</span>
<a name="l01757"></a>01757 <span class="comment">     - (e.g. fopen()), and OpenSSL cannot change these; so in general you cannot</span>
<a name="l01758"></a>01758 <span class="comment">     - rely on CRYPTO_malloc_init() solving your problem, and you should</span>
<a name="l01759"></a>01759 <span class="comment">     - consistently use the multithreaded library.</span>
<a name="l01760"></a>01760 <span class="comment">     */</span>
<a name="l01761"></a>01761 <span class="preprocessor">#ifdef _WIN32</span>
<a name="l01762"></a>01762 <span class="preprocessor"></span>    CRYPTO_malloc_init();                           <span class="comment">//      # -1</span>
<a name="l01763"></a>01763     <span class="comment">// FYI: this call appeared in the client version, not the server version.</span>
<a name="l01764"></a>01764     <span class="comment">// but now it will obviously appear in both, since they both will just call this (OT_Init.)</span>
<a name="l01765"></a>01765     <span class="comment">// Therefore if any weird errors crop in the server, just be aware. This call might have been</span>
<a name="l01766"></a>01766     <span class="comment">// specifically for DLLs or something.</span>
<a name="l01767"></a>01767 <span class="preprocessor">#endif</span>
<a name="l01768"></a>01768 <span class="preprocessor"></span>    <span class="comment">// *********************************************************************************</span>
<a name="l01769"></a>01769     <span class="comment">// SSL_library_init() must be called before any other action takes place.</span>
<a name="l01770"></a>01770     <span class="comment">// SSL_library_init() is not reentrant.</span>
<a name="l01771"></a>01771     <span class="comment">//</span>
<a name="l01772"></a>01772     SSL_library_init();                               <span class="comment">//     #0</span>
<a name="l01773"></a>01773 
<a name="l01774"></a>01774     <span class="comment">// *********************************************************************************</span>
<a name="l01775"></a>01775 
<a name="l01776"></a>01776     <span class="comment">/*</span>
<a name="l01777"></a>01777 <span class="comment">     We all owe a debt of gratitude to the OpenSSL team but fuck is their documentation</span>
<a name="l01778"></a>01778 <span class="comment">     difficult!! In this case I am trying to figure out whether I should call SSL_library_init()</span>
<a name="l01779"></a>01779 <span class="comment">     first, or SSL_load_error_strings() first.</span>
<a name="l01780"></a>01780 <span class="comment">     Docs say:</span>
<a name="l01781"></a>01781 <span class="comment"></span>
<a name="l01782"></a>01782 <span class="comment">     EXAMPLES   (http://www.openssl.org/docs/ssl/SSL_library_init.html#)</span>
<a name="l01783"></a>01783 <span class="comment"></span>
<a name="l01784"></a>01784 <span class="comment">     A typical TLS/SSL application will start with the library initialization,</span>
<a name="l01785"></a>01785 <span class="comment">     and provide readable error messages.</span>
<a name="l01786"></a>01786 <span class="comment"></span>
<a name="l01787"></a>01787 <span class="comment">     SSL_load_error_strings();               // readable error messages</span>
<a name="l01788"></a>01788 <span class="comment">     SSL_library_init();                      // initialize library</span>
<a name="l01789"></a>01789 <span class="comment">     -----------</span>
<a name="l01790"></a>01790 <span class="comment">     ===&gt; NOTICE it said &quot;START&quot; with library initialization, &quot;AND&quot; provide</span>
<a name="l01791"></a>01791 <span class="comment">     readable error messages... But then what order does it PUT them in?</span>
<a name="l01792"></a>01792 <span class="comment"></span>
<a name="l01793"></a>01793 <span class="comment">     SSL_load_error_strings();        // readable error messages</span>
<a name="l01794"></a>01794 <span class="comment">     SSL_library_init();              // initialize library</span>
<a name="l01795"></a>01795 <span class="comment">     -------</span>
<a name="l01796"></a>01796 <span class="comment"></span>
<a name="l01797"></a>01797 <span class="comment">     ON THE SAME PAGE, as if things weren&#39;t confusing enough, see THIS:</span>
<a name="l01798"></a>01798 <span class="comment"></span>
<a name="l01799"></a>01799 <span class="comment">     NOTES</span>
<a name="l01800"></a>01800 <span class="comment">     SSL_library_init() must be called before any other action takes place.</span>
<a name="l01801"></a>01801 <span class="comment">     SSL_library_init() is not reentrant.</span>
<a name="l01802"></a>01802 <span class="comment">     -------------------</span>
<a name="l01803"></a>01803 <span class="comment">     Then, on http://www.openssl.org/docs/crypto/ERR_load_crypto_strings.html#, in</span>
<a name="l01804"></a>01804 <span class="comment">     reference to SSL_load_error_strings and ERR_load_crypto_strings, it says:</span>
<a name="l01805"></a>01805 <span class="comment"></span>
<a name="l01806"></a>01806 <span class="comment">     One of these functions should be called BEFORE generating textual error messages.</span>
<a name="l01807"></a>01807 <span class="comment"></span>
<a name="l01808"></a>01808 <span class="comment">     ====&gt;  ?? Huh?? So which should I call first? Ben Laurie, if you are ever googling your</span>
<a name="l01809"></a>01809 <span class="comment">     own name on the Internet, please drop me a line and lemme know:</span>
<a name="l01810"></a>01810 <span class="comment">     fellowtraveler around rayservers cough net</span>
<a name="l01811"></a>01811 <span class="comment">     */</span>
<a name="l01812"></a>01812     <span class="comment">// ---------------------------------------------</span>
<a name="l01813"></a>01813 
<a name="l01814"></a>01814     <span class="comment">// NOTE: the below sections are numbered #1, #2, #3, etc so that they can be UNROLLED</span>
<a name="l01815"></a>01815     <span class="comment">// IN THE OPPOSITE ORDER when we get to OT_Cleanup().</span>
<a name="l01816"></a>01816 
<a name="l01817"></a>01817     <span class="comment">// *********************************************************************************</span>
<a name="l01818"></a>01818     <span class="comment">/*</span>
<a name="l01819"></a>01819 <span class="comment">     - ERR_load_crypto_strings() registers the error strings for all libcrypto functions.</span>
<a name="l01820"></a>01820 <span class="comment">     - SSL_load_error_strings() does the same, but also registers the libssl error strings.</span>
<a name="l01821"></a>01821 <span class="comment">     One of these functions should be called before generating textual error messages.</span>
<a name="l01822"></a>01822 <span class="comment">     - ERR_free_strings() frees all previously loaded error strings.</span>
<a name="l01823"></a>01823 <span class="comment">     */</span>
<a name="l01824"></a>01824 
<a name="l01825"></a>01825     SSL_load_error_strings();    <span class="comment">// DONE -- corresponds to ERR_free_strings in OT_Cleanup()   #1</span>
<a name="l01826"></a>01826 
<a name="l01827"></a>01827 <span class="comment">//  ERR_load_crypto_strings();   // Redundant -- SSL_load_error_strings does this already.</span>
<a name="l01828"></a>01828     <span class="comment">// *********************************************************************************</span>
<a name="l01829"></a>01829     <span class="comment">//</span>
<a name="l01830"></a>01830     <span class="comment">/*</span>
<a name="l01831"></a>01831 <span class="comment">     OpenSSL keeps an internal table of digest algorithms and ciphers.</span>
<a name="l01832"></a>01832 <span class="comment">     It uses this table to lookup ciphers via functions such as EVP_get_cipher_byname().</span>
<a name="l01833"></a>01833 <span class="comment"></span>
<a name="l01834"></a>01834 <span class="comment">     OpenSSL_add_all_algorithms() adds all algorithms to the table (digests and ciphers).</span>
<a name="l01835"></a>01835 <span class="comment"></span>
<a name="l01836"></a>01836 <span class="comment">     OpenSSL_add_all_digests() adds all digest algorithms to the table.</span>
<a name="l01837"></a>01837 <span class="comment">     OpenSSL_add_all_ciphers() adds all encryption algorithms to the table including password based encryption algorithms.</span>
<a name="l01838"></a>01838 <span class="comment">     // ---------------------</span>
<a name="l01839"></a>01839 <span class="comment">     TODO optimization:</span>
<a name="l01840"></a>01840 <span class="comment">     Calling OpenSSL_add_all_algorithms() links in all algorithms: as a result a statically linked executable</span>
<a name="l01841"></a>01841 <span class="comment">     can be quite large. If this is important it is possible to just add the required ciphers and digests.</span>
<a name="l01842"></a>01842 <span class="comment">     -- Thought: I will probably have different optimization options. Some things will be done no matter what, but</span>
<a name="l01843"></a>01843 <span class="comment">     other things will be compile-flags for optimizing specifically for speed, or size, or use of RAM, or CPU cycles,</span>
<a name="l01844"></a>01844 <span class="comment">     or security options, etc. This is one example of something where I would optimize it out, if possible, when trying</span>
<a name="l01845"></a>01845 <span class="comment">     to conserve RAM.</span>
<a name="l01846"></a>01846 <span class="comment">     Note: However it seems from the docs, that this table needs to be populated anyway due to problems in</span>
<a name="l01847"></a>01847 <span class="comment">     OpenSSL when it&#39;s not.</span>
<a name="l01848"></a>01848 <span class="comment">     */</span>
<a name="l01849"></a>01849 
<a name="l01850"></a>01850     <span class="comment">/*</span>
<a name="l01851"></a>01851 <span class="comment">    Try to activate OpenSSL debug memory procedure:</span>
<a name="l01852"></a>01852 <span class="comment">        OpenSSL_BIO pbio = BIO_new(BIO_s_file());</span>
<a name="l01853"></a>01853 <span class="comment">        BIO_set_fp(out,stdout,BIO_NOCLOSE);</span>
<a name="l01854"></a>01854 <span class="comment">        CRYPTO_malloc_debug_init();</span>
<a name="l01855"></a>01855 <span class="comment">        MemCheck_start();</span>
<a name="l01856"></a>01856 <span class="comment">        MemCheck_on();</span>
<a name="l01857"></a>01857 <span class="comment"></span>
<a name="l01858"></a>01858 <span class="comment">        .</span>
<a name="l01859"></a>01859 <span class="comment">        .</span>
<a name="l01860"></a>01860 <span class="comment">        .</span>
<a name="l01861"></a>01861 <span class="comment">        MemCheck_off()</span>
<a name="l01862"></a>01862 <span class="comment">        MemCheck_stop()</span>
<a name="l01863"></a>01863 <span class="comment">        CRYPTO_mem_leaks(pbio);</span>
<a name="l01864"></a>01864 <span class="comment"></span>
<a name="l01865"></a>01865 <span class="comment">     This will print out to stdout all memory that has been not deallocated.</span>
<a name="l01866"></a>01866 <span class="comment"></span>
<a name="l01867"></a>01867 <span class="comment">     Put starting part before everything ( even before OpenSSL_add_all_algorithms() call)</span>
<a name="l01868"></a>01868 <span class="comment">     this way you will see everything.</span>
<a name="l01869"></a>01869 <span class="comment"></span>
<a name="l01870"></a>01870 <span class="comment">     */</span>
<a name="l01871"></a>01871 
<a name="l01872"></a>01872 
<a name="l01873"></a>01873     OpenSSL_add_all_algorithms();   <span class="comment">// DONE -- corresponds to EVP_cleanup() in OT_Cleanup().    #2</span>
<a name="l01874"></a>01874 
<a name="l01875"></a>01875     <span class="comment">//</span>
<a name="l01876"></a>01876     <span class="comment">// *********************************************************************************</span>
<a name="l01877"></a>01877     <span class="comment">//</span>
<a name="l01878"></a>01878     <span class="comment">// RAND</span>
<a name="l01879"></a>01879     <span class="comment">//</span>
<a name="l01880"></a>01880     <span class="comment">/*</span>
<a name="l01881"></a>01881 <span class="comment">     RAND_bytes() automatically calls RAND_poll() if it has not already been done at least once.</span>
<a name="l01882"></a>01882 <span class="comment">     So you do not have to call it yourself. RAND_poll() feeds on what the operating system provides:</span>
<a name="l01883"></a>01883 <span class="comment">     on Linux, Solaris, FreeBSD and similar Unix-like systems, it will use /dev/urandom (or /dev/random</span>
<a name="l01884"></a>01884 <span class="comment">     if there is no /dev/urandom) to obtain a cryptographically secure initial seed; on Windows, it will</span>
<a name="l01885"></a>01885 <span class="comment">     call CryptGenRandom() for the same effect.</span>
<a name="l01886"></a>01886 <span class="comment"></span>
<a name="l01887"></a>01887 <span class="comment">     RAND_screen() is provided by OpenSSL only for backward compatibility with (much) older code which</span>
<a name="l01888"></a>01888 <span class="comment">     may call it (that was before OpenSSL used proper OS-based seed initialization).</span>
<a name="l01889"></a>01889 <span class="comment"></span>
<a name="l01890"></a>01890 <span class="comment">     So the &quot;normal&quot; way of dealing with RAND_poll() and RAND_screen() is to call neither. Just use RAND_bytes()</span>
<a name="l01891"></a>01891 <span class="comment">     and be happy.</span>
<a name="l01892"></a>01892 <span class="comment"></span>
<a name="l01893"></a>01893 <span class="comment">     RESPONSE: Thanks for the detailed answer. In regards to your suggestion to call neither, the problem</span>
<a name="l01894"></a>01894 <span class="comment">     under Windows is that RAND_poll can take some time and will block our UI. So we call it upon initialization,</span>
<a name="l01895"></a>01895 <span class="comment">     which works for us.</span>
<a name="l01896"></a>01896 <span class="comment">     */</span>
<a name="l01897"></a>01897     <span class="comment">// I guess Windows will seed the PRNG whenever someone tries to get</span>
<a name="l01898"></a>01898     <span class="comment">// some RAND_bytes() the first time...</span>
<a name="l01899"></a>01899     <span class="comment">//</span>
<a name="l01900"></a>01900     <span class="comment">//#ifdef _WIN32</span>
<a name="l01901"></a>01901     <span class="comment">// CORRESPONDS to RAND_cleanup in OT_Cleanup().</span>
<a name="l01902"></a>01902     <span class="comment">//      RAND_screen();</span>
<a name="l01903"></a>01903     <span class="comment">//#else</span>
<a name="l01904"></a>01904     <span class="comment">// note: optimization: might want to remove this, since supposedly it happens anyway</span>
<a name="l01905"></a>01905     <span class="comment">// when you use RAND_bytes. So the &quot;lazy evaluation&quot; rule would seem to imply, not bothering</span>
<a name="l01906"></a>01906     <span class="comment">// to slow things down NOW, since it&#39;s not really needed until THEN.</span>
<a name="l01907"></a>01907     <span class="comment">//</span>
<a name="l01908"></a>01908 
<a name="l01909"></a>01909 <span class="preprocessor">#if defined(USE_RAND_POLL)</span>
<a name="l01910"></a>01910 <span class="preprocessor"></span>
<a name="l01911"></a>01911     RAND_poll();                                <span class="comment">//                                   #3</span>
<a name="l01912"></a>01912 
<a name="l01913"></a>01913 <span class="preprocessor">#endif</span>
<a name="l01914"></a>01914 <span class="preprocessor"></span>
<a name="l01915"></a>01915     <span class="comment">// *********************************************************************************</span>
<a name="l01916"></a>01916 
<a name="l01917"></a>01917     <span class="comment">// OPENSSL_config()                                             #4</span>
<a name="l01918"></a>01918     <span class="comment">//</span>
<a name="l01919"></a>01919     <span class="comment">// OPENSSL_config configures OpenSSL using the standard openssl.cnf configuration file name</span>
<a name="l01920"></a>01920     <span class="comment">// using config_name. If config_name is NULL then the default name openssl_conf will be used.</span>
<a name="l01921"></a>01921     <span class="comment">// Any errors are ignored. Further calls to OPENSSL_config() will have no effect. The configuration</span>
<a name="l01922"></a>01922     <span class="comment">// file format is documented in the conf(5) manual page.</span>
<a name="l01923"></a>01923     <span class="comment">//</span>
<a name="l01924"></a>01924 
<a name="l01925"></a>01925     OPENSSL_config(NULL); <span class="comment">// const char *config_name = NULL: the default name openssl_conf will be used.</span>
<a name="l01926"></a>01926 
<a name="l01927"></a>01927     <span class="comment">//</span>
<a name="l01928"></a>01928     <span class="comment">// Corresponds to CONF_modules_free() in OT_Cleanup().</span>
<a name="l01929"></a>01929     <span class="comment">//</span>
<a name="l01930"></a>01930     <span class="comment">// *********************************************************************************</span>
<a name="l01931"></a>01931 
<a name="l01932"></a>01932 
<a name="l01933"></a>01933 
<a name="l01934"></a>01934     <span class="comment">// *********************************************************************************</span>
<a name="l01935"></a>01935     <span class="comment">//</span>
<a name="l01936"></a>01936     <span class="comment">// Let&#39;s see &#39;em!</span>
<a name="l01937"></a>01937     <span class="comment">//</span>
<a name="l01938"></a>01938     ERR_print_errors_fp(stderr);
<a name="l01939"></a>01939     <span class="comment">//</span>
<a name="l01940"></a>01940     <span class="comment">// *********************************************************************************</span>
<a name="l01941"></a>01941     <span class="comment">//</span>
<a name="l01942"></a>01942     <span class="comment">//</span>
<a name="l01943"></a>01943     <span class="comment">// THREADS</span>
<a name="l01944"></a>01944     <span class="comment">//</span>
<a name="l01945"></a>01945     <span class="comment">//</span>
<a name="l01946"></a>01946 <span class="comment">// -------------------------------------------------</span>
<a name="l01947"></a>01947 <span class="preprocessor">#if defined(OPENSSL_THREADS)</span>
<a name="l01948"></a>01948 <span class="preprocessor"></span>    <span class="comment">// thread support enabled</span>
<a name="l01949"></a>01949 
<a name="l01950"></a>01950     <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(1, <span class="stringliteral">&quot;%s: OpenSSL WAS compiled with thread support, FYI. Setting up mutexes...\n&quot;</span>,
<a name="l01951"></a>01951                    szFunc);
<a name="l01952"></a>01952 
<a name="l01953"></a>01953     this-&gt;thread_setup();
<a name="l01954"></a>01954 
<a name="l01955"></a>01955 <span class="preprocessor">#else</span>
<a name="l01956"></a>01956 <span class="preprocessor"></span>    <span class="comment">// no thread support</span>
<a name="l01957"></a>01957 
<a name="l01958"></a>01958     <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;%s: WARNING: OpenSSL was NOT compiled with thread support. &quot;</span>
<a name="l01959"></a>01959                  <span class="stringliteral">&quot;(Also: Master Key will not expire.)\n&quot;</span>, szFunc);
<a name="l01960"></a>01960 
<a name="l01961"></a>01961 <span class="preprocessor">#endif</span>
<a name="l01962"></a>01962 <span class="preprocessor"></span><span class="comment">// -------------------------------------------------</span>
<a name="l01963"></a>01963 
<a name="l01964"></a>01964 
<a name="l01965"></a>01965 
<a name="l01966"></a>01966 }
<a name="l01967"></a>01967 
<a name="l01968"></a>01968 
<a name="l01969"></a>01969 <span class="comment">// RAND_status() and RAND_event() return 1 if the PRNG has been seeded with enough data, 0 otherwise.</span>
<a name="l01970"></a>01970 
<a name="l01971"></a>01971 <span class="comment">/*</span>
<a name="l01972"></a>01972 <span class="comment"> 13. I think I&#39;ve detected a memory leak, is this a bug?</span>
<a name="l01973"></a>01973 <span class="comment"></span>
<a name="l01974"></a>01974 <span class="comment"> In most cases the cause of an apparent memory leak is an OpenSSL internal</span>
<a name="l01975"></a>01975 <span class="comment"> table that is allocated when an application starts up. Since such tables do</span>
<a name="l01976"></a>01976 <span class="comment"> not grow in size over time they are harmless.</span>
<a name="l01977"></a>01977 <span class="comment"></span>
<a name="l01978"></a>01978 <span class="comment"> These internal tables can be freed up when an application closes using</span>
<a name="l01979"></a>01979 <span class="comment"> various functions. Currently these include following:</span>
<a name="l01980"></a>01980 <span class="comment"></span>
<a name="l01981"></a>01981 <span class="comment"> Thread-local cleanup functions:</span>
<a name="l01982"></a>01982 <span class="comment"></span>
<a name="l01983"></a>01983 <span class="comment"> ERR_remove_state()</span>
<a name="l01984"></a>01984 <span class="comment"></span>
<a name="l01985"></a>01985 <span class="comment"> Application-global cleanup functions that are aware of usage (and therefore thread-safe):</span>
<a name="l01986"></a>01986 <span class="comment"></span>
<a name="l01987"></a>01987 <span class="comment"> ENGINE_cleanup() and CONF_modules_unload()</span>
<a name="l01988"></a>01988 <span class="comment"></span>
<a name="l01989"></a>01989 <span class="comment"> &quot;Brutal&quot; (thread-unsafe) Application-global cleanup functions:</span>
<a name="l01990"></a>01990 <span class="comment"></span>
<a name="l01991"></a>01991 <span class="comment"> ERR_free_strings(), EVP_cleanup() and CRYPTO_cleanup_all_ex_data().</span>
<a name="l01992"></a>01992 <span class="comment"> */</span>
<a name="l01993"></a>01993 
<a name="l01994"></a>01994 
<a name="l01995"></a>01995 <span class="keywordtype">void</span> OTCrypto_OpenSSL::Cleanup_Override()
<a name="l01996"></a>01996 {
<a name="l01997"></a>01997     <span class="keyword">const</span> <span class="keywordtype">char</span> * szFunc = <span class="stringliteral">&quot;OTCrypto_OpenSSL::Cleanup_Override&quot;</span>;
<a name="l01998"></a>01998 
<a name="l01999"></a>01999     <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(4, <span class="stringliteral">&quot;%s: Cleaning up OpenSSL...\n&quot;</span>, szFunc);
<a name="l02000"></a>02000 
<a name="l02001"></a>02001 <span class="comment">// In the future if we start using ENGINEs, then do the cleanup here:</span>
<a name="l02002"></a>02002 <span class="comment">//#ifndef OPENSSL_NO_ENGINE</span>
<a name="l02003"></a>02003 <span class="comment">//  void ENGINE_cleanup(void);</span>
<a name="l02004"></a>02004 <span class="comment">//#endif</span>
<a name="l02005"></a>02005 <span class="comment">//</span>
<a name="l02006"></a>02006 
<a name="l02007"></a>02007 
<a name="l02008"></a>02008 <span class="preprocessor">#if defined(OPENSSL_THREADS)</span>
<a name="l02009"></a>02009 <span class="preprocessor"></span>    <span class="comment">// thread support enabled</span>
<a name="l02010"></a>02010 
<a name="l02011"></a>02011     this-&gt;thread_cleanup();
<a name="l02012"></a>02012 
<a name="l02013"></a>02013 <span class="preprocessor">#else</span>
<a name="l02014"></a>02014 <span class="preprocessor"></span>    <span class="comment">// no thread support</span>
<a name="l02015"></a>02015 
<a name="l02016"></a>02016 
<a name="l02017"></a>02017 <span class="preprocessor">#endif</span>
<a name="l02018"></a>02018 <span class="preprocessor"></span>
<a name="l02019"></a>02019     <span class="comment">/*</span>
<a name="l02020"></a>02020 <span class="comment">     CONF_modules_free()</span>
<a name="l02021"></a>02021 <span class="comment"></span>
<a name="l02022"></a>02022 <span class="comment">     OpenSSL configuration cleanup function. CONF_modules_free() closes down and frees</span>
<a name="l02023"></a>02023 <span class="comment">     up all memory allocated by all configuration modules.</span>
<a name="l02024"></a>02024 <span class="comment">     Normally applications will only call CONF_modules_free() at application [shutdown]</span>
<a name="l02025"></a>02025 <span class="comment">     to tidy up any configuration performed.</span>
<a name="l02026"></a>02026 <span class="comment">     */</span>
<a name="l02027"></a>02027     CONF_modules_free(); <span class="comment">// CORRESPONDS to: OPENSSL_config() in OT_Init().   #4</span>
<a name="l02028"></a>02028 
<a name="l02029"></a>02029     RAND_cleanup();      <span class="comment">// Corresponds to RAND_screen / RAND_poll in OT_Init()  #3</span>
<a name="l02030"></a>02030 
<a name="l02031"></a>02031     EVP_cleanup();       <span class="comment">// DONE (brutal) -- corresponds to OpenSSL_add_all_algorithms in OT_Init(). #2</span>
<a name="l02032"></a>02032     <span class="comment">// -------------------------------------------------</span>
<a name="l02033"></a>02033 
<a name="l02034"></a>02034     CRYPTO_cleanup_all_ex_data(); <span class="comment">// (brutal)</span>
<a name="l02035"></a>02035 <span class="comment">//  CRYPTO_mem_leaks(bio_err);</span>
<a name="l02036"></a>02036 
<a name="l02037"></a>02037     <span class="comment">// -------------------------------------------------</span>
<a name="l02038"></a>02038 
<a name="l02039"></a>02039     ERR_free_strings(); <span class="comment">// DONE (brutal) -- corresponds to SSL_load_error_strings in OT_Init().  #1</span>
<a name="l02040"></a>02040 
<a name="l02041"></a>02041     <span class="comment">// ----------------------------------</span>
<a name="l02042"></a>02042     <span class="comment">// ERR_remove_state - free a thread&#39;s error queue &quot;prevents memory leaks...&quot;</span>
<a name="l02043"></a>02043     <span class="comment">//</span>
<a name="l02044"></a>02044     <span class="comment">// ERR_remove_state() frees the error queue associated with thread pid. If pid == 0,</span>
<a name="l02045"></a>02045     <span class="comment">// the current thread will have its error queue removed.</span>
<a name="l02046"></a>02046     <span class="comment">//</span>
<a name="l02047"></a>02047     <span class="comment">// Since error queue data structures are allocated automatically for new threads,</span>
<a name="l02048"></a>02048     <span class="comment">// they must be freed when threads are terminated in order to avoid memory leaks.</span>
<a name="l02049"></a>02049     <span class="comment">//</span>
<a name="l02050"></a>02050 <span class="comment">//  ERR_remove_state(0);</span>
<a name="l02051"></a>02051     ERR_remove_thread_state(NULL);
<a name="l02052"></a>02052 
<a name="l02053"></a>02053     <span class="comment">/*</span>
<a name="l02054"></a>02054 <span class="comment">    +     Note that ERR_remove_state() is now deprecated, because it is tied</span>
<a name="l02055"></a>02055 <span class="comment">    +     to the assumption that thread IDs are numeric.  ERR_remove_state(0)</span>
<a name="l02056"></a>02056 <span class="comment">    +     to free the current thread&#39;s error state should be replaced by</span>
<a name="l02057"></a>02057 <span class="comment">    +     ERR_remove_thread_state(NULL).</span>
<a name="l02058"></a>02058 <span class="comment">    */</span>
<a name="l02059"></a>02059 
<a name="l02060"></a>02060 
<a name="l02061"></a>02061     <span class="comment">// NOTE: You must call SSL_shutdown() before you call SSL_free().</span>
<a name="l02062"></a>02062     <span class="comment">// Update: these are for SSL sockets, they must be called per socket.</span>
<a name="l02063"></a>02063     <span class="comment">// (IOW: Not needed here for app cleanup.)</span>
<a name="l02064"></a>02064 }
<a name="l02065"></a>02065 
<a name="l02066"></a>02066 
<a name="l02067"></a>02067 <span class="comment">// #define OTCryptoConfig::SymmetricBufferSize()   default: 4096</span>
<a name="l02068"></a>02068 
<a name="l02069"></a>02069 <span class="keywordtype">bool</span> OTCrypto_OpenSSL::Encrypt(<span class="keyword">const</span> <a class="code" href="class_o_t_password.html">OTPassword</a> &amp; theRawSymmetricKey, <span class="comment">// The symmetric key, in clear form.</span>
<a name="l02070"></a>02070                                <span class="comment">// -------------------------------</span>
<a name="l02071"></a>02071                                <span class="keyword">const</span> <span class="keywordtype">char</span>       * szInput,            <span class="comment">// This is the Plaintext.</span>
<a name="l02072"></a>02072                                <span class="keyword">const</span> uint32_t     lInputLength,
<a name="l02073"></a>02073                                <span class="comment">// -------------------------------</span>
<a name="l02074"></a>02074                                <span class="keyword">const</span> <a class="code" href="class_o_t_payload.html">OTPayload</a>  &amp; theIV,              <span class="comment">// (We assume this IV is already generated and passed in.)</span>
<a name="l02075"></a>02075                                <span class="comment">// -------------------------------</span>
<a name="l02076"></a>02076                                      <a class="code" href="class_o_t_payload.html">OTPayload</a>  &amp; theEncryptedOutput) <span class="keyword">const</span> <span class="comment">// OUTPUT. (Ciphertext.)</span>
<a name="l02077"></a>02077 {
<a name="l02078"></a>02078     <span class="keyword">const</span> <span class="keywordtype">char</span> * szFunc = <span class="stringliteral">&quot;OTCrypto_OpenSSL::Encrypt&quot;</span>;
<a name="l02079"></a>02079     <span class="comment">// -----------------------------------------------</span>
<a name="l02080"></a>02080     <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(<a class="code" href="class_o_t_crypto_config.html#ae6a1a4137bd87e84c342bb4e0149ca56">OTCryptoConfig::SymmetricIvSize</a>()  == theIV.GetSize());
<a name="l02081"></a>02081     <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(<a class="code" href="class_o_t_crypto_config.html#a835596fd28dc8f14d62e6a141e6b4c11">OTCryptoConfig::SymmetricKeySize</a>() == theRawSymmetricKey.getMemorySize());
<a name="l02082"></a>02082     <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != szInput);
<a name="l02083"></a>02083     <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(lInputLength &gt; 0);
<a name="l02084"></a>02084     <span class="comment">// -----------------------------------------------</span>
<a name="l02085"></a>02085     EVP_CIPHER_CTX  ctx;
<a name="l02086"></a>02086 
<a name="l02087"></a>02087     std::vector&lt;uint8_t&gt; vBuffer(<a class="code" href="class_o_t_crypto_config.html#a6fc89263c5ae6042f7cc511e820ef369">OTCryptoConfig::SymmetricBufferSize</a>()); <span class="comment">// 4096</span>
<a name="l02088"></a>02088     std::vector&lt;uint8_t&gt; vBuffer_out(<a class="code" href="class_o_t_crypto_config.html#a6fc89263c5ae6042f7cc511e820ef369">OTCryptoConfig::SymmetricBufferSize</a>() + EVP_MAX_IV_LENGTH);
<a name="l02089"></a>02089 
<a name="l02090"></a>02090     uint32_t        len     = 0;
<a name="l02091"></a>02091     int32_t             len_out = 0;
<a name="l02092"></a>02092     <span class="comment">// -----------------------------------------------</span>
<a name="l02093"></a>02093     memset(&amp;vBuffer.at(0),     0, <a class="code" href="class_o_t_crypto_config.html#a6fc89263c5ae6042f7cc511e820ef369">OTCryptoConfig::SymmetricBufferSize</a>() );
<a name="l02094"></a>02094     memset(&amp;vBuffer_out.at(0), 0, <a class="code" href="class_o_t_crypto_config.html#a6fc89263c5ae6042f7cc511e820ef369">OTCryptoConfig::SymmetricBufferSize</a>() + EVP_MAX_IV_LENGTH);
<a name="l02095"></a>02095     <span class="comment">// -----------------------------------------------</span>
<a name="l02096"></a>02096     <span class="comment">//</span>
<a name="l02097"></a>02097     <span class="comment">// This is where the envelope final contents will be placed.</span>
<a name="l02098"></a>02098     <span class="comment">// including the size of the IV, the IV itself, and the ciphertext.</span>
<a name="l02099"></a>02099     <span class="comment">//</span>
<a name="l02100"></a>02100     theEncryptedOutput.Release();
<a name="l02101"></a>02101     <span class="comment">// -----------------------------------------------</span>
<a name="l02102"></a>02102     <span class="keyword">class </span>_OTEnv_Enc_stat
<a name="l02103"></a>02103     {
<a name="l02104"></a>02104     <span class="keyword">private</span>:
<a name="l02105"></a>02105         <span class="keyword">const</span> <span class="keywordtype">char</span>      *  m_szFunc;
<a name="l02106"></a>02106         EVP_CIPHER_CTX  &amp;  m_ctx;
<a name="l02107"></a>02107     <span class="keyword">public</span>:
<a name="l02108"></a>02108         _OTEnv_Enc_stat(<span class="keyword">const</span> <span class="keywordtype">char</span> * param_szFunc,
<a name="l02109"></a>02109                         EVP_CIPHER_CTX &amp; param_ctx) :
<a name="l02110"></a>02110             m_szFunc(param_szFunc),
<a name="l02111"></a>02111             m_ctx(param_ctx)
<a name="l02112"></a>02112         {
<a name="l02113"></a>02113             <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != param_szFunc);
<a name="l02114"></a>02114 
<a name="l02115"></a>02115             EVP_CIPHER_CTX_init(&amp;m_ctx);
<a name="l02116"></a>02116         }
<a name="l02117"></a>02117         ~_OTEnv_Enc_stat()
<a name="l02118"></a>02118         {
<a name="l02119"></a>02119             <span class="comment">// EVP_CIPHER_CTX_cleanup returns 1 for success and 0 for failure.</span>
<a name="l02120"></a>02120             <span class="comment">//</span>
<a name="l02121"></a>02121             <span class="keywordflow">if</span> (0 == EVP_CIPHER_CTX_cleanup(&amp;m_ctx))
<a name="l02122"></a>02122                 <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;%s: Failure in EVP_CIPHER_CTX_cleanup. (It returned 0.)\n&quot;</span>, m_szFunc);
<a name="l02123"></a>02123 
<a name="l02124"></a>02124             m_szFunc = NULL; <span class="comment">// keep the static analyzer happy</span>
<a name="l02125"></a>02125         }
<a name="l02126"></a>02126     };
<a name="l02127"></a>02127     _OTEnv_Enc_stat  theInstance(szFunc, ctx);
<a name="l02128"></a>02128     <span class="comment">// -----------------------------------------------</span>
<a name="l02129"></a>02129 
<a name="l02130"></a>02130     <span class="keyword">const</span> EVP_CIPHER * cipher_type = EVP_aes_128_cbc();   <span class="comment">// todo hardcoding.</span>
<a name="l02131"></a>02131 
<a name="l02132"></a>02132     <span class="comment">// -----------------------------------------------</span>
<a name="l02133"></a>02133     <span class="keywordflow">if</span> (!EVP_EncryptInit(&amp;ctx,
<a name="l02134"></a>02134                          cipher_type,
<a name="l02135"></a>02135                          const_cast&lt;uint8_t *&gt;(theRawSymmetricKey.getMemory_uint8()),
<a name="l02136"></a>02136                          static_cast&lt;uint8_t *&gt;(const_cast&lt;void *&gt;(theIV.GetPayloadPointer()))))
<a name="l02137"></a>02137     {
<a name="l02138"></a>02138         <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;%s: EVP_EncryptInit: failed.\n&quot;</span>, szFunc);
<a name="l02139"></a>02139         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02140"></a>02140     }
<a name="l02141"></a>02141     <span class="comment">// -----------------------------------------------</span>
<a name="l02142"></a>02142     <span class="comment">//</span>
<a name="l02143"></a>02143     <span class="comment">// Now we process the input and write the encrypted data to</span>
<a name="l02144"></a>02144     <span class="comment">// the output.</span>
<a name="l02145"></a>02145     <span class="comment">//</span>
<a name="l02146"></a>02146     uint32_t  lRemainingLength = lInputLength;
<a name="l02147"></a>02147     uint32_t  lCurrentIndex    = 0;
<a name="l02148"></a>02148 
<a name="l02149"></a>02149     <span class="keywordflow">while</span> (lRemainingLength &gt; 0)
<a name="l02150"></a>02150     {
<a name="l02151"></a>02151         <span class="comment">// If the remaining length is less than the default buffer size, then set len to remaining length.</span>
<a name="l02152"></a>02152         <span class="comment">// else if remaining length is larger than or equal to default buffer size, then use the default buffer size.</span>
<a name="l02153"></a>02153         <span class="comment">// Resulting value stored in len.</span>
<a name="l02154"></a>02154         <span class="comment">//</span>
<a name="l02155"></a>02155         len = <span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>((lRemainingLength &lt; <a class="code" href="class_o_t_crypto_config.html#a6fc89263c5ae6042f7cc511e820ef369">OTCryptoConfig::SymmetricBufferSize</a>()) ? lRemainingLength : <a class="code" href="class_o_t_crypto_config.html#a6fc89263c5ae6042f7cc511e820ef369">OTCryptoConfig::SymmetricBufferSize</a>()); <span class="comment">// 4096</span>
<a name="l02156"></a>02156 
<a name="l02157"></a>02157         <span class="keywordflow">if</span> (!EVP_EncryptUpdate(&amp;ctx,
<a name="l02158"></a>02158                                &amp;vBuffer_out.at(0),
<a name="l02159"></a>02159                                &amp;len_out,
<a name="l02160"></a>02160                                <span class="keyword">const_cast&lt;</span>uint8_t *<span class="keyword">&gt;</span>(<span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span>uint8_t *<span class="keyword">&gt;</span>(&amp;(szInput [ lCurrentIndex ]))),
<a name="l02161"></a>02161                                len))
<a name="l02162"></a>02162         {
<a name="l02163"></a>02163             <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;%s: EVP_EncryptUpdate: failed.\n&quot;</span>, szFunc);
<a name="l02164"></a>02164             <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02165"></a>02165         }
<a name="l02166"></a>02166         lRemainingLength -= len;
<a name="l02167"></a>02167         lCurrentIndex    += len;
<a name="l02168"></a>02168 
<a name="l02169"></a>02169         <span class="keywordflow">if</span> (len_out &gt; 0)
<a name="l02170"></a>02170             theEncryptedOutput.Concatenate(reinterpret_cast&lt;void *&gt;(&amp;vBuffer_out.at(0)),
<a name="l02171"></a>02171                                            static_cast&lt;uint32_t&gt;(len_out));
<a name="l02172"></a>02172     }
<a name="l02173"></a>02173     <span class="comment">// -----------------------------------------------</span>
<a name="l02174"></a>02174     <span class="comment">//</span>
<a name="l02175"></a>02175     <span class="keywordflow">if</span> (!EVP_EncryptFinal(&amp;ctx, &amp;vBuffer_out.at(0), &amp;len_out))
<a name="l02176"></a>02176     {
<a name="l02177"></a>02177         <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;%s: EVP_EncryptFinal: failed.\n&quot;</span>, szFunc);
<a name="l02178"></a>02178         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02179"></a>02179     }
<a name="l02180"></a>02180     <span class="comment">// -----------------------------------------------</span>
<a name="l02181"></a>02181     <span class="comment">// This is the &quot;final&quot; piece that is added from EncryptFinal just above.</span>
<a name="l02182"></a>02182     <span class="comment">//</span>
<a name="l02183"></a>02183     <span class="keywordflow">if</span> (len_out &gt; 0)
<a name="l02184"></a>02184         theEncryptedOutput.Concatenate(reinterpret_cast&lt;void *&gt;(&amp;vBuffer_out.at(0)),
<a name="l02185"></a>02185                                        static_cast&lt;uint32_t&gt;(len_out));
<a name="l02186"></a>02186     <span class="comment">// -----------------------------------------------</span>
<a name="l02187"></a>02187     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l02188"></a>02188 }
<a name="l02189"></a>02189 
<a name="l02190"></a>02190 
<a name="l02191"></a>02191 <span class="keywordtype">bool</span> OTCrypto_OpenSSL::Decrypt(<span class="keyword">const</span> <a class="code" href="class_o_t_password.html">OTPassword</a> &amp; theRawSymmetricKey, <span class="comment">// The symmetric key, in clear form.</span>
<a name="l02192"></a>02192                                <span class="comment">// -------------------------------</span>
<a name="l02193"></a>02193                                <span class="keyword">const</span> <span class="keywordtype">char</span>      *  szInput,            <span class="comment">// This is the Ciphertext.</span>
<a name="l02194"></a>02194                                <span class="keyword">const</span> uint32_t     lInputLength,
<a name="l02195"></a>02195                                <span class="comment">// -------------------------------</span>
<a name="l02196"></a>02196                                <span class="keyword">const</span> <a class="code" href="class_o_t_payload.html">OTPayload</a> &amp;  theIV,              <span class="comment">// (We assume this IV is already generated and passed in.)</span>
<a name="l02197"></a>02197                                <span class="comment">// -------------------------------</span>
<a name="l02198"></a>02198                                <a class="code" href="class_o_t_crypto___decrypt___output.html">OTCrypto_Decrypt_Output</a> theDecryptedOutput) <span class="keyword">const</span> <span class="comment">// OUTPUT. (Recovered plaintext.) You can pass OTPassword&amp; OR OTPayload&amp; here (either will work.)</span>
<a name="l02199"></a>02199 {
<a name="l02200"></a>02200     <span class="keyword">const</span> <span class="keywordtype">char</span> * szFunc = <span class="stringliteral">&quot;OTCrypto_OpenSSL::Decrypt&quot;</span>;
<a name="l02201"></a>02201     <span class="comment">// -----------------------------------------------</span>
<a name="l02202"></a>02202     <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(<a class="code" href="class_o_t_crypto_config.html#ae6a1a4137bd87e84c342bb4e0149ca56">OTCryptoConfig::SymmetricIvSize</a>()   == theIV.GetSize());
<a name="l02203"></a>02203     <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(<a class="code" href="class_o_t_crypto_config.html#a835596fd28dc8f14d62e6a141e6b4c11">OTCryptoConfig::SymmetricKeySize</a>()  == theRawSymmetricKey.getMemorySize());
<a name="l02204"></a>02204     <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != szInput);
<a name="l02205"></a>02205     <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(lInputLength &gt; 0);
<a name="l02206"></a>02206     <span class="comment">// -----------------------------------------------</span>
<a name="l02207"></a>02207     EVP_CIPHER_CTX  ctx;
<a name="l02208"></a>02208 
<a name="l02209"></a>02209     std::vector&lt;uint8_t&gt; vBuffer(<a class="code" href="class_o_t_crypto_config.html#a6fc89263c5ae6042f7cc511e820ef369">OTCryptoConfig::SymmetricBufferSize</a>()); <span class="comment">// 4096</span>
<a name="l02210"></a>02210     std::vector&lt;uint8_t&gt; vBuffer_out(<a class="code" href="class_o_t_crypto_config.html#a6fc89263c5ae6042f7cc511e820ef369">OTCryptoConfig::SymmetricBufferSize</a>() + EVP_MAX_IV_LENGTH);
<a name="l02211"></a>02211 
<a name="l02212"></a>02212     uint32_t        len     = 0;
<a name="l02213"></a>02213     int32_t             len_out = 0;
<a name="l02214"></a>02214     <span class="comment">// -----------------------------------------------</span>
<a name="l02215"></a>02215     memset(&amp;vBuffer.at(0),     0, <a class="code" href="class_o_t_crypto_config.html#a6fc89263c5ae6042f7cc511e820ef369">OTCryptoConfig::SymmetricBufferSize</a>() );
<a name="l02216"></a>02216     memset(&amp;vBuffer_out.at(0), 0, <a class="code" href="class_o_t_crypto_config.html#a6fc89263c5ae6042f7cc511e820ef369">OTCryptoConfig::SymmetricBufferSize</a>() + EVP_MAX_IV_LENGTH);
<a name="l02217"></a>02217     <span class="comment">// -----------------------------------------------</span>
<a name="l02218"></a>02218     <span class="comment">//</span>
<a name="l02219"></a>02219     <span class="comment">// This is where the plaintext results will be placed.</span>
<a name="l02220"></a>02220     <span class="comment">//</span>
<a name="l02221"></a>02221     theDecryptedOutput.Release();
<a name="l02222"></a>02222 
<a name="l02223"></a>02223     <span class="comment">// -----------------------------------------------</span>
<a name="l02224"></a>02224     <span class="keyword">class </span>_OTEnv_Dec_stat
<a name="l02225"></a>02225     {
<a name="l02226"></a>02226     <span class="keyword">private</span>:
<a name="l02227"></a>02227         <span class="keyword">const</span> <span class="keywordtype">char</span>      *  m_szFunc;
<a name="l02228"></a>02228         EVP_CIPHER_CTX  &amp;  m_ctx;
<a name="l02229"></a>02229     <span class="keyword">public</span>:
<a name="l02230"></a>02230         _OTEnv_Dec_stat(<span class="keyword">const</span> <span class="keywordtype">char</span> * param_szFunc,
<a name="l02231"></a>02231                         EVP_CIPHER_CTX &amp; param_ctx) :
<a name="l02232"></a>02232             m_szFunc(param_szFunc),
<a name="l02233"></a>02233             m_ctx(param_ctx)
<a name="l02234"></a>02234         {
<a name="l02235"></a>02235             <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != param_szFunc);
<a name="l02236"></a>02236 
<a name="l02237"></a>02237             EVP_CIPHER_CTX_init(&amp;m_ctx);
<a name="l02238"></a>02238         }
<a name="l02239"></a>02239         ~_OTEnv_Dec_stat()
<a name="l02240"></a>02240         {
<a name="l02241"></a>02241             <span class="comment">// EVP_CIPHER_CTX_cleanup returns 1 for success and 0 for failure.</span>
<a name="l02242"></a>02242             <span class="comment">//</span>
<a name="l02243"></a>02243             <span class="keywordflow">if</span> (0 == EVP_CIPHER_CTX_cleanup(&amp;m_ctx))
<a name="l02244"></a>02244                 <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;%s: Failure in EVP_CIPHER_CTX_cleanup. (It returned 0.)\n&quot;</span>, m_szFunc);
<a name="l02245"></a>02245             m_szFunc = NULL; <span class="comment">// to keep the static analyzer happy.</span>
<a name="l02246"></a>02246         }
<a name="l02247"></a>02247     };
<a name="l02248"></a>02248     _OTEnv_Dec_stat  theInstance(szFunc, ctx);
<a name="l02249"></a>02249     <span class="comment">// -----------------------------------------------</span>
<a name="l02250"></a>02250 
<a name="l02251"></a>02251     <span class="keyword">const</span> EVP_CIPHER * cipher_type = EVP_aes_128_cbc();
<a name="l02252"></a>02252 
<a name="l02253"></a>02253     <span class="comment">// -----------------------------------------------</span>
<a name="l02254"></a>02254     <span class="comment">//</span>
<a name="l02255"></a>02255     <span class="keywordflow">if</span> (!EVP_DecryptInit(&amp;ctx,
<a name="l02256"></a>02256                          cipher_type,
<a name="l02257"></a>02257                          const_cast&lt;uint8_t *&gt;(theRawSymmetricKey.getMemory_uint8()),
<a name="l02258"></a>02258                          static_cast&lt;uint8_t *&gt;(const_cast&lt;void *&gt;(theIV.GetPayloadPointer()))))
<a name="l02259"></a>02259     {
<a name="l02260"></a>02260         <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;%s: EVP_DecryptInit: failed.\n&quot;</span>, szFunc);
<a name="l02261"></a>02261         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02262"></a>02262     }
<a name="l02263"></a>02263     <span class="comment">// -----------------------------------------------</span>
<a name="l02264"></a>02264     <span class="comment">//</span>
<a name="l02265"></a>02265     <span class="comment">// Now we process the input and write the decrypted data to</span>
<a name="l02266"></a>02266     <span class="comment">// the output.</span>
<a name="l02267"></a>02267     <span class="comment">//</span>
<a name="l02268"></a>02268     uint32_t  lRemainingLength = lInputLength;
<a name="l02269"></a>02269     uint32_t  lCurrentIndex    = 0;
<a name="l02270"></a>02270 
<a name="l02271"></a>02271     <span class="keywordflow">while</span> (lRemainingLength &gt; 0)
<a name="l02272"></a>02272     {
<a name="l02273"></a>02273         <span class="comment">// If the remaining length is less than the default buffer size, then set len to remaining length.</span>
<a name="l02274"></a>02274         <span class="comment">// else if remaining length is larger than or equal to default buffer size, then use the default buffer size.</span>
<a name="l02275"></a>02275         <span class="comment">// Resulting value stored in len.</span>
<a name="l02276"></a>02276         <span class="comment">//</span>
<a name="l02277"></a>02277         len = (lRemainingLength &lt; <a class="code" href="class_o_t_crypto_config.html#a6fc89263c5ae6042f7cc511e820ef369">OTCryptoConfig::SymmetricBufferSize</a>()) ? lRemainingLength : <a class="code" href="class_o_t_crypto_config.html#a6fc89263c5ae6042f7cc511e820ef369">OTCryptoConfig::SymmetricBufferSize</a>(); <span class="comment">// 4096</span>
<a name="l02278"></a>02278         lRemainingLength -= len;
<a name="l02279"></a>02279 
<a name="l02280"></a>02280         <span class="keywordflow">if</span> (!EVP_DecryptUpdate(&amp;ctx,
<a name="l02281"></a>02281                                &amp;vBuffer_out.at(0),
<a name="l02282"></a>02282                                &amp;len_out,
<a name="l02283"></a>02283                                <span class="keyword">const_cast&lt;</span>uint8_t *<span class="keyword">&gt;</span>(<span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span>uint8_t *<span class="keyword">&gt;</span>(&amp;(szInput [ lCurrentIndex ]))),
<a name="l02284"></a>02284                                len))
<a name="l02285"></a>02285         {
<a name="l02286"></a>02286             <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;%s: EVP_DecryptUpdate: failed.\n&quot;</span>, szFunc);
<a name="l02287"></a>02287             <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02288"></a>02288         }
<a name="l02289"></a>02289         lCurrentIndex += len;
<a name="l02290"></a>02290 
<a name="l02291"></a>02291         <span class="keywordflow">if</span> (len_out &gt; 0)
<a name="l02292"></a>02292             <span class="keywordflow">if</span> (<span class="keyword">false</span> == theDecryptedOutput.Concatenate(reinterpret_cast&lt;void *&gt;(&amp;vBuffer_out.at(0)),
<a name="l02293"></a>02293                                                         static_cast&lt;uint32_t&gt;(len_out)))
<a name="l02294"></a>02294             {
<a name="l02295"></a>02295                 <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;%s: Failure: theDecryptedOutput isn&#39;t large enough for the decrypted output (1).\n&quot;</span>, szFunc);
<a name="l02296"></a>02296                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02297"></a>02297             }
<a name="l02298"></a>02298 
<a name="l02299"></a>02299     }
<a name="l02300"></a>02300     <span class="comment">// -----------------------------------------------</span>
<a name="l02301"></a>02301     <span class="comment">//</span>
<a name="l02302"></a>02302     <span class="keywordflow">if</span> (!EVP_DecryptFinal(&amp;ctx, &amp;vBuffer_out.at(0), &amp;len_out))
<a name="l02303"></a>02303     {
<a name="l02304"></a>02304         <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;%s: EVP_DecryptFinal: failed.\n&quot;</span>, szFunc);
<a name="l02305"></a>02305         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02306"></a>02306     }
<a name="l02307"></a>02307     <span class="comment">// -----------------------------------------------</span>
<a name="l02308"></a>02308     <span class="comment">// This is the &quot;final&quot; piece that is added from DecryptFinal just above.</span>
<a name="l02309"></a>02309     <span class="comment">//</span>
<a name="l02310"></a>02310     <span class="keywordflow">if</span> (len_out &gt; 0)
<a name="l02311"></a>02311         <span class="keywordflow">if</span> (<span class="keyword">false</span> == theDecryptedOutput.Concatenate(reinterpret_cast&lt;void *&gt;(&amp;vBuffer_out.at(0)),
<a name="l02312"></a>02312                                                     static_cast&lt;uint32_t&gt;(len_out)))
<a name="l02313"></a>02313         {
<a name="l02314"></a>02314             <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;%s: Failure: theDecryptedOutput isn&#39;t large enough for the decrypted output (2).\n&quot;</span>, szFunc);
<a name="l02315"></a>02315             <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02316"></a>02316         }
<a name="l02317"></a>02317     <span class="comment">// -----------------------------------------------</span>
<a name="l02318"></a>02318     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l02319"></a>02319 }
<a name="l02320"></a>02320 
<a name="l02321"></a>02321 
<a name="l02322"></a>02322 <span class="comment">// Seal up as envelope (Asymmetric, using public key and then AES key.)</span>
<a name="l02323"></a>02323 
<a name="l02324"></a>02324 <span class="keywordtype">bool</span> OTCrypto_OpenSSL::Seal(<a class="code" href="_o_t_crypto_8hpp.html#a26e3eb3c76441ff452fdae8253c0c375">mapOfAsymmetricKeys</a> &amp; RecipPubKeys, <span class="keyword">const</span> <a class="code" href="class_o_t_string.html">OTString</a> &amp; theInput, <a class="code" href="class_o_t_data.html">OTData</a> &amp; dataOutput)<span class="keyword"> const</span>
<a name="l02325"></a>02325 <span class="keyword"></span>{
<a name="l02326"></a>02326     <a class="code" href="_o_t_assert_8hpp.html#a033b133f48e61f2b227c52ad2be0c882">OT_ASSERT_MSG</a>(RecipPubKeys.size() &gt; 0, <span class="stringliteral">&quot;OTCrypto_OpenSSL::Seal: ASSERT: RecipPubKeys.size() &gt; 0&quot;</span>);
<a name="l02327"></a>02327     <span class="comment">// -----------------------------------------------</span>
<a name="l02328"></a>02328     <span class="keyword">const</span> <span class="keywordtype">char</span> * szFunc = <span class="stringliteral">&quot;OTCrypto_OpenSSL::Seal&quot;</span>;
<a name="l02329"></a>02329     <span class="comment">// -----------------------------------------------</span>
<a name="l02330"></a>02330     EVP_CIPHER_CTX   ctx;
<a name="l02331"></a>02331 
<a name="l02332"></a>02332     uint8_t  buffer[4096];
<a name="l02333"></a>02333     uint8_t  buffer_out[4096 + EVP_MAX_IV_LENGTH];
<a name="l02334"></a>02334     uint8_t  iv[EVP_MAX_IV_LENGTH];
<a name="l02335"></a>02335 
<a name="l02336"></a>02336     uint32_t         len     = 0;
<a name="l02337"></a>02337     int32_t              len_out = 0;
<a name="l02338"></a>02338     <span class="comment">// -----------------------------------------------</span>
<a name="l02339"></a>02339 
<a name="l02340"></a>02340     memset(buffer, 0, 4096);
<a name="l02341"></a>02341     memset(buffer_out, 0, 4096 + EVP_MAX_IV_LENGTH);
<a name="l02342"></a>02342     memset(iv, 0, EVP_MAX_IV_LENGTH);
<a name="l02343"></a>02343 
<a name="l02344"></a>02344     <span class="comment">// -----------------------------------------------</span>
<a name="l02345"></a>02345     <span class="comment">// The below three arrays are ALL allocated and then cleaned-up inside this fuction</span>
<a name="l02346"></a>02346     <span class="comment">// (Using the below nested class, _OTEnv_Seal.) The first array will contain useful pointers, but we do NOT delete those.</span>
<a name="l02347"></a>02347     <span class="comment">// The next array contains pointers that we DO need to cleanup.</span>
<a name="l02348"></a>02348     <span class="comment">// The final array contains integers (sizes.)</span>
<a name="l02349"></a>02349     <span class="comment">//</span>
<a name="l02350"></a>02350     EVP_PKEY      ** array_pubkey = NULL;  <span class="comment">// These will be pointers we use, but do NOT need to clean-up.</span>
<a name="l02351"></a>02351     uint8_t       ** ek           = NULL;  <span class="comment">// These we DO need to cleanup...</span>
<a name="l02352"></a>02352     int32_t           *  eklen        = NULL;  <span class="comment">// This will just be an array of integers.</span>
<a name="l02353"></a>02353 
<a name="l02354"></a>02354     <span class="keywordtype">bool</span>             bFinalized   = <span class="keyword">false</span>; <span class="comment">// If this is set true, then we don&#39;t bother to cleanup the ctx. (See the destructor below.)</span>
<a name="l02355"></a>02355 
<a name="l02356"></a>02356     <span class="comment">// -----------------------------------------------</span>
<a name="l02357"></a>02357     <span class="comment">// This class is used as a nested function, for easier cleanup. (C++ doesn&#39;t directly support nested functions.)</span>
<a name="l02358"></a>02358     <span class="comment">// Basically it translates the incoming RecipPubKeys into the low-level arrays</span>
<a name="l02359"></a>02359     <span class="comment">// ek and eklen (that OpenSSL needs.) This also cleans up those same arrays, once</span>
<a name="l02360"></a>02360     <span class="comment">// this object destructs (when we leave scope of this function.)</span>
<a name="l02361"></a>02361     <span class="comment">//</span>
<a name="l02362"></a>02362     <span class="keyword">class </span>_OTEnv_Seal
<a name="l02363"></a>02363     {
<a name="l02364"></a>02364     <span class="keyword">private</span>:
<a name="l02365"></a>02365         <span class="keyword">const</span> <span class="keywordtype">char</span>                  *   m_szFunc;
<a name="l02366"></a>02366         EVP_CIPHER_CTX              &amp;   m_ctx;                  <span class="comment">// reference to openssl cipher context.</span>
<a name="l02367"></a>02367         EVP_PKEY                    *** m_array_pubkey;         <span class="comment">// pointer to array of public key pointers.</span>
<a name="l02368"></a>02368         uint8_t                     *** m_ek;                   <span class="comment">// pointer to array of encrypted symmetric keys.</span>
<a name="l02369"></a>02369         int32_t                         **  m_eklen;                <span class="comment">// pointer to array of lengths for each encrypted symmetric key</span>
<a name="l02370"></a>02370         <a class="code" href="_o_t_crypto_8hpp.html#a26e3eb3c76441ff452fdae8253c0c375">mapOfAsymmetricKeys</a>         &amp;   m_RecipPubKeys;         <span class="comment">// array of public keys (to initialize the above members with.)</span>
<a name="l02371"></a>02371         int32_t                             m_nLastPopulatedIndex;  <span class="comment">// We store the highest-populated index (so we can free() up &#39;til the same index, in destructor.)</span>
<a name="l02372"></a>02372         <span class="keywordtype">bool</span>                        &amp;   m_bFinalized;
<a name="l02373"></a>02373     <span class="keyword">public</span>:
<a name="l02374"></a>02374         _OTEnv_Seal(<span class="keyword">const</span> <span class="keywordtype">char</span>            * param_szFunc,
<a name="l02375"></a>02375                     EVP_CIPHER_CTX        &amp; theCTX,
<a name="l02376"></a>02376                     EVP_PKEY            *** param_array_pubkey,
<a name="l02377"></a>02377                     uint8_t             *** param_ek,
<a name="l02378"></a>02378                     int32_t                  ** param_eklen,
<a name="l02379"></a>02379                     <a class="code" href="_o_t_crypto_8hpp.html#a26e3eb3c76441ff452fdae8253c0c375">mapOfAsymmetricKeys</a>   &amp; param_RecipPubKeys,
<a name="l02380"></a>02380                     <span class="keywordtype">bool</span>                  &amp; param_Finalized) :
<a name="l02381"></a>02381             m_szFunc(param_szFunc),
<a name="l02382"></a>02382             m_ctx(theCTX),
<a name="l02383"></a>02383             m_array_pubkey(NULL),
<a name="l02384"></a>02384             m_ek(NULL),
<a name="l02385"></a>02385             m_eklen(NULL),
<a name="l02386"></a>02386             m_RecipPubKeys(param_RecipPubKeys),
<a name="l02387"></a>02387             m_nLastPopulatedIndex(-1),
<a name="l02388"></a>02388             m_bFinalized(param_Finalized)
<a name="l02389"></a>02389         {
<a name="l02390"></a>02390             <span class="keywordflow">if</span> (NULL == param_szFunc)       <a class="code" href="_o_t_assert_8hpp.html#a1ae1def3bdc59b89b0d96240d3c5c321">OT_FAIL</a>;
<a name="l02391"></a>02391             <span class="keywordflow">if</span> (NULL == param_array_pubkey) <a class="code" href="_o_t_assert_8hpp.html#a1ae1def3bdc59b89b0d96240d3c5c321">OT_FAIL</a>;
<a name="l02392"></a>02392             <span class="keywordflow">if</span> (NULL == param_ek)           <a class="code" href="_o_t_assert_8hpp.html#a1ae1def3bdc59b89b0d96240d3c5c321">OT_FAIL</a>;
<a name="l02393"></a>02393             <span class="keywordflow">if</span> (NULL == param_eklen)        <a class="code" href="_o_t_assert_8hpp.html#a1ae1def3bdc59b89b0d96240d3c5c321">OT_FAIL</a>;
<a name="l02394"></a>02394             <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(m_RecipPubKeys.size() &gt; 0);
<a name="l02395"></a>02395             <span class="comment">// ----------------------------</span>
<a name="l02396"></a>02396             <span class="comment">// Notice that each variable is a &quot;pointer to&quot; the actual array that was passed in.</span>
<a name="l02397"></a>02397             <span class="comment">// (So use them that way, inside this class,</span>
<a name="l02398"></a>02398             <span class="comment">//  like this:    *m_ek   and   *m_eklen )</span>
<a name="l02399"></a>02399             <span class="comment">//</span>
<a name="l02400"></a>02400             m_array_pubkey = param_array_pubkey;
<a name="l02401"></a>02401             m_ek           = param_ek;
<a name="l02402"></a>02402             m_eklen        = param_eklen;
<a name="l02403"></a>02403             <span class="comment">// -----------------------------------------------</span>
<a name="l02404"></a>02404             <span class="comment">// EVP_CIPHER_CTX_init() corresponds to: EVP_CIPHER_CTX_cleanup()</span>
<a name="l02405"></a>02405             <span class="comment">// EVP_CIPHER_CTX_cleanup clears all information from a cipher context and free up any allocated</span>
<a name="l02406"></a>02406             <span class="comment">// memory associate with it. It should be called after all operations using a cipher are complete</span>
<a name="l02407"></a>02407             <span class="comment">// so sensitive information does not remain in memory.</span>
<a name="l02408"></a>02408             <span class="comment">//</span>
<a name="l02409"></a>02409             EVP_CIPHER_CTX_init(&amp;m_ctx);
<a name="l02410"></a>02410 
<a name="l02411"></a>02411             <span class="comment">// ----------------------------------------------</span>
<a name="l02412"></a>02412             <span class="comment">// (*m_array_pubkey)[] array must have m_RecipPubKeys.size() no. of elements (each containing a pointer</span>
<a name="l02413"></a>02413             <span class="comment">// to an EVP_PKEY that we must NOT clean up.)</span>
<a name="l02414"></a>02414             <span class="comment">//</span>
<a name="l02415"></a>02415             *m_array_pubkey = (EVP_PKEY **)malloc(m_RecipPubKeys.size() * <span class="keyword">sizeof</span>(EVP_PKEY *));
<a name="l02416"></a>02416             <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != *m_array_pubkey);
<a name="l02417"></a>02417             memset(*m_array_pubkey, 0, m_RecipPubKeys.size() * <span class="keyword">sizeof</span>(EVP_PKEY *)); <span class="comment">// size of array length * sizeof(pointer)</span>
<a name="l02418"></a>02418             <span class="comment">// ----------------------------------------------</span>
<a name="l02419"></a>02419             <span class="comment">// (*m_ek)[] array must have m_RecipPubKeys.size() no. of elements (each will contain a pointer from OpenSSL that we must clean up.)</span>
<a name="l02420"></a>02420             <span class="comment">//</span>
<a name="l02421"></a>02421             *m_ek = (uint8_t**)malloc(m_RecipPubKeys.size() * <span class="keyword">sizeof</span>(uint8_t*));
<a name="l02422"></a>02422             <span class="keywordflow">if</span> (NULL == *m_ek) <a class="code" href="_o_t_assert_8hpp.html#a1ae1def3bdc59b89b0d96240d3c5c321">OT_FAIL</a>;
<a name="l02423"></a>02423             memset(*m_ek, 0, m_RecipPubKeys.size() * <span class="keyword">sizeof</span>(uint8_t*)); <span class="comment">// size of array length * sizeof(pointer)</span>
<a name="l02424"></a>02424             <span class="comment">// ----------------------------------------------</span>
<a name="l02425"></a>02425             <span class="comment">// (*m_eklen)[] array must also have m_RecipPubKeys.size() no. of elements (each containing a size as integer.)</span>
<a name="l02426"></a>02426             <span class="comment">//</span>
<a name="l02427"></a>02427             *m_eklen = <span class="keyword">static_cast&lt;</span>int32_t *<span class="keyword">&gt;</span>(malloc(m_RecipPubKeys.size() * <span class="keyword">sizeof</span>(int32_t)));
<a name="l02428"></a>02428             <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != *m_eklen);
<a name="l02429"></a>02429             memset(*m_eklen, 0, m_RecipPubKeys.size() * <span class="keyword">sizeof</span>(int32_t)); <span class="comment">// size of array length * sizeof(int32_t)</span>
<a name="l02430"></a>02430             <span class="comment">// ----------------------------------------------</span>
<a name="l02431"></a>02431             <span class="comment">//</span>
<a name="l02432"></a>02432             <span class="comment">// ABOVE is all just above allocating the memory and setting it to 0 / NULL.</span>
<a name="l02433"></a>02433             <span class="comment">//</span>
<a name="l02434"></a>02434             <span class="comment">// Whereas BELOW is about populating that memory, so the actual OTEnvelope::Seal() function can use it.</span>
<a name="l02435"></a>02435             <span class="comment">//</span>
<a name="l02436"></a>02436             <span class="comment">// -----------------------------------------------</span>
<a name="l02437"></a>02437             int32_t nKeyIndex = -1; <span class="comment">// it will be 0 upon first iteration.</span>
<a name="l02438"></a>02438 
<a name="l02439"></a>02439             <a class="code" href="_o_t_storage_8hpp.html#aa135ed03585fa4b246d7907afbd5873d">FOR_EACH</a>(<a class="code" href="_o_t_crypto_8hpp.html#a26e3eb3c76441ff452fdae8253c0c375">mapOfAsymmetricKeys</a>, m_RecipPubKeys)
<a name="l02440"></a>02440             {
<a name="l02441"></a>02441                 ++nKeyIndex; <span class="comment">// 0 on first iteration.</span>
<a name="l02442"></a>02442                 m_nLastPopulatedIndex = nKeyIndex;
<a name="l02443"></a>02443                 <span class="comment">// -------------------</span>
<a name="l02444"></a>02444                 <a class="code" href="class_o_t_asymmetric_key.html">OTAsymmetricKey</a> * pTempPublicKey = it-&gt;second; <span class="comment">// first is the NymID</span>
<a name="l02445"></a>02445                 <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != pTempPublicKey);
<a name="l02446"></a>02446                 <span class="comment">// -------------------</span>
<a name="l02447"></a>02447                 OTAsymmetricKey_OpenSSL * pPublicKey = <span class="keyword">dynamic_cast&lt;</span>OTAsymmetricKey_OpenSSL*<span class="keyword">&gt;</span>(pTempPublicKey);
<a name="l02448"></a>02448                 <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != pPublicKey);
<a name="l02449"></a>02449                 <span class="comment">// -------------------</span>
<a name="l02450"></a>02450                 EVP_PKEY * public_key   = <span class="keyword">const_cast&lt;</span>EVP_PKEY *<span class="keyword">&gt;</span>(pPublicKey-&gt;dp-&gt;GetKey());
<a name="l02451"></a>02451                 <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != public_key);
<a name="l02452"></a>02452                 <span class="comment">// -------------------</span>
<a name="l02453"></a>02453                 <span class="comment">// Copy the public key pointer to an array of public key pointers...</span>
<a name="l02454"></a>02454                 <span class="comment">//</span>
<a name="l02455"></a>02455                 (*m_array_pubkey)[nKeyIndex] = public_key; <span class="comment">// For OpenSSL, it needs an array of ALL the public keys.</span>
<a name="l02456"></a>02456                 <span class="comment">// -------------------</span>
<a name="l02457"></a>02457                 <span class="comment">// We allocate enough space for the encrypted symmetric key to be placed</span>
<a name="l02458"></a>02458                 <span class="comment">// at this index (the space determined based on size of the public key that</span>
<a name="l02459"></a>02459                 <span class="comment">// the symmetric key will be encrypted to.) The space is left empty, for OpenSSL</span>
<a name="l02460"></a>02460                 <span class="comment">// to populate.</span>
<a name="l02461"></a>02461                 <span class="comment">//</span>
<a name="l02462"></a>02462                 (*m_ek)[nKeyIndex] = (uint8_t*)malloc(EVP_PKEY_size(public_key));  <span class="comment">// (*m_ek)[i] must have room for EVP_PKEY_size(pubk[i]) bytes.</span>
<a name="l02463"></a>02463                 <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != (*m_ek)[nKeyIndex]);
<a name="l02464"></a>02464                 memset((*m_ek)[nKeyIndex], 0, EVP_PKEY_size(public_key));
<a name="l02465"></a>02465                 <span class="comment">// -------------------</span>
<a name="l02466"></a>02466             } <span class="comment">// FOR_EACH(mapOfAsymmetricKeys, m_RecipPubKeys)</span>
<a name="l02467"></a>02467             <span class="comment">// -----------------------------------------------</span>
<a name="l02468"></a>02468         }
<a name="l02469"></a>02469         <span class="comment">// --------------------------------</span>
<a name="l02470"></a>02470         ~_OTEnv_Seal() <span class="comment">// (destructor)</span>
<a name="l02471"></a>02471         {
<a name="l02472"></a>02472             <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != m_array_pubkey);  <span class="comment">// 1. pointer to an array of pointers to EVP_PKEY,</span>
<a name="l02473"></a>02473             <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != m_ek);            <span class="comment">// 2. pointer to an array of pointers to encrypted symmetric keys</span>
<a name="l02474"></a>02474             <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != m_eklen);         <span class="comment">// 3. pointer to an array storing the lengths of those keys.</span>
<a name="l02475"></a>02475             <span class="comment">// -------------------------------</span>
<a name="l02476"></a>02476             <span class="comment">// Iterate the array of encrypted symmetric keys, and free the key at each index...</span>
<a name="l02477"></a>02477             <span class="comment">//</span>
<a name="l02478"></a>02478             <span class="comment">// We know how many there are, because each pointer will otherwise be NULL.</span>
<a name="l02479"></a>02479             <span class="comment">// Plus we have m_nLastPopulatedIndex, which is obviously as far as we will go.</span>
<a name="l02480"></a>02480             <span class="comment">//</span>
<a name="l02481"></a>02481             <span class="comment">// -------------------------------</span>
<a name="l02482"></a>02482             int32_t    nKeyIndex = -1; <span class="comment">// it will be 0 upon first iteration.</span>
<a name="l02483"></a>02483             <span class="keywordflow">while</span> (nKeyIndex &lt; m_nLastPopulatedIndex) <span class="comment">// if m_nLastPopulatedIndex is 0, then this loop will iterate ONCE, with nKeyIndex incrementing to 0 on the first line.</span>
<a name="l02484"></a>02484             {
<a name="l02485"></a>02485                 ++nKeyIndex; <span class="comment">// 0 on first iteration.</span>
<a name="l02486"></a>02486                 <span class="comment">// --------------</span>
<a name="l02487"></a>02487                 <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != (*m_ek)[nKeyIndex]);
<a name="l02488"></a>02488                 <span class="comment">// --------------</span>
<a name="l02489"></a>02489                 free((*m_ek)[nKeyIndex]);
<a name="l02490"></a>02490                 (*m_ek)[nKeyIndex] = NULL;
<a name="l02491"></a>02491             }
<a name="l02492"></a>02492             <span class="comment">// -------------------------------</span>
<a name="l02493"></a>02493             <span class="comment">//</span>
<a name="l02494"></a>02494             <span class="comment">// Now free all of the arrays:</span>
<a name="l02495"></a>02495             <span class="comment">// 1. an array of pointers to EVP_PKEY,</span>
<a name="l02496"></a>02496             <span class="comment">// 2. an array of pointers to encrypted symmetric keys</span>
<a name="l02497"></a>02497             <span class="comment">//    (those all being NULL pointers due to the above while-loop),</span>
<a name="l02498"></a>02498             <span class="comment">//    and</span>
<a name="l02499"></a>02499             <span class="comment">// 3. an array storing the lengths of those keys.</span>
<a name="l02500"></a>02500             <span class="comment">//</span>
<a name="l02501"></a>02501             <span class="comment">// -------------------------------</span>
<a name="l02502"></a>02502             <span class="keywordflow">if</span> (NULL != *m_array_pubkey) <span class="comment">// NOTE: The individual pubkeys are NOT to be cleaned up, but this array, containing pointers to those pubkeys, IS cleaned up.</span>
<a name="l02503"></a>02503                 free(*m_array_pubkey); *m_array_pubkey = NULL;  m_array_pubkey = NULL;
<a name="l02504"></a>02504             <span class="keywordflow">if</span> (NULL != *m_ek)
<a name="l02505"></a>02505                 free(*m_ek);           *m_ek           = NULL;  m_ek           = NULL;
<a name="l02506"></a>02506             <span class="keywordflow">if</span> (NULL != *m_eklen)
<a name="l02507"></a>02507                 free(*m_eklen);        *m_eklen        = NULL;  m_eklen        = NULL;
<a name="l02508"></a>02508             <span class="comment">// -------------------------------</span>
<a name="l02509"></a>02509 
<a name="l02510"></a>02510             <span class="comment">// EVP_CIPHER_CTX_cleanup returns 1 for success and 0 for failure.</span>
<a name="l02511"></a>02511             <span class="comment">// EVP_EncryptFinal(), EVP_DecryptFinal() and EVP_CipherFinal() behave in a similar way to EVP_EncryptFinal_ex(), EVP_DecryptFinal_ex() and EVP_CipherFinal_ex() except ctx is automatically cleaned up after the call.</span>
<a name="l02512"></a>02512             <span class="comment">//</span>
<a name="l02513"></a>02513             <span class="keywordflow">if</span> (!m_bFinalized)
<a name="l02514"></a>02514             {
<a name="l02515"></a>02515                 <span class="comment">// We only clean this up here, if the &quot;Final&quot; Seal function didn&#39;t get called. (It normally</span>
<a name="l02516"></a>02516                 <span class="comment">// would have done this for us.)</span>
<a name="l02517"></a>02517 
<a name="l02518"></a>02518                 <span class="keywordflow">if</span> (0 == EVP_CIPHER_CTX_cleanup(&amp;m_ctx))
<a name="l02519"></a>02519                     <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;%s: Failure in EVP_CIPHER_CTX_cleanup. (It returned 0.)\n&quot;</span>, m_szFunc);
<a name="l02520"></a>02520             }
<a name="l02521"></a>02521         }
<a name="l02522"></a>02522         <span class="comment">// -----------------------------------</span>
<a name="l02523"></a>02523     }; <span class="comment">// class _OTEnv_Seal</span>
<a name="l02524"></a>02524     <span class="comment">// ---------------------------------------------------------------------------------------------------------------</span>
<a name="l02525"></a>02525 
<a name="l02526"></a>02526     <span class="comment">// INSTANTIATE IT (This does all our setup on construction here, AND cleanup</span>
<a name="l02527"></a>02527     <span class="comment">// on destruction, whenever exiting this function.)</span>
<a name="l02528"></a>02528 
<a name="l02529"></a>02529     _OTEnv_Seal local_RAII(szFunc, ctx, &amp;array_pubkey, &amp;ek, &amp;eklen, RecipPubKeys, bFinalized);
<a name="l02530"></a>02530 
<a name="l02531"></a>02531     <span class="comment">// --------------------------------</span>
<a name="l02532"></a>02532     <span class="comment">// This is where the envelope final contents will be placed.</span>
<a name="l02533"></a>02533     <span class="comment">// including the size of the encrypted symmetric key, the symmetric key</span>
<a name="l02534"></a>02534     <span class="comment">// itself, the initialization vector, and the ciphertext.</span>
<a name="l02535"></a>02535     <span class="comment">//</span>
<a name="l02536"></a>02536     dataOutput.<a class="code" href="class_o_t_data.html#aab9a5758e85597ef1d7250bcf2cc56a6">Release</a>();
<a name="l02537"></a>02537 
<a name="l02538"></a>02538     <span class="comment">// -----------------------------------------------</span>
<a name="l02539"></a>02539     <span class="keyword">const</span> EVP_CIPHER * cipher_type = EVP_aes_128_cbc(); <span class="comment">// todo hardcoding.</span>
<a name="l02540"></a>02540     <span class="comment">// --------------------------</span>
<a name="l02541"></a>02541     <span class="comment">/*</span>
<a name="l02542"></a>02542 <span class="comment">    int32_t EVP_SealInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type,</span>
<a name="l02543"></a>02543 <span class="comment">                     uint8_t **ek,  int32_t *ekl,</span>
<a name="l02544"></a>02544 <span class="comment">                     uint8_t *iv,</span>
<a name="l02545"></a>02545 <span class="comment">                     EVP_PKEY **pubk,     int32_t npubk);</span>
<a name="l02546"></a>02546 <span class="comment"></span>
<a name="l02547"></a>02547 <span class="comment">     -- ek is an array of buffers where the public-key-encrypted secret key will be written (for each recipient.)</span>
<a name="l02548"></a>02548 <span class="comment">     -- Each buffer must contain enough room for the corresponding encrypted key: that is,</span>
<a name="l02549"></a>02549 <span class="comment">            ek[i] must have room for EVP_PKEY_size(pubk[i]) bytes.</span>
<a name="l02550"></a>02550 <span class="comment">     -- The actual size of each encrypted secret key is written to the array ekl.</span>
<a name="l02551"></a>02551 <span class="comment">     -- pubk is an array of npubk public keys.</span>
<a name="l02552"></a>02552 <span class="comment">     */</span>
<a name="l02553"></a>02553 
<a name="l02554"></a>02554 <span class="comment">//    EVP_PKEY      ** array_pubkey = NULL;  // These will be pointers we use, but do NOT need to clean-up.</span>
<a name="l02555"></a>02555 <span class="comment">//    uint8_t ** ek           = NULL;  // These we DO need to cleanup...</span>
<a name="l02556"></a>02556 <span class="comment">//    int32_t           *  eklen        = NULL;  // This will just be an array of integers.</span>
<a name="l02557"></a>02557     <span class="comment">// **********************************************************</span>
<a name="l02558"></a>02558 
<a name="l02559"></a>02559     <span class="keywordflow">if</span> (!EVP_SealInit(&amp;ctx, cipher_type,
<a name="l02560"></a>02560                       ek,   eklen, <span class="comment">// array of buffers for output of encrypted copies of the symmetric &quot;session key&quot;. (Plus array of ints, to receive the size of each key.)</span>
<a name="l02561"></a>02561                       iv,          <span class="comment">// A buffer where the generated IV is written. Must contain room for the corresponding cipher&#39;s IV, as determined by (for example) EVP_CIPHER_iv_length(type).</span>
<a name="l02562"></a>02562                       array_pubkey, static_cast&lt;int32_t&gt; (RecipPubKeys.size()))) <span class="comment">// array of public keys we are addressing this envelope to.</span>
<a name="l02563"></a>02563     {
<a name="l02564"></a>02564         <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;%s: EVP_SealInit: failed.\n&quot;</span>, szFunc);
<a name="l02565"></a>02565         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02566"></a>02566     }
<a name="l02567"></a>02567     <span class="comment">// -----------------------------------------------</span>
<a name="l02568"></a>02568     <span class="comment">// Write the ENVELOPE TYPE (network order version.)</span>
<a name="l02569"></a>02569     <span class="comment">//</span>
<a name="l02570"></a>02570     <span class="comment">// 0 == Error</span>
<a name="l02571"></a>02571     <span class="comment">// 1 == Asymmetric Key  (this function -- Seal / Open)</span>
<a name="l02572"></a>02572     <span class="comment">// 2 == Symmetric Key   (other functions -- Encrypt / Decrypt use this.)</span>
<a name="l02573"></a>02573     <span class="comment">// Anything else: error.</span>
<a name="l02574"></a>02574 
<a name="l02575"></a>02575     uint16_t   temp_env_type = 1; <span class="comment">// todo hardcoding.</span>
<a name="l02576"></a>02576     uint16_t   env_type_n    = <span class="keyword">static_cast&lt;</span>uint16_t<span class="keyword">&gt;</span>(htons( static_cast&lt;uint16_t&gt;(temp_env_type) )); <span class="comment">// Calculate &quot;network-order&quot; version of envelope type 1.</span>
<a name="l02577"></a>02577 
<a name="l02578"></a>02578     dataOutput.<a class="code" href="class_o_t_data.html#a95c6d4d474bb010f504d0f2c7ae75211">Concatenate</a>(reinterpret_cast&lt;void *&gt;(&amp;env_type_n),
<a name="l02579"></a>02579                            static_cast&lt;uint32_t&gt;(<span class="keyword">sizeof</span>(env_type_n)));
<a name="l02580"></a>02580     <span class="comment">// ------------------------------------------------------------</span>
<a name="l02581"></a>02581     <span class="comment">// Write the ARRAY SIZE (network order version.)</span>
<a name="l02582"></a>02582 
<a name="l02583"></a>02583     uint32_t   array_size_n = <span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(htonl(static_cast&lt;uint32_t&gt;(RecipPubKeys.size()))); <span class="comment">// Calculate &quot;network-order&quot; version of array size.</span>
<a name="l02584"></a>02584 
<a name="l02585"></a>02585     dataOutput.<a class="code" href="class_o_t_data.html#a95c6d4d474bb010f504d0f2c7ae75211">Concatenate</a>(reinterpret_cast&lt;void *&gt;(&amp;array_size_n),
<a name="l02586"></a>02586                            static_cast&lt;uint32_t&gt;(<span class="keyword">sizeof</span>(array_size_n)));
<a name="l02587"></a>02587     <span class="comment">// ------------------------------------------------------------</span>
<a name="l02588"></a>02588 
<a name="l02589"></a>02589     <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(5, <span class="stringliteral">&quot;%s: Envelope type:  %d    Array size: %lld\n&quot;</span>, __FUNCTION__,
<a name="l02590"></a>02590                    static_cast&lt;int32_t&gt;(ntohs(env_type_n)),
<a name="l02591"></a>02591                    static_cast&lt;int64_t&gt;(ntohl(array_size_n))
<a name="l02592"></a>02592                    );
<a name="l02593"></a>02593 
<a name="l02594"></a>02594     <span class="comment">// ------------------------------------------------------------</span>
<a name="l02595"></a>02595     <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != ek);
<a name="l02596"></a>02596     <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != eklen);
<a name="l02597"></a>02597     <span class="comment">// -----------------</span>
<a name="l02598"></a>02598     <span class="comment">// Loop through the encrypted symmetric keys, and for each, write its</span>
<a name="l02599"></a>02599     <span class="comment">// network-order NymID size, and its NymID, and its network-order content size,</span>
<a name="l02600"></a>02600     <span class="comment">// and its content, to the envelope data contents</span>
<a name="l02601"></a>02601     <span class="comment">// (that we are currently building...)</span>
<a name="l02602"></a>02602     <span class="comment">//</span>
<a name="l02603"></a>02603     int32_t ii = -1; <span class="comment">// it will be 0 upon first iteration.</span>
<a name="l02604"></a>02604 
<a name="l02605"></a>02605     <a class="code" href="_o_t_storage_8hpp.html#aa135ed03585fa4b246d7907afbd5873d">FOR_EACH</a>(<a class="code" href="_o_t_crypto_8hpp.html#a26e3eb3c76441ff452fdae8253c0c375">mapOfAsymmetricKeys</a>, RecipPubKeys)
<a name="l02606"></a>02606     {
<a name="l02607"></a>02607         ++ii; <span class="comment">// 0 on first iteration.</span>
<a name="l02608"></a>02608         <span class="comment">// -------------------</span>
<a name="l02609"></a>02609         std::string       str_nym_id     = it-&gt;first;
<a name="l02610"></a>02610 <span class="comment">//        OTAsymmetricKey * pTempPublicKey = it-&gt;second;</span>
<a name="l02611"></a>02611 <span class="comment">//        OT_ASSERT(NULL != pTempPublicKey);</span>
<a name="l02612"></a>02612         <span class="comment">// -------------------</span>
<a name="l02613"></a>02613 <span class="comment">//        OTAsymmetricKey_OpenSSL * pPublicKey = dynamic_cast&lt;OTAsymmetricKey_OpenSSL*&gt;(pTempPublicKey);</span>
<a name="l02614"></a>02614 <span class="comment">//        OT_ASSERT(NULL != pPublicKey);</span>
<a name="l02615"></a>02615         <span class="comment">// -------------------</span>
<a name="l02616"></a>02616 <span class="comment">//        OTIdentifier theNymID;</span>
<a name="l02617"></a>02617 <span class="comment">//        bool bCalculatedID = pPublicKey-&gt;CalculateID(theNymID); // Only works for public keys.</span>
<a name="l02618"></a>02618 <span class="comment">//</span>
<a name="l02619"></a>02619 <span class="comment">//        if (false == bCalculatedID)</span>
<a name="l02620"></a>02620 <span class="comment">//        {</span>
<a name="l02621"></a>02621 <span class="comment">//            OTLog::vError(&quot;%s: Error trying to calculate ID of recipient.\n&quot;, szFunc);</span>
<a name="l02622"></a>02622 <span class="comment">//            return false;</span>
<a name="l02623"></a>02623 <span class="comment">//        }</span>
<a name="l02624"></a>02624         <span class="comment">// -------------------------</span>
<a name="l02625"></a>02625         <span class="keyword">const</span> <a class="code" href="class_o_t_string.html">OTString</a> strNymID(str_nym_id.c_str());
<a name="l02626"></a>02626 
<a name="l02627"></a>02627         uint32_t    nymid_len   = <span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(strNymID.GetLength()+1); <span class="comment">// +1 for null terminator.</span>
<a name="l02628"></a>02628         uint32_t    nymid_len_n = <span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(htonl(nymid_len)); <span class="comment">// Calculate &quot;network-order&quot; version of length (+1 for null terminator)</span>
<a name="l02629"></a>02629 
<a name="l02630"></a>02630         <span class="comment">// Write nymid_len_n and strNymID for EACH encrypted symmetric key.</span>
<a name="l02631"></a>02631         <span class="comment">//</span>
<a name="l02632"></a>02632         dataOutput.<a class="code" href="class_o_t_data.html#a95c6d4d474bb010f504d0f2c7ae75211">Concatenate</a>(reinterpret_cast&lt;void *&gt;(&amp;nymid_len_n),
<a name="l02633"></a>02633                                static_cast&lt;uint32_t&gt;(<span class="keyword">sizeof</span>(nymid_len_n)));
<a name="l02634"></a>02634 
<a name="l02635"></a>02635         dataOutput.<a class="code" href="class_o_t_data.html#a95c6d4d474bb010f504d0f2c7ae75211">Concatenate</a>(reinterpret_cast&lt;const void *&gt;(strNymID.Get()),
<a name="l02636"></a>02636                                static_cast&lt;uint32_t&gt;(nymid_len)); <span class="comment">// (+1 for null terminator is included here already, from above.)</span>
<a name="l02637"></a>02637         <span class="comment">// -----------------------------------------</span>
<a name="l02638"></a>02638         <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(5, <span class="stringliteral">&quot;%s: INDEX: %lld  NymID length:  %lld   Nym ID: %s   Strlen (should be a byte shorter): %lld\n&quot;</span>, __FUNCTION__,
<a name="l02639"></a>02639                        static_cast&lt;int64_t&gt;(ii),
<a name="l02640"></a>02640                        static_cast&lt;int64_t&gt;(ntohl(nymid_len_n)),
<a name="l02641"></a>02641                        strNymID.Get(),
<a name="l02642"></a>02642                        <span class="keyword">static_cast&lt;</span>int64_t<span class="keyword">&gt;</span>(strNymID.GetLength())
<a name="l02643"></a>02643                        );
<a name="l02644"></a>02644 
<a name="l02645"></a>02645 
<a name="l02646"></a>02646         <span class="comment">// **********************************</span>
<a name="l02647"></a>02647 
<a name="l02648"></a>02648 <span class="comment">//      Write eklen_n and ek for EACH encrypted symmetric key,</span>
<a name="l02649"></a>02649 <span class="comment">//</span>
<a name="l02650"></a>02650 <span class="comment">//        EVP_PKEY      ** array_pubkey = NULL;  // These will be pointers we use, but do NOT need to clean-up.</span>
<a name="l02651"></a>02651 <span class="comment">//        uint8_t ** ek           = NULL;  // These we DO need to cleanup...</span>
<a name="l02652"></a>02652 <span class="comment">//        int32_t           *  eklen        = NULL;  // This will just be an array of integers.</span>
<a name="l02653"></a>02653 
<a name="l02654"></a>02654         <span class="comment">// --------------------------</span>
<a name="l02655"></a>02655         <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != ek[ii]); <span class="comment">// assert key pointer not null.</span>
<a name="l02656"></a>02656         <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(eklen[ii] &gt; 0);  <span class="comment">// assert key length larger than 0.</span>
<a name="l02657"></a>02657         <span class="comment">// -----------------</span>
<a name="l02658"></a>02658         uint32_t    eklen_n = <span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(htonl(static_cast&lt;uint32_t&gt;(eklen[ii]))); <span class="comment">// Calculate &quot;network-order&quot; version of length.</span>
<a name="l02659"></a>02659         <span class="comment">// -----------------</span>
<a name="l02660"></a>02660         dataOutput.<a class="code" href="class_o_t_data.html#a95c6d4d474bb010f504d0f2c7ae75211">Concatenate</a>(reinterpret_cast&lt;void *&gt;(&amp;eklen_n),
<a name="l02661"></a>02661                                static_cast&lt;uint32_t&gt;(<span class="keyword">sizeof</span>(eklen_n)));
<a name="l02662"></a>02662 
<a name="l02663"></a>02663         dataOutput.<a class="code" href="class_o_t_data.html#a95c6d4d474bb010f504d0f2c7ae75211">Concatenate</a>(reinterpret_cast&lt;void *&gt;(ek[ii]),
<a name="l02664"></a>02664                                static_cast&lt;uint32_t&gt;(eklen[ii]));
<a name="l02665"></a>02665 
<a name="l02666"></a>02666         <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(5, <span class="stringliteral">&quot;%s: EK length:  %lld     First byte: %d      Last byte: %d\n&quot;</span>, __FUNCTION__,
<a name="l02667"></a>02667                        static_cast&lt;int64_t&gt;(ntohl(eklen_n)),
<a name="l02668"></a>02668                        static_cast&lt;int32_t&gt;((ek[ii])[0]),
<a name="l02669"></a>02669                        static_cast&lt;int32_t&gt;((ek[ii])[eklen[ii]-1])
<a name="l02670"></a>02670                        );
<a name="l02671"></a>02671 
<a name="l02672"></a>02672         <span class="comment">// -------------------</span>
<a name="l02673"></a>02673     } <span class="comment">// FOR_EACH(mapOfAsymmetricKeys, m_RecipPubKeys)</span>
<a name="l02674"></a>02674     <span class="comment">// -----------------------------------------------</span>
<a name="l02675"></a>02675     <span class="comment">//</span>
<a name="l02676"></a>02676     <span class="comment">// Write IV size before then writing IV itself.</span>
<a name="l02677"></a>02677     <span class="comment">//</span>
<a name="l02678"></a>02678     uint32_t       ivlen   = <span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(EVP_CIPHER_iv_length(cipher_type)); <span class="comment">// Length of IV for this cipher... (TODO: add cipher name to output, and use it for looking up cipher upon Open.)</span>
<a name="l02679"></a>02679 <span class="comment">//  OT_ASSERT(ivlen &gt; 0);</span>
<a name="l02680"></a>02680     uint32_t  ivlen_n = <span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(htonl(static_cast&lt;uint32_t&gt;(ivlen))); <span class="comment">// Calculate &quot;network-order&quot; version of iv length.</span>
<a name="l02681"></a>02681 
<a name="l02682"></a>02682     dataOutput.<a class="code" href="class_o_t_data.html#a95c6d4d474bb010f504d0f2c7ae75211">Concatenate</a>(reinterpret_cast&lt;void *&gt;(&amp;ivlen_n),
<a name="l02683"></a>02683                            static_cast&lt;uint32_t&gt;(<span class="keyword">sizeof</span>(ivlen_n)));
<a name="l02684"></a>02684 
<a name="l02685"></a>02685     dataOutput.<a class="code" href="class_o_t_data.html#a95c6d4d474bb010f504d0f2c7ae75211">Concatenate</a>(reinterpret_cast&lt;void *&gt;(iv),
<a name="l02686"></a>02686                            static_cast&lt;uint32_t&gt;(ivlen));
<a name="l02687"></a>02687 
<a name="l02688"></a>02688 
<a name="l02689"></a>02689     <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(5, <span class="stringliteral">&quot;%s: iv_size: %lld   IV first byte: %d    IV last byte: %d   \n&quot;</span>,
<a name="l02690"></a>02690                    __FUNCTION__,
<a name="l02691"></a>02691                    static_cast&lt;int64_t&gt;(ntohl(ivlen_n)),
<a name="l02692"></a>02692                    static_cast&lt;int32_t&gt;(iv[0]),
<a name="l02693"></a>02693                    static_cast&lt;int32_t&gt;(iv[ivlen-1])
<a name="l02694"></a>02694                    );
<a name="l02695"></a>02695 
<a name="l02696"></a>02696     <span class="comment">// -----------------------------------------------</span>
<a name="l02697"></a>02697     <span class="comment">// Next we put the plaintext into a data object so we can process it via EVP_SealUpdate,</span>
<a name="l02698"></a>02698     <span class="comment">// in blocks, into encrypted form in dataOutput. Each iteration of the loop processes</span>
<a name="l02699"></a>02699     <span class="comment">// one block.</span>
<a name="l02700"></a>02700     <span class="comment">//</span>
<a name="l02701"></a>02701     <a class="code" href="class_o_t_data.html">OTData</a> plaintext(static_cast&lt;const void*&gt;(theInput.<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>()), theInput.<a class="code" href="class_o_t_string.html#a640392dd17a786dab643dbfc7e5a8672">GetLength</a>()+1); <span class="comment">// +1 for null terminator</span>
<a name="l02702"></a>02702 
<a name="l02703"></a>02703     <span class="comment">// -----------------------------------------------</span>
<a name="l02704"></a>02704     <span class="comment">// Now we process the input and write the encrypted data to the</span>
<a name="l02705"></a>02705     <span class="comment">// output.</span>
<a name="l02706"></a>02706     <span class="comment">//</span>
<a name="l02707"></a>02707     <span class="keywordflow">while</span> (0 &lt; (len = plaintext.OTfread(reinterpret_cast&lt;uint8_t*&gt;(buffer),
<a name="l02708"></a>02708                                         static_cast&lt;uint32_t&gt;(<span class="keyword">sizeof</span>(buffer)))))
<a name="l02709"></a>02709     {
<a name="l02710"></a>02710         <span class="keywordflow">if</span> (!EVP_SealUpdate(&amp;ctx, buffer_out, &amp;len_out, buffer, static_cast&lt;int32_t&gt;(len)))
<a name="l02711"></a>02711         {
<a name="l02712"></a>02712             <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;%s: EVP_SealUpdate failed.\n&quot;</span>, szFunc);
<a name="l02713"></a>02713             <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02714"></a>02714         }
<a name="l02715"></a>02715         <span class="comment">// -------------------</span>
<a name="l02716"></a>02716         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (len_out &gt; 0)
<a name="l02717"></a>02717             dataOutput.<a class="code" href="class_o_t_data.html#a95c6d4d474bb010f504d0f2c7ae75211">Concatenate</a>(reinterpret_cast&lt;void *&gt;(buffer_out),
<a name="l02718"></a>02718                                    static_cast&lt;uint32_t&gt;(len_out));
<a name="l02719"></a>02719         <span class="keywordflow">else</span> <span class="keywordflow">break</span>;
<a name="l02720"></a>02720     }
<a name="l02721"></a>02721     <span class="comment">// -----------------------------------------------</span>
<a name="l02722"></a>02722 
<a name="l02723"></a>02723     <span class="keywordflow">if</span> (!EVP_SealFinal(&amp;ctx, buffer_out, &amp;len_out))
<a name="l02724"></a>02724     {
<a name="l02725"></a>02725         <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;%s: EVP_SealFinal failed.\n&quot;</span>, szFunc);
<a name="l02726"></a>02726         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02727"></a>02727     }
<a name="l02728"></a>02728     <span class="comment">// This is the &quot;final&quot; piece that is added from SealFinal just above.</span>
<a name="l02729"></a>02729     <span class="comment">//</span>
<a name="l02730"></a>02730     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (len_out &gt; 0)
<a name="l02731"></a>02731     {
<a name="l02732"></a>02732         bFinalized = <span class="keyword">true</span>;
<a name="l02733"></a>02733         dataOutput.<a class="code" href="class_o_t_data.html#a95c6d4d474bb010f504d0f2c7ae75211">Concatenate</a>(reinterpret_cast&lt;void *&gt;(buffer_out),
<a name="l02734"></a>02734                                static_cast&lt;uint32_t&gt;(len_out));
<a name="l02735"></a>02735     }
<a name="l02736"></a>02736     <span class="keywordflow">else</span>
<a name="l02737"></a>02737         bFinalized = <span class="keyword">true</span>;
<a name="l02738"></a>02738 
<a name="l02739"></a>02739     <span class="comment">// -----------------------------------------------</span>
<a name="l02740"></a>02740 
<a name="l02741"></a>02741     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l02742"></a>02742 }
<a name="l02743"></a>02743 
<a name="l02744"></a>02744 
<a name="l02745"></a>02745 <span class="comment">/*</span>
<a name="l02746"></a>02746 <span class="comment">#include &lt;openssl/evp.h&gt;</span>
<a name="l02747"></a>02747 <span class="comment">int32_t EVP_OpenInit(EVP_CIPHER_CTX *ctx,EVP_CIPHER *type,uint8_t *ek,</span>
<a name="l02748"></a>02748 <span class="comment">                 int32_t ekl,uint8_t *iv,EVP_PKEY *priv);</span>
<a name="l02749"></a>02749 <span class="comment">int32_t EVP_OpenUpdate(EVP_CIPHER_CTX *ctx, uint8_t *out,</span>
<a name="l02750"></a>02750 <span class="comment">                   int32_t *outl, uint8_t *in, int32_t inl);</span>
<a name="l02751"></a>02751 <span class="comment">int32_t EVP_OpenFinal(EVP_CIPHER_CTX *ctx, uint8_t *out,</span>
<a name="l02752"></a>02752 <span class="comment">                  int32_t *outl);</span>
<a name="l02753"></a>02753 <span class="comment">DESCRIPTION</span>
<a name="l02754"></a>02754 <span class="comment"></span>
<a name="l02755"></a>02755 <span class="comment">The EVP envelope routines are a high level interface to envelope decryption. They decrypt a public key</span>
<a name="l02756"></a>02756 <span class="comment"> encrypted symmetric key and then decrypt data using it.</span>
<a name="l02757"></a>02757 <span class="comment"></span>
<a name="l02758"></a>02758 <span class="comment"> int32_t EVP_OpenInit(EVP_CIPHER_CTX *ctx,EVP_CIPHER *type,uint8_t *ek, int32_t ekl,uint8_t *iv,EVP_PKEY *priv);</span>
<a name="l02759"></a>02759 <span class="comment">EVP_OpenInit() initializes a cipher context ctx for decryption with cipher type. It decrypts the encrypted</span>
<a name="l02760"></a>02760 <span class="comment"> symmetric key of length ekl bytes passed in the ek parameter using the private key priv. The IV is supplied</span>
<a name="l02761"></a>02761 <span class="comment"> in the iv parameter.</span>
<a name="l02762"></a>02762 <span class="comment"></span>
<a name="l02763"></a>02763 <span class="comment">EVP_OpenUpdate() and EVP_OpenFinal() have exactly the same properties as the EVP_DecryptUpdate() and</span>
<a name="l02764"></a>02764 <span class="comment"> EVP_DecryptFinal() routines, as documented on the EVP_EncryptInit(3) manual page.</span>
<a name="l02765"></a>02765 <span class="comment"></span>
<a name="l02766"></a>02766 <span class="comment">NOTES</span>
<a name="l02767"></a>02767 <span class="comment"></span>
<a name="l02768"></a>02768 <span class="comment">It is possible to call EVP_OpenInit() twice in the same way as EVP_DecryptInit(). The first call should have</span>
<a name="l02769"></a>02769 <span class="comment"> priv set to NULL and (after setting any cipher parameters) it should be called again with type set to NULL.</span>
<a name="l02770"></a>02770 <span class="comment"></span>
<a name="l02771"></a>02771 <span class="comment">If the cipher passed in the type parameter is a variable length cipher then the key length will be set to the</span>
<a name="l02772"></a>02772 <span class="comment">value of the recovered key length. If the cipher is a fixed length cipher then the recovered key length must</span>
<a name="l02773"></a>02773 <span class="comment">match the fixed cipher length.</span>
<a name="l02774"></a>02774 <span class="comment"></span>
<a name="l02775"></a>02775 <span class="comment">RETURN VALUES</span>
<a name="l02776"></a>02776 <span class="comment"></span>
<a name="l02777"></a>02777 <span class="comment">EVP_OpenInit() returns 0 on error or a non zero integer (actually the recovered secret key size) if successful.</span>
<a name="l02778"></a>02778 <span class="comment"></span>
<a name="l02779"></a>02779 <span class="comment">EVP_OpenUpdate() returns 1 for success or 0 for failure.</span>
<a name="l02780"></a>02780 <span class="comment"></span>
<a name="l02781"></a>02781 <span class="comment">EVP_OpenFinal() returns 0 if the decrypt failed or 1 for success.</span>
<a name="l02782"></a>02782 <span class="comment">*/</span>
<a name="l02783"></a>02783 
<a name="l02784"></a>02784 <span class="comment">// RSA / AES</span>
<a name="l02785"></a>02785 
<a name="l02786"></a>02786 <span class="keywordtype">bool</span> OTCrypto_OpenSSL::Open(<a class="code" href="class_o_t_data.html">OTData</a> &amp; dataInput, <span class="keyword">const</span> <a class="code" href="class_o_t_pseudonym.html">OTPseudonym</a> &amp; theRecipient, <a class="code" href="class_o_t_string.html">OTString</a> &amp; theOutput, <a class="code" href="class_o_t_password_data.html">OTPasswordData</a> * pPWData<span class="comment">/*=NULL*/</span>)<span class="keyword"> const</span>
<a name="l02787"></a>02787 <span class="keyword"></span>{
<a name="l02788"></a>02788     <span class="keyword">const</span> <span class="keywordtype">char</span> * szFunc = <span class="stringliteral">&quot;OTCrypto_OpenSSL::Open&quot;</span>;
<a name="l02789"></a>02789     <span class="comment">// ------------------------------------------------</span>
<a name="l02790"></a>02790     uint8_t buffer[4096];
<a name="l02791"></a>02791     uint8_t buffer_out[4096 + EVP_MAX_IV_LENGTH];
<a name="l02792"></a>02792     uint8_t iv[EVP_MAX_IV_LENGTH];
<a name="l02793"></a>02793     <span class="comment">// ------------------------------------</span>
<a name="l02794"></a>02794     uint32_t    len     = 0;
<a name="l02795"></a>02795     int32_t         len_out = 0;
<a name="l02796"></a>02796     <span class="keywordtype">bool</span>        bFinalized = <span class="keyword">false</span>;  <span class="comment">// We only clean up the ctx if the Open &quot;Final&quot; function hasn&#39;t been called, since it does that automatically already.</span>
<a name="l02797"></a>02797     <span class="comment">// ------------------------------------------------</span>
<a name="l02798"></a>02798     memset(buffer, 0, 4096);
<a name="l02799"></a>02799     memset(buffer_out, 0, 4096 + EVP_MAX_IV_LENGTH);
<a name="l02800"></a>02800     memset(iv, 0, EVP_MAX_IV_LENGTH);
<a name="l02801"></a>02801     <span class="comment">// ------------------------------------------------</span>
<a name="l02802"></a>02802     <span class="comment">// theOutput is where we&#39;ll put the decrypted result.</span>
<a name="l02803"></a>02803     <span class="comment">//</span>
<a name="l02804"></a>02804     theOutput.<a class="code" href="class_o_t_string.html#abef4b21b2170468705c58d64212d7257">Release</a>();
<a name="l02805"></a>02805     <span class="comment">// ------------------------------------------------</span>
<a name="l02806"></a>02806     <span class="comment">// Grab the NymID of the recipient, so we can find his session</span>
<a name="l02807"></a>02807     <span class="comment">// key (there might be symmetric keys for several Nyms, not just this</span>
<a name="l02808"></a>02808     <span class="comment">// one, and we need to find the right one in order to perform this Open.)</span>
<a name="l02809"></a>02809     <span class="comment">//</span>
<a name="l02810"></a>02810     <a class="code" href="class_o_t_string.html">OTString</a>  strNymID;
<a name="l02811"></a>02811     theRecipient.<a class="code" href="class_o_t_pseudonym.html#a1775c7aedd0dd25b2faf3f78dcccabe7">GetIdentifier</a>(strNymID);
<a name="l02812"></a>02812     <span class="comment">// ------------------------------------------------</span>
<a name="l02813"></a>02813     <a class="code" href="class_o_t_asymmetric_key.html">OTAsymmetricKey</a>         &amp; theTempPrivateKey = <span class="keyword">const_cast&lt;</span><a class="code" href="class_o_t_asymmetric_key.html">OTAsymmetricKey</a> &amp;<span class="keyword">&gt;</span>(theRecipient.<a class="code" href="class_o_t_pseudonym.html#a89830be018a88bd1201b296065602f61">GetPrivateEncrKey</a>());
<a name="l02814"></a>02814     <span class="comment">// -------------------</span>
<a name="l02815"></a>02815     OTAsymmetricKey_OpenSSL * pPrivateKey       = <span class="keyword">dynamic_cast&lt;</span>OTAsymmetricKey_OpenSSL *<span class="keyword">&gt;</span>(&amp;theTempPrivateKey);
<a name="l02816"></a>02816     <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != pPrivateKey);
<a name="l02817"></a>02817     <span class="comment">// -------------------</span>
<a name="l02818"></a>02818     EVP_PKEY                * private_key       = <span class="keyword">const_cast&lt;</span>EVP_PKEY *<span class="keyword">&gt;</span>(pPrivateKey-&gt;dp-&gt;GetKey(pPWData));
<a name="l02819"></a>02819 
<a name="l02820"></a>02820     <span class="keywordflow">if</span> (NULL == private_key)
<a name="l02821"></a>02821     {
<a name="l02822"></a>02822         <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;%s: Null private key on recipient. (Returning false.)\n&quot;</span>, szFunc);
<a name="l02823"></a>02823         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02824"></a>02824     }
<a name="l02825"></a>02825     <span class="keywordflow">else</span>
<a name="l02826"></a>02826         <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(5, <span class="stringliteral">&quot;%s: Private key is available for NymID: %s \n&quot;</span>, __FUNCTION__,
<a name="l02827"></a>02827                        strNymID.<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>());
<a name="l02828"></a>02828     <span class="comment">// ------------------------------------------------</span>
<a name="l02829"></a>02829     EVP_CIPHER_CTX  ctx;
<a name="l02830"></a>02830     <span class="comment">// ----------------------------------------------</span>
<a name="l02831"></a>02831     <span class="keyword">class </span>_OTEnv_Open
<a name="l02832"></a>02832     {
<a name="l02833"></a>02833     <span class="keyword">private</span>:
<a name="l02834"></a>02834         <span class="keyword">const</span> <span class="keywordtype">char</span>        *   m_szFunc;
<a name="l02835"></a>02835         EVP_CIPHER_CTX    &amp;   m_ctx;        <span class="comment">// reference to openssl cipher context.</span>
<a name="l02836"></a>02836         <a class="code" href="class_o_t_asymmetric_key.html">OTAsymmetricKey</a>   &amp;   m_privateKey; <span class="comment">// reference to OTAsymmetricKey object.</span>
<a name="l02837"></a>02837         <span class="keywordtype">bool</span>              &amp;   m_bFinalized;
<a name="l02838"></a>02838     <span class="keyword">public</span>:
<a name="l02839"></a>02839         <span class="comment">// ------------------------</span>
<a name="l02840"></a>02840         _OTEnv_Open(<span class="keyword">const</span> <span class="keywordtype">char</span>       * param_szFunc,
<a name="l02841"></a>02841                     EVP_CIPHER_CTX   &amp; theCTX,
<a name="l02842"></a>02842                     <a class="code" href="class_o_t_asymmetric_key.html">OTAsymmetricKey</a>  &amp; param_privateKey,
<a name="l02843"></a>02843                     <span class="keywordtype">bool</span>             &amp; param_Finalized) :
<a name="l02844"></a>02844             m_szFunc(param_szFunc),
<a name="l02845"></a>02845             m_ctx(theCTX),
<a name="l02846"></a>02846             m_privateKey(param_privateKey),
<a name="l02847"></a>02847             m_bFinalized(param_Finalized)
<a name="l02848"></a>02848         {
<a name="l02849"></a>02849             <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != param_szFunc);
<a name="l02850"></a>02850 
<a name="l02851"></a>02851             EVP_CIPHER_CTX_init(&amp;m_ctx);
<a name="l02852"></a>02852         }
<a name="l02853"></a>02853         <span class="comment">// ------------------------</span>
<a name="l02854"></a>02854         ~_OTEnv_Open()  <span class="comment">// DESTRUCTOR</span>
<a name="l02855"></a>02855         {
<a name="l02856"></a>02856             m_privateKey.ReleaseKey();
<a name="l02857"></a>02857             <span class="comment">//</span>
<a name="l02858"></a>02858             <span class="comment">// BELOW this point, private_key (which is a member of m_privateKey is either</span>
<a name="l02859"></a>02859             <span class="comment">// cleaned up, or kept based on a timer value. (It MAY not be cleaned up,</span>
<a name="l02860"></a>02860             <span class="comment">// depending on its state.)</span>
<a name="l02861"></a>02861 
<a name="l02862"></a>02862 
<a name="l02863"></a>02863             <span class="comment">// EVP_CIPHER_CTX_cleanup returns 1 for success and 0 for failure.</span>
<a name="l02864"></a>02864             <span class="comment">//</span>
<a name="l02865"></a>02865             <span class="keywordflow">if</span> (!m_bFinalized)
<a name="l02866"></a>02866             {
<a name="l02867"></a>02867                 <span class="keywordflow">if</span> (0 == EVP_CIPHER_CTX_cleanup(&amp;m_ctx))
<a name="l02868"></a>02868                     <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;%s: Failure in EVP_CIPHER_CTX_cleanup. (It returned 0.)\n&quot;</span>, m_szFunc);
<a name="l02869"></a>02869             }
<a name="l02870"></a>02870 
<a name="l02871"></a>02871             m_szFunc = NULL;
<a name="l02872"></a>02872         }
<a name="l02873"></a>02873     };
<a name="l02874"></a>02874     <span class="comment">// ------------------------------------------------</span>
<a name="l02875"></a>02875     <span class="comment">// INSTANTIATE the clean-up object.</span>
<a name="l02876"></a>02876     <span class="comment">//</span>
<a name="l02877"></a>02877     _OTEnv_Open     theNestedInstance(szFunc, ctx, *pPrivateKey, bFinalized);
<a name="l02878"></a>02878     <span class="comment">//</span>
<a name="l02879"></a>02879     <span class="comment">// ------------------------------------------------</span>
<a name="l02880"></a>02880     <span class="comment">//</span>
<a name="l02881"></a>02881     dataInput.<a class="code" href="class_o_t_data.html#ad6e1d52647f43ec65069a9aa676d7e26">reset</a>(); <span class="comment">// Reset the fread position on this object to 0.</span>
<a name="l02882"></a>02882 
<a name="l02883"></a>02883     uint32_t nRunningTotal  = 0; <span class="comment">// Everytime we read something, we add the length to this variable.</span>
<a name="l02884"></a>02884 
<a name="l02885"></a>02885     uint32_t nReadEnvType   = 0;
<a name="l02886"></a>02886     uint32_t nReadArraySize = 0;
<a name="l02887"></a>02887     uint32_t nReadIV        = 0;
<a name="l02888"></a>02888     <span class="comment">// ----------------------------------------------------------------------------</span>
<a name="l02889"></a>02889     <span class="comment">//</span>
<a name="l02890"></a>02890     <span class="comment">// Read the ARRAY SIZE (network order version -- convert to host version.)</span>
<a name="l02891"></a>02891     <span class="comment">// -----------------</span>
<a name="l02892"></a>02892     <span class="comment">// Loop through the array of encrypted symmetric keys, and for each:</span>
<a name="l02893"></a>02893     <span class="comment">//      read its network-order NymID size (convert to host version), and then read its NymID,</span>
<a name="l02894"></a>02894     <span class="comment">//      read its network-order key content size (convert to host), and then read its key content,</span>
<a name="l02895"></a>02895     <span class="comment">// -----------------</span>
<a name="l02896"></a>02896     <span class="comment">//</span>
<a name="l02897"></a>02897     <span class="comment">// Read network-order IV size (convert to host version) before then reading IV itself.</span>
<a name="l02898"></a>02898     <span class="comment">// (Then update encrypted blocks until evp open final...)</span>
<a name="l02899"></a>02899     <span class="comment">//</span>
<a name="l02900"></a>02900     <span class="comment">// --------------------------------------------------</span>
<a name="l02901"></a>02901 
<a name="l02902"></a>02902     <span class="comment">// So here we go...</span>
<a name="l02903"></a>02903 
<a name="l02904"></a>02904     <span class="comment">// ****************************************************************************</span>
<a name="l02905"></a>02905     <span class="comment">//</span>
<a name="l02906"></a>02906     <span class="comment">// Read the ENVELOPE TYPE (as network order version -- and convert to host version.)</span>
<a name="l02907"></a>02907     <span class="comment">//</span>
<a name="l02908"></a>02908     <span class="comment">// 0 == Error</span>
<a name="l02909"></a>02909     <span class="comment">// 1 == Asymmetric Key  (this function -- Seal / Open)</span>
<a name="l02910"></a>02910     <span class="comment">// 2 == Symmetric Key   (other functions -- Encrypt / Decrypt use this.)</span>
<a name="l02911"></a>02911     <span class="comment">// Anything else: error.</span>
<a name="l02912"></a>02912     <span class="comment">//</span>
<a name="l02913"></a>02913     uint16_t  env_type_n = 0;
<a name="l02914"></a>02914 
<a name="l02915"></a>02915     <span class="keywordflow">if</span> (0 == (nReadEnvType = dataInput.<a class="code" href="class_o_t_data.html#a4892d79a257500ee8c798736ce0d1ba8">OTfread</a>(reinterpret_cast&lt;uint8_t*&gt;(&amp;env_type_n),
<a name="l02916"></a>02916                                                static_cast&lt;uint32_t&gt;(<span class="keyword">sizeof</span>(env_type_n)))))
<a name="l02917"></a>02917     {
<a name="l02918"></a>02918         <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;%s: Error reading Envelope Type. Expected asymmetric(1) or symmetric (2).\n&quot;</span>, szFunc);
<a name="l02919"></a>02919         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02920"></a>02920     }
<a name="l02921"></a>02921     nRunningTotal += nReadEnvType;
<a name="l02922"></a>02922     <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(nReadEnvType == static_cast&lt;uint32_t&gt;(<span class="keyword">sizeof</span>(env_type_n)));
<a name="l02923"></a>02923     <span class="comment">// ----------------------------------------------------------------------------</span>
<a name="l02924"></a>02924     <span class="comment">// convert that envelope type from network to HOST endian.</span>
<a name="l02925"></a>02925     <span class="comment">//</span>
<a name="l02926"></a>02926     <span class="keyword">const</span> uint16_t env_type = <span class="keyword">static_cast&lt;</span>uint16_t<span class="keyword">&gt;</span>(ntohs(static_cast&lt;uint16_t&gt;(env_type_n)));
<a name="l02927"></a>02927 <span class="comment">//  nRunningTotal += env_type;    // NOPE! Just because envelope type is 1 or 2, doesn&#39;t mean we add 1 or 2 extra bytes to the length here. Nope!</span>
<a name="l02928"></a>02928 
<a name="l02929"></a>02929 
<a name="l02930"></a>02930     <span class="keywordflow">if</span> (1 != env_type)
<a name="l02931"></a>02931     {
<a name="l02932"></a>02932         <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;%s: Error: Expected Envelope for Asymmetric key (type 1) but instead found type %d.\n&quot;</span>,
<a name="l02933"></a>02933                       szFunc, static_cast&lt;int32_t&gt;(env_type));
<a name="l02934"></a>02934         print_stacktrace();
<a name="l02935"></a>02935         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02936"></a>02936     }
<a name="l02937"></a>02937     <span class="keywordflow">else</span>
<a name="l02938"></a>02938         <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(5, <span class="stringliteral">&quot;%s: Envelope type: %d\n&quot;</span>, __FUNCTION__,
<a name="l02939"></a>02939                        static_cast&lt;int32_t&gt;(env_type)
<a name="l02940"></a>02940                        );
<a name="l02941"></a>02941 
<a name="l02942"></a>02942     <span class="comment">// ****************************************************************************</span>
<a name="l02943"></a>02943     <span class="comment">//</span>
<a name="l02944"></a>02944     <span class="comment">// Read the ARRAY SIZE (network order version -- convert to host version.)</span>
<a name="l02945"></a>02945     <span class="comment">//</span>
<a name="l02946"></a>02946     uint32_t    array_size_n = 0;
<a name="l02947"></a>02947 
<a name="l02948"></a>02948     <span class="keywordflow">if</span> (0 == (nReadArraySize = dataInput.<a class="code" href="class_o_t_data.html#a4892d79a257500ee8c798736ce0d1ba8">OTfread</a>(reinterpret_cast&lt;uint8_t*&gt;(&amp;array_size_n),
<a name="l02949"></a>02949                                                  static_cast&lt;uint32_t&gt;(<span class="keyword">sizeof</span>(array_size_n)))))
<a name="l02950"></a>02950     {
<a name="l02951"></a>02951         <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;%s: Error reading Array Size for encrypted symmetric keys.\n&quot;</span>, szFunc);
<a name="l02952"></a>02952         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02953"></a>02953     }
<a name="l02954"></a>02954     nRunningTotal += nReadArraySize;
<a name="l02955"></a>02955     <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(nReadArraySize == static_cast&lt;uint32_t&gt;(<span class="keyword">sizeof</span>(array_size_n)));
<a name="l02956"></a>02956     <span class="comment">// ----------------------------------------------------------------------------</span>
<a name="l02957"></a>02957     <span class="comment">// convert that array size from network to HOST endian.</span>
<a name="l02958"></a>02958     <span class="comment">//</span>
<a name="l02959"></a>02959     <span class="keyword">const</span> uint32_t array_size = ntohl(array_size_n);
<a name="l02960"></a>02960 
<a name="l02961"></a>02961     <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(5, <span class="stringliteral">&quot;%s: Array size: %lld\n&quot;</span>, __FUNCTION__,
<a name="l02962"></a>02962                    static_cast&lt;int64_t&gt;(array_size)
<a name="l02963"></a>02963                    );
<a name="l02964"></a>02964 
<a name="l02965"></a>02965 <span class="comment">//  nRunningTotal += array_size;    // NOPE! Just because there are 10 array elements doesn&#39;t mean I want to add &quot;10&quot; here to the running total!! Not logical.</span>
<a name="l02966"></a>02966     <span class="comment">// ****************************************************************************</span>
<a name="l02967"></a>02967     <span class="comment">//</span>
<a name="l02968"></a>02968     <span class="comment">// We are going to loop through all the keys and load each up (then delete.)</span>
<a name="l02969"></a>02969     <span class="comment">// Each one is proceeded by its length.</span>
<a name="l02970"></a>02970     <span class="comment">// IF we find the one we are looking for, then we set it onto this variable,</span>
<a name="l02971"></a>02971     <span class="comment">// theRawEncryptedKey, so we have it available below this loop.</span>
<a name="l02972"></a>02972     <span class="comment">//</span>
<a name="l02973"></a>02973     <a class="code" href="class_o_t_payload.html">OTPayload</a>  theRawEncryptedKey;
<a name="l02974"></a>02974     <span class="keywordtype">bool</span>       bFoundKeyAlready = <span class="keyword">false</span>; <span class="comment">// If we find it during the loop below, we&#39;ll set this to true.</span>
<a name="l02975"></a>02975     <span class="comment">// ----------------------------------------------------------------------------</span>
<a name="l02976"></a>02976     <span class="comment">// Loop through as we read the encrypted symmetric keys, and for each:</span>
<a name="l02977"></a>02977     <span class="comment">//      read its network-order NymID size (convert to host version), and then read its NymID,</span>
<a name="l02978"></a>02978     <span class="comment">//      read its network-order key content size (convert to host), and then read its key content,</span>
<a name="l02979"></a>02979     <span class="comment">//</span>
<a name="l02980"></a>02980     <span class="keywordflow">for</span> (uint32_t ii = 0; ii &lt; array_size; ++ii)
<a name="l02981"></a>02981     {
<a name="l02982"></a>02982         <span class="comment">// ****************************************************************************</span>
<a name="l02983"></a>02983         <span class="comment">//</span>
<a name="l02984"></a>02984         <span class="comment">// Loop through the encrypted symmetric keys, and for each:</span>
<a name="l02985"></a>02985         <span class="comment">//      read its network-order NymID size (convert to host version), and then read its NymID,</span>
<a name="l02986"></a>02986         <span class="comment">//      read its network-order key content size (convert to host), and then read its key content.</span>
<a name="l02987"></a>02987         <span class="comment">// -----------------</span>
<a name="l02988"></a>02988         <span class="comment">//</span>
<a name="l02989"></a>02989         uint32_t    nymid_len_n    = 0;
<a name="l02990"></a>02990         uint32_t    nReadNymIDSize = 0;
<a name="l02991"></a>02991 
<a name="l02992"></a>02992         <span class="keywordflow">if</span> (0 == (nReadNymIDSize = dataInput.<a class="code" href="class_o_t_data.html#a4892d79a257500ee8c798736ce0d1ba8">OTfread</a>(reinterpret_cast&lt;uint8_t*&gt;(&amp;nymid_len_n),
<a name="l02993"></a>02993                                                      static_cast&lt;uint32_t&gt;(<span class="keyword">sizeof</span>(nymid_len_n)))))
<a name="l02994"></a>02994         {
<a name="l02995"></a>02995             <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;%s: Error reading NymID length for an encrypted symmetric key.\n&quot;</span>, szFunc);
<a name="l02996"></a>02996             <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02997"></a>02997         }
<a name="l02998"></a>02998         nRunningTotal += nReadNymIDSize;
<a name="l02999"></a>02999         <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(nReadNymIDSize == static_cast&lt;uint32_t&gt;(<span class="keyword">sizeof</span>(nymid_len_n)));
<a name="l03000"></a>03000         <span class="comment">// ----------------------------------------------------------------------------</span>
<a name="l03001"></a>03001         <span class="comment">// convert that array size from network to HOST endian.</span>
<a name="l03002"></a>03002         <span class="comment">//</span>
<a name="l03003"></a>03003         uint32_t nymid_len = <span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(ntohl(static_cast&lt;uint32_t&gt;(nymid_len_n)));    <span class="comment">// FYI: ntohl returns uint32_t !!!!!</span>
<a name="l03004"></a>03004 
<a name="l03005"></a>03005 
<a name="l03006"></a>03006         <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(5, <span class="stringliteral">&quot;%s: NymID length: %lld\n&quot;</span>, __FUNCTION__,
<a name="l03007"></a>03007                        static_cast&lt;int64_t&gt;(nymid_len)
<a name="l03008"></a>03008                        );
<a name="l03009"></a>03009 
<a name="l03010"></a>03010 
<a name="l03011"></a>03011 <span class="comment">//      nRunningTotal += nymid_len; // Nope!</span>
<a name="l03012"></a>03012         <span class="comment">// ----------------------------------------------------------------------------</span>
<a name="l03013"></a>03013         uint8_t * nymid = <span class="keyword">static_cast&lt;</span>uint8_t *<span class="keyword">&gt;</span>(malloc(<span class="keyword">sizeof</span>(uint8_t) * nymid_len));
<a name="l03014"></a>03014         <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != nymid);
<a name="l03015"></a>03015         nymid[0] = <span class="charliteral">&#39;\0&#39;</span>; <span class="comment">// null terminator.</span>
<a name="l03016"></a>03016 
<a name="l03017"></a>03017         uint32_t  nReadNymID = 0;
<a name="l03018"></a>03018 
<a name="l03019"></a>03019         <span class="keywordflow">if</span> (0 == (nReadNymID = dataInput.<a class="code" href="class_o_t_data.html#a4892d79a257500ee8c798736ce0d1ba8">OTfread</a>(reinterpret_cast&lt;uint8_t *&gt;(nymid),
<a name="l03020"></a>03020                                                  static_cast&lt;uint32_t&gt;(<span class="keyword">sizeof</span>(uint8_t) * nymid_len)))) <span class="comment">// this length includes the null terminator (it was written that way.)</span>
<a name="l03021"></a>03021         {
<a name="l03022"></a>03022             <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;%s: Error reading NymID for an encrypted symmetric key.\n&quot;</span>, szFunc);
<a name="l03023"></a>03023             free(nymid); nymid = NULL;
<a name="l03024"></a>03024             <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l03025"></a>03025         }
<a name="l03026"></a>03026         nRunningTotal += nReadNymID;
<a name="l03027"></a>03027         <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(nReadNymID == static_cast&lt;uint32_t&gt;(<span class="keyword">sizeof</span>(uint8_t) * nymid_len));
<a name="l03028"></a>03028 <span class="comment">//      OT_ASSERT(nymid_len == nReadNymID);</span>
<a name="l03029"></a>03029         <span class="comment">// ----------------------------------------------------------------------------</span>
<a name="l03030"></a>03030         nymid[nymid_len-1] = <span class="charliteral">&#39;\0&#39;</span>; <span class="comment">// for null terminator. If string is 10 bytes int64_t, it&#39;s from 0-9, and the null terminator is at index 9.</span>
<a name="l03031"></a>03031         <span class="keyword">const</span> <a class="code" href="class_o_t_string.html">OTString</a> loopStrNymID(reinterpret_cast&lt;char *&gt;(nymid));
<a name="l03032"></a>03032         free(nymid); nymid = NULL;
<a name="l03033"></a>03033         <span class="comment">// ****************************************************************************</span>
<a name="l03034"></a>03034         <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(5, <span class="stringliteral">&quot;%s: (LOOP) Current NymID: %s    Strlen:  %lld\n&quot;</span>, __FUNCTION__,
<a name="l03035"></a>03035                        loopStrNymID.Get(),
<a name="l03036"></a>03036                        <span class="keyword">static_cast&lt;</span>int64_t<span class="keyword">&gt;</span>(loopStrNymID.GetLength())
<a name="l03037"></a>03037                        );
<a name="l03038"></a>03038         <span class="comment">//</span>
<a name="l03039"></a>03039         <span class="comment">// loopStrNymID ... if this matches strNymID then it&#39;s the one we&#39;re looking for.</span>
<a name="l03040"></a>03040         <span class="comment">// But we have to load it all either way, just to iterate through them, so might</span>
<a name="l03041"></a>03041         <span class="comment">// as well load it all first, then check. If it matches, we use it and break.</span>
<a name="l03042"></a>03042         <span class="comment">// Otherwise we keep iterating until we find it.</span>
<a name="l03043"></a>03043         <span class="comment">//</span>
<a name="l03044"></a>03044         <span class="comment">// ----------------------------------------------------------------------------</span>
<a name="l03045"></a>03045         <span class="comment">// Read its network-order key content size (convert to host-order), and then</span>
<a name="l03046"></a>03046         <span class="comment">// read its key content.</span>
<a name="l03047"></a>03047         uint8_t      *  ek          = NULL;
<a name="l03048"></a>03048         uint32_t        eklen       = 0;
<a name="l03049"></a>03049         uint32_t        eklen_n     = 0;
<a name="l03050"></a>03050         uint32_t        nReadLength = 0;
<a name="l03051"></a>03051         uint32_t        nReadKey    = 0;
<a name="l03052"></a>03052         <span class="comment">// ----------------------------------------------------------------------------</span>
<a name="l03053"></a>03053         <span class="comment">// First we read the encrypted key size.</span>
<a name="l03054"></a>03054         <span class="comment">//</span>
<a name="l03055"></a>03055         <span class="keywordflow">if</span> (0 == (nReadLength = dataInput.<a class="code" href="class_o_t_data.html#a4892d79a257500ee8c798736ce0d1ba8">OTfread</a>(reinterpret_cast&lt;uint8_t *&gt;(&amp;eklen_n),
<a name="l03056"></a>03056                                                   static_cast&lt;uint32_t&gt;(<span class="keyword">sizeof</span>(eklen_n)))))
<a name="l03057"></a>03057         {
<a name="l03058"></a>03058             <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;%s: Error reading encrypted key size.\n&quot;</span>, szFunc);
<a name="l03059"></a>03059             <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l03060"></a>03060         }
<a name="l03061"></a>03061         nRunningTotal += nReadLength;
<a name="l03062"></a>03062         <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(nReadLength == static_cast&lt;uint32_t&gt;(<span class="keyword">sizeof</span>(eklen_n)));
<a name="l03063"></a>03063         <span class="comment">// ----------------------------------------------------------------------------</span>
<a name="l03064"></a>03064         <span class="comment">// convert that key size from network to host endian.</span>
<a name="l03065"></a>03065         <span class="comment">//</span>
<a name="l03066"></a>03066         eklen  = <span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(ntohl(static_cast&lt;uint32_t&gt;(eklen_n)));
<a name="l03067"></a>03067 <span class="comment">//      eklen  = EVP_PKEY_size(private_key);  // We read this size from file now...</span>
<a name="l03068"></a>03068 
<a name="l03069"></a>03069         <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(5, <span class="stringliteral">&quot;%s: EK length:  %lld   \n&quot;</span>, __FUNCTION__,
<a name="l03070"></a>03070                        static_cast&lt;int64_t&gt;(eklen));
<a name="l03071"></a>03071 
<a name="l03072"></a>03072 <span class="comment">//      nRunningTotal += eklen;  // Nope!</span>
<a name="l03073"></a>03073         <span class="comment">// ----------------------------------------------------------------------------</span>
<a name="l03074"></a>03074         ek     = <span class="keyword">static_cast&lt;</span>uint8_t*<span class="keyword">&gt;</span>(malloc(static_cast&lt;int32_t&gt;(eklen) * <span class="keyword">sizeof</span>(uint8_t)));  <span class="comment">// I assume this is for the AES key</span>
<a name="l03075"></a>03075         <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != ek);
<a name="l03076"></a>03076         memset(static_cast&lt;void *&gt;(ek), 0, static_cast&lt;int32_t&gt;(eklen));
<a name="l03077"></a>03077         <span class="comment">// ----------------------------------------------------------------------------</span>
<a name="l03078"></a>03078         <span class="comment">// Next we read the encrypted key itself...</span>
<a name="l03079"></a>03079         <span class="comment">//</span>
<a name="l03080"></a>03080         <span class="keywordflow">if</span> (0 == (nReadKey = dataInput.<a class="code" href="class_o_t_data.html#a4892d79a257500ee8c798736ce0d1ba8">OTfread</a>(reinterpret_cast&lt;uint8_t*&gt;(ek),
<a name="l03081"></a>03081                                                static_cast&lt;uint32_t&gt;(eklen))))
<a name="l03082"></a>03082         {
<a name="l03083"></a>03083             <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;%s: Error reading encrypted key.\n&quot;</span>, szFunc);
<a name="l03084"></a>03084             free(ek); ek = NULL;
<a name="l03085"></a>03085             <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l03086"></a>03086         }
<a name="l03087"></a>03087         nRunningTotal += nReadKey;
<a name="l03088"></a>03088 
<a name="l03089"></a>03089         <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(5, <span class="stringliteral">&quot;%s:    EK First byte: %d     EK Last byte: %d\n&quot;</span>, __FUNCTION__,
<a name="l03090"></a>03090                        static_cast&lt;int32_t&gt;(ek[0]),
<a name="l03091"></a>03091                        static_cast&lt;int32_t&gt;(ek[eklen-1])
<a name="l03092"></a>03092                        );
<a name="l03093"></a>03093 
<a name="l03094"></a>03094         <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(nReadKey == static_cast&lt;uint32_t&gt;(eklen));
<a name="l03095"></a>03095         <span class="comment">// ****************************************************************************</span>
<a name="l03096"></a>03096         <span class="comment">//</span>
<a name="l03097"></a>03097         <span class="comment">// If we &quot;found the key already&quot; that means we already found the right key on</span>
<a name="l03098"></a>03098         <span class="comment">// a previous iteration, so therefore we&#39;re *definitely* just going to throw</span>
<a name="l03099"></a>03099         <span class="comment">// THIS one away. We just continue on to the next iteration and keep counting</span>
<a name="l03100"></a>03100         <span class="comment">// the bytes.</span>
<a name="l03101"></a>03101         <span class="comment">//</span>
<a name="l03102"></a>03102         <span class="keywordflow">if</span> (<span class="keyword">false</span> == bFoundKeyAlready)
<a name="l03103"></a>03103         {
<a name="l03104"></a>03104             <span class="comment">// We have NOT found the right key yet, so let&#39;s see if this is the one we&#39;re looking for.</span>
<a name="l03105"></a>03105 
<a name="l03106"></a>03106             <span class="keyword">const</span> <span class="keywordtype">bool</span> bNymIDMatches = strNymID.<a class="code" href="class_o_t_string.html#a03401b39fb66d63696342c4f61ea8bf5">Compare</a>(loopStrNymID); <span class="comment">// FOUND IT! &lt;==========</span>
<a name="l03107"></a>03107 
<a name="l03108"></a>03108             <span class="keywordflow">if</span> ((ii == (array_size-1)) ||  <span class="comment">// If we&#39;re on the LAST INDEX in the array (often the only index), OR if the</span>
<a name="l03109"></a>03109                 bNymIDMatches)             <span class="comment">// NymID is a guaranteed match, then we&#39;ll try to decrypt using this session key.</span>
<a name="l03110"></a>03110             {                              <span class="comment">// (Of course also we know that we haven&#39;t found the Key yet, or we wouldn&#39;t even be here.)</span>
<a name="l03111"></a>03111                 <span class="comment">// NOTE: What if we&#39;re on the last index, but the NymID DOES exist, and it DEFINITELY doesn&#39;t match?</span>
<a name="l03112"></a>03112                 <span class="comment">// In other words, if loopStrNymID EXISTS, and it DEFINITELY doesn&#39;t match (bNymIDMatches is false) then we</span>
<a name="l03113"></a>03113                 <span class="comment">// DEFINITELY want to skip it. But if bNymIDMatches is false simply because loopStrNymID is EMPTY, then we</span>
<a name="l03114"></a>03114                 <span class="comment">// can&#39;t rule that key out, in that case.</span>
<a name="l03115"></a>03115                 <span class="comment">//</span>
<a name="l03116"></a>03116                 <span class="keywordflow">if</span> (!(loopStrNymID.Exists() &amp;&amp; !bNymIDMatches)) <span class="comment">// Skip if ID was definitely found and definitely doesn&#39;t match.</span>
<a name="l03117"></a>03117                 {
<a name="l03118"></a>03118                     bFoundKeyAlready = <span class="keyword">true</span>;
<a name="l03119"></a>03119 
<a name="l03120"></a>03120                     theRawEncryptedKey.<a class="code" href="class_o_t_data.html#a253cd3974cb837ad06980579eb7bc0e4">Assign</a>(static_cast&lt;void *&gt;(ek), static_cast&lt;uint32_t&gt;(eklen));
<a name="l03121"></a>03121 <span class="comment">//                  theRawEncryptedKey.Assign(const_cast&lt;const void *&gt;(static_cast&lt;void *&gt;(ek)), eklen);</span>
<a name="l03122"></a>03122                 }
<a name="l03123"></a>03123             }
<a name="l03124"></a>03124         }
<a name="l03125"></a>03125 
<a name="l03126"></a>03126         free(ek); ek = NULL;
<a name="l03127"></a>03127 
<a name="l03128"></a>03128     } <span class="comment">// for</span>
<a name="l03129"></a>03129     <span class="comment">// ------------------------------------------------------------------</span>
<a name="l03130"></a>03130 
<a name="l03131"></a>03131     <span class="keywordflow">if</span> (<span class="keyword">false</span> == bFoundKeyAlready) <span class="comment">// Todo: AND if list of POTENTIAL matches is also empty...</span>
<a name="l03132"></a>03132     {
<a name="l03133"></a>03133         <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(0, <span class="stringliteral">&quot;%s: Sorry: Unable to find a session key for the Nym attempting to open this envelope: %s\n&quot;</span>,
<a name="l03134"></a>03134                        __FUNCTION__, strNymID.<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>());
<a name="l03135"></a>03135         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l03136"></a>03136     }
<a name="l03137"></a>03137 
<a name="l03138"></a>03138     <span class="comment">// ****************************************************************************</span>
<a name="l03139"></a>03139     <span class="comment">//</span>
<a name="l03140"></a>03140     <span class="comment">// Read network-order IV size (convert to host version) before then reading IV itself.</span>
<a name="l03141"></a>03141     <span class="comment">// (Then update encrypted blocks until evp open final...)</span>
<a name="l03142"></a>03142     <span class="comment">//</span>
<a name="l03143"></a>03143     <span class="comment">// --------------------------------------------------</span>
<a name="l03144"></a>03144     <span class="comment">//</span>
<a name="l03145"></a>03145     <span class="keyword">const</span> uint32_t max_iv_length = <a class="code" href="class_o_t_crypto_config.html#ae6a1a4137bd87e84c342bb4e0149ca56">OTCryptoConfig::SymmetricIvSize</a>(); <span class="comment">// I believe this is a max length, so it may not match the actual length.</span>
<a name="l03146"></a>03146 
<a name="l03147"></a>03147     <span class="comment">// Read the IV SIZE (network order version -- convert to host version.)</span>
<a name="l03148"></a>03148     <span class="comment">//</span>
<a name="l03149"></a>03149     uint32_t    iv_size_n   = 0;
<a name="l03150"></a>03150     uint32_t    nReadIVSize = 0;
<a name="l03151"></a>03151 
<a name="l03152"></a>03152     <span class="keywordflow">if</span> (0 == (nReadIVSize = dataInput.<a class="code" href="class_o_t_data.html#a4892d79a257500ee8c798736ce0d1ba8">OTfread</a>(reinterpret_cast&lt;uint8_t*&gt;(&amp;iv_size_n),
<a name="l03153"></a>03153                                               static_cast&lt;uint32_t&gt;(<span class="keyword">sizeof</span>(iv_size_n)))))
<a name="l03154"></a>03154     {
<a name="l03155"></a>03155         <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;%s: Error reading IV Size for encrypted symmetric keys.\n&quot;</span>, szFunc);
<a name="l03156"></a>03156         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l03157"></a>03157     }
<a name="l03158"></a>03158     nRunningTotal += nReadIVSize;
<a name="l03159"></a>03159     <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(nReadIVSize == static_cast&lt;uint32_t&gt;(<span class="keyword">sizeof</span>(iv_size_n)));
<a name="l03160"></a>03160     <span class="comment">// ----------------------------------------------------------------------------</span>
<a name="l03161"></a>03161     <span class="comment">// convert that iv size from network to HOST endian.</span>
<a name="l03162"></a>03162     <span class="comment">//</span>
<a name="l03163"></a>03163     <span class="keyword">const</span> uint32_t iv_size_host_order = ntohl(static_cast&lt;uint32_t&gt;(iv_size_n));
<a name="l03164"></a>03164 
<a name="l03165"></a>03165     <span class="keywordflow">if</span> (iv_size_host_order &gt; max_iv_length)
<a name="l03166"></a>03166     {
<a name="l03167"></a>03167         <span class="keyword">const</span> int64_t l1 = iv_size_host_order, l2 = max_iv_length;
<a name="l03168"></a>03168         <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;%s: Error: iv_size (%lld) is larger than max_iv_length (%lld).\n&quot;</span>,
<a name="l03169"></a>03169                       __FUNCTION__, l1, l2);
<a name="l03170"></a>03170         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l03171"></a>03171     }
<a name="l03172"></a>03172     <span class="keywordflow">else</span>
<a name="l03173"></a>03173         <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(5, <span class="stringliteral">&quot;%s: IV size: %lld\n&quot;</span>, __FUNCTION__,
<a name="l03174"></a>03174                        static_cast&lt;int64_t&gt;(iv_size_host_order)
<a name="l03175"></a>03175                        );
<a name="l03176"></a>03176 
<a name="l03177"></a>03177     <span class="comment">// ****************************************************************************</span>
<a name="l03178"></a>03178     <span class="comment">//</span>
<a name="l03179"></a>03179     <span class="comment">// Then read the IV (initialization vector) itself.</span>
<a name="l03180"></a>03180     <span class="comment">//</span>
<a name="l03181"></a>03181     <span class="keywordflow">if</span> (0 == (nReadIV = dataInput.<a class="code" href="class_o_t_data.html#a4892d79a257500ee8c798736ce0d1ba8">OTfread</a>(reinterpret_cast&lt;uint8_t*&gt;(iv),
<a name="l03182"></a>03182                                           static_cast&lt;uint32_t&gt;(iv_size_host_order))))
<a name="l03183"></a>03183     {
<a name="l03184"></a>03184         <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;%s: Error reading initialization vector.\n&quot;</span>, szFunc);
<a name="l03185"></a>03185         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l03186"></a>03186     }
<a name="l03187"></a>03187 
<a name="l03188"></a>03188     nRunningTotal += nReadIV;
<a name="l03189"></a>03189     <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(nReadIV == static_cast&lt;uint32_t&gt;(iv_size_host_order));
<a name="l03190"></a>03190     <span class="comment">// ----------------------------------------------------------------------------</span>
<a name="l03191"></a>03191 
<a name="l03192"></a>03192     <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(5, <span class="stringliteral">&quot;%s:    IV First byte: %d     IV Last byte: %d\n&quot;</span>, __FUNCTION__,
<a name="l03193"></a>03193                    static_cast&lt;int32_t&gt;   (iv[0]),
<a name="l03194"></a>03194                    static_cast&lt;int32_t&gt;   (iv[iv_size_host_order-1])
<a name="l03195"></a>03195                    );
<a name="l03196"></a>03196 
<a name="l03197"></a>03197     <span class="comment">// We read the encrypted key size, then we read the encrypted key itself, with nReadKey containing</span>
<a name="l03198"></a>03198     <span class="comment">// the number of bytes actually read. The IF statement says &quot;if 0 ==&quot; but it should probably say</span>
<a name="l03199"></a>03199     <span class="comment">// &quot;if eklen !=&quot; (right?) Wrong: because I think it&#39;s a max length.</span>
<a name="l03200"></a>03200     <span class="comment">//</span>
<a name="l03201"></a>03201     <span class="comment">// We create an OTData object to store the ciphertext itself, which begins AFTER the end of the IV.</span>
<a name="l03202"></a>03202     <span class="comment">// So we see pointer + nRunningTotal as the starting point for the ciphertext.</span>
<a name="l03203"></a>03203     <span class="comment">// the size of the ciphertext, meanwhile, is the size of the entire thing, MINUS nRunningTotal.</span>
<a name="l03204"></a>03204     <span class="comment">//</span>
<a name="l03205"></a>03205     <a class="code" href="class_o_t_data.html">OTData</a> ciphertext(static_cast&lt;const void*&gt;(
<a name="l03206"></a>03206                                          static_cast&lt;const uint8_t *&gt;(dataInput.<a class="code" href="class_o_t_data.html#a649046d86480b41406a8b2d8529378e5">GetPointer</a>()) + nRunningTotal
<a name="l03207"></a>03207                                          ),
<a name="l03208"></a>03208                       dataInput.<a class="code" href="class_o_t_data.html#a18fd0599061eaf2c031548e030c3112d">GetSize</a>() - nRunningTotal);
<a name="l03209"></a>03209     <span class="comment">// ------------------------------------------------</span>
<a name="l03210"></a>03210     <span class="comment">//</span>
<a name="l03211"></a>03211     <span class="keyword">const</span> EVP_CIPHER * cipher_type = EVP_aes_128_cbc();  <span class="comment">// todo hardcoding.</span>
<a name="l03212"></a>03212     <span class="comment">//</span>
<a name="l03213"></a>03213     <span class="comment">//  OTPayload</span>
<a name="l03214"></a>03214     <span class="comment">//  void   SetPayloadSize   (uint32_t lNewSize);</span>
<a name="l03215"></a>03215     <span class="comment">//  const</span>
<a name="l03216"></a>03216     <span class="comment">//  void * GetPayloadPointer() const;</span>
<a name="l03217"></a>03217 
<a name="l03218"></a>03218     <span class="comment">//  OTData</span>
<a name="l03219"></a>03219     <span class="comment">//  inline</span>
<a name="l03220"></a>03220     <span class="comment">//  uint32_t     GetSize    () const { return m_lSize; }</span>
<a name="l03221"></a>03221     <span class="comment">//  bool         IsEmpty    () const;</span>
<a name="l03222"></a>03222     <span class="comment">//  virtual void Release    ();</span>
<a name="l03223"></a>03223     <span class="comment">//  void         Assign     (const void * pNewData, uint32_t lNewSize);</span>
<a name="l03224"></a>03224     <span class="comment">//  void         Concatenate(const void * pNewData, uint32_t lNewSize);</span>
<a name="l03225"></a>03225     <span class="comment">// ----------------------------------------------</span>
<a name="l03226"></a>03226     <span class="comment">// int32_t EVP_OpenInit(</span>
<a name="l03227"></a>03227     <span class="comment">//          EVP_CIPHER_CTX *ctx,</span>
<a name="l03228"></a>03228     <span class="comment">//          EVP_CIPHER *type,</span>
<a name="l03229"></a>03229     <span class="comment">//          uint8_t *ek,</span>
<a name="l03230"></a>03230     <span class="comment">//          int32_t ekl,</span>
<a name="l03231"></a>03231     <span class="comment">//          uint8_t *iv,</span>
<a name="l03232"></a>03232     <span class="comment">//          EVP_PKEY *priv);</span>
<a name="l03233"></a>03233     <span class="comment">// ----------------------------------------------</span>
<a name="l03234"></a>03234 <span class="comment">//  if (!EVP_OpenInit(&amp;ctx, cipher_type, ek, eklen, iv, private_key))</span>
<a name="l03235"></a>03235     <span class="keywordflow">if</span> (!EVP_OpenInit(&amp;ctx, cipher_type,
<a name="l03236"></a>03236                       static_cast&lt;const uint8_t *&gt;(theRawEncryptedKey.<a class="code" href="class_o_t_payload.html#aef8d7f40ba7886f7da16290091681aa9">GetPayloadPointer</a>()),
<a name="l03237"></a>03237                       static_cast&lt;int32_t&gt;(theRawEncryptedKey.<a class="code" href="class_o_t_data.html#a18fd0599061eaf2c031548e030c3112d">GetSize</a>()),
<a name="l03238"></a>03238                       static_cast&lt;const uint8_t *&gt;(iv),
<a name="l03239"></a>03239                       private_key))
<a name="l03240"></a>03240     {
<a name="l03241"></a>03241 
<a name="l03242"></a>03242         <span class="comment">//EVP_OpenInit() initializes a cipher context ctx for decryption with cipher type. It decrypts the encrypted</span>
<a name="l03243"></a>03243         <span class="comment">//  symmetric key of length ekl bytes passed in the ek parameter using the private key priv. The IV is supplied</span>
<a name="l03244"></a>03244         <span class="comment">//  in the iv parameter.</span>
<a name="l03245"></a>03245 
<a name="l03246"></a>03246         <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;%s: EVP_OpenInit: failed.\n&quot;</span>, szFunc);
<a name="l03247"></a>03247         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l03248"></a>03248     }
<a name="l03249"></a>03249 
<a name="l03250"></a>03250     <span class="comment">// ----------------------------------------------------------------------------</span>
<a name="l03251"></a>03251     <span class="comment">// Now we process ciphertext and write the decrypted data to plaintext.</span>
<a name="l03252"></a>03252     <span class="comment">//</span>
<a name="l03253"></a>03253     <a class="code" href="class_o_t_data.html">OTData</a> plaintext;
<a name="l03254"></a>03254 
<a name="l03255"></a>03255     <span class="comment">// We loop through the ciphertext and process it in blocks...</span>
<a name="l03256"></a>03256     <span class="comment">//</span>
<a name="l03257"></a>03257     <span class="keywordflow">while</span> (0 &lt; (len = ciphertext.OTfread(reinterpret_cast&lt;uint8_t*&gt;(buffer),
<a name="l03258"></a>03258                                          static_cast&lt;uint32_t&gt;(<span class="keyword">sizeof</span>(buffer)))))
<a name="l03259"></a>03259     {
<a name="l03260"></a>03260         <span class="keywordflow">if</span> (!EVP_OpenUpdate(&amp;ctx, buffer_out, &amp;len_out, buffer, static_cast&lt;int32_t&gt;(len)))
<a name="l03261"></a>03261         {
<a name="l03262"></a>03262             <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;%s: EVP_OpenUpdate: failed.\n&quot;</span>, szFunc);
<a name="l03263"></a>03263             <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l03264"></a>03264         }
<a name="l03265"></a>03265         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (len_out &gt; 0)
<a name="l03266"></a>03266             plaintext.<a class="code" href="class_o_t_data.html#a95c6d4d474bb010f504d0f2c7ae75211">Concatenate</a>(reinterpret_cast&lt;void *&gt;(buffer_out),
<a name="l03267"></a>03267                                   static_cast&lt;uint32_t&gt;(len_out));
<a name="l03268"></a>03268         <span class="keywordflow">else</span> <span class="keywordflow">break</span>;
<a name="l03269"></a>03269     }
<a name="l03270"></a>03270     <span class="comment">// -----------------------------------------------------</span>
<a name="l03271"></a>03271 
<a name="l03272"></a>03272     <span class="keywordflow">if</span> (!EVP_OpenFinal(&amp;ctx, buffer_out, &amp;len_out))
<a name="l03273"></a>03273     {
<a name="l03274"></a>03274         <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;%s: EVP_OpenFinal: failed.\n&quot;</span>, szFunc);
<a name="l03275"></a>03275         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l03276"></a>03276     }
<a name="l03277"></a>03277     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (len_out &gt; 0)
<a name="l03278"></a>03278     {
<a name="l03279"></a>03279         bFinalized = <span class="keyword">true</span>;
<a name="l03280"></a>03280         plaintext.<a class="code" href="class_o_t_data.html#a95c6d4d474bb010f504d0f2c7ae75211">Concatenate</a>(reinterpret_cast&lt;void *&gt;(buffer_out),
<a name="l03281"></a>03281                               static_cast&lt;uint32_t&gt;(len_out));
<a name="l03282"></a>03282 
<a name="l03283"></a>03283     }
<a name="l03284"></a>03284     <span class="keywordflow">else</span>
<a name="l03285"></a>03285         bFinalized = <span class="keyword">true</span>;
<a name="l03286"></a>03286 
<a name="l03287"></a>03287     <span class="comment">// -----------------------------------------------------</span>
<a name="l03288"></a>03288     <span class="comment">// Make sure it&#39;s null-terminated...</span>
<a name="l03289"></a>03289     <span class="comment">//</span>
<a name="l03290"></a>03290     uint32_t nIndex = plaintext.<a class="code" href="class_o_t_data.html#a18fd0599061eaf2c031548e030c3112d">GetSize</a>()-1; <span class="comment">// null terminator is already part of length here (it was, or at least should have been, sealed that way in the first place.)</span>
<a name="l03291"></a>03291     (<span class="keyword">static_cast&lt;</span>uint8_t*<span class="keyword">&gt;</span>(<span class="keyword">const_cast&lt;</span><span class="keywordtype">void</span>*<span class="keyword">&gt;</span>(plaintext.<a class="code" href="class_o_t_data.html#a649046d86480b41406a8b2d8529378e5">GetPointer</a>())))[nIndex] = <span class="charliteral">&#39;\0&#39;</span>;
<a name="l03292"></a>03292 
<a name="l03293"></a>03293     <span class="comment">// -----------------------------------------------------</span>
<a name="l03294"></a>03294     <span class="comment">// Set it into theOutput (to return the plaintext to the caller)</span>
<a name="l03295"></a>03295     <span class="comment">//</span>
<a name="l03296"></a>03296     <span class="comment">// if size is 10, then indices are 0..9 and we pass &#39;10&#39; as the size here.</span>
<a name="l03297"></a>03297     <span class="comment">// Since it&#39;s an OTData, then the 10th byte (at index 9) is expected to contain</span>
<a name="l03298"></a>03298     <span class="comment">// the null terminator.</span>
<a name="l03299"></a>03299     <span class="comment">// Thus the ACTUAL string is only 9 bytes int64_t, and is contained in indices 0..8.</span>
<a name="l03300"></a>03300     <span class="comment">//</span>
<a name="l03301"></a>03301     <span class="keyword">const</span> <span class="keywordtype">bool</span> bSetMem = theOutput.<a class="code" href="class_o_t_string.html#afe8b9f0781c0159cd7575b92af89bf9a">MemSet</a>(static_cast&lt;const char *&gt;(plaintext.<a class="code" href="class_o_t_data.html#a649046d86480b41406a8b2d8529378e5">GetPointer</a>()),
<a name="l03302"></a>03302                                           plaintext.<a class="code" href="class_o_t_data.html#a18fd0599061eaf2c031548e030c3112d">GetSize</a>());
<a name="l03303"></a>03303 
<a name="l03304"></a>03304     <span class="keywordflow">if</span> (bSetMem)
<a name="l03305"></a>03305         <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(5, <span class="stringliteral">&quot;%s: Output:\n%s\n\n&quot;</span>, __FUNCTION__, theOutput.<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>());
<a name="l03306"></a>03306     <span class="keywordflow">else</span>
<a name="l03307"></a>03307         <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;%s: Error: Failed while trying to memset from plaintext OTData to output OTString.\n&quot;</span>,
<a name="l03308"></a>03308                       __FUNCTION__);
<a name="l03309"></a>03309     <span class="comment">// ----------------</span>
<a name="l03310"></a>03310     <span class="keywordflow">return</span> bSetMem;
<a name="l03311"></a>03311 }
<a name="l03312"></a>03312 
<a name="l03313"></a>03313 
<a name="l03314"></a>03314 <span class="comment">// If length is 10,</span>
<a name="l03315"></a>03315 <span class="comment">// Then indices are 0..9</span>
<a name="l03316"></a>03316 <span class="comment">// Therefore &#39;9&#39; is the 10th byte, starting from 0.</span>
<a name="l03317"></a>03317 <span class="comment">// Therefore &quot;GetSize()&quot; would be 10,</span>
<a name="l03318"></a>03318 <span class="comment">// and &quot;GetSize()-1&quot; would be 9, which is the 10th byte starting from 0.</span>
<a name="l03319"></a>03319 <span class="comment">// Therefore if the string is 9 bytes int64_t, it will have data from 0 through 8, with 9 being \0.</span>
<a name="l03320"></a>03320 <span class="comment">// Normally you wouldn&#39;t expect a string to include the null terminator as part of its length.</span>
<a name="l03321"></a>03321 <span class="comment">// But for OTData, you WOULD expect the null 0 to be at the end.</span>
<a name="l03322"></a>03322 <span class="comment">//</span>
<a name="l03323"></a>03323 
<a name="l03324"></a>03324 
<a name="l03325"></a>03325 <span class="comment">/*</span>
<a name="l03326"></a>03326 <span class="comment"> * An implementation of RSA PSS digital signature using OpenSSL</span>
<a name="l03327"></a>03327 <span class="comment"> *</span>
<a name="l03328"></a>03328 <span class="comment"> * Copyright (c) 2009 Mounir IDRASSI &lt;mounir.idrassi@idrix.fr&gt;. All rights reserved.</span>
<a name="l03329"></a>03329 <span class="comment"> *</span>
<a name="l03330"></a>03330 <span class="comment"> * This program is distributed in the hope that it will be useful,</span>
<a name="l03331"></a>03331 <span class="comment"> * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY</span>
<a name="l03332"></a>03332 <span class="comment"> * or FITNESS FOR A PARTICULAR PURPOSE.</span>
<a name="l03333"></a>03333 <span class="comment"> *</span>
<a name="l03334"></a>03334 <span class="comment"> */</span>
<a name="l03335"></a>03335 <span class="comment">/*</span>
<a name="l03336"></a>03336 <span class="comment">// inside a comment here #include &lt;cstdio&gt;</span>
<a name="l03337"></a>03337 <span class="comment">// inside a comment here #include &lt;string.h&gt;</span>
<a name="l03338"></a>03338 <span class="comment">#include &lt;openssl/err.h&gt;</span>
<a name="l03339"></a>03339 <span class="comment">#include &lt;openssl/evp.h&gt;</span>
<a name="l03340"></a>03340 <span class="comment">#include &lt;openssl/rsa.h&gt;</span>
<a name="l03341"></a>03341 <span class="comment">#include &lt;openssl/rand.h&gt;</span>
<a name="l03342"></a>03342 <span class="comment"></span>
<a name="l03343"></a>03343 <span class="comment"></span>
<a name="l03344"></a>03344 <span class="comment">int32_t main(int32_t argc, char** argv)</span>
<a name="l03345"></a>03345 <span class="comment">{</span>
<a name="l03346"></a>03346 <span class="comment">    RSA* pRsaKey = NULL;</span>
<a name="l03347"></a>03347 <span class="comment">    uint8_t pDigest[32];</span>
<a name="l03348"></a>03348 <span class="comment">    size_t uDigestLen = 32;</span>
<a name="l03349"></a>03349 <span class="comment">    const char* szMessage = &quot;This is the string to be signed&quot;;</span>
<a name="l03350"></a>03350 <span class="comment">    EVP_MD_CTX md_ctx;</span>
<a name="l03351"></a>03351 <span class="comment">    uint8_t EM[128];</span>
<a name="l03352"></a>03352 <span class="comment">    uint8_t pSignature[128];</span>
<a name="l03353"></a>03353 <span class="comment">    uint8_t pDecrypted[128];</span>
<a name="l03354"></a>03354 <span class="comment">    int32_t status = 0;</span>
<a name="l03355"></a>03355 <span class="comment"></span>
<a name="l03356"></a>03356 <span class="comment">    // openssl initialization</span>
<a name="l03357"></a>03357 <span class="comment">    ERR_load_crypto_strings();</span>
<a name="l03358"></a>03358 <span class="comment">    OpenSSL_add_all_algorithms();</span>
<a name="l03359"></a>03359 <span class="comment"></span>
<a name="l03360"></a>03360 <span class="comment">#ifdef _WIN32</span>
<a name="l03361"></a>03361 <span class="comment">    RAND_screen();</span>
<a name="l03362"></a>03362 <span class="comment">#else</span>
<a name="l03363"></a>03363 <span class="comment">    RAND_poll();</span>
<a name="l03364"></a>03364 <span class="comment">#endif</span>
<a name="l03365"></a>03365 <span class="comment"></span>
<a name="l03366"></a>03366 <span class="comment">    // Generate an RSA key pair</span>
<a name="l03367"></a>03367 <span class="comment">    pRsaKey = RSA_generate_key(1024, 0x010001, NULL, NULL);</span>
<a name="l03368"></a>03368 <span class="comment">    if (!pRsaKey)</span>
<a name="l03369"></a>03369 <span class="comment">    {</span>
<a name="l03370"></a>03370 <span class="comment">        printf(&quot;RSA_generate_key failed with error %s\n&quot;, ERR_error_string(ERR_get_error(), NULL));</span>
<a name="l03371"></a>03371 <span class="comment">        goto prog_end;</span>
<a name="l03372"></a>03372 <span class="comment">    }</span>
<a name="l03373"></a>03373 <span class="comment"></span>
<a name="l03374"></a>03374 <span class="comment">    // hash the message</span>
<a name="l03375"></a>03375 <span class="comment">    EVP_MD_CTX_init(&amp;md_ctx);</span>
<a name="l03376"></a>03376 <span class="comment">    EVP_DigestInit(&amp;md_ctx, EVP_sha256());</span>
<a name="l03377"></a>03377 <span class="comment">    EVP_DigestUpdate(&amp;md_ctx, (const void*) szMessage, strlen(szMessage));</span>
<a name="l03378"></a>03378 <span class="comment">    EVP_DigestFinal(&amp;md_ctx, pDigest, &amp;uDigestLen);</span>
<a name="l03379"></a>03379 <span class="comment">    EVP_MD_CTX_cleanup(&amp;md_ctx);</span>
<a name="l03380"></a>03380 <span class="comment"></span>
<a name="l03381"></a>03381 <span class="comment">    // compute the PSS padded data</span>
<a name="l03382"></a>03382 <span class="comment">    status = RSA_padding_add_PKCS1_PSS(pRsaKey, EM, pDigest, EVP_sha256(), -2); //maximum salt length</span>
<a name="l03383"></a>03383 <span class="comment">    if (!status)</span>
<a name="l03384"></a>03384 <span class="comment">    {</span>
<a name="l03385"></a>03385 <span class="comment">        printf(&quot;RSA_padding_add_PKCS1_PSS failed with error %s\n&quot;, ERR_error_string(ERR_get_error(), NULL));</span>
<a name="l03386"></a>03386 <span class="comment">        goto prog_end;</span>
<a name="l03387"></a>03387 <span class="comment">    }</span>
<a name="l03388"></a>03388 <span class="comment"></span>
<a name="l03389"></a>03389 <span class="comment">    // perform digital signature</span>
<a name="l03390"></a>03390 <span class="comment">    status = RSA_private_encrypt(128, EM, pSignature, pRsaKey, RSA_NO_PADDING);</span>
<a name="l03391"></a>03391 <span class="comment">    if (status == -1)</span>
<a name="l03392"></a>03392 <span class="comment">    {</span>
<a name="l03393"></a>03393 <span class="comment">        printf(&quot;RSA_private_encrypt failed with error %s\n&quot;, ERR_error_string(ERR_get_error(), NULL));</span>
<a name="l03394"></a>03394 <span class="comment">        goto prog_end;</span>
<a name="l03395"></a>03395 <span class="comment">    }</span>
<a name="l03396"></a>03396 <span class="comment"></span>
<a name="l03397"></a>03397 <span class="comment">    // now we will verify the signature</span>
<a name="l03398"></a>03398 <span class="comment">    // Start by a RAW decrypt of the signature</span>
<a name="l03399"></a>03399 <span class="comment">    status = RSA_public_decrypt(128, pSignature, pDecrypted, pRsaKey, RSA_NO_PADDING);</span>
<a name="l03400"></a>03400 <span class="comment">    if (status == -1)</span>
<a name="l03401"></a>03401 <span class="comment">    {</span>
<a name="l03402"></a>03402 <span class="comment">        printf(&quot;RSA_public_decrypt failed with error %s\n&quot;, ERR_error_string(ERR_get_error(), NULL));</span>
<a name="l03403"></a>03403 <span class="comment">        goto prog_end;</span>
<a name="l03404"></a>03404 <span class="comment">    }</span>
<a name="l03405"></a>03405 <span class="comment"></span>
<a name="l03406"></a>03406 <span class="comment">    // verify the data</span>
<a name="l03407"></a>03407 <span class="comment">    status = RSA_verify_PKCS1_PSS(pRsaKey, pDigest, EVP_sha256(), pDecrypted, -2); // salt length recovered from signature</span>
<a name="l03408"></a>03408 <span class="comment">    if (status == 1)</span>
<a name="l03409"></a>03409 <span class="comment">    {</span>
<a name="l03410"></a>03410 <span class="comment">        printf(&quot;Signature verification successfull!\n&quot;);</span>
<a name="l03411"></a>03411 <span class="comment">    }</span>
<a name="l03412"></a>03412 <span class="comment">    else</span>
<a name="l03413"></a>03413 <span class="comment">    {</span>
<a name="l03414"></a>03414 <span class="comment">        printf(&quot;RSA_verify_PKCS1_PSS failed with error %s\n&quot;, ERR_error_string(ERR_get_error(), NULL));</span>
<a name="l03415"></a>03415 <span class="comment">        goto prog_end;</span>
<a name="l03416"></a>03416 <span class="comment">    }</span>
<a name="l03417"></a>03417 <span class="comment"></span>
<a name="l03418"></a>03418 <span class="comment">prog_end:</span>
<a name="l03419"></a>03419 <span class="comment">    if (pRsaKey)</span>
<a name="l03420"></a>03420 <span class="comment">        RSA_free(pRsaKey);</span>
<a name="l03421"></a>03421 <span class="comment"></span>
<a name="l03422"></a>03422 <span class="comment">    // openssl cleanup</span>
<a name="l03423"></a>03423 <span class="comment">    CRYPTO_cleanup_all_ex_data();</span>
<a name="l03424"></a>03424 <span class="comment">    RAND_cleanup();</span>
<a name="l03425"></a>03425 <span class="comment">    EVP_cleanup();</span>
<a name="l03426"></a>03426 <span class="comment">    ERR_free_strings();</span>
<a name="l03427"></a>03427 <span class="comment">    ERR_remove_state(0);</span>
<a name="l03428"></a>03428 <span class="comment"></span>
<a name="l03429"></a>03429 <span class="comment">    return 0;</span>
<a name="l03430"></a>03430 <span class="comment">}</span>
<a name="l03431"></a>03431 <span class="comment">*/</span>
<a name="l03432"></a>03432 
<a name="l03433"></a>03433 <span class="comment">// The default hashing algorithm in this software should be one that XOR combines two other,</span>
<a name="l03434"></a>03434 <span class="comment">// established and respected algorithms. In this case, we use the &quot;SAMY&quot; hash which is actually</span>
<a name="l03435"></a>03435 <span class="comment">// SHA512 XOR&#39;d with WHIRLPOOL (also 512 in output). Credit to SAMY for the idea.</span>
<a name="l03436"></a>03436 <span class="comment">//</span>
<a name="l03437"></a>03437 <span class="comment">// This way if one is ever cracked, our system is still strong, and we can swap it out.</span>
<a name="l03438"></a>03438 <span class="comment">// Thus, I had to write this special function so that if the Default hash algorithm is the one</span>
<a name="l03439"></a>03439 <span class="comment">// chosen, (&quot;SAMY&quot;) then we have to hash it twice using Hash1 (SHA512) and Hash2 (Whirlpool)</span>
<a name="l03440"></a>03440 <span class="comment">// before we encrypt it with the private key.</span>
<a name="l03441"></a>03441 <span class="comment">//</span>
<a name="l03442"></a>03442 <span class="comment">// Since the envelope (EVP) interface did not allow this, I had to Google everywhere to find</span>
<a name="l03443"></a>03443 <span class="comment">// lower-level code I could model.</span>
<a name="l03444"></a>03444 
<a name="l03445"></a>03445 <span class="comment">/*</span>
<a name="l03446"></a>03446 <span class="comment"> 128 bytes * 8 bits == 1024 bits key.  (RSA)</span>
<a name="l03447"></a>03447 <span class="comment"></span>
<a name="l03448"></a>03448 <span class="comment"> 64 bytes * 8 bits == 512 bits key (for WHIRLPOOL and SHA-512 message digests.)</span>
<a name="l03449"></a>03449 <span class="comment"></span>
<a name="l03450"></a>03450 <span class="comment"> BUT--now I want to allow various key sizes (above 1024...)</span>
<a name="l03451"></a>03451 <span class="comment"> and I also have a smaller message digest now: 256 bits.</span>
<a name="l03452"></a>03452 <span class="comment"></span>
<a name="l03453"></a>03453 <span class="comment"> */</span>
<a name="l03454"></a>03454 <span class="keywordtype">bool</span> OTCrypto_OpenSSL::OTCrypto_OpenSSLdp::SignContractDefaultHash(<span class="keyword">const</span> <a class="code" href="class_o_t_string.html">OTString</a>    &amp; strContractUnsigned,
<a name="l03455"></a>03455                                                                    <span class="keyword">const</span> EVP_PKEY    * pkey,
<a name="l03456"></a>03456                                                                    <a class="code" href="class_o_t_signature.html">OTSignature</a>       &amp; theSignature,
<a name="l03457"></a>03457                                                                    <a class="code" href="class_o_t_password_data.html">OTPasswordData</a>    * pPWData<span class="comment">/*=NULL*/</span>)<span class="keyword"> const</span>
<a name="l03458"></a>03458 <span class="keyword"></span>{
<a name="l03459"></a>03459     <span class="keyword">const</span> <span class="keywordtype">char</span> * szFunc = <span class="stringliteral">&quot;OTCrypto_OpenSSL::SignContractDefaultHash&quot;</span>;
<a name="l03460"></a>03460     <span class="comment">// -------------------------------</span>
<a name="l03461"></a>03461     <span class="keywordtype">bool</span> bReturnValue = <span class="keyword">false</span>;
<a name="l03462"></a>03462 
<a name="l03463"></a>03463     <span class="comment">// These two contain the output of the two message digest</span>
<a name="l03464"></a>03464     <span class="comment">// functions that we&#39;re using (SHA-256 and WHIRLPOOL.)</span>
<a name="l03465"></a>03465     <span class="comment">// the two output hashes are then merged together into this one.</span>
<a name="l03466"></a>03466     std::vector&lt;uint8_t&gt; vOutputHash1(<a class="code" href="class_o_t_crypto_config.html#a5a057078486934bf436028937bd338c6">OTCryptoConfig::SymmetricKeySizeMax</a>());
<a name="l03467"></a>03467     std::vector&lt;uint8_t&gt; vOutputHash2(<a class="code" href="class_o_t_crypto_config.html#a5a057078486934bf436028937bd338c6">OTCryptoConfig::SymmetricKeySizeMax</a>());
<a name="l03468"></a>03468     std::vector&lt;uint8_t&gt; vDigest     (<a class="code" href="class_o_t_crypto_config.html#a5a057078486934bf436028937bd338c6">OTCryptoConfig::SymmetricKeySizeMax</a>());
<a name="l03469"></a>03469 
<a name="l03470"></a>03470     <span class="comment">// This stores the message digest, pre-encrypted, but with the padding added.</span>
<a name="l03471"></a>03471     <span class="comment">// This stores the final signature, when the EM value has been signed by RSA private key.</span>
<a name="l03472"></a>03472     std::vector&lt;uint8_t&gt; vEM        (<a class="code" href="class_o_t_crypto_config.html#a30aaf4e08e6fa68ed59b458ab3787096">OTCryptoConfig::PublicKeysizeMax</a>());
<a name="l03473"></a>03473     std::vector&lt;uint8_t&gt; vpSignature(<a class="code" href="class_o_t_crypto_config.html#a30aaf4e08e6fa68ed59b458ab3787096">OTCryptoConfig::PublicKeysizeMax</a>());
<a name="l03474"></a>03474 
<a name="l03475"></a>03475     uint32_t    uDigest1Len  = <a class="code" href="class_o_t_crypto_config.html#ac643539dd99516aa4205241bd3c922bf">OTCryptoConfig::Digest1Size</a>(); <span class="comment">// 32 bytes == 256 bits. (These are used for function output below, not input.)</span>
<a name="l03476"></a>03476     uint32_t    uDigest2Len  = <a class="code" href="class_o_t_crypto_config.html#aa1580b84f8b414f060303194c82b19b8">OTCryptoConfig::Digest2Size</a>(); <span class="comment">// 64 bytes == 512 bits. (These are used for function output below, not input.)</span>
<a name="l03477"></a>03477     <span class="comment">// --------------------------</span>
<a name="l03478"></a>03478     EVP_MD_CTX  mdHash1_ctx, mdHash2_ctx;
<a name="l03479"></a>03479 
<a name="l03480"></a>03480 <span class="comment">//  OTPassword::zeroMemory(uint8_t * szMemory, uint32_t theSize);</span>
<a name="l03481"></a>03481 <span class="comment">//  OTPassword::zeroMemory(void * vMemory,     uint32_t theSize);</span>
<a name="l03482"></a>03482     <a class="code" href="class_o_t_password.html#a3a971b06f42d1c89802167a0ab5330a5">OTPassword::zeroMemory</a>(&amp;vOutputHash1.at(0), <a class="code" href="class_o_t_crypto_config.html#a5a057078486934bf436028937bd338c6">OTCryptoConfig::SymmetricKeySizeMax</a>());
<a name="l03483"></a>03483     <a class="code" href="class_o_t_password.html#a3a971b06f42d1c89802167a0ab5330a5">OTPassword::zeroMemory</a>(&amp;vOutputHash2.at(0), <a class="code" href="class_o_t_crypto_config.html#a5a057078486934bf436028937bd338c6">OTCryptoConfig::SymmetricKeySizeMax</a>());
<a name="l03484"></a>03484     <a class="code" href="class_o_t_password.html#a3a971b06f42d1c89802167a0ab5330a5">OTPassword::zeroMemory</a>(&amp;vDigest.at(0),      <a class="code" href="class_o_t_crypto_config.html#a5a057078486934bf436028937bd338c6">OTCryptoConfig::SymmetricKeySizeMax</a>());
<a name="l03485"></a>03485     <a class="code" href="class_o_t_password.html#a3a971b06f42d1c89802167a0ab5330a5">OTPassword::zeroMemory</a>(&amp;vEM.at(0),          <a class="code" href="class_o_t_crypto_config.html#a30aaf4e08e6fa68ed59b458ab3787096">OTCryptoConfig::PublicKeysizeMax</a>());
<a name="l03486"></a>03486     <a class="code" href="class_o_t_password.html#a3a971b06f42d1c89802167a0ab5330a5">OTPassword::zeroMemory</a>(&amp;vpSignature.at(0),  <a class="code" href="class_o_t_crypto_config.html#a30aaf4e08e6fa68ed59b458ab3787096">OTCryptoConfig::PublicKeysizeMax</a>());
<a name="l03487"></a>03487     <span class="comment">// --------------------------</span>
<a name="l03488"></a>03488     <span class="comment">// Here, we convert the EVP_PKEY that was passed in, to an RSA key for signing.</span>
<a name="l03489"></a>03489     <span class="comment">//</span>
<a name="l03490"></a>03490     RSA * pRsaKey = EVP_PKEY_get1_RSA(const_cast&lt; EVP_PKEY* &gt; (pkey));
<a name="l03491"></a>03491 
<a name="l03492"></a>03492     <span class="keywordflow">if</span> (!pRsaKey)
<a name="l03493"></a>03493     {
<a name="l03494"></a>03494         <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;%s: EVP_PKEY_get1_RSA failed with error %s\n&quot;</span>, szFunc,
<a name="l03495"></a>03495                       ERR_error_string(ERR_get_error(), NULL));
<a name="l03496"></a>03496         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l03497"></a>03497     }
<a name="l03498"></a>03498     <span class="comment">// --------------------------</span>
<a name="l03499"></a>03499     <span class="comment">// Since the idea of this special code is that we&#39;re using 2 hash algorithms,</span>
<a name="l03500"></a>03500     <span class="comment">// let&#39;s look them up and see what they are.</span>
<a name="l03501"></a>03501     <span class="comment">// addendum: unless we&#39;re on Android... then there&#39;s only 1 hash algorithm.</span>
<a name="l03502"></a>03502     <span class="comment">//</span>
<a name="l03503"></a>03503     <span class="keyword">const</span> EVP_MD * digest1 = OTCrypto_OpenSSL::OTCrypto_OpenSSLdp::GetOpenSSLDigestByName(<a class="code" href="class_o_t_identifier.html#a1999830fc99ab7f152a28322c32af45f">OTIdentifier::HashAlgorithm1</a>); <span class="comment">// SHA-256</span>
<a name="l03504"></a>03504 
<a name="l03505"></a>03505     <span class="keywordflow">if</span> (NULL == digest1)
<a name="l03506"></a>03506     {
<a name="l03507"></a>03507         <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;%s: Failure to load message digest algorithm.\n&quot;</span>, szFunc);
<a name="l03508"></a>03508         RSA_free(pRsaKey);  pRsaKey = NULL;
<a name="l03509"></a>03509         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l03510"></a>03510     }
<a name="l03511"></a>03511     <span class="comment">// --------------------------</span>
<a name="l03512"></a>03512     <span class="comment">// hash the contents of the contract with HashAlgorithm1 (SHA-256)</span>
<a name="l03513"></a>03513     EVP_MD_CTX_init   (&amp;mdHash1_ctx);
<a name="l03514"></a>03514     EVP_DigestInit    (&amp;mdHash1_ctx, digest1); <span class="comment">// digest1 is the actual algorithm</span>
<a name="l03515"></a>03515     EVP_DigestUpdate  (&amp;mdHash1_ctx, strContractUnsigned.<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>(), strContractUnsigned.<a class="code" href="class_o_t_string.html#a640392dd17a786dab643dbfc7e5a8672">GetLength</a>()); <span class="comment">// input</span>
<a name="l03516"></a>03516     EVP_DigestFinal   (&amp;mdHash1_ctx, &amp;vOutputHash1.at(0), &amp;uDigest1Len); <span class="comment">// output and length</span>
<a name="l03517"></a>03517     EVP_MD_CTX_cleanup(&amp;mdHash1_ctx); <span class="comment">// cleanup</span>
<a name="l03518"></a>03518 
<a name="l03519"></a>03519     <span class="comment">/*</span>
<a name="l03520"></a>03520 <span class="comment">     TODO:</span>
<a name="l03521"></a>03521 <span class="comment">     The functions EVP_DigestInit(), EVP_DigestFinal() and EVP_MD_CTX_copy() are obsolete but are retained to maintain compatibility</span>
<a name="l03522"></a>03522 <span class="comment">     with existing code. New applications should use EVP_DigestInit_ex(), EVP_DigestFinal_ex() and EVP_MD_CTX_copy_ex() because they</span>
<a name="l03523"></a>03523 <span class="comment">     can efficiently reuse a digest context instead of initializing and cleaning it up on each call and allow non default implementations</span>
<a name="l03524"></a>03524 <span class="comment">     of digests to be specified.</span>
<a name="l03525"></a>03525 <span class="comment">     */</span>
<a name="l03526"></a>03526 <span class="comment">//#ifndef ANDROID</span>
<a name="l03527"></a>03527     <span class="keyword">const</span> EVP_MD * digest2 = OTCrypto_OpenSSL::OTCrypto_OpenSSLdp::GetOpenSSLDigestByName(<a class="code" href="class_o_t_identifier.html#a1bd0ea93b2eeecc25f20b71bfad4f2b2">OTIdentifier::HashAlgorithm2</a>); <span class="comment">// WHIRLPOOL (512)</span>
<a name="l03528"></a>03528 
<a name="l03529"></a>03529     <span class="keywordflow">if</span> (NULL == digest2)
<a name="l03530"></a>03530     {
<a name="l03531"></a>03531         <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;%s: Failure to load message digest algorithm.\n&quot;</span>, szFunc);
<a name="l03532"></a>03532         RSA_free(pRsaKey);  pRsaKey = NULL;
<a name="l03533"></a>03533         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l03534"></a>03534     }
<a name="l03535"></a>03535     <span class="comment">// --------------------------</span>
<a name="l03536"></a>03536     <span class="comment">// hash the same contents with HashAlgorithm2 (WHIRLPOOL)</span>
<a name="l03537"></a>03537     EVP_MD_CTX_init   (&amp;mdHash2_ctx);
<a name="l03538"></a>03538     EVP_DigestInit    (&amp;mdHash2_ctx, digest2);  <span class="comment">// digest2 is the algorithm</span>
<a name="l03539"></a>03539     EVP_DigestUpdate  (&amp;mdHash2_ctx, strContractUnsigned.<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>(), strContractUnsigned.<a class="code" href="class_o_t_string.html#a640392dd17a786dab643dbfc7e5a8672">GetLength</a>()); <span class="comment">// Input</span>
<a name="l03540"></a>03540     EVP_DigestFinal   (&amp;mdHash2_ctx, &amp;vOutputHash2.at(0), &amp;uDigest2Len); <span class="comment">// output and length</span>
<a name="l03541"></a>03541     EVP_MD_CTX_cleanup(&amp;mdHash2_ctx); <span class="comment">// cleanup</span>
<a name="l03542"></a>03542 
<a name="l03543"></a>03543     <span class="comment">// (Goes with the smaller size.)</span>
<a name="l03544"></a>03544     <span class="keyword">const</span> uint32_t uDigestMergedLength = (uDigest1Len &gt; uDigest2Len ? uDigest2Len : uDigest1Len);
<a name="l03545"></a>03545 
<a name="l03546"></a>03546     <span class="comment">// XOR the two together</span>
<a name="l03547"></a>03547     <span class="comment">//</span>
<a name="l03548"></a>03548     <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; uDigestMergedLength; i++)
<a name="l03549"></a>03549     {
<a name="l03550"></a>03550         vDigest.at(i) = ((vOutputHash1.at(i)) ^ (vOutputHash2.at(i)));
<a name="l03551"></a>03551     }
<a name="l03552"></a>03552 <span class="comment">//#else // ANDROID</span>
<a name="l03553"></a>03553 <span class="comment">//  const uint32_t uDigestMergedLength = uDigest1Len;</span>
<a name="l03554"></a>03554 <span class="comment">//</span>
<a name="l03555"></a>03555 <span class="comment">//  for (int32_t i = 0; i &lt; uDigestMergedLength; i++)</span>
<a name="l03556"></a>03556 <span class="comment">//  {</span>
<a name="l03557"></a>03557 <span class="comment">//      pDigest[i] = (vOutputHash1.at(i));</span>
<a name="l03558"></a>03558 <span class="comment">//  }</span>
<a name="l03559"></a>03559 <span class="comment">//#endif // ANDROID</span>
<a name="l03560"></a>03560 
<a name="l03561"></a>03561     <span class="comment">// pDigest is now set up.</span>
<a name="l03562"></a>03562     <span class="comment">// uDigestMergedLength contains its length in bytes.</span>
<a name="l03563"></a>03563 
<a name="l03564"></a>03564     <span class="comment">// ---------------------------------------------------------</span>
<a name="l03565"></a>03565     <span class="comment">/*</span>
<a name="l03566"></a>03566 <span class="comment">     NOTE:</span>
<a name="l03567"></a>03567 <span class="comment">     RSA_sign only supports PKCS# 1 v1.5 padding which always gives the same</span>
<a name="l03568"></a>03568 <span class="comment">     output for the same input data.</span>
<a name="l03569"></a>03569 <span class="comment">     If you want to perfom a digital signature with PSS padding, you have to</span>
<a name="l03570"></a>03570 <span class="comment">     pad the data yourself by calling RSA_padding_add_PKCS1_PSS and then call</span>
<a name="l03571"></a>03571 <span class="comment">     RSA_private_encrypt on the padded output after setting its last</span>
<a name="l03572"></a>03572 <span class="comment">     parameter to RSA_NO_PADDING.</span>
<a name="l03573"></a>03573 <span class="comment"></span>
<a name="l03574"></a>03574 <span class="comment">     I have written a small sample code that shows how to perform PSS</span>
<a name="l03575"></a>03575 <span class="comment">     signature and verification. You can get the code from the following link:</span>
<a name="l03576"></a>03576 <span class="comment">     http://www.idrix.fr/Root/Samples/openssl_pss_signature.c</span>
<a name="l03577"></a>03577 <span class="comment"></span>
<a name="l03578"></a>03578 <span class="comment">     I hope this answers your questions.</span>
<a name="l03579"></a>03579 <span class="comment">     Cheers,</span>
<a name="l03580"></a>03580 <span class="comment">     --</span>
<a name="l03581"></a>03581 <span class="comment">     Mounir IDRASSI</span>
<a name="l03582"></a>03582 <span class="comment">     */</span>
<a name="l03583"></a>03583     <span class="comment">// compute the PSS padded data</span>
<a name="l03584"></a>03584     <span class="comment">// the result goes into EM.</span>
<a name="l03585"></a>03585 
<a name="l03586"></a>03586     <span class="comment">/*</span>
<a name="l03587"></a>03587 <span class="comment">     int32_t RSA_padding_add_PKCS1_PSS(RSA *rsa, uint8_t *EM,</span>
<a name="l03588"></a>03588 <span class="comment">     const uint8_t *mHash,</span>
<a name="l03589"></a>03589 <span class="comment">     const EVP_MD *Hash, int32_t sLen);</span>
<a name="l03590"></a>03590 <span class="comment">     */</span>
<a name="l03591"></a>03591     <span class="comment">//  int32_t RSA_padding_add_xxx(uint8_t *to, int32_t tlen,</span>
<a name="l03592"></a>03592     <span class="comment">//                          uint8_t *f, int32_t fl);</span>
<a name="l03593"></a>03593     <span class="comment">// RSA_padding_add_xxx() encodes *fl* bytes from *f* so as to fit into *tlen*</span>
<a name="l03594"></a>03594     <span class="comment">// bytes and stores the result at *to*.</span>
<a name="l03595"></a>03595     <span class="comment">// An error occurs if fl does not meet the size requirements of the encoding method.</span>
<a name="l03596"></a>03596     <span class="comment">// The RSA_padding_add_xxx() functions return 1 on success, 0 on error.</span>
<a name="l03597"></a>03597     <span class="comment">// The RSA_padding_check_xxx() functions return the length of the recovered data, -1 on error.</span>
<a name="l03598"></a>03598 
<a name="l03599"></a>03599     <span class="comment">//   rsa    EM  mHash     Hash    sLen</span>
<a name="l03600"></a>03600     <span class="comment">//    in    OUT   IN        in      in</span>
<a name="l03601"></a>03601     int32_t status = RSA_padding_add_PKCS1_PSS(pRsaKey, &amp;vEM.at(0), &amp;vDigest.at(0), digest1, -2); <span class="comment">//maximum salt length</span>
<a name="l03602"></a>03602 
<a name="l03603"></a>03603     <span class="comment">// Above, pDigest is the input, but its length is not needed, since it is determined</span>
<a name="l03604"></a>03604     <span class="comment">// by the digest algorithm (digest1.) In this case, that size is 32 bytes == 256 bits.</span>
<a name="l03605"></a>03605 
<a name="l03606"></a>03606     <span class="comment">// Also notice that digest1 and digest2 are both processed, and then digest1 is used here</span>
<a name="l03607"></a>03607     <span class="comment">// again, since RSA_padding_add_PKCS1_PSS requires a digest. Might be optimization opportunities there.</span>
<a name="l03608"></a>03608     <span class="comment">//</span>
<a name="l03609"></a>03609     <span class="comment">// More clearly: pDigest is 256 bits int64_t, aka 32 bytes. The call to RSA_padding_add_PKCS1_PSS above</span>
<a name="l03610"></a>03610     <span class="comment">// is transforming its contents based on digest1, into EM. Once this is done, the new digest stored in</span>
<a name="l03611"></a>03611     <span class="comment">// EM will be RSA_size(pRsaKey)-11 bytes in size, with the rest padded.</span>
<a name="l03612"></a>03612     <span class="comment">// Therefore if this is sucessful, then we can call RSA_private_encrypt without any further padding,</span>
<a name="l03613"></a>03613     <span class="comment">// since it&#39;s already accomplished here. EM itself will be RSA_size(pRsaKey) in size total (exactly.)</span>
<a name="l03614"></a>03614 
<a name="l03615"></a>03615     <span class="keywordflow">if</span> (!status)  <span class="comment">// 1 or 0.</span>
<a name="l03616"></a>03616     {
<a name="l03617"></a>03617         <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;%s: RSA_padding_add_PKCS1_PSS failure: %s\n&quot;</span>,
<a name="l03618"></a>03618                       ERR_error_string(ERR_get_error(), NULL));
<a name="l03619"></a>03619         RSA_free(pRsaKey);  pRsaKey = NULL;
<a name="l03620"></a>03620         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l03621"></a>03621     }
<a name="l03622"></a>03622 
<a name="l03623"></a>03623     <span class="comment">// EM is now set up.</span>
<a name="l03624"></a>03624     <span class="comment">// But how big is it? Answer: RSA_size(pRsaKey)</span>
<a name="l03625"></a>03625     <span class="comment">// No size is returned because the whole point of RSA_padding_add_PKCS1_PSS is to safely pad</span>
<a name="l03626"></a>03626     <span class="comment">// pDigest into EM within a specific size based on the keysize.</span>
<a name="l03627"></a>03627 
<a name="l03628"></a>03628     <span class="comment">// RSA_padding_check_xxx() verifies that the fl bytes at f contain a valid encoding for a rsa_len byte RSA key in the respective</span>
<a name="l03629"></a>03629     <span class="comment">// encoding method and stores the recovered data of at most tlen bytes (for RSA_NO_PADDING: of size tlen) at to.</span>
<a name="l03630"></a>03630 
<a name="l03631"></a>03631     <span class="comment">// RSA_private_encrypt</span>
<a name="l03632"></a>03632     <span class="comment">//  int32_t RSA_private_encrypt(int32_t flen, uint8_t *from,</span>
<a name="l03633"></a>03633     <span class="comment">//                          uint8_t *to, RSA *rsa, int32_t padding);</span>
<a name="l03634"></a>03634     <span class="comment">// RSA_private_encrypt() signs the *flen* bytes at *from* (usually a message digest with</span>
<a name="l03635"></a>03635     <span class="comment">// an algorithm identifier) using the private key rsa and stores the signature in *to*.</span>
<a name="l03636"></a>03636     <span class="comment">// to must point to RSA_size(rsa) bytes of memory.</span>
<a name="l03637"></a>03637     <span class="comment">// RSA_private_encrypt() returns the size of the signature (i.e., RSA_size(rsa)).</span>
<a name="l03638"></a>03638     <span class="comment">//</span>
<a name="l03639"></a>03639     status = RSA_private_encrypt(RSA_size(pRsaKey),     <span class="comment">// input</span>
<a name="l03640"></a>03640                                  &amp;vEM.at(0),                    <span class="comment">// padded message digest (input)</span>
<a name="l03641"></a>03641                                  &amp;vpSignature.at(0),            <span class="comment">// encrypted padded message digest (output)</span>
<a name="l03642"></a>03642                                  pRsaKey,               <span class="comment">// private key (input )</span>
<a name="l03643"></a>03643                                  RSA_NO_PADDING);       <span class="comment">// why not RSA_PKCS1_PADDING ? (Custom padding above in PSS mode with two hashes.)</span>
<a name="l03644"></a>03644 
<a name="l03645"></a>03645     <span class="keywordflow">if</span> (status == -1)
<a name="l03646"></a>03646     {
<a name="l03647"></a>03647         <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;%s: RSA_private_encrypt failure: %s\n&quot;</span>, szFunc,
<a name="l03648"></a>03648                       ERR_error_string(ERR_get_error(), NULL));
<a name="l03649"></a>03649         RSA_free(pRsaKey);  pRsaKey = NULL;
<a name="l03650"></a>03650         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l03651"></a>03651     }
<a name="l03652"></a>03652     <span class="comment">// status contains size</span>
<a name="l03653"></a>03653 
<a name="l03654"></a>03654     <a class="code" href="class_o_t_data.html">OTData</a> binSignature(&amp;vpSignature.at(0), status); <span class="comment">// RSA_private_encrypt actually returns the right size.</span>
<a name="l03655"></a>03655 <span class="comment">//  OTData binSignature(pSignature, 128);    // stop hardcoding this block size.</span>
<a name="l03656"></a>03656 
<a name="l03657"></a>03657     <span class="comment">// theSignature that was passed in, now contains the final signature.</span>
<a name="l03658"></a>03658     <span class="comment">// The contents were hashed twice, and the resulting hashes were</span>
<a name="l03659"></a>03659     <span class="comment">// XOR&#39;d together, and then padding was added, and then it was signed</span>
<a name="l03660"></a>03660     <span class="comment">// with the private key.</span>
<a name="l03661"></a>03661     theSignature.<a class="code" href="class_o_t_a_s_c_i_i_armor.html#a48e0e2e2eff86ad382a2cc63298a0b8b">SetData</a>(binSignature, <span class="keyword">true</span>); <span class="comment">// true means, &quot;yes, with newlines in the b64-encoded output, please.&quot;</span>
<a name="l03662"></a>03662     bReturnValue = <span class="keyword">true</span>;
<a name="l03663"></a>03663     <span class="comment">// ---------------------------------------------------------</span>
<a name="l03664"></a>03664     <span class="keywordflow">if</span> (pRsaKey)
<a name="l03665"></a>03665         RSA_free(pRsaKey);
<a name="l03666"></a>03666     pRsaKey = NULL;
<a name="l03667"></a>03667     <span class="comment">// ---------------------------------------------------------</span>
<a name="l03668"></a>03668     <span class="keywordflow">return</span> bReturnValue;
<a name="l03669"></a>03669 }
<a name="l03670"></a>03670 
<a name="l03671"></a>03671 
<a name="l03672"></a>03672 <span class="comment">// Verify a contract that has been signed with our own default algorithm (aka SAMY hash)</span>
<a name="l03673"></a>03673 <span class="comment">// Basically we had to customize for that algorithm since, by default, it XORs two different</span>
<a name="l03674"></a>03674 <span class="comment">// algorithms together (SHA256 and WHIRLPOOL) in anticipation of the day that one of them is</span>
<a name="l03675"></a>03675 <span class="comment">// broken.</span>
<a name="l03676"></a>03676 
<a name="l03677"></a>03677 <span class="keywordtype">bool</span> OTCrypto_OpenSSL::OTCrypto_OpenSSLdp::VerifyContractDefaultHash(<span class="keyword">const</span> <a class="code" href="class_o_t_string.html">OTString</a>    &amp; strContractToVerify,
<a name="l03678"></a>03678                                                                      <span class="keyword">const</span> EVP_PKEY    * pkey,
<a name="l03679"></a>03679                                                                      <span class="keyword">const</span> <a class="code" href="class_o_t_signature.html">OTSignature</a> &amp; theSignature,
<a name="l03680"></a>03680                                                                      <a class="code" href="class_o_t_password_data.html">OTPasswordData</a>    * pPWData<span class="comment">/*=NULL*/</span>)<span class="keyword"> const</span>
<a name="l03681"></a>03681 <span class="keyword"></span>{
<a name="l03682"></a>03682     <span class="keyword">const</span> <span class="keywordtype">char</span> * szFunc = <span class="stringliteral">&quot;OTCrypto_OpenSSL::VerifyContractDefaultHash&quot;</span>;
<a name="l03683"></a>03683     <span class="comment">// ----------------------------</span>
<a name="l03684"></a>03684     <span class="keywordtype">bool</span> bReturnValue = <span class="keyword">false</span>;
<a name="l03685"></a>03685 
<a name="l03686"></a>03686     std::vector&lt;uint8_t&gt; vOutputHash1(<a class="code" href="class_o_t_crypto_config.html#a5a057078486934bf436028937bd338c6">OTCryptoConfig::SymmetricKeySizeMax</a>());   <span class="comment">// These two contain the output of the two message digest</span>
<a name="l03687"></a>03687     std::vector&lt;uint8_t&gt; vOutputHash2(<a class="code" href="class_o_t_crypto_config.html#a5a057078486934bf436028937bd338c6">OTCryptoConfig::SymmetricKeySizeMax</a>());   <span class="comment">// functions that we&#39;re using (SHA-256 and WHIRLPOOL.)</span>
<a name="l03688"></a>03688     std::vector&lt;uint8_t&gt; vDigest(<a class="code" href="class_o_t_crypto_config.html#a5a057078486934bf436028937bd338c6">OTCryptoConfig::SymmetricKeySizeMax</a>()); <span class="comment">// the two output hashes are then merged together into this one.</span>
<a name="l03689"></a>03689 
<a name="l03690"></a>03690     std::vector&lt;uint8_t&gt; vDecrypted(<a class="code" href="class_o_t_crypto_config.html#a30aaf4e08e6fa68ed59b458ab3787096">OTCryptoConfig::PublicKeysizeMax</a>());    <span class="comment">// Contains the decrypted signature.</span>
<a name="l03691"></a>03691 
<a name="l03692"></a>03692     uint32_t    uDigest1Len = <a class="code" href="class_o_t_crypto_config.html#ac643539dd99516aa4205241bd3c922bf">OTCryptoConfig::Digest1Size</a>(); <span class="comment">// 32 bytes == 256 bits. (These are used for function output below, not input.)</span>
<a name="l03693"></a>03693     uint32_t    uDigest2Len = <a class="code" href="class_o_t_crypto_config.html#aa1580b84f8b414f060303194c82b19b8">OTCryptoConfig::Digest2Size</a>(); <span class="comment">// 64 bytes == 512 bits. (These are used for function output below, not input.)</span>
<a name="l03694"></a>03694     <span class="comment">// ----------------------------</span>
<a name="l03695"></a>03695     EVP_MD_CTX mdHash1_ctx, mdHash2_ctx;
<a name="l03696"></a>03696 
<a name="l03697"></a>03697     <a class="code" href="class_o_t_password.html#a3a971b06f42d1c89802167a0ab5330a5">OTPassword::zeroMemory</a>(&amp;vOutputHash1.at(0), <a class="code" href="class_o_t_crypto_config.html#a5a057078486934bf436028937bd338c6">OTCryptoConfig::SymmetricKeySizeMax</a>());
<a name="l03698"></a>03698     <a class="code" href="class_o_t_password.html#a3a971b06f42d1c89802167a0ab5330a5">OTPassword::zeroMemory</a>(&amp;vOutputHash2.at(0), <a class="code" href="class_o_t_crypto_config.html#a5a057078486934bf436028937bd338c6">OTCryptoConfig::SymmetricKeySizeMax</a>());
<a name="l03699"></a>03699     <a class="code" href="class_o_t_password.html#a3a971b06f42d1c89802167a0ab5330a5">OTPassword::zeroMemory</a>(&amp;vDigest.at(0),      <a class="code" href="class_o_t_crypto_config.html#a5a057078486934bf436028937bd338c6">OTCryptoConfig::SymmetricKeySizeMax</a>());
<a name="l03700"></a>03700     <a class="code" href="class_o_t_password.html#a3a971b06f42d1c89802167a0ab5330a5">OTPassword::zeroMemory</a>(&amp;vDecrypted.at(0),   <a class="code" href="class_o_t_crypto_config.html#a30aaf4e08e6fa68ed59b458ab3787096">OTCryptoConfig::PublicKeysizeMax</a>());
<a name="l03701"></a>03701 
<a name="l03702"></a>03702     <span class="comment">// --------------------------</span>
<a name="l03703"></a>03703     <span class="comment">// Here, we convert the EVP_PKEY that was passed in, to an RSA key for signing.</span>
<a name="l03704"></a>03704     RSA* pRsaKey = EVP_PKEY_get1_RSA(const_cast&lt; EVP_PKEY* &gt;(pkey));
<a name="l03705"></a>03705 
<a name="l03706"></a>03706     <span class="keywordflow">if</span> (!pRsaKey)
<a name="l03707"></a>03707     {
<a name="l03708"></a>03708         <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;%s: EVP_PKEY_get1_RSA failed with error %s\n&quot;</span>, szFunc,
<a name="l03709"></a>03709                       ERR_error_string(ERR_get_error(), NULL));
<a name="l03710"></a>03710         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l03711"></a>03711     }
<a name="l03712"></a>03712     <span class="comment">// --------------------------</span>
<a name="l03713"></a>03713     <span class="comment">// Since the idea of this special code is that we&#39;re using 2 hash algorithms,</span>
<a name="l03714"></a>03714     <span class="comment">// let&#39;s look them up and see what they are.</span>
<a name="l03715"></a>03715     <span class="keyword">const</span> EVP_MD * digest1 = OTCrypto_OpenSSL::OTCrypto_OpenSSLdp::GetOpenSSLDigestByName(<a class="code" href="class_o_t_identifier.html#a1999830fc99ab7f152a28322c32af45f">OTIdentifier::HashAlgorithm1</a>); <span class="comment">// SHA-256</span>
<a name="l03716"></a>03716     <span class="keywordflow">if</span> (NULL == digest1)
<a name="l03717"></a>03717     {
<a name="l03718"></a>03718         <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;%s: Failure to load message digest algorithm.\n&quot;</span>, szFunc);
<a name="l03719"></a>03719         RSA_free(pRsaKey); pRsaKey = NULL;
<a name="l03720"></a>03720         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l03721"></a>03721     }
<a name="l03722"></a>03722     <span class="comment">// ----------------------------</span>
<a name="l03723"></a>03723     <span class="comment">// hash the contents of the contract with HashAlgorithm1 (SHA-256)</span>
<a name="l03724"></a>03724     EVP_MD_CTX_init   (&amp;mdHash1_ctx);
<a name="l03725"></a>03725     EVP_DigestInit    (&amp;mdHash1_ctx, digest1); <span class="comment">// digest1 is the algorithm itself</span>
<a name="l03726"></a>03726     EVP_DigestUpdate  (&amp;mdHash1_ctx, strContractToVerify.<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>(), strContractToVerify.<a class="code" href="class_o_t_string.html#a640392dd17a786dab643dbfc7e5a8672">GetLength</a>()); <span class="comment">// input</span>
<a name="l03727"></a>03727     EVP_DigestFinal   (&amp;mdHash1_ctx, &amp;vOutputHash1.at(0), &amp;uDigest1Len); <span class="comment">// output and size</span>
<a name="l03728"></a>03728     EVP_MD_CTX_cleanup(&amp;mdHash1_ctx); <span class="comment">// cleanup</span>
<a name="l03729"></a>03729     <span class="comment">// ----------------------------</span>
<a name="l03730"></a>03730 <span class="comment">//#ifndef ANDROID   // NOT Android.</span>
<a name="l03731"></a>03731     <span class="keyword">const</span> EVP_MD * digest2 = OTCrypto_OpenSSL::OTCrypto_OpenSSLdp::GetOpenSSLDigestByName(<a class="code" href="class_o_t_identifier.html#a1bd0ea93b2eeecc25f20b71bfad4f2b2">OTIdentifier::HashAlgorithm2</a>); <span class="comment">// WHIRLPOOL</span>
<a name="l03732"></a>03732     <span class="keywordflow">if</span> (NULL == digest2)
<a name="l03733"></a>03733     {
<a name="l03734"></a>03734         <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;%s: Failure to load message digest algorithm.\n&quot;</span>, szFunc);
<a name="l03735"></a>03735         RSA_free(pRsaKey); pRsaKey = NULL;
<a name="l03736"></a>03736         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l03737"></a>03737     }
<a name="l03738"></a>03738 
<a name="l03739"></a>03739     <span class="comment">// hash the same contents with HashAlgorithm2 (WHIRLPOOL)</span>
<a name="l03740"></a>03740     EVP_MD_CTX_init   (&amp;mdHash2_ctx);
<a name="l03741"></a>03741     EVP_DigestInit    (&amp;mdHash2_ctx, digest2); <span class="comment">// digest2 is the algorithm itself</span>
<a name="l03742"></a>03742     EVP_DigestUpdate  (&amp;mdHash2_ctx, strContractToVerify.<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>(), strContractToVerify.<a class="code" href="class_o_t_string.html#a640392dd17a786dab643dbfc7e5a8672">GetLength</a>()); <span class="comment">// Input</span>
<a name="l03743"></a>03743     EVP_DigestFinal   (&amp;mdHash2_ctx, &amp;vOutputHash2.at(0), &amp;uDigest2Len); <span class="comment">// output and size</span>
<a name="l03744"></a>03744     EVP_MD_CTX_cleanup(&amp;mdHash2_ctx); <span class="comment">// cleanup</span>
<a name="l03745"></a>03745 
<a name="l03746"></a>03746     <span class="comment">// (Goes with the smaller size.)</span>
<a name="l03747"></a>03747     <span class="keyword">const</span> uint32_t uDigestMergedLength = (uDigest1Len &gt; uDigest2Len ? uDigest2Len : uDigest1Len);
<a name="l03748"></a>03748 
<a name="l03749"></a>03749     <span class="comment">// XOR the two together</span>
<a name="l03750"></a>03750     <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; uDigestMergedLength; i++)
<a name="l03751"></a>03751     {
<a name="l03752"></a>03752         vDigest.at(i) = ((vOutputHash1.at(i)) ^ (vOutputHash2.at(i)));
<a name="l03753"></a>03753     }
<a name="l03754"></a>03754 <span class="comment">//#else // ** is ** ANDROID</span>
<a name="l03755"></a>03755 <span class="comment">//    // ----------------------------</span>
<a name="l03756"></a>03756 <span class="comment">//  // (Goes with the smaller size.)</span>
<a name="l03757"></a>03757 <span class="comment">//  const uint32_t uDigestMergedLength = uDigest1Len;</span>
<a name="l03758"></a>03758 <span class="comment">//</span>
<a name="l03759"></a>03759 <span class="comment">//  for (int32_t i = 0; i &lt; uDigest1Len; i++)</span>
<a name="l03760"></a>03760 <span class="comment">//  {</span>
<a name="l03761"></a>03761 <span class="comment">//      pDigest[i] = (pOutputHash1[i]);</span>
<a name="l03762"></a>03762 <span class="comment">//  }</span>
<a name="l03763"></a>03763 <span class="comment">//#endif // ANDROID</span>
<a name="l03764"></a>03764 
<a name="l03765"></a>03765     <span class="comment">// Now we have the exact content in pDigest that we should also see if we decrypt</span>
<a name="l03766"></a>03766     <span class="comment">// the signature that was passed in.</span>
<a name="l03767"></a>03767     <span class="comment">//</span>
<a name="l03768"></a>03768     <span class="comment">// ---------------------------------------------------------</span>
<a name="l03769"></a>03769     <a class="code" href="class_o_t_payload.html">OTPayload</a> binSignature;
<a name="l03770"></a>03770 
<a name="l03771"></a>03771     <span class="comment">// This will cause binSignature to contain the base64 decoded binary of the</span>
<a name="l03772"></a>03772     <span class="comment">// signature that we&#39;re verifying. Unless the call fails of course...</span>
<a name="l03773"></a>03773     <span class="comment">//</span>
<a name="l03774"></a>03774     <span class="keywordflow">if</span> ((theSignature.<a class="code" href="class_o_t_string.html#a640392dd17a786dab643dbfc7e5a8672">GetLength</a>() &lt; 10) || (<span class="keyword">false</span> == theSignature.<a class="code" href="class_o_t_a_s_c_i_i_armor.html#a5564f05ead3366c5b97c8b7edfea083b">GetData</a>(binSignature)))
<a name="l03775"></a>03775     {
<a name="l03776"></a>03776         <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;%s: Error decoding base64 data for Signature.\n&quot;</span>, szFunc);
<a name="l03777"></a>03777         RSA_free(pRsaKey); pRsaKey = NULL;
<a name="l03778"></a>03778         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l03779"></a>03779     }
<a name="l03780"></a>03780     <span class="comment">// --------------------------------------------------------</span>
<a name="l03781"></a>03781     <span class="keyword">const</span> int32_t nSignatureSize = <span class="keyword">static_cast&lt;</span>int32_t<span class="keyword">&gt;</span> (binSignature.<a class="code" href="class_o_t_data.html#a18fd0599061eaf2c031548e030c3112d">GetSize</a>()); <span class="comment">// converting from unsigned to signed (since openssl wants it that way.)</span>
<a name="l03782"></a>03782 
<a name="l03783"></a>03783     <span class="keywordflow">if</span> ((binSignature.<a class="code" href="class_o_t_data.html#a18fd0599061eaf2c031548e030c3112d">GetSize</a>() &lt; <span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(RSA_size(pRsaKey))) ||
<a name="l03784"></a>03784         (nSignatureSize         &lt; RSA_size(pRsaKey))) <span class="comment">// this one probably unnecessary.</span>
<a name="l03785"></a>03785     {
<a name="l03786"></a>03786         <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;%s: Decoded base64-encoded data for signature, but resulting size was &lt; RSA_size(pRsaKey): &quot;</span>
<a name="l03787"></a>03787                       <span class="stringliteral">&quot;Signed: %d. Unsigned: %u.\n&quot;</span>, szFunc, nSignatureSize, binSignature.<a class="code" href="class_o_t_data.html#a18fd0599061eaf2c031548e030c3112d">GetSize</a>());
<a name="l03788"></a>03788         RSA_free(pRsaKey); pRsaKey = NULL;
<a name="l03789"></a>03789         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l03790"></a>03790     }
<a name="l03791"></a>03791     <span class="comment">// ----------------------------</span>
<a name="l03792"></a>03792     <span class="comment">// now we will verify the signature</span>
<a name="l03793"></a>03793     <span class="comment">// Start by a RAW decrypt of the signature</span>
<a name="l03794"></a>03794     <span class="comment">// output goes to pDecrypted</span>
<a name="l03795"></a>03795     <span class="comment">// FYI: const void * binSignature.GetPointer()</span>
<a name="l03796"></a>03796 
<a name="l03797"></a>03797     <span class="comment">// RSA_PKCS1_OAEP_PADDING</span>
<a name="l03798"></a>03798     <span class="comment">// RSA_PKCS1_PADDING</span>
<a name="l03799"></a>03799 
<a name="l03800"></a>03800     <span class="comment">// the 128 in the below call was a BUG. The SIZE of the ciphertext (signature) being decrypted is NOT 128 (modulus / cleartext size).</span>
<a name="l03801"></a>03801     <span class="comment">// Rather, the size of the signature is RSA_size(pRsaKey).  Will have to revisit this likely, elsewhere in the code.</span>
<a name="l03802"></a>03802     <span class="comment">//  status = RSA_public_decrypt(128, static_cast&lt;const uint8_t*&gt;(binSignature.GetPointer()), pDecrypted, pRsaKey, RSA_NO_PADDING);</span>
<a name="l03803"></a>03803     int32_t status = RSA_public_decrypt(nSignatureSize, <span class="comment">// length of signature, aka RSA_size(rsa)</span>
<a name="l03804"></a>03804                                     static_cast&lt;const uint8_t*&gt;(binSignature.<a class="code" href="class_o_t_payload.html#aef8d7f40ba7886f7da16290091681aa9">GetPayloadPointer</a>()), <span class="comment">// location of signature</span>
<a name="l03805"></a>03805                                     &amp;vDecrypted.at(0),      <span class="comment">// Output--must be large enough to hold the md (which is smaller than RSA_size(rsa) - 11)</span>
<a name="l03806"></a>03806                                     pRsaKey,        <span class="comment">// signer&#39;s public key</span>
<a name="l03807"></a>03807                                     RSA_NO_PADDING);
<a name="l03808"></a>03808 
<a name="l03809"></a>03809     <span class="comment">// int32_t RSA_public_decrypt(int32_t flen, uint8_t *from,</span>
<a name="l03810"></a>03810     <span class="comment">//                          uint8_t *to, RSA *rsa, int32_t padding);</span>
<a name="l03811"></a>03811 
<a name="l03812"></a>03812     <span class="comment">// RSA_public_decrypt() recovers the message digest from the *flen* bytes int64_t signature at *from*,</span>
<a name="l03813"></a>03813     <span class="comment">// using the signer&#39;s public key *rsa*.</span>
<a name="l03814"></a>03814     <span class="comment">// padding is the padding mode that was used to sign the data.</span>
<a name="l03815"></a>03815     <span class="comment">// *to* must point to a memory section large enough to hold the message digest</span>
<a name="l03816"></a>03816     <span class="comment">// (which is smaller than RSA_size(rsa) - 11).</span>
<a name="l03817"></a>03817     <span class="comment">// RSA_public_decrypt() returns the size of the recovered message digest.</span>
<a name="l03818"></a>03818     <span class="comment">/*</span>
<a name="l03819"></a>03819 <span class="comment">     message to be encrypted, an octet string of length at</span>
<a name="l03820"></a>03820 <span class="comment">     most k-2-2hLen, where k is the length in octets of the</span>
<a name="l03821"></a>03821 <span class="comment">     modulus n and hLen is the length in octets of the hash</span>
<a name="l03822"></a>03822 <span class="comment">     function output for EME-OAEP</span>
<a name="l03823"></a>03823 <span class="comment">     */</span>
<a name="l03824"></a>03824     <span class="comment">// ----------------------------</span>
<a name="l03825"></a>03825     <span class="keywordflow">if</span> (status == -1) <span class="comment">// Error</span>
<a name="l03826"></a>03826     {
<a name="l03827"></a>03827         <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;%s: RSA_public_decrypt failed with error %s\n&quot;</span>, szFunc,
<a name="l03828"></a>03828                       ERR_error_string(ERR_get_error(), NULL));
<a name="l03829"></a>03829         RSA_free(pRsaKey); pRsaKey = NULL;
<a name="l03830"></a>03830         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l03831"></a>03831     }
<a name="l03832"></a>03832     <span class="comment">// status contains size of recovered message digest after signature decryption.</span>
<a name="l03833"></a>03833     <span class="comment">// ----------------------------</span>
<a name="l03834"></a>03834     <span class="comment">// verify the data</span>
<a name="l03835"></a>03835     <span class="comment">// Now it compares pDecrypted (the decrypted message digest from the signature) with pDigest</span>
<a name="l03836"></a>03836     <span class="comment">// (supposedly the same message digest, which we calculated above based on the message itself.)</span>
<a name="l03837"></a>03837     <span class="comment">// They SHOULD be the same.</span>
<a name="l03838"></a>03838     <span class="comment">/*</span>
<a name="l03839"></a>03839 <span class="comment">     int32_t RSA_verify_PKCS1_PSS(RSA *rsa, const uint8_t *mHash,</span>
<a name="l03840"></a>03840 <span class="comment">     const EVP_MD *Hash, const uint8_t *EM, int32_t sLen)</span>
<a name="l03841"></a>03841 <span class="comment">     */</span>                         <span class="comment">// rsa      mHash   Hash alg.   EM       sLen</span>
<a name="l03842"></a>03842     status = RSA_verify_PKCS1_PSS(pRsaKey, &amp;vDigest.at(0), digest1, &amp;vDecrypted.at(0), -2); <span class="comment">// salt length recovered from signature</span>
<a name="l03843"></a>03843 
<a name="l03844"></a>03844     <span class="keywordflow">if</span> (status == 1)
<a name="l03845"></a>03845     {
<a name="l03846"></a>03846         <a class="code" href="class_o_t_log.html#a1f7549d776ee919dcb6517f611ded015">OTLog::Output</a>(5, <span class="stringliteral">&quot;  *Signature verified*\n&quot;</span>);
<a name="l03847"></a>03847         bReturnValue = <span class="keyword">true</span>;
<a name="l03848"></a>03848     }
<a name="l03849"></a>03849     <span class="keywordflow">else</span>
<a name="l03850"></a>03850     {
<a name="l03851"></a>03851         <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(5, <span class="stringliteral">&quot;%s: RSA_verify_PKCS1_PSS failed with error: %s\n&quot;</span>, szFunc,
<a name="l03852"></a>03852                        ERR_error_string(ERR_get_error(), NULL));
<a name="l03853"></a>03853         RSA_free(pRsaKey); pRsaKey = NULL;
<a name="l03854"></a>03854         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l03855"></a>03855     }
<a name="l03856"></a>03856     <span class="comment">// ----------------------------</span>
<a name="l03857"></a>03857     <span class="comment">/*</span>
<a name="l03858"></a>03858 <span class="comment"></span>
<a name="l03859"></a>03859 <span class="comment">     NOTE:</span>
<a name="l03860"></a>03860 <span class="comment">     RSA_private_encrypt() signs the flen bytes at from (usually a message digest with an algorithm identifier)</span>
<a name="l03861"></a>03861 <span class="comment">     using the private key rsa and stores the signature in to. to must point to RSA_size(rsa) bytes of memory.</span>
<a name="l03862"></a>03862 <span class="comment"></span>
<a name="l03863"></a>03863 <span class="comment">     From: http://linux.die.net/man/3/rsa_public_decrypt</span>
<a name="l03864"></a>03864 <span class="comment"></span>
<a name="l03865"></a>03865 <span class="comment">     RSA_NO_PADDING</span>
<a name="l03866"></a>03866 <span class="comment">     Raw RSA signature. This mode should only be used to implement cryptographically sound padding modes in the application code.</span>
<a name="l03867"></a>03867 <span class="comment">     Signing user data directly with RSA is insecure.</span>
<a name="l03868"></a>03868 <span class="comment"></span>
<a name="l03869"></a>03869 <span class="comment">     RSA_PKCS1_PADDING</span>
<a name="l03870"></a>03870 <span class="comment">     PKCS #1 v1.5 padding. This function does not handle the algorithmIdentifier specified in PKCS #1. When generating or verifying</span>
<a name="l03871"></a>03871 <span class="comment">     PKCS #1 signatures, rsa_sign(3) and rsa_verify(3) should be used.</span>
<a name="l03872"></a>03872 <span class="comment"></span>
<a name="l03873"></a>03873 <span class="comment">     Need to research this and make sure it&#39;s being done right.</span>
<a name="l03874"></a>03874 <span class="comment"></span>
<a name="l03875"></a>03875 <span class="comment">     Perhaps my use of the lower-level call here is related to my use of two message-digest algorithms.</span>
<a name="l03876"></a>03876 <span class="comment">     -------------------------------</span>
<a name="l03877"></a>03877 <span class="comment"></span>
<a name="l03878"></a>03878 <span class="comment">     On Sun, Feb 25, 2001 at 08:04:55PM -0500, Greg Stark wrote:</span>
<a name="l03879"></a>03879 <span class="comment"></span>
<a name="l03880"></a>03880 <span class="comment">     &gt; It is not a bug, it is a known fact. As Joseph Ashwood notes, you end up</span>
<a name="l03881"></a>03881 <span class="comment">     &gt; trying to encrypt values that are larger than the modulus. The documentation</span>
<a name="l03882"></a>03882 <span class="comment">     &gt; and most literature do tend to refer to moduli as having a certain &quot;length&quot;</span>
<a name="l03883"></a>03883 <span class="comment">     &gt; in bits or bytes. This is fine for most discussions, but if you are planning</span>
<a name="l03884"></a>03884 <span class="comment">     &gt; to use RSA to directly encrypt/decrypt AND you are not willing or able to</span>
<a name="l03885"></a>03885 <span class="comment">     &gt; use one of the padding schemes, then you&#39;ll have to understand *all* the</span>
<a name="l03886"></a>03886 <span class="comment">     &gt; details. One of these details is that it is possible to supply</span>
<a name="l03887"></a>03887 <span class="comment">     &gt; RSA_public_encrypt() with plaintext values that are greater than the modulus</span>
<a name="l03888"></a>03888 <span class="comment">     &gt; N. It returns values that are always between 0 and N-1, which is the only</span>
<a name="l03889"></a>03889 <span class="comment">     &gt; reasonable behavior. Similarly, RSA_public_decrypt() returns values between</span>
<a name="l03890"></a>03890 <span class="comment">     &gt; 0 and N-1.</span>
<a name="l03891"></a>03891 <span class="comment"></span>
<a name="l03892"></a>03892 <span class="comment">     I have to confess I totally overlooked that and just assumed that if</span>
<a name="l03893"></a>03893 <span class="comment">     RSA_size(key) would be 1024, then I would be able to encrypt messages of 1024</span>
<a name="l03894"></a>03894 <span class="comment">     bits.</span>
<a name="l03895"></a>03895 <span class="comment"></span>
<a name="l03896"></a>03896 <span class="comment">     &gt; There are multiple solutions to this problem. A generally useful one</span>
<a name="l03897"></a>03897 <span class="comment">     &gt; is to use the RSA PKCS#1 ver 1.5 padding</span>
<a name="l03898"></a>03898 <span class="comment">     &gt; (http://www.rsalabs.com/pkcs/pkcs-1/index.html). If you don&#39;t like that</span>
<a name="l03899"></a>03899 <span class="comment">     &gt; padding scheme, then you might want to read the PKCS#1 document for the</span>
<a name="l03900"></a>03900 <span class="comment">     &gt; reasons behind that padding scheme and decide for yourself where you can</span>
<a name="l03901"></a>03901 <span class="comment">     &gt; modify it. It sounds like it be easiest if you just follow Mr. Ashwood&#39;s</span>
<a name="l03902"></a>03902 <span class="comment">     &gt; advice. Is there some problem with that?</span>
<a name="l03903"></a>03903 <span class="comment"></span>
<a name="l03904"></a>03904 <span class="comment">     Yes well, upon reading the PKCS#1 v1.5 document I noticed that Mr. Ashwood</span>
<a name="l03905"></a>03905 <span class="comment">     solves this problem by not only making the most significant bit zero, but in</span>
<a name="l03906"></a>03906 <span class="comment">     fact the 6 most significant bits.</span>
<a name="l03907"></a>03907 <span class="comment"></span>
<a name="l03908"></a>03908 <span class="comment">     I don&#39;t want to use one of the padding schemes because I already know the</span>
<a name="l03909"></a>03909 <span class="comment">     message size in advance, and so does a possible attacker. Using a padding</span>
<a name="l03910"></a>03910 <span class="comment">     scheme would therefore add known plaintext, which does not improve security.</span>
<a name="l03911"></a>03911 <span class="comment"></span>
<a name="l03912"></a>03912 <span class="comment">     But thank you for the link! I think this solves my problem now :).</span>
<a name="l03913"></a>03913 <span class="comment">     */</span>
<a name="l03914"></a>03914 
<a name="l03915"></a>03915     <span class="comment">/*</span>
<a name="l03916"></a>03916 <span class="comment">     #include &lt;openssl/rsa.h&gt;</span>
<a name="l03917"></a>03917 <span class="comment"></span>
<a name="l03918"></a>03918 <span class="comment">     int32_t RSA_sign(int32_t type, const uint8_t *m, uint32_t m_len,</span>
<a name="l03919"></a>03919 <span class="comment">     uint8_t *sigret, uint32_t *siglen, RSA *rsa);</span>
<a name="l03920"></a>03920 <span class="comment">     int32_t RSA_verify(int32_t type, const uint8_t *m, uint32_t m_len,</span>
<a name="l03921"></a>03921 <span class="comment">     uint8_t *sigbuf, uint32_t siglen, RSA *rsa);</span>
<a name="l03922"></a>03922 <span class="comment"></span>
<a name="l03923"></a>03923 <span class="comment">     DESCRIPTION</span>
<a name="l03924"></a>03924 <span class="comment"></span>
<a name="l03925"></a>03925 <span class="comment">     RSA_sign() signs the message digest m of size m_len using the private key rsa as specified in PKCS #1 v2.0.</span>
<a name="l03926"></a>03926 <span class="comment">     It stores the signature in sigret and the signature size in siglen. sigret must point to RSA_size(rsa) bytes of memory.</span>
<a name="l03927"></a>03927 <span class="comment"></span>
<a name="l03928"></a>03928 <span class="comment">     type denotes the message digest algorithm that was used to generate m. It usually is one of NID_sha1, NID_ripemd160</span>
<a name="l03929"></a>03929 <span class="comment">     and NID_md5; see objects(3) for details. If type is NID_md5_sha1, an SSL signature (MD5 and SHA1 message digests with</span>
<a name="l03930"></a>03930 <span class="comment">     PKCS #1 padding and no algorithm identifier) is created.</span>
<a name="l03931"></a>03931 <span class="comment"></span>
<a name="l03932"></a>03932 <span class="comment">     RSA_verify() verifies that the signature sigbuf of size siglen matches a given message digest m of size m_len. type</span>
<a name="l03933"></a>03933 <span class="comment">     denotes the message digest algorithm that was used to generate the signature. rsa is the signer&#39;s public key.</span>
<a name="l03934"></a>03934 <span class="comment"></span>
<a name="l03935"></a>03935 <span class="comment">     RETURN VALUES</span>
<a name="l03936"></a>03936 <span class="comment"></span>
<a name="l03937"></a>03937 <span class="comment">     RSA_sign() returns 1 on success, 0 otherwise. RSA_verify() returns 1 on successful verification, 0 otherwise.</span>
<a name="l03938"></a>03938 <span class="comment"></span>
<a name="l03939"></a>03939 <span class="comment">     The error codes can be obtained by ERR_get_error(3).</span>
<a name="l03940"></a>03940 <span class="comment">     */</span>
<a name="l03941"></a>03941 
<a name="l03942"></a>03942     <span class="comment">/*</span>
<a name="l03943"></a>03943 <span class="comment">     Hello,</span>
<a name="l03944"></a>03944 <span class="comment">     &gt; I am getting the following error in calling OCSP_basic_verify():</span>
<a name="l03945"></a>03945 <span class="comment">     &gt;</span>
<a name="l03946"></a>03946 <span class="comment">     &gt; error:04067084:rsa routines:RSA_EAY_PUBLIC_DECRYPT:data too large for modulus</span>
<a name="l03947"></a>03947 <span class="comment">     &gt;</span>
<a name="l03948"></a>03948 <span class="comment">     &gt; Could somebody advice what is going wrong?</span>
<a name="l03949"></a>03949 <span class="comment"></span>
<a name="l03950"></a>03950 <span class="comment">     In RSA you can encrypt/decrypt only as much data as RSA key size</span>
<a name="l03951"></a>03951 <span class="comment">     (size of RSA key is the size of modulus n = p*q).</span>
<a name="l03952"></a>03952 <span class="comment">     In this situation, RSA routine checks size of data to decrypt</span>
<a name="l03953"></a>03953 <span class="comment">     (probably signature) and this size of bigger than RSA key size,</span>
<a name="l03954"></a>03954 <span class="comment">     this if of course error.</span>
<a name="l03955"></a>03955 <span class="comment">     I think that in this situation this is possible when OCSP was signed</span>
<a name="l03956"></a>03956 <span class="comment">     with (for example) 2048 bit key (private key) and you have some</span>
<a name="l03957"></a>03957 <span class="comment">     certificate with (maybe old) 1024 bit public key.</span>
<a name="l03958"></a>03958 <span class="comment">     In this case this error may happen.</span>
<a name="l03959"></a>03959 <span class="comment">     My suggestion is to check signer certificate.</span>
<a name="l03960"></a>03960 <span class="comment"></span>
<a name="l03961"></a>03961 <span class="comment">     Best regards,</span>
<a name="l03962"></a>03962 <span class="comment">     --</span>
<a name="l03963"></a>03963 <span class="comment">     Marek Marcola &lt;[EMAIL PROTECTED]&gt;</span>
<a name="l03964"></a>03964 <span class="comment"></span>
<a name="l03965"></a>03965 <span class="comment"></span>
<a name="l03966"></a>03966 <span class="comment"></span>
<a name="l03967"></a>03967 <span class="comment">     Daniel Stenberg | 16 Jul 19:57</span>
<a name="l03968"></a>03968 <span class="comment"></span>
<a name="l03969"></a>03969 <span class="comment">     Re: SSL cert error with CURLOPT_SSL_VERIFYPEER</span>
<a name="l03970"></a>03970 <span class="comment"></span>
<a name="l03971"></a>03971 <span class="comment">     On Thu, 16 Jul 2009, Stephen Collyer wrote:</span>
<a name="l03972"></a>03972 <span class="comment"></span>
<a name="l03973"></a>03973 <span class="comment">     &gt; error:04067084:rsa routines:RSA_EAY_PUBLIC_DECRYPT:data too large for</span>
<a name="l03974"></a>03974 <span class="comment">     &gt; modulus</span>
<a name="l03975"></a>03975 <span class="comment"></span>
<a name="l03976"></a>03976 <span class="comment">     This sounds like an OpenSSL problem to me.</span>
<a name="l03977"></a>03977 <span class="comment"></span>
<a name="l03978"></a>03978 <span class="comment"></span>
<a name="l03979"></a>03979 <span class="comment"></span>
<a name="l03980"></a>03980 <span class="comment">     http://www.mail-archive.com/openssl-users@openssl.org/msg38183.html</span>
<a name="l03981"></a>03981 <span class="comment">     On Tue, Dec 07, 2004, Jesse Hammons wrote:</span>
<a name="l03982"></a>03982 <span class="comment"></span>
<a name="l03983"></a>03983 <span class="comment">     &gt;</span>
<a name="l03984"></a>03984 <span class="comment">     &gt; &gt; Jesse Hammons wrote:</span>
<a name="l03985"></a>03985 <span class="comment">     &gt; &gt;</span>
<a name="l03986"></a>03986 <span class="comment">     &gt; &gt;&gt; So to clarify: If I generate a 65-bit key, will I be able to use that</span>
<a name="l03987"></a>03987 <span class="comment">     &gt; &gt;&gt; 65-bit key to sign any 64-bit value?</span>
<a name="l03988"></a>03988 <span class="comment">     &gt; &gt;</span>
<a name="l03989"></a>03989 <span class="comment">     &gt; &gt; Yes, but</span>
<a name="l03990"></a>03990 <span class="comment">     &gt;</span>
<a name="l03991"></a>03991 <span class="comment">     &gt; Actually, I have found the answer to be &quot;no&quot; :-)</span>
<a name="l03992"></a>03992 <span class="comment">     &gt;</span>
<a name="l03993"></a>03993 <span class="comment">     &gt; &gt; a 65 bit key won&#39;t be very secure AT ALL, it will be</span>
<a name="l03994"></a>03994 <span class="comment">     &gt; &gt; very easy to factor a modulus that small.</span>
<a name="l03995"></a>03995 <span class="comment">     &gt;</span>
<a name="l03996"></a>03996 <span class="comment">     &gt; Security is not my goal.  This is more of a theoretical exercise that</span>
<a name="l03997"></a>03997 <span class="comment">     &gt; happens to have a practical application for me.</span>
<a name="l03998"></a>03998 <span class="comment">     &gt;</span>
<a name="l03999"></a>03999 <span class="comment">     &gt; &gt;  Bottom line: asymmetrical</span>
<a name="l04000"></a>04000 <span class="comment">     &gt; &gt; (public-key) encryption has a fairly large &quot;minimum block size&quot; that</span>
<a name="l04001"></a>04001 <span class="comment">     &gt; &gt; actually increases as key size increases.</span>
<a name="l04002"></a>04002 <span class="comment">     &gt;</span>
<a name="l04003"></a>04003 <span class="comment">     &gt; Indeed.  I have found experimentally that:</span>
<a name="l04004"></a>04004 <span class="comment">     &gt;  * The minimum signable data quantity in OpenSSL is 1 byte</span>
<a name="l04005"></a>04005 <span class="comment">     &gt;  * The minimum size RSA key that can be used to sign 1 byte is 89 bits</span>
<a name="l04006"></a>04006 <span class="comment">     &gt;  * A signature created using a 64-bit RSA key would create a number 64</span>
<a name="l04007"></a>04007 <span class="comment">     &gt; bits int64_t, BUT:</span>
<a name="l04008"></a>04008 <span class="comment">     &gt;    - This is not possible to do in OpenSSL because the maximum signable</span>
<a name="l04009"></a>04009 <span class="comment">     &gt; quantity for a 64</span>
<a name="l04010"></a>04010 <span class="comment">     &gt;       bit RSA key is only a few bits, and OpenSSL input/output is done on</span>
<a name="l04011"></a>04011 <span class="comment">     &gt; byte boundaries</span>
<a name="l04012"></a>04012 <span class="comment">     &gt;</span>
<a name="l04013"></a>04013 <span class="comment">     &gt; Do those number sound right?</span>
<a name="l04014"></a>04014 <span class="comment"></span>
<a name="l04015"></a>04015 <span class="comment">     It depends on the padding mode. These insert/delete padding bytes depending on</span>
<a name="l04016"></a>04016 <span class="comment">     the mode used. If you use the no padding mode you can &quot;sign&quot; data equal to the</span>
<a name="l04017"></a>04017 <span class="comment">     modulus length but less than its magnitude.</span>
<a name="l04018"></a>04018 <span class="comment"></span>
<a name="l04019"></a>04019 <span class="comment">     Check the manual pages (e.g. RSA_private_encrypt()) for more info.</span>
<a name="l04020"></a>04020 <span class="comment"></span>
<a name="l04021"></a>04021 <span class="comment"></span>
<a name="l04022"></a>04022 <span class="comment"></span>
<a name="l04023"></a>04023 <span class="comment"></span>
<a name="l04024"></a>04024 <span class="comment"></span>
<a name="l04025"></a>04025 <span class="comment">     http://www.mail-archive.com/openssl-users@openssl.org/msg29731.html</span>
<a name="l04026"></a>04026 <span class="comment">     Hmm, the error message &quot;RSA_R_DATA_TOO_LARGE_FOR_MODULUS&quot;</span>
<a name="l04027"></a>04027 <span class="comment">     is triggered by:</span>
<a name="l04028"></a>04028 <span class="comment"></span>
<a name="l04029"></a>04029 <span class="comment">     ... (from RSA_eay_private_encrypt() in rsa_eay.c)</span>
<a name="l04030"></a>04030 <span class="comment">     if (BN_ucmp(&amp;f, rsa-&gt;n) &gt;= 0)</span>
<a name="l04031"></a>04031 <span class="comment">     {</span>
<a name="l04032"></a>04032 <span class="comment">     // usually the padding functions would catch this</span>
<a name="l04033"></a>04033 <span class="comment">     RSAerr(...,RSA_R_DATA_TOO_LARGE_FOR_MODULUS);</span>
<a name="l04034"></a>04034 <span class="comment">     goto err;</span>
<a name="l04035"></a>04035 <span class="comment">     }</span>
<a name="l04036"></a>04036 <span class="comment">     ...</span>
<a name="l04037"></a>04037 <span class="comment">     =&gt; the error message has nothing to do with PKCS#1. It should tell you</span>
<a name="l04038"></a>04038 <span class="comment">     that your plaintext (as a BIGNUM) is greater (or equal) than the modulus.</span>
<a name="l04039"></a>04039 <span class="comment">     The typical error message in case of PKCS#1 error (in your case) would</span>
<a name="l04040"></a>04040 <span class="comment">     be &quot;RSA_R_DATA_TOO_LARGE_FOR_KEY_SIZE&quot;.</span>
<a name="l04041"></a>04041 <span class="comment"></span>
<a name="l04042"></a>04042 <span class="comment">     &gt; I can arrange for the plaintext to be a little smaller: 14 octets is</span>
<a name="l04043"></a>04043 <span class="comment">     &gt; definitely doable. (The 15 octet length for the ciphertext I can&#39;t exceed.)</span>
<a name="l04044"></a>04044 <span class="comment">     &gt; If I arrange for the plaintext to be a zero followed by 14 octets of data,</span>
<a name="l04045"></a>04045 <span class="comment">     &gt; can I make this work?</span>
<a name="l04046"></a>04046 <span class="comment"></span>
<a name="l04047"></a>04047 <span class="comment">     it should work (, but what about a longer (== more secure) key ?)</span>
<a name="l04048"></a>04048 <span class="comment"></span>
<a name="l04049"></a>04049 <span class="comment">     Regards,</span>
<a name="l04050"></a>04050 <span class="comment">     Nils</span>
<a name="l04051"></a>04051 <span class="comment"></span>
<a name="l04052"></a>04052 <span class="comment"></span>
<a name="l04053"></a>04053 <span class="comment"></span>
<a name="l04054"></a>04054 <span class="comment"></span>
<a name="l04055"></a>04055 <span class="comment">     For reasons that would be tedious to rehearse, the size of the encrypted block has to be not more than 15 octets.</span>
<a name="l04056"></a>04056 <span class="comment">     I was hoping for something a little more definitive than &quot;should work.&quot;</span>
<a name="l04057"></a>04057 <span class="comment"></span>
<a name="l04058"></a>04058 <span class="comment"></span>
<a name="l04059"></a>04059 <span class="comment">     &gt;</span>
<a name="l04060"></a>04060 <span class="comment">     &gt; Would a good approach be perhaps to generate keys until I found one for</span>
<a name="l04061"></a>04061 <span class="comment">     &gt; which n is greater than the bignum representation of the largest plaintext?</span>
<a name="l04062"></a>04062 <span class="comment">     &gt; (Yeah, I know, this would restrict the key space, which might be a security</span>
<a name="l04063"></a>04063 <span class="comment">     &gt; concern.)</span>
<a name="l04064"></a>04064 <span class="comment"></span>
<a name="l04065"></a>04065 <span class="comment">     It would be sufficient is the highest bit of the plaintext is zero</span>
<a name="l04066"></a>04066 <span class="comment">     , because the highest bit of the modulus is certainly set</span>
<a name="l04067"></a>04067 <span class="comment">     (at least if the key is generated with OpenSSL).</span>
<a name="l04068"></a>04068 <span class="comment"></span>
<a name="l04069"></a>04069 <span class="comment">     ...</span>
<a name="l04070"></a>04070 <span class="comment">     &gt; &gt; it should work (, but what about a longer (== more secure) key ?)</span>
<a name="l04071"></a>04071 <span class="comment">     &gt;</span>
<a name="l04072"></a>04072 <span class="comment">     &gt; For reasons that would be tedious to rehearse, the size of the encrypted</span>
<a name="l04073"></a>04073 <span class="comment">     &gt; block has to be not more than 15 octets.</span>
<a name="l04074"></a>04074 <span class="comment">     &gt;</span>
<a name="l04075"></a>04075 <span class="comment">     &gt; I was hoping for something a little more definitive than &quot;should work.&quot;</span>
<a name="l04076"></a>04076 <span class="comment"></span>
<a name="l04077"></a>04077 <span class="comment">     Ok , unless something really strange happens: it will work :-)</span>
<a name="l04078"></a>04078 <span class="comment"></span>
<a name="l04079"></a>04079 <span class="comment">     Regards,</span>
<a name="l04080"></a>04080 <span class="comment">     Nils</span>
<a name="l04081"></a>04081 <span class="comment"></span>
<a name="l04082"></a>04082 <span class="comment"></span>
<a name="l04083"></a>04083 <span class="comment">     Re: RSA_private_encrypt does not work with RSA_NO_PADDING option</span>
<a name="l04084"></a>04084 <span class="comment">     by Dr. Stephen Henson Jul 19, 2010; 10:31am :: Rate this Message:    - Use ratings to moderate (?)</span>
<a name="l04085"></a>04085 <span class="comment">     Reply | Print | View Threaded | Show Only this Message</span>
<a name="l04086"></a>04086 <span class="comment">     On Mon, Jul 19, 2010, anhpham wrote:</span>
<a name="l04087"></a>04087 <span class="comment"></span>
<a name="l04088"></a>04088 <span class="comment">     &gt;</span>
<a name="l04089"></a>04089 <span class="comment">     &gt; Hi all :x</span>
<a name="l04090"></a>04090 <span class="comment">     &gt; I encountered an error when using function RSA_private_encrypt with</span>
<a name="l04091"></a>04091 <span class="comment">     &gt; RSA_NO_PADDING option.</span>
<a name="l04092"></a>04092 <span class="comment">     &gt; I had an uint8_t array a with length = 20, RSA* r,</span>
<a name="l04093"></a>04093 <span class="comment">     &gt; uint8_t* sig = (uint8_t*) malloc(RSA_size(r)) and then I invoked</span>
<a name="l04094"></a>04094 <span class="comment">     &gt; function int32_t i = RSA_private_encrypt(20,a ,sign,r,RSA_NO_PADDING ); The</span>
<a name="l04095"></a>04095 <span class="comment">     &gt; returned value  i = -1 means that this function failed. However, when I</span>
<a name="l04096"></a>04096 <span class="comment">     &gt; invoked int32_t i = RSA_private_encrypt(20,a,sig,r,RSA_PKCS1_PADDING ), it did</span>
<a name="l04097"></a>04097 <span class="comment">     &gt; run smoothly. I&#39;m confused whether it is an error of the library or not but</span>
<a name="l04098"></a>04098 <span class="comment">     &gt; I don&#39;t know how to solve this problem.</span>
<a name="l04099"></a>04099 <span class="comment">     &gt; Please help me :-&lt;</span>
<a name="l04100"></a>04100 <span class="comment">     ... [show rest of quote]</span>
<a name="l04101"></a>04101 <span class="comment"></span>
<a name="l04102"></a>04102 <span class="comment">     If you use RSA_NO_PADDING you have to supply a buffer of RSA_size(r) bytes and</span>
<a name="l04103"></a>04103 <span class="comment">     whose value is less than the modulus.</span>
<a name="l04104"></a>04104 <span class="comment"></span>
<a name="l04105"></a>04105 <span class="comment">     With RSA_PKCS1_PADDING you can pass up to RSA_size(r) - 11.</span>
<a name="l04106"></a>04106 <span class="comment"></span>
<a name="l04107"></a>04107 <span class="comment">     Steve.</span>
<a name="l04108"></a>04108 <span class="comment">     --</span>
<a name="l04109"></a>04109 <span class="comment">     Dr Stephen N. Henson. OpenSSL project core developer.</span>
<a name="l04110"></a>04110 <span class="comment">     Commercial tech support now available see: http://www.openssl.org</span>
<a name="l04111"></a>04111 <span class="comment"></span>
<a name="l04112"></a>04112 <span class="comment"></span>
<a name="l04113"></a>04113 <span class="comment"></span>
<a name="l04114"></a>04114 <span class="comment">     Hello,</span>
<a name="l04115"></a>04115 <span class="comment"></span>
<a name="l04116"></a>04116 <span class="comment">     I have a problem, I cannot really cover.</span>
<a name="l04117"></a>04117 <span class="comment"></span>
<a name="l04118"></a>04118 <span class="comment">     I&#39;m using public key encryption together with RSA_NO_PADDING. The</span>
<a name="l04119"></a>04119 <span class="comment">     Key-/Modulus-Size is 128Byte and the message to be encrypted are also</span>
<a name="l04120"></a>04120 <span class="comment">     128Byte sized.</span>
<a name="l04121"></a>04121 <span class="comment"></span>
<a name="l04122"></a>04122 <span class="comment">     Now my problem:</span>
<a name="l04123"></a>04123 <span class="comment">     Using the same (!) binary code (running in a debugging environment or not)</span>
<a name="l04124"></a>04124 <span class="comment">     it sometimes work properly, sometimes it failes with the following</span>
<a name="l04125"></a>04125 <span class="comment">     message:</span>
<a name="l04126"></a>04126 <span class="comment"></span>
<a name="l04127"></a>04127 <span class="comment">     &quot;error:04068084:rsa routines:RSA_EAY_PUBLIC_ENCRYPT:data too large for</span>
<a name="l04128"></a>04128 <span class="comment">     modulus&quot;</span>
<a name="l04129"></a>04129 <span class="comment"></span>
<a name="l04130"></a>04130 <span class="comment">     Reply:</span>
<a name="l04131"></a>04131 <span class="comment">     It is *not* enough that the modulus and message are both 128 bytes. You need</span>
<a name="l04132"></a>04132 <span class="comment">     a stronger condition.</span>
<a name="l04133"></a>04133 <span class="comment"></span>
<a name="l04134"></a>04134 <span class="comment">     Suppose your RSA modulus, as a BigNum, is n. Suppose the data you are trying</span>
<a name="l04135"></a>04135 <span class="comment">     to encrypt, as a BigNum, is x. You must ensure that x &lt; n, or you get that</span>
<a name="l04136"></a>04136 <span class="comment">     error message. That is one of the reasons to use a padding scheme such as</span>
<a name="l04137"></a>04137 <span class="comment">     RSA_PKCS1 padding.</span>
<a name="l04138"></a>04138 <span class="comment"></span>
<a name="l04139"></a>04139 <span class="comment"></span>
<a name="l04140"></a>04140 <span class="comment">     knotwork</span>
<a name="l04141"></a>04141 <span class="comment">     is this a reason to use larger keys or something? 4096 instead of2048 or 1024?</span>
<a name="l04142"></a>04142 <span class="comment"></span>
<a name="l04143"></a>04143 <span class="comment">     4:41</span>
<a name="l04144"></a>04144 <span class="comment">     FellowTraveler</span>
<a name="l04145"></a>04145 <span class="comment">     larger keys is one solution, and that is why I&#39;ve been looking at mkcert.c</span>
<a name="l04146"></a>04146 <span class="comment">     which, BTW *you* need to look at mkcert.c since there are default values hardcoded, and I need you to give me a better idea of what you would want in those places, as a server operator.</span>
<a name="l04147"></a>04147 <span class="comment">     First argument of encrypt should have been key.size() and first argument of decrypt should have been RSA_size(myKey).</span>
<a name="l04148"></a>04148 <span class="comment">     Padding scheme should have been used</span>
<a name="l04149"></a>04149 <span class="comment">     furthermore, RSA_Sign and RSA_Verify should have been used instead of RSA_Public_Decrypt and RSA_Private_Encrypt</span>
<a name="l04150"></a>04150 <span class="comment">     What you are seeing, your error, is a perfectly normal result of the fact that the message data being passed in is too large for the modulus of your key.</span>
<a name="l04151"></a>04151 <span class="comment">     .</span>
<a name="l04152"></a>04152 <span class="comment">     All of the above fixes need to be investigated and implemented at some point, and that will almost certainly change the data format inside the key enough to invalidate all existing signatures</span>
<a name="l04153"></a>04153 <span class="comment">     This is a real bug you found, in the crypto.</span>
<a name="l04154"></a>04154 <span class="comment"></span>
<a name="l04155"></a>04155 <span class="comment">     4:43</span>
<a name="l04156"></a>04156 <span class="comment">     knotwork</span>
<a name="l04157"></a>04157 <span class="comment">     zmq got you thinking you could have large messages so you forgot the crypto had its own limits on message size?</span>
<a name="l04158"></a>04158 <span class="comment"></span>
<a name="l04159"></a>04159 <span class="comment">     4:43</span>
<a name="l04160"></a>04160 <span class="comment">     FellowTraveler</span>
<a name="l04161"></a>04161 <span class="comment">     it&#39;s not message size per se</span>
<a name="l04162"></a>04162 <span class="comment">     it&#39;s message DIGEST size in relation to key modulus</span>
<a name="l04163"></a>04163 <span class="comment">     which must be smaller based on a bignum comparison of the two</span>
<a name="l04164"></a>04164 <span class="comment">     RSA_Size is supposed to be used in decrypt</span>
<a name="l04165"></a>04165 <span class="comment"></span>
<a name="l04166"></a>04166 <span class="comment">     4:44</span>
<a name="l04167"></a>04167 <span class="comment">     knotwork</span>
<a name="l04168"></a>04168 <span class="comment">     a form of the resync should fix everything, it just needs to run throguh everything resigning it with new type of signature?</span>
<a name="l04169"></a>04169 <span class="comment"></span>
<a name="l04170"></a>04170 <span class="comment">     4:44</span>
<a name="l04171"></a>04171 <span class="comment">     FellowTraveler</span>
<a name="l04172"></a>04172 <span class="comment">     not that simple</span>
<a name="l04173"></a>04173 <span class="comment">     I would have to code some kind of special &quot;convert legacy data&quot; thing into OT itself</span>
<a name="l04174"></a>04174 <span class="comment">     though there might be a stopgap measure now, good enough to keep data until all the above fixes are made</span>
<a name="l04175"></a>04175 <span class="comment">     ok see if this fixes it for you......</span>
<a name="l04176"></a>04176 <span class="comment">     knotwork, go into OTLib/OTContract.cpp</span>
<a name="l04177"></a>04177 <span class="comment">     Find the first line that begins with status = RSA_public_decrypt</span>
<a name="l04178"></a>04178 <span class="comment"></span>
<a name="l04179"></a>04179 <span class="comment">     4:46</span>
<a name="l04180"></a>04180 <span class="comment">     knotwork</span>
<a name="l04181"></a>04181 <span class="comment">     vanalces would be enough maybe. jsut a way to set balances of all accoutns to whatever they actually are at the time</span>
<a name="l04182"></a>04182 <span class="comment"></span>
<a name="l04183"></a>04183 <span class="comment">     4:46</span>
<a name="l04184"></a>04184 <span class="comment">     FellowTraveler</span>
<a name="l04185"></a>04185 <span class="comment">     the only other one is commented out, so it&#39;s not hard</span>
<a name="l04186"></a>04186 <span class="comment">     you will see a hardcoded size:    status = RSA_public_decrypt(128,</span>
<a name="l04187"></a>04187 <span class="comment">     CHANGE the 128 to this value:</span>
<a name="l04188"></a>04188 <span class="comment">     RSA_size(pRsaKey)</span>
<a name="l04189"></a>04189 <span class="comment">     for now you can change the entire line to this:</span>
<a name="l04190"></a>04190 <span class="comment">     status = RSA_public_decrypt(RSA_size(pRsaKey), static_cast&lt;const uint8_t*&gt;(binSignature.GetPointer()), pDecrypted, pRsaKey, RSA_NO_PADDING);</span>
<a name="l04191"></a>04191 <span class="comment">     Then see if your bug goes away</span>
<a name="l04192"></a>04192 <span class="comment">     I will still need to make fixes someday though, even if this works, and will have to lose or convert data.</span>
<a name="l04193"></a>04193 <span class="comment">     4:48</span>
<a name="l04194"></a>04194 <span class="comment">     otherwise there could be security issues down the road.</span>
<a name="l04195"></a>04195 <span class="comment"></span>
<a name="l04196"></a>04196 <span class="comment"></span>
<a name="l04197"></a>04197 <span class="comment">     TODO SECURITY ^  sign/verify needs revamping!</span>
<a name="l04198"></a>04198 <span class="comment"></span>
<a name="l04199"></a>04199 <span class="comment">     UPDATE: Okay I may have it fixed now, though need to test still.</span>
<a name="l04200"></a>04200 <span class="comment"></span>
<a name="l04201"></a>04201 <span class="comment">     http://www.bmt-online.org/geekisms/RSA_verify</span>
<a name="l04202"></a>04202 <span class="comment"></span>
<a name="l04203"></a>04203 <span class="comment">     Also see: ~/Projects/openssl/demos/sign</span>
<a name="l04204"></a>04204 <span class="comment">     */</span>
<a name="l04205"></a>04205 
<a name="l04206"></a>04206 
<a name="l04207"></a>04207     <span class="comment">// ----------------------</span>
<a name="l04208"></a>04208 
<a name="l04209"></a>04209     <span class="keywordflow">if</span> (pRsaKey)
<a name="l04210"></a>04210         RSA_free(pRsaKey);
<a name="l04211"></a>04211     pRsaKey = NULL;
<a name="l04212"></a>04212 
<a name="l04213"></a>04213     <span class="keywordflow">return</span> bReturnValue;
<a name="l04214"></a>04214 }
<a name="l04215"></a>04215 
<a name="l04216"></a>04216 
<a name="l04217"></a>04217 <span class="comment">// All the other various versions eventually call this one, where the actual work is done.</span>
<a name="l04218"></a>04218 <span class="keywordtype">bool</span> OTCrypto_OpenSSL::OTCrypto_OpenSSLdp::SignContract(<span class="keyword">const</span> <a class="code" href="class_o_t_string.html">OTString</a>    &amp; strContractUnsigned,
<a name="l04219"></a>04219                                                         <span class="keyword">const</span> EVP_PKEY    * pkey,
<a name="l04220"></a>04220                                                         <a class="code" href="class_o_t_signature.html">OTSignature</a>       &amp; theSignature,
<a name="l04221"></a>04221                                                         <span class="keyword">const</span> <a class="code" href="class_o_t_string.html">OTString</a>    &amp; strHashType,
<a name="l04222"></a>04222                                                         <a class="code" href="class_o_t_password_data.html">OTPasswordData</a>    * pPWData<span class="comment">/*=NULL*/</span>)<span class="keyword"> const</span>
<a name="l04223"></a>04223 <span class="keyword"></span>{
<a name="l04224"></a>04224     <a class="code" href="_o_t_assert_8hpp.html#a033b133f48e61f2b227c52ad2be0c882">OT_ASSERT_MSG</a>(NULL != pkey, <span class="stringliteral">&quot;Null private key sent to OTCrypto_OpenSSL::SignContract.\n&quot;</span>);
<a name="l04225"></a>04225     <span class="comment">// ---------------------------------------------------</span>
<a name="l04226"></a>04226     <span class="keyword">const</span> <span class="keywordtype">char</span> * szFunc = <span class="stringliteral">&quot;OTCrypto_OpenSSL::SignContract&quot;</span>;
<a name="l04227"></a>04227     <span class="comment">// ---------------------------------------------------</span>
<a name="l04228"></a>04228     <span class="keyword">class </span>_OTCont_SignCont1
<a name="l04229"></a>04229     {
<a name="l04230"></a>04230     <span class="keyword">private</span>:
<a name="l04231"></a>04231         <span class="keyword">const</span> <span class="keywordtype">char</span>  *  m_szFunc;
<a name="l04232"></a>04232         EVP_MD_CTX  &amp;  m_ctx;
<a name="l04233"></a>04233 
<a name="l04234"></a>04234     <span class="keyword">public</span>:
<a name="l04235"></a>04235         _OTCont_SignCont1(<span class="keyword">const</span> <span class="keywordtype">char</span> * param_szFunc, EVP_MD_CTX &amp; param_ctx) :
<a name="l04236"></a>04236         m_szFunc(param_szFunc),
<a name="l04237"></a>04237         m_ctx(param_ctx)
<a name="l04238"></a>04238         {
<a name="l04239"></a>04239             <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != m_szFunc);
<a name="l04240"></a>04240 
<a name="l04241"></a>04241             EVP_MD_CTX_init(&amp;m_ctx);
<a name="l04242"></a>04242         }
<a name="l04243"></a>04243         ~_OTCont_SignCont1()
<a name="l04244"></a>04244         {
<a name="l04245"></a>04245             <span class="keywordflow">if</span> (0 == EVP_MD_CTX_cleanup(&amp;m_ctx))
<a name="l04246"></a>04246                 <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;%s: Failure in cleanup. (It returned 0.)\n&quot;</span>, m_szFunc);
<a name="l04247"></a>04247         }
<a name="l04248"></a>04248     };
<a name="l04249"></a>04249     <span class="comment">// ------------------------------------</span>
<a name="l04250"></a>04250     <span class="comment">// Moving this lower...</span>
<a name="l04251"></a>04251 
<a name="l04252"></a>04252 <span class="comment">//  _OTCont_SignCont1 theInstance(szFunc, md_ctx);</span>
<a name="l04253"></a>04253 
<a name="l04254"></a>04254     <span class="comment">// ------------------------------------</span>
<a name="l04255"></a>04255     <span class="comment">//  OTString strDoubleHash;</span>
<a name="l04256"></a>04256 
<a name="l04257"></a>04257     <span class="comment">// Are we using the special SAMY hash? In which case, we have to actually combine two signatures.</span>
<a name="l04258"></a>04258     <span class="keyword">const</span> <span class="keywordtype">bool</span> bUsesDefaultHashAlgorithm = strHashType.<a class="code" href="class_o_t_string.html#a03401b39fb66d63696342c4f61ea8bf5">Compare</a>(<a class="code" href="class_o_t_identifier.html#a1179b45355107bf4511249a823217c94">OTIdentifier::DefaultHashAlgorithm</a>);
<a name="l04259"></a>04259     EVP_MD * md = NULL;
<a name="l04260"></a>04260 
<a name="l04261"></a>04261     <span class="comment">// SAMY hash. (The &quot;default&quot; hash.)</span>
<a name="l04262"></a>04262     <span class="keywordflow">if</span> (bUsesDefaultHashAlgorithm)
<a name="l04263"></a>04263     {
<a name="l04264"></a>04264 <span class="comment">//      OTIdentifier hash1, hash2;</span>
<a name="l04265"></a>04265 <span class="comment">//</span>
<a name="l04266"></a>04266 <span class="comment">//      hash1.CalculateDigest(strContractUnsigned, OTIdentifier::HashAlgorithm1);</span>
<a name="l04267"></a>04267 <span class="comment">//      hash2.CalculateDigest(strContractUnsigned, OTIdentifier::HashAlgorithm2);</span>
<a name="l04268"></a>04268 <span class="comment">//</span>
<a name="l04269"></a>04269 <span class="comment">//      hash1.XOR(hash2);</span>
<a name="l04270"></a>04270 <span class="comment">//      hash1.GetString(strDoubleHash);</span>
<a name="l04271"></a>04271 <span class="comment">//</span>
<a name="l04272"></a>04272 <span class="comment">//      md = (EVP_MD *)OTCrypto_OpenSSL::GetOpenSSLDigestByName(OTIdentifier::HashAlgorithm1);</span>
<a name="l04273"></a>04273 
<a name="l04274"></a>04274         <span class="keywordflow">return</span> this-&gt;SignContractDefaultHash(strContractUnsigned, pkey, theSignature, pPWData);
<a name="l04275"></a>04275     }
<a name="l04276"></a>04276     <span class="comment">// ---------------------------------------------------</span>
<a name="l04277"></a>04277 <span class="comment">//  else</span>
<a name="l04278"></a>04278     {
<a name="l04279"></a>04279         md = (EVP_MD *)OTCrypto_OpenSSL::OTCrypto_OpenSSLdp::GetOpenSSLDigestByName(strHashType); <span class="comment">// todo cast</span>
<a name="l04280"></a>04280     }
<a name="l04281"></a>04281     <span class="comment">// ---------------------------------------------------</span>
<a name="l04282"></a>04282 
<a name="l04283"></a>04283     <span class="comment">// If it&#39;s not the default hash, then it&#39;s just a normal hash.</span>
<a name="l04284"></a>04284     <span class="comment">// Either way then we process it, first by getting the message digest pointer for signing.</span>
<a name="l04285"></a>04285 
<a name="l04286"></a>04286     <span class="keywordflow">if</span> (NULL == md)
<a name="l04287"></a>04287     {
<a name="l04288"></a>04288         <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;%s: Unable to decipher Hash algorithm: %s\n&quot;</span>,
<a name="l04289"></a>04289                       szFunc, strHashType.<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>());
<a name="l04290"></a>04290         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l04291"></a>04291     }
<a name="l04292"></a>04292     <span class="comment">// ---------------------------------------------------</span>
<a name="l04293"></a>04293     <span class="comment">// RE: EVP_SignInit() or EVP_MD_CTX_init()...</span>
<a name="l04294"></a>04294     <span class="comment">//</span>
<a name="l04295"></a>04295     <span class="comment">// Since only a copy of the digest context is ever finalized the</span>
<a name="l04296"></a>04296     <span class="comment">// context MUST be cleaned up after use by calling EVP_MD_CTX_cleanup()</span>
<a name="l04297"></a>04297     <span class="comment">// or a memory leak will occur.</span>
<a name="l04298"></a>04298     <span class="comment">//</span>
<a name="l04299"></a>04299     EVP_MD_CTX   md_ctx;
<a name="l04300"></a>04300     <span class="comment">// ---------------------------------------------------</span>
<a name="l04301"></a>04301 
<a name="l04302"></a>04302     _OTCont_SignCont1 theInstance(szFunc, md_ctx);
<a name="l04303"></a>04303 
<a name="l04304"></a>04304     <span class="comment">// ----------------------</span>
<a name="l04305"></a>04305     <span class="comment">// Do the signature</span>
<a name="l04306"></a>04306     <span class="comment">// Note: I just changed this to the _ex version (in case I&#39;m debugging later</span>
<a name="l04307"></a>04307     <span class="comment">// and find a problem here.)</span>
<a name="l04308"></a>04308     <span class="comment">//</span>
<a name="l04309"></a>04309     EVP_SignInit_ex(&amp;md_ctx, md, NULL);
<a name="l04310"></a>04310 
<a name="l04311"></a>04311     <span class="comment">// ---------------------------------------------------</span>
<a name="l04312"></a>04312 <span class="comment">//  if (bUsesDefaultHashAlgorithm)</span>
<a name="l04313"></a>04313 <span class="comment">//  {</span>
<a name="l04314"></a>04314 <span class="comment">//      EVP_SignUpdate (&amp;md_ctx, strDoubleHash.Get(), strDoubleHash.GetLength());</span>
<a name="l04315"></a>04315 <span class="comment">//  }</span>
<a name="l04316"></a>04316 <span class="comment">//  else</span>
<a name="l04317"></a>04317     {
<a name="l04318"></a>04318         EVP_SignUpdate (&amp;md_ctx, strContractUnsigned.<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>(), strContractUnsigned.<a class="code" href="class_o_t_string.html#a640392dd17a786dab643dbfc7e5a8672">GetLength</a>());
<a name="l04319"></a>04319     }
<a name="l04320"></a>04320     <span class="comment">// ----------------------------------------------</span>
<a name="l04321"></a>04321     uint8_t sig_buf [4096]; <span class="comment">// Safe since we pass the size when we use it.</span>
<a name="l04322"></a>04322 
<a name="l04323"></a>04323     int32_t sig_len = <span class="keyword">sizeof</span>(sig_buf);
<a name="l04324"></a>04324     int32_t err = EVP_SignFinal (&amp;md_ctx, sig_buf, (uint32_t *)&amp;sig_len, (EVP_PKEY *)pkey);  <span class="comment">// todo cast</span>
<a name="l04325"></a>04325 
<a name="l04326"></a>04326     <span class="keywordflow">if</span> (err != 1)
<a name="l04327"></a>04327     {
<a name="l04328"></a>04328         <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;%s: Error signing xml contents.\n&quot;</span>, szFunc);
<a name="l04329"></a>04329         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l04330"></a>04330     }
<a name="l04331"></a>04331     <span class="keywordflow">else</span>
<a name="l04332"></a>04332     {
<a name="l04333"></a>04333         <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(3, <span class="stringliteral">&quot;%s: Successfully signed xml contents.\n&quot;</span>, szFunc);
<a name="l04334"></a>04334 
<a name="l04335"></a>04335         <span class="comment">// We put the signature data into the signature object that</span>
<a name="l04336"></a>04336         <span class="comment">// was passed in for that purpose.</span>
<a name="l04337"></a>04337         <a class="code" href="class_o_t_data.html">OTData</a> tempData;
<a name="l04338"></a>04338         tempData.<a class="code" href="class_o_t_data.html#a253cd3974cb837ad06980579eb7bc0e4">Assign</a>(sig_buf, sig_len);
<a name="l04339"></a>04339         theSignature.<a class="code" href="class_o_t_a_s_c_i_i_armor.html#a48e0e2e2eff86ad382a2cc63298a0b8b">SetData</a>(tempData);
<a name="l04340"></a>04340 
<a name="l04341"></a>04341         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l04342"></a>04342     }
<a name="l04343"></a>04343 }
<a name="l04344"></a>04344 
<a name="l04345"></a>04345 
<a name="l04346"></a>04346 <span class="keywordtype">bool</span> OTCrypto_OpenSSL::SignContract(<span class="keyword">const</span> <a class="code" href="class_o_t_string.html">OTString</a>        &amp; strContractUnsigned,
<a name="l04347"></a>04347                                     <span class="keyword">const</span> <a class="code" href="class_o_t_asymmetric_key.html">OTAsymmetricKey</a> &amp; theKey,
<a name="l04348"></a>04348                                     <a class="code" href="class_o_t_signature.html">OTSignature</a>           &amp; theSignature, <span class="comment">// output</span>
<a name="l04349"></a>04349                                     <span class="keyword">const</span> <a class="code" href="class_o_t_string.html">OTString</a>        &amp; strHashType,
<a name="l04350"></a>04350                                     <a class="code" href="class_o_t_password_data.html">OTPasswordData</a>        * pPWData<span class="comment">/*=NULL*/</span>)<span class="keyword"> const</span>
<a name="l04351"></a>04351 <span class="keyword"></span>{
<a name="l04352"></a>04352     <span class="keyword">const</span> <span class="keywordtype">char</span> * szFunc = <span class="stringliteral">&quot;OTCrypto_OpenSSL::SignContract&quot;</span>;
<a name="l04353"></a>04353     <span class="comment">// -------------------------------------------------</span>
<a name="l04354"></a>04354     <a class="code" href="class_o_t_asymmetric_key.html">OTAsymmetricKey</a>         &amp; theTempKey      = const_cast  &lt;<a class="code" href="class_o_t_asymmetric_key.html">OTAsymmetricKey</a> &amp;&gt;(theKey);
<a name="l04355"></a>04355     OTAsymmetricKey_OpenSSL * pTempOpenSSLKey = <span class="keyword">dynamic_cast&lt;</span>OTAsymmetricKey_OpenSSL *<span class="keyword">&gt;</span>(&amp;theTempKey);
<a name="l04356"></a>04356     <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != pTempOpenSSLKey);
<a name="l04357"></a>04357     <span class="comment">// -------------------------------------------------</span>
<a name="l04358"></a>04358     <span class="keyword">const</span> EVP_PKEY * pkey = pTempOpenSSLKey-&gt;dp-&gt;GetKey(pPWData);
<a name="l04359"></a>04359     <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != pkey);
<a name="l04360"></a>04360     <span class="comment">// -------------------------------------------------</span>
<a name="l04361"></a>04361     <span class="keywordflow">if</span> (<span class="keyword">false</span> == this-&gt;dp-&gt;SignContract(strContractUnsigned,
<a name="l04362"></a>04362                                     pkey,
<a name="l04363"></a>04363                                     theSignature,
<a name="l04364"></a>04364                                     strHashType,
<a name="l04365"></a>04365                                     pPWData))
<a name="l04366"></a>04366     {
<a name="l04367"></a>04367         <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;%s: this-&gt;SignContract returned false.\n&quot;</span>,
<a name="l04368"></a>04368                       szFunc);
<a name="l04369"></a>04369         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l04370"></a>04370     }
<a name="l04371"></a>04371     <span class="comment">// --------------------------------------------------------------------</span>
<a name="l04372"></a>04372     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l04373"></a>04373 }
<a name="l04374"></a>04374 
<a name="l04375"></a>04375 
<a name="l04376"></a>04376 <span class="keywordtype">bool</span> OTCrypto_OpenSSL::VerifySignature(<span class="keyword">const</span> <a class="code" href="class_o_t_string.html">OTString</a>        &amp; strContractToVerify,
<a name="l04377"></a>04377                                        <span class="keyword">const</span> <a class="code" href="class_o_t_asymmetric_key.html">OTAsymmetricKey</a> &amp; theKey,
<a name="l04378"></a>04378                                        <span class="keyword">const</span> <a class="code" href="class_o_t_signature.html">OTSignature</a>     &amp; theSignature,
<a name="l04379"></a>04379                                        <span class="keyword">const</span> <a class="code" href="class_o_t_string.html">OTString</a>        &amp; strHashType,
<a name="l04380"></a>04380                                        <a class="code" href="class_o_t_password_data.html">OTPasswordData</a>        * pPWData<span class="comment">/*=NULL*/</span>)<span class="keyword"> const</span>
<a name="l04381"></a>04381 <span class="keyword"></span>{
<a name="l04382"></a>04382     <span class="keyword">const</span> <span class="keywordtype">char</span> * szFunc = <span class="stringliteral">&quot;OTCrypto_OpenSSL::VerifySignature&quot;</span>;
<a name="l04383"></a>04383     <span class="comment">// -------------------------------------------------</span>
<a name="l04384"></a>04384     <a class="code" href="class_o_t_asymmetric_key.html">OTAsymmetricKey</a>         &amp; theTempKey      = const_cast  &lt;<a class="code" href="class_o_t_asymmetric_key.html">OTAsymmetricKey</a> &amp;&gt;(theKey);
<a name="l04385"></a>04385     OTAsymmetricKey_OpenSSL * pTempOpenSSLKey = <span class="keyword">dynamic_cast&lt;</span>OTAsymmetricKey_OpenSSL *<span class="keyword">&gt;</span>(&amp;theTempKey);
<a name="l04386"></a>04386     <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != pTempOpenSSLKey);
<a name="l04387"></a>04387     <span class="comment">// -------------------------------------------------</span>
<a name="l04388"></a>04388     <span class="keyword">const</span> EVP_PKEY * pkey = pTempOpenSSLKey-&gt;dp-&gt;GetKey(pPWData);
<a name="l04389"></a>04389     <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != pkey);
<a name="l04390"></a>04390     <span class="comment">// -------------------------------------------------</span>
<a name="l04391"></a>04391     <span class="keywordflow">if</span> (<span class="keyword">false</span> == this-&gt;dp-&gt;VerifySignature(strContractToVerify,
<a name="l04392"></a>04392                                        pkey,
<a name="l04393"></a>04393                                        theSignature,
<a name="l04394"></a>04394                                        strHashType,
<a name="l04395"></a>04395                                        pPWData))
<a name="l04396"></a>04396     {
<a name="l04397"></a>04397         <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(3, <span class="stringliteral">&quot;%s: this-&gt;VerifySignature returned false.\n&quot;</span>,
<a name="l04398"></a>04398                       szFunc);
<a name="l04399"></a>04399         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l04400"></a>04400     }
<a name="l04401"></a>04401     <span class="comment">// --------------------------------------------------------------------</span>
<a name="l04402"></a>04402     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l04403"></a>04403 }
<a name="l04404"></a>04404 
<a name="l04405"></a>04405 
<a name="l04406"></a>04406 <span class="comment">// All the other various versions eventually call this one, where the actual work is done.</span>
<a name="l04407"></a>04407 <span class="keywordtype">bool</span> OTCrypto_OpenSSL::OTCrypto_OpenSSLdp::VerifySignature(<span class="keyword">const</span> <a class="code" href="class_o_t_string.html">OTString</a>    &amp; strContractToVerify,
<a name="l04408"></a>04408                                        <span class="keyword">const</span> EVP_PKEY    * pkey,
<a name="l04409"></a>04409                                        <span class="keyword">const</span> <a class="code" href="class_o_t_signature.html">OTSignature</a> &amp; theSignature,
<a name="l04410"></a>04410                                        <span class="keyword">const</span> <a class="code" href="class_o_t_string.html">OTString</a>    &amp; strHashType,
<a name="l04411"></a>04411                                        <a class="code" href="class_o_t_password_data.html">OTPasswordData</a>    * pPWData<span class="comment">/*=NULL*/</span>)<span class="keyword"> const</span>
<a name="l04412"></a>04412 <span class="keyword"></span>{
<a name="l04413"></a>04413     <a class="code" href="_o_t_assert_8hpp.html#a033b133f48e61f2b227c52ad2be0c882">OT_ASSERT_MSG</a>(strContractToVerify.<a class="code" href="class_o_t_string.html#adf7489cd917d4ae5bf30853a3ad78daf">Exists</a>(), <span class="stringliteral">&quot;OTCrypto_OpenSSL::VerifySignature: ASSERT FAILURE: strContractToVerify.Exists()&quot;</span>);
<a name="l04414"></a>04414     <a class="code" href="_o_t_assert_8hpp.html#a033b133f48e61f2b227c52ad2be0c882">OT_ASSERT_MSG</a>(NULL != pkey, <span class="stringliteral">&quot;Null pkey in OTCrypto_OpenSSL::VerifySignature.\n&quot;</span>);
<a name="l04415"></a>04415     <span class="comment">// -------------------------------</span>
<a name="l04416"></a>04416     <span class="keyword">const</span> <span class="keywordtype">char</span> *szFunc = <span class="stringliteral">&quot;OTCrypto_OpenSSL::VerifySignature&quot;</span>;
<a name="l04417"></a>04417     <span class="comment">// -------------------------------</span>
<a name="l04418"></a>04418     <span class="comment">// Are we using the special SAMY hash? In which case, we have to actually combine two hashes.</span>
<a name="l04419"></a>04419     <span class="keyword">const</span> <span class="keywordtype">bool</span> bUsesDefaultHashAlgorithm = strHashType.<a class="code" href="class_o_t_string.html#a03401b39fb66d63696342c4f61ea8bf5">Compare</a>(<a class="code" href="class_o_t_identifier.html#a1179b45355107bf4511249a823217c94">OTIdentifier::DefaultHashAlgorithm</a>);
<a name="l04420"></a>04420     EVP_MD * md = NULL;
<a name="l04421"></a>04421 
<a name="l04422"></a>04422     <span class="keywordflow">if</span> (bUsesDefaultHashAlgorithm)
<a name="l04423"></a>04423     {
<a name="l04424"></a>04424 <span class="comment">//      OTIdentifier hash1, hash2;</span>
<a name="l04425"></a>04425 <span class="comment">//</span>
<a name="l04426"></a>04426 <span class="comment">//      hash1.CalculateDigest(strContractToVerify, OTIdentifier::HashAlgorithm1);</span>
<a name="l04427"></a>04427 <span class="comment">//      hash2.CalculateDigest(strContractToVerify, OTIdentifier::HashAlgorithm2);</span>
<a name="l04428"></a>04428 <span class="comment">//</span>
<a name="l04429"></a>04429 <span class="comment">//      hash1.XOR(hash2);</span>
<a name="l04430"></a>04430 <span class="comment">//      hash1.GetString(strDoubleHash);</span>
<a name="l04431"></a>04431 <span class="comment">//</span>
<a name="l04432"></a>04432 <span class="comment">//      md = (EVP_MD *)OTCrypto_OpenSSL::GetOpenSSLDigestByName(OTIdentifier::HashAlgorithm1);</span>
<a name="l04433"></a>04433 
<a name="l04434"></a>04434         <span class="keywordflow">return</span> this-&gt;VerifyContractDefaultHash(strContractToVerify, pkey, theSignature, pPWData);
<a name="l04435"></a>04435     }
<a name="l04436"></a>04436     <span class="comment">// --------------------------</span>
<a name="l04437"></a>04437 <span class="comment">//  else</span>
<a name="l04438"></a>04438     {
<a name="l04439"></a>04439         md = (EVP_MD *)OTCrypto_OpenSSL::OTCrypto_OpenSSLdp::GetOpenSSLDigestByName(strHashType); <span class="comment">// todo cast</span>
<a name="l04440"></a>04440     }
<a name="l04441"></a>04441     <span class="comment">// --------------------------</span>
<a name="l04442"></a>04442     <span class="keywordflow">if</span> (!md)
<a name="l04443"></a>04443     {
<a name="l04444"></a>04444         <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(1, <span class="stringliteral">&quot;%s: Unknown message digest algorithm: %s\n&quot;</span>,
<a name="l04445"></a>04445                        szFunc, strHashType.<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>());
<a name="l04446"></a>04446         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l04447"></a>04447     }
<a name="l04448"></a>04448     <span class="comment">// --------------------------</span>
<a name="l04449"></a>04449     <a class="code" href="class_o_t_payload.html">OTPayload</a> binSignature;
<a name="l04450"></a>04450 
<a name="l04451"></a>04451     <span class="comment">// now binSignature contains the base64 decoded binary of the signature.</span>
<a name="l04452"></a>04452     <span class="comment">// Unless the call failed of course...</span>
<a name="l04453"></a>04453     <span class="keywordflow">if</span> (!theSignature.<a class="code" href="class_o_t_a_s_c_i_i_armor.html#a5564f05ead3366c5b97c8b7edfea083b">GetData</a>(binSignature))
<a name="l04454"></a>04454     {
<a name="l04455"></a>04455         <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;%s: Error decoding base64 data for Signature.\n&quot;</span>, szFunc);
<a name="l04456"></a>04456         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l04457"></a>04457     }
<a name="l04458"></a>04458     <span class="comment">// --------------------------</span>
<a name="l04459"></a>04459     EVP_MD_CTX ctx;
<a name="l04460"></a>04460     EVP_MD_CTX_init(&amp;ctx);
<a name="l04461"></a>04461 
<a name="l04462"></a>04462     EVP_VerifyInit(&amp;ctx, md);
<a name="l04463"></a>04463 
<a name="l04464"></a>04464     <span class="comment">// Here I&#39;m adding the actual XML portion of the contract (the portion that gets signed.)</span>
<a name="l04465"></a>04465     <span class="comment">// Basically we are repeating similarly to the signing process in order to verify.</span>
<a name="l04466"></a>04466 
<a name="l04467"></a>04467 <span class="comment">//  if (bUsesDefaultHashAlgorithm)</span>
<a name="l04468"></a>04468 <span class="comment">//  {</span>
<a name="l04469"></a>04469 <span class="comment">//      EVP_VerifyUpdate(&amp;ctx, strDoubleHash.Get(), strDoubleHash.GetLength());</span>
<a name="l04470"></a>04470 <span class="comment">//  }</span>
<a name="l04471"></a>04471 <span class="comment">//  else</span>
<a name="l04472"></a>04472     {
<a name="l04473"></a>04473         EVP_VerifyUpdate(&amp;ctx, strContractToVerify.<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>(), strContractToVerify.<a class="code" href="class_o_t_string.html#a640392dd17a786dab643dbfc7e5a8672">GetLength</a>());
<a name="l04474"></a>04474     }
<a name="l04475"></a>04475     <span class="comment">// --------------------------</span>
<a name="l04476"></a>04476     <span class="comment">// Now we pass in the Signature</span>
<a name="l04477"></a>04477     <span class="comment">// EVP_VerifyFinal() returns 1 for a correct signature,</span>
<a name="l04478"></a>04478     <span class="comment">// 0 for failure and -1 if some other error occurred.</span>
<a name="l04479"></a>04479     <span class="comment">//</span>
<a name="l04480"></a>04480     int32_t nErr = EVP_VerifyFinal(&amp;ctx, (<span class="keyword">const</span> uint8_t *)binSignature.<a class="code" href="class_o_t_payload.html#aef8d7f40ba7886f7da16290091681aa9">GetPayloadPointer</a>(),  <span class="comment">// todo cast</span>
<a name="l04481"></a>04481                                (uint32_t)binSignature.<a class="code" href="class_o_t_data.html#a18fd0599061eaf2c031548e030c3112d">GetSize</a>(), (EVP_PKEY *)pkey); <span class="comment">// todo cast</span>
<a name="l04482"></a>04482     <span class="comment">// --------------------------</span>
<a name="l04483"></a>04483     EVP_MD_CTX_cleanup(&amp;ctx);
<a name="l04484"></a>04484     <span class="comment">// --------------------------</span>
<a name="l04485"></a>04485     <span class="comment">// the moment of true. 1 means the signature verified.</span>
<a name="l04486"></a>04486     <span class="keywordflow">if</span> (1 == nErr)
<a name="l04487"></a>04487         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l04488"></a>04488     <span class="keywordflow">else</span>
<a name="l04489"></a>04489         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l04490"></a>04490 }
<a name="l04491"></a>04491 
<a name="l04492"></a>04492 
<a name="l04493"></a>04493 <span class="comment">// Sign the Contract using a private key from a file.</span>
<a name="l04494"></a>04494 <span class="comment">// theSignature will contain the output.</span>
<a name="l04495"></a>04495 <span class="keywordtype">bool</span> OTCrypto_OpenSSL::SignContract(<span class="keyword">const</span> <a class="code" href="class_o_t_string.html">OTString</a>    &amp; strContractUnsigned,
<a name="l04496"></a>04496                                     <span class="keyword">const</span> <a class="code" href="class_o_t_string.html">OTString</a>    &amp; strSigHashType,
<a name="l04497"></a>04497                                     <span class="keyword">const</span> std::string &amp; strCertFileContents,
<a name="l04498"></a>04498                                     <a class="code" href="class_o_t_signature.html">OTSignature</a>       &amp; theSignature,
<a name="l04499"></a>04499                                     <a class="code" href="class_o_t_password_data.html">OTPasswordData</a>    * pPWData<span class="comment">/*=NULL*/</span>)<span class="keyword"> const</span>
<a name="l04500"></a>04500 <span class="keyword"></span>{
<a name="l04501"></a>04501     <a class="code" href="_o_t_assert_8hpp.html#a033b133f48e61f2b227c52ad2be0c882">OT_ASSERT_MSG</a>(strContractUnsigned.<a class="code" href="class_o_t_string.html#adf7489cd917d4ae5bf30853a3ad78daf">Exists</a>(), <span class="stringliteral">&quot;OTCrypto_OpenSSL::SignContract: ASSERT FAILURE: strContractUnsigned.Exists()&quot;</span>);
<a name="l04502"></a>04502     <a class="code" href="_o_t_assert_8hpp.html#a033b133f48e61f2b227c52ad2be0c882">OT_ASSERT_MSG</a>(strCertFileContents.size() &gt; 2, <span class="stringliteral">&quot;Empty strCertFileContents passed to OTCrypto_OpenSSL::SignContract&quot;</span>);
<a name="l04503"></a>04503     <span class="comment">// --------------------------------------------------------------------</span>
<a name="l04504"></a>04504     <span class="keyword">const</span> <span class="keywordtype">char</span> * szFunc = <span class="stringliteral">&quot;OTCrypto_OpenSSL::SignContract&quot;</span>;
<a name="l04505"></a>04505     <span class="comment">// --------------------------------------------------------------------</span>
<a name="l04506"></a>04506     <span class="comment">// Create a new memory buffer on the OpenSSL side</span>
<a name="l04507"></a>04507     <span class="comment">//</span>
<a name="l04508"></a>04508     <a class="code" href="class_open_s_s_l___b_i_o.html">OpenSSL_BIO</a> bio = BIO_new_mem_buf((<span class="keywordtype">void</span>*)strCertFileContents.c_str(), -1);  <span class="comment">// todo cast.</span>
<a name="l04509"></a>04509     <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != bio);
<a name="l04510"></a>04510     <span class="comment">// --------------------------------------------------------------------</span>
<a name="l04511"></a>04511     <span class="comment">// TODO security:</span>
<a name="l04512"></a>04512     <span class="comment">/* The old PrivateKey write routines are retained for compatibility.</span>
<a name="l04513"></a>04513 <span class="comment">     New applications should write private keys using the PEM_write_bio_PKCS8PrivateKey() or PEM_write_PKCS8PrivateKey()</span>
<a name="l04514"></a>04514 <span class="comment">     routines because they are more secure (they use an iteration count of 2048 whereas the traditional routines use a</span>
<a name="l04515"></a>04515 <span class="comment">     count of 1) unless compatibility with older versions of OpenSSL is important.</span>
<a name="l04516"></a>04516 <span class="comment">     NOTE: The PrivateKey read routines can be used in all applications because they handle all formats transparently.</span>
<a name="l04517"></a>04517 <span class="comment">     */</span>
<a name="l04518"></a>04518     <a class="code" href="class_o_t_password_data.html">OTPasswordData</a> thePWData(<span class="stringliteral">&quot;(OTCrypto_OpenSSL::SignContract is trying to read the private key...)&quot;</span>);
<a name="l04519"></a>04519 
<a name="l04520"></a>04520     <span class="keywordflow">if</span> (NULL == pPWData)
<a name="l04521"></a>04521         pPWData = &amp;thePWData;
<a name="l04522"></a>04522     <span class="comment">// --------------------------------------------------------------------</span>
<a name="l04523"></a>04523     <span class="keywordtype">bool</span>       bSigned = <span class="keyword">false</span>;
<a name="l04524"></a>04524     EVP_PKEY * pkey    = PEM_read_bio_PrivateKey( bio, NULL, <a class="code" href="class_o_t_asymmetric_key.html#a7515df1669bf358ddfc7ea477aedafdf">OTAsymmetricKey::GetPasswordCallback</a>(), pPWData);
<a name="l04525"></a>04525 
<a name="l04526"></a>04526     <span class="comment">// --------------------------------------------------------------------</span>
<a name="l04527"></a>04527     <span class="keywordflow">if</span> (NULL == pkey)
<a name="l04528"></a>04528     {
<a name="l04529"></a>04529         <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;%s: Error reading private key from BIO.\n&quot;</span>, szFunc);
<a name="l04530"></a>04530     }
<a name="l04531"></a>04531     <span class="keywordflow">else</span>
<a name="l04532"></a>04532     {
<a name="l04533"></a>04533         bSigned = this-&gt;dp-&gt;SignContract(strContractUnsigned, pkey, theSignature, strSigHashType, pPWData);
<a name="l04534"></a>04534 
<a name="l04535"></a>04535         EVP_PKEY_free (pkey);  pkey = NULL;
<a name="l04536"></a>04536     }
<a name="l04537"></a>04537     <span class="comment">// --------------------------------------------------------------------</span>
<a name="l04538"></a>04538     <span class="keywordflow">return</span> bSigned;
<a name="l04539"></a>04539 }
<a name="l04540"></a>04540 
<a name="l04541"></a>04541 
<a name="l04542"></a>04542 <span class="comment">// Presumably the Signature passed in here was just loaded as part of this contract and is</span>
<a name="l04543"></a>04543 <span class="comment">// somewhere in m_listSignatures. Now it is being verified.</span>
<a name="l04544"></a>04544 <span class="comment">//</span>
<a name="l04545"></a>04545 <span class="keywordtype">bool</span> OTCrypto_OpenSSL::VerifySignature(<span class="keyword">const</span> <a class="code" href="class_o_t_string.html">OTString</a>    &amp; strContractToVerify,
<a name="l04546"></a>04546                                        <span class="keyword">const</span> <a class="code" href="class_o_t_string.html">OTString</a>    &amp; strSigHashType,
<a name="l04547"></a>04547                                        <span class="keyword">const</span> std::string &amp; strCertFileContents,
<a name="l04548"></a>04548                                        <span class="keyword">const</span> <a class="code" href="class_o_t_signature.html">OTSignature</a> &amp; theSignature,
<a name="l04549"></a>04549                                        <a class="code" href="class_o_t_password_data.html">OTPasswordData</a>    * pPWData<span class="comment">/*=NULL*/</span>)<span class="keyword"> const</span>
<a name="l04550"></a>04550 <span class="keyword"></span>{
<a name="l04551"></a>04551     <a class="code" href="_o_t_assert_8hpp.html#a033b133f48e61f2b227c52ad2be0c882">OT_ASSERT_MSG</a>(strContractToVerify.<a class="code" href="class_o_t_string.html#adf7489cd917d4ae5bf30853a3ad78daf">Exists</a>(), <span class="stringliteral">&quot;OTCrypto_OpenSSL::VerifySignature: ASSERT FAILURE: strContractToVerify.Exists()&quot;</span>);
<a name="l04552"></a>04552     <a class="code" href="_o_t_assert_8hpp.html#a033b133f48e61f2b227c52ad2be0c882">OT_ASSERT_MSG</a>(strCertFileContents.size() &gt; 2, <span class="stringliteral">&quot;Empty strCertFileContents passed to OTCrypto_OpenSSL::VerifySignature&quot;</span>);
<a name="l04553"></a>04553     <span class="comment">// --------------------------------------------------------------------</span>
<a name="l04554"></a>04554     <span class="keyword">const</span> <span class="keywordtype">char</span> * szFunc = <span class="stringliteral">&quot;OTCrypto_OpenSSL::VerifySignature&quot;</span>;
<a name="l04555"></a>04555     <span class="comment">// --------------------------------------------------------------------</span>
<a name="l04556"></a>04556     <span class="comment">// Create a new memory buffer on the OpenSSL side</span>
<a name="l04557"></a>04557     <span class="comment">//</span>
<a name="l04558"></a>04558     <a class="code" href="class_open_s_s_l___b_i_o.html">OpenSSL_BIO</a> bio = BIO_new_mem_buf((<span class="keywordtype">void</span>*)strCertFileContents.c_str(), -1); <span class="comment">// todo cast</span>
<a name="l04559"></a>04559     <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != bio);
<a name="l04560"></a>04560     <span class="comment">// --------------------------------------------------------------------</span>
<a name="l04561"></a>04561     <a class="code" href="class_o_t_password_data.html">OTPasswordData</a> thePWData(<span class="stringliteral">&quot;(OTCrypto_OpenSSL::VerifySignature is trying to read the public key...)&quot;</span>);
<a name="l04562"></a>04562 
<a name="l04563"></a>04563     <span class="keywordflow">if</span> (NULL == pPWData)
<a name="l04564"></a>04564         pPWData = &amp;thePWData;
<a name="l04565"></a>04565     <span class="comment">// --------------------------------------------------------------------</span>
<a name="l04566"></a>04566     X509  *  x509  = PEM_read_bio_X509(bio, NULL, <a class="code" href="class_o_t_asymmetric_key.html#a7515df1669bf358ddfc7ea477aedafdf">OTAsymmetricKey::GetPasswordCallback</a>(), pPWData);
<a name="l04567"></a>04567 
<a name="l04568"></a>04568     <span class="comment">// --------------------------</span>
<a name="l04569"></a>04569     <span class="keywordflow">if</span> (NULL == x509)
<a name="l04570"></a>04570     {
<a name="l04571"></a>04571         <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;%s: Failed reading x509 out of cert file...\n&quot;</span>, szFunc);
<a name="l04572"></a>04572         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l04573"></a>04573     }
<a name="l04574"></a>04574     <span class="comment">// --------------------------</span>
<a name="l04575"></a>04575     <span class="keywordtype">bool</span>        bVerifySig  = <span class="keyword">false</span>;
<a name="l04576"></a>04576     EVP_PKEY  * pkey        = X509_get_pubkey(x509);
<a name="l04577"></a>04577 
<a name="l04578"></a>04578     <span class="keywordflow">if</span> (NULL == pkey)
<a name="l04579"></a>04579     {
<a name="l04580"></a>04580         <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;%s: Failed reading public key from x509 from certfile...\n&quot;</span>, szFunc);
<a name="l04581"></a>04581     }
<a name="l04582"></a>04582     <span class="keywordflow">else</span>
<a name="l04583"></a>04583     {
<a name="l04584"></a>04584         bVerifySig = this-&gt;dp-&gt;VerifySignature(strContractToVerify, pkey, theSignature, strSigHashType, pPWData);
<a name="l04585"></a>04585 
<a name="l04586"></a>04586         EVP_PKEY_free(pkey); pkey = NULL;
<a name="l04587"></a>04587     }
<a name="l04588"></a>04588     <span class="comment">// --------------------------</span>
<a name="l04589"></a>04589     <span class="comment">// At some point have to call this.</span>
<a name="l04590"></a>04590     <span class="comment">//</span>
<a name="l04591"></a>04591     X509_free(x509);   x509 = NULL;
<a name="l04592"></a>04592     <span class="comment">// --------------------------</span>
<a name="l04593"></a>04593     <span class="keywordflow">return</span> bVerifySig;
<a name="l04594"></a>04594 }
<a name="l04595"></a>04595 
<a name="l04596"></a>04596 
<a name="l04597"></a>04597 <span class="comment">// OpenSSL_BIO</span>
<a name="l04598"></a>04598 
<a name="l04599"></a>04599 <span class="comment">//static</span>
<a name="l04600"></a>04600 BIO * OpenSSL_BIO::assertBioNotNull(BIO * pBIO)
<a name="l04601"></a>04601 {
<a name="l04602"></a>04602     <span class="keywordflow">if</span> (NULL == pBIO) <a class="code" href="_o_t_assert_8hpp.html#a1ae1def3bdc59b89b0d96240d3c5c321">OT_FAIL</a>;
<a name="l04603"></a>04603     <span class="keywordflow">return</span> pBIO;
<a name="l04604"></a>04604 }
<a name="l04605"></a>04605 
<a name="l04606"></a>04606 
<a name="l04607"></a>04607 <a class="code" href="class_open_s_s_l___b_i_o.html#aad882ab4d63a8d80021d4c3f545df518">OpenSSL_BIO::OpenSSL_BIO</a>(BIO * pBIO) : m_refBIO(*assertBioNotNull(pBIO)), bCleanup(true), bFreeOnly(false)
<a name="l04608"></a>04608 {
<a name="l04609"></a>04609 }
<a name="l04610"></a>04610 
<a name="l04611"></a>04611 
<a name="l04612"></a>04612 <a class="code" href="class_open_s_s_l___b_i_o.html#a0464fd814c12cc74974ff5746c904e38">OpenSSL_BIO::~OpenSSL_BIO</a>()
<a name="l04613"></a>04613 {
<a name="l04614"></a>04614     <span class="keywordflow">if</span>(bCleanup) {
<a name="l04615"></a>04615         <span class="keywordflow">if</span>(NULL != &amp;m_refBIO) {
<a name="l04616"></a>04616             <span class="keywordflow">if</span> (bFreeOnly)
<a name="l04617"></a>04617             {
<a name="l04618"></a>04618                 BIO_free(&amp;m_refBIO);
<a name="l04619"></a>04619             }
<a name="l04620"></a>04620             <span class="keywordflow">else</span>
<a name="l04621"></a>04621             {
<a name="l04622"></a>04622                 BIO_free_all(&amp;m_refBIO);
<a name="l04623"></a>04623             }
<a name="l04624"></a>04624         }
<a name="l04625"></a>04625     }
<a name="l04626"></a>04626 }
<a name="l04627"></a>04627 
<a name="l04628"></a>04628 
<a name="l04629"></a>04629 <a class="code" href="class_open_s_s_l___b_i_o.html#aecc40810785ea2d9d3ce32d302db0bf0">OpenSSL_BIO::operator BIO *</a>()<span class="keyword"> const</span>
<a name="l04630"></a>04630 <span class="keyword"></span>{
<a name="l04631"></a>04631     <span class="keywordflow">return</span> (&amp;m_refBIO);
<a name="l04632"></a>04632 }
<a name="l04633"></a>04633 
<a name="l04634"></a>04634 
<a name="l04635"></a>04635 <span class="keywordtype">void</span> <a class="code" href="class_open_s_s_l___b_i_o.html#a641bbca2aa7d30d99b20267cbee9d542">OpenSSL_BIO::release</a>()
<a name="l04636"></a>04636 {
<a name="l04637"></a>04637     bCleanup = <span class="keyword">false</span>;
<a name="l04638"></a>04638 }
<a name="l04639"></a>04639 
<a name="l04640"></a>04640 
<a name="l04641"></a>04641 <span class="keywordtype">void</span> <a class="code" href="class_open_s_s_l___b_i_o.html#aff116876302d242f071191158ca345a4">OpenSSL_BIO::setFreeOnly</a>()
<a name="l04642"></a>04642 {
<a name="l04643"></a>04643     bFreeOnly = <span class="keyword">true</span>;
<a name="l04644"></a>04644 }
<a name="l04645"></a>04645 
<a name="l04646"></a>04646 
<a name="l04647"></a>04647 <span class="preprocessor">#elif defined (OT_CRYPTO_USING_GPG)</span>
<a name="l04648"></a>04648 <span class="preprocessor"></span>
<a name="l04649"></a>04649 
<a name="l04650"></a>04650 <span class="comment">// Someday    }:-)</span>
<a name="l04651"></a>04651 
<a name="l04652"></a>04652 
<a name="l04653"></a>04653 <span class="preprocessor">#else // Apparently NO crypto engine is defined!</span>
<a name="l04654"></a>04654 <span class="preprocessor"></span>
<a name="l04655"></a>04655 
<a name="l04656"></a>04656 <span class="comment">// Perhaps error out here...</span>
<a name="l04657"></a>04657 
<a name="l04658"></a>04658 
<a name="l04659"></a>04659 <span class="preprocessor">#endif // if defined (OT_CRYPTO_USING_OPENSSL), elif defined (OT_CRYPTO_USING_GPG), else, endif.</span>
<a name="l04660"></a>04660 <span class="preprocessor"></span>
<a name="l04661"></a>04661 
<a name="l04662"></a>04662 <span class="comment">/*</span>
<a name="l04663"></a>04663 <span class="comment"></span>
<a name="l04664"></a>04664 <span class="comment"> DERIVING KEYS FROM A PASSWORD</span>
<a name="l04665"></a>04665 <span class="comment"></span>
<a name="l04666"></a>04666 <span class="comment"> #include &lt;evp.h&gt;</span>
<a name="l04667"></a>04667 <span class="comment"> #include &lt;openssl/rand.h&gt;</span>
<a name="l04668"></a>04668 <span class="comment"></span>
<a name="l04669"></a>04669 <span class="comment"> char * passwd = &quot;secret password&quot;;</span>
<a name="l04670"></a>04670 <span class="comment"></span>
<a name="l04671"></a>04671 <span class="comment"> uint8_t salt[8];</span>
<a name="l04672"></a>04672 <span class="comment"></span>
<a name="l04673"></a>04673 <span class="comment"> int32_t iter = 65535;</span>
<a name="l04674"></a>04674 <span class="comment"></span>
<a name="l04675"></a>04675 <span class="comment"> uint8_t key[16];</span>
<a name="l04676"></a>04676 <span class="comment"></span>
<a name="l04677"></a>04677 <span class="comment"> RAND_bytes(salt, sizeof(salt));</span>
<a name="l04678"></a>04678 <span class="comment"></span>
<a name="l04679"></a>04679 <span class="comment"> // From OTPassword.h:</span>
<a name="l04680"></a>04680 <span class="comment"> // size_t strnlen(const char *s, size_t max)</span>
<a name="l04681"></a>04681 <span class="comment"></span>
<a name="l04682"></a>04682 <span class="comment"> PKCS5_PBKDF2_HMAC_SHA1(passwd, strnlen(passwd, BIGGEST_POSSIBLE_PWD), salt, sizeof(salt), iter, sizeof(key), key);</span>
<a name="l04683"></a>04683 <span class="comment"></span>
<a name="l04684"></a>04684 <span class="comment"> AES_KEY aes_key;</span>
<a name="l04685"></a>04685 <span class="comment"> AES_set_encrypt_key(key, 128, aes_key);</span>
<a name="l04686"></a>04686 <span class="comment"></span>
<a name="l04687"></a>04687 <span class="comment"></span>
<a name="l04688"></a>04688 <span class="comment"> // perform aes encryption here...</span>
<a name="l04689"></a>04689 <span class="comment"></span>
<a name="l04690"></a>04690 <span class="comment"> uint8_t iv[16];</span>
<a name="l04691"></a>04691 <span class="comment"> RAND_bytes(iv,   sizeof(iv));</span>
<a name="l04692"></a>04692 <span class="comment"></span>
<a name="l04693"></a>04693 <span class="comment"></span>
<a name="l04694"></a>04694 <span class="comment"> -----------------------------------------------------------</span>
<a name="l04695"></a>04695 <span class="comment"></span>
<a name="l04696"></a>04696 <span class="comment"> DEALING WITH SALT:</span>
<a name="l04697"></a>04697 <span class="comment"></span>
<a name="l04698"></a>04698 <span class="comment"> // Note: Salt is generated randomly when the symmetric key is created from the passphrase.</span>
<a name="l04699"></a>04699 <span class="comment"> // Then the salt must be STORED with the symmetric key, so that the passphrase / salt / encrypted symmetric key</span>
<a name="l04700"></a>04700 <span class="comment"> // can later be used to produce a decrypted symmetric key (which should not stay in memory for int64_t...)</span>
<a name="l04701"></a>04701 <span class="comment"> //</span>
<a name="l04702"></a>04702 <span class="comment"></span>
<a name="l04703"></a>04703 <span class="comment">int32_t main()</span>
<a name="l04704"></a>04704 <span class="comment">{</span>
<a name="l04705"></a>04705 <span class="comment">    char *pass = &quot;password&quot;;</span>
<a name="l04706"></a>04706 <span class="comment">    char *salt = &quot;12340000&quot;;</span>
<a name="l04707"></a>04707 <span class="comment">    int32_t ic = 1;</span>
<a name="l04708"></a>04708 <span class="comment">    uint8_t buf[1024];</span>
<a name="l04709"></a>04709 <span class="comment"></span>
<a name="l04710"></a>04710 <span class="comment">    ic = 1;</span>
<a name="l04711"></a>04711 <span class="comment">    PKCS5_PBKDF2_HMAC_SHA1(pass, strlen(pass), (uint8_t*)salt, strlen(salt), ic, 32+16, buf);</span>
<a name="l04712"></a>04712 <span class="comment">    printf(&quot;PKCS5_PBKDF2_HMAC_SHA1(\&quot;%s\&quot;, \&quot;%s\&quot;, %d)=\n&quot;, pass, salt, ic);</span>
<a name="l04713"></a>04713 <span class="comment">    print_hex(buf, 32+16);</span>
<a name="l04714"></a>04714 <span class="comment"></span>
<a name="l04715"></a>04715 <span class="comment"> // NOTE: The above function is used INSTEAD of the one below!</span>
<a name="l04716"></a>04716 <span class="comment"></span>
<a name="l04717"></a>04717 <span class="comment">    ic = 1;</span>
<a name="l04718"></a>04718 <span class="comment">    EVP_BytesToKey(EVP_aes_256_cbc(), EVP_sha1(), (uint8_t*)salt, (uint8_t*)pass, strlen(pass), ic, buf, buf+32);</span>
<a name="l04719"></a>04719 <span class="comment">    printf(&quot;EVP_BytesToKey(\&quot;%s\&quot;, \&quot;%s\&quot;, %d)=\n&quot;, pass, salt, ic);</span>
<a name="l04720"></a>04720 <span class="comment">    print_hex(buf, 32+16);</span>
<a name="l04721"></a>04721 <span class="comment"></span>
<a name="l04722"></a>04722 <span class="comment">    return(0);</span>
<a name="l04723"></a>04723 <span class="comment">}</span>
<a name="l04724"></a>04724 <span class="comment"></span>
<a name="l04725"></a>04725 <span class="comment"></span>
<a name="l04726"></a>04726 <span class="comment"></span>
<a name="l04727"></a>04727 <span class="comment"></span>
<a name="l04728"></a>04728 <span class="comment"></span>
<a name="l04729"></a>04729 <span class="comment"> int32_t EVP_BytesToKey(const EVP_CIPHER *type,const EVP_MD *md,</span>
<a name="l04730"></a>04730 <span class="comment">                    const uint8_t *salt,</span>
<a name="l04731"></a>04731 <span class="comment">                    const uint8_t *data, int32_t datal,</span>
<a name="l04732"></a>04732 <span class="comment">                    int32_t count,</span>
<a name="l04733"></a>04733 <span class="comment">                    uint8_t *key,uint8_t *iv);</span>
<a name="l04734"></a>04734 <span class="comment"></span>
<a name="l04735"></a>04735 <span class="comment"> EVP_BytesToKey() derives a key and IV from various parameters.</span>
<a name="l04736"></a>04736 <span class="comment">    type is the cipher to derive the key and IV for.</span>
<a name="l04737"></a>04737 <span class="comment">    md is the message digest to use.</span>
<a name="l04738"></a>04738 <span class="comment">    The salt paramter is used as a salt in the derivation: it should point to an 8 byte buffer or NULL if no salt is used.</span>
<a name="l04739"></a>04739 <span class="comment">    data is a buffer containing datal bytes which is used to derive the keying data.</span>
<a name="l04740"></a>04740 <span class="comment">    count is the iteration count to use.</span>
<a name="l04741"></a>04741 <span class="comment"> The derived key and IV will be written to key and iv respectively.</span>
<a name="l04742"></a>04742 <span class="comment"> -----------------------------------------------------------</span>
<a name="l04743"></a>04743 <span class="comment"></span>
<a name="l04744"></a>04744 <span class="comment"></span>
<a name="l04745"></a>04745 <span class="comment"></span>
<a name="l04746"></a>04746 <span class="comment"> The initialization vector needs to be known to Alice AND Bob.</span>
<a name="l04747"></a>04747 <span class="comment">   And it needs to be transmitted at the time the session key is negotiated.</span>
<a name="l04748"></a>04748 <span class="comment"></span>
<a name="l04749"></a>04749 <span class="comment"> So there should probably be a &quot;OTEnvelope&quot; class which stores the IV</span>
<a name="l04750"></a>04750 <span class="comment"> as well as the session key, and which can be encrypted with a public key</span>
<a name="l04751"></a>04751 <span class="comment"> and decrypted with a private key. The keys can just be passed in or whatever.</span>
<a name="l04752"></a>04752 <span class="comment"></span>
<a name="l04753"></a>04753 <span class="comment"></span>
<a name="l04754"></a>04754 <span class="comment">int32_t PKCS5_PBKDF2_HMAC_SHA1  (</span>
<a name="l04755"></a>04755 <span class="comment">    const void *    password,</span>
<a name="l04756"></a>04756 <span class="comment">    size_t          password_len,</span>
<a name="l04757"></a>04757 <span class="comment">    const void *    salt,</span>
<a name="l04758"></a>04758 <span class="comment">    size_t          salt_len,</span>
<a name="l04759"></a>04759 <span class="comment">    uint64_t    iter,</span>
<a name="l04760"></a>04760 <span class="comment">    size_t          keylen,</span>
<a name="l04761"></a>04761 <span class="comment">    void *          key</span>
<a name="l04762"></a>04762 <span class="comment">)</span>
<a name="l04763"></a>04763 <span class="comment"></span>
<a name="l04764"></a>04764 <span class="comment"></span>
<a name="l04765"></a>04765 <span class="comment"> OPENSSL&#39;s version:</span>
<a name="l04766"></a>04766 <span class="comment"></span>
<a name="l04767"></a>04767 <span class="comment"> int32_t PKCS5_PBKDF2_HMAC_SHA1(</span>
<a name="l04768"></a>04768 <span class="comment">    const char *pass, int32_t passlen,</span>
<a name="l04769"></a>04769 <span class="comment">    const uint8_t *salt, int32_t saltlen,</span>
<a name="l04770"></a>04770 <span class="comment">    int32_t iter,</span>
<a name="l04771"></a>04771 <span class="comment">    int32_t keylen,  uint8_t *out);</span>
<a name="l04772"></a>04772 <span class="comment"></span>
<a name="l04773"></a>04773 <span class="comment"> */</span>
<a name="l04774"></a>04774 
<a name="l04775"></a>04775 <span class="comment">/*</span>
<a name="l04776"></a>04776 <span class="comment">int32_t do_evp_seal(FILE *rsa_pkey_file, FILE *in_file, FILE *out_file)</span>
<a name="l04777"></a>04777 <span class="comment">{</span>
<a name="l04778"></a>04778 <span class="comment">    int32_t retval = 0;</span>
<a name="l04779"></a>04779 <span class="comment">    RSA *rsa_pkey = NULL;</span>
<a name="l04780"></a>04780 <span class="comment">    EVP_PKEY *pkey = EVP_PKEY_new();</span>
<a name="l04781"></a>04781 <span class="comment">    EVP_CIPHER_CTX ctx;</span>
<a name="l04782"></a>04782 <span class="comment">    uint8_t buffer[4096];</span>
<a name="l04783"></a>04783 <span class="comment">    uint8_t buffer_out[4096 + EVP_MAX_IV_LENGTH];</span>
<a name="l04784"></a>04784 <span class="comment">    size_t len;</span>
<a name="l04785"></a>04785 <span class="comment">    int32_t len_out;</span>
<a name="l04786"></a>04786 <span class="comment">    uint8_t *ek;</span>
<a name="l04787"></a>04787 <span class="comment">    int32_t eklen;</span>
<a name="l04788"></a>04788 <span class="comment">    uint32_t eklen_n;</span>
<a name="l04789"></a>04789 <span class="comment">    uint8_t iv[EVP_MAX_IV_LENGTH];</span>
<a name="l04790"></a>04790 <span class="comment"></span>
<a name="l04791"></a>04791 <span class="comment">    if (!PEM_read_RSA_PUBKEY(rsa_pkey_file, &amp;rsa_pkey, OTAsymmetricKey::GetPasswordCallback(), NULL))</span>
<a name="l04792"></a>04792 <span class="comment">    {</span>
<a name="l04793"></a>04793 <span class="comment">        OTLog::Error(&quot;Error loading RSA Public Key File.\n&quot;);</span>
<a name="l04794"></a>04794 <span class="comment">        ERR_print_errors_fp(stderr);</span>
<a name="l04795"></a>04795 <span class="comment">        retval = 2;</span>
<a name="l04796"></a>04796 <span class="comment">        goto out;</span>
<a name="l04797"></a>04797 <span class="comment">    }</span>
<a name="l04798"></a>04798 <span class="comment"></span>
<a name="l04799"></a>04799 <span class="comment">    if (!EVP_PKEY_assign_RSA(pkey, rsa_pkey))</span>
<a name="l04800"></a>04800 <span class="comment">    {</span>
<a name="l04801"></a>04801 <span class="comment">        OTLog::Error(&quot;EVP_PKEY_assign_RSA: failed.\n&quot;);</span>
<a name="l04802"></a>04802 <span class="comment">        retval = 3;</span>
<a name="l04803"></a>04803 <span class="comment">        goto out;</span>
<a name="l04804"></a>04804 <span class="comment">    }</span>
<a name="l04805"></a>04805 <span class="comment"></span>
<a name="l04806"></a>04806 <span class="comment">    EVP_CIPHER_CTX_init(&amp;ctx);</span>
<a name="l04807"></a>04807 <span class="comment">    ek = malloc(EVP_PKEY_size(pkey));</span>
<a name="l04808"></a>04808 <span class="comment"></span>
<a name="l04809"></a>04809 <span class="comment">    if (!EVP_SealInit(&amp;ctx, EVP_aes_128_cbc(), &amp;ek, &amp;eklen, iv, &amp;pkey, 1))</span>
<a name="l04810"></a>04810 <span class="comment">    {</span>
<a name="l04811"></a>04811 <span class="comment">        OTLog::Error(&quot;EVP_SealInit: failed.\n&quot;);</span>
<a name="l04812"></a>04812 <span class="comment">        retval = 3;</span>
<a name="l04813"></a>04813 <span class="comment">        goto out_free;</span>
<a name="l04814"></a>04814 <span class="comment">    }</span>
<a name="l04815"></a>04815 <span class="comment"></span>
<a name="l04816"></a>04816 <span class="comment">    // First we write out the encrypted key length, then the encrypted key,</span>
<a name="l04817"></a>04817 <span class="comment">     / then the iv (the IV length is fixed by the cipher we have chosen).</span>
<a name="l04818"></a>04818 <span class="comment"></span>
<a name="l04819"></a>04819 <span class="comment"></span>
<a name="l04820"></a>04820 <span class="comment">    eklen_n = htonl(eklen);</span>
<a name="l04821"></a>04821 <span class="comment">    if (fwrite(&amp;eklen_n, sizeof eklen_n, 1, out_file) != 1)</span>
<a name="l04822"></a>04822 <span class="comment">    {</span>
<a name="l04823"></a>04823 <span class="comment">        perror(&quot;output file&quot;);</span>
<a name="l04824"></a>04824 <span class="comment">        retval = 5;</span>
<a name="l04825"></a>04825 <span class="comment">        goto out_free;</span>
<a name="l04826"></a>04826 <span class="comment">    }</span>
<a name="l04827"></a>04827 <span class="comment">    if (fwrite(ek, eklen, 1, out_file) != 1)</span>
<a name="l04828"></a>04828 <span class="comment">    {</span>
<a name="l04829"></a>04829 <span class="comment">        perror(&quot;output file&quot;);</span>
<a name="l04830"></a>04830 <span class="comment">        retval = 5;</span>
<a name="l04831"></a>04831 <span class="comment">        goto out_free;</span>
<a name="l04832"></a>04832 <span class="comment">    }</span>
<a name="l04833"></a>04833 <span class="comment">    if (fwrite(iv, EVP_CIPHER_iv_length(EVP_aes_128_cbc()), 1, out_file) != 1)</span>
<a name="l04834"></a>04834 <span class="comment">    {</span>
<a name="l04835"></a>04835 <span class="comment">        perror(&quot;output file&quot;);</span>
<a name="l04836"></a>04836 <span class="comment">        retval = 5;</span>
<a name="l04837"></a>04837 <span class="comment">        goto out_free;</span>
<a name="l04838"></a>04838 <span class="comment">    }</span>
<a name="l04839"></a>04839 <span class="comment"></span>
<a name="l04840"></a>04840 <span class="comment">    // Now we process the input file and write the encrypted data to the</span>
<a name="l04841"></a>04841 <span class="comment">    //output file.</span>
<a name="l04842"></a>04842 <span class="comment"></span>
<a name="l04843"></a>04843 <span class="comment">    while ((len = fread(buffer, 1, sizeof buffer, in_file)) &gt; 0)</span>
<a name="l04844"></a>04844 <span class="comment">    {</span>
<a name="l04845"></a>04845 <span class="comment">        if (!EVP_SealUpdate(&amp;ctx, buffer_out, &amp;len_out, buffer, len))</span>
<a name="l04846"></a>04846 <span class="comment">        {</span>
<a name="l04847"></a>04847 <span class="comment">            OTLog::Error(&quot;EVP_SealUpdate: failed.\n&quot;);</span>
<a name="l04848"></a>04848 <span class="comment">            retval = 3;</span>
<a name="l04849"></a>04849 <span class="comment">            goto out_free;</span>
<a name="l04850"></a>04850 <span class="comment">        }</span>
<a name="l04851"></a>04851 <span class="comment"></span>
<a name="l04852"></a>04852 <span class="comment">        if (fwrite(buffer_out, len_out, 1, out_file) != 1)</span>
<a name="l04853"></a>04853 <span class="comment">        {</span>
<a name="l04854"></a>04854 <span class="comment">            perror(&quot;output file&quot;);</span>
<a name="l04855"></a>04855 <span class="comment">            retval = 5;</span>
<a name="l04856"></a>04856 <span class="comment">            goto out_free;</span>
<a name="l04857"></a>04857 <span class="comment">        }</span>
<a name="l04858"></a>04858 <span class="comment">    }</span>
<a name="l04859"></a>04859 <span class="comment"></span>
<a name="l04860"></a>04860 <span class="comment">    if (ferror(in_file))</span>
<a name="l04861"></a>04861 <span class="comment">    {</span>
<a name="l04862"></a>04862 <span class="comment">        perror(&quot;input file&quot;);</span>
<a name="l04863"></a>04863 <span class="comment">        retval = 4;</span>
<a name="l04864"></a>04864 <span class="comment">        goto out_free;</span>
<a name="l04865"></a>04865 <span class="comment">    }</span>
<a name="l04866"></a>04866 <span class="comment"></span>
<a name="l04867"></a>04867 <span class="comment">    if (!EVP_SealFinal(&amp;ctx, buffer_out, &amp;len_out))</span>
<a name="l04868"></a>04868 <span class="comment">    {</span>
<a name="l04869"></a>04869 <span class="comment">        OTLog::Error(&quot;EVP_SealFinal: failed.\n&quot;);</span>
<a name="l04870"></a>04870 <span class="comment">        retval = 3;</span>
<a name="l04871"></a>04871 <span class="comment">        goto out_free;</span>
<a name="l04872"></a>04872 <span class="comment">    }</span>
<a name="l04873"></a>04873 <span class="comment"></span>
<a name="l04874"></a>04874 <span class="comment">    if (fwrite(buffer_out, len_out, 1, out_file) != 1)</span>
<a name="l04875"></a>04875 <span class="comment">    {</span>
<a name="l04876"></a>04876 <span class="comment">        perror(&quot;output file&quot;);</span>
<a name="l04877"></a>04877 <span class="comment">        retval = 5;</span>
<a name="l04878"></a>04878 <span class="comment">        goto out_free;</span>
<a name="l04879"></a>04879 <span class="comment">    }</span>
<a name="l04880"></a>04880 <span class="comment"></span>
<a name="l04881"></a>04881 <span class="comment">out_free:</span>
<a name="l04882"></a>04882 <span class="comment">    EVP_PKEY_free(pkey);</span>
<a name="l04883"></a>04883 <span class="comment">    free(ek);</span>
<a name="l04884"></a>04884 <span class="comment"></span>
<a name="l04885"></a>04885 <span class="comment">out:</span>
<a name="l04886"></a>04886 <span class="comment">    return retval;</span>
<a name="l04887"></a>04887 <span class="comment">}</span>
<a name="l04888"></a>04888 <span class="comment"></span>
<a name="l04889"></a>04889 <span class="comment">int32_t main(int32_t argc, char *argv[])</span>
<a name="l04890"></a>04890 <span class="comment">{</span>
<a name="l04891"></a>04891 <span class="comment">    FILE *rsa_pkey_file;</span>
<a name="l04892"></a>04892 <span class="comment">    int32_t rv;</span>
<a name="l04893"></a>04893 <span class="comment"></span>
<a name="l04894"></a>04894 <span class="comment">    if (argc &lt; 2)</span>
<a name="l04895"></a>04895 <span class="comment">    {</span>
<a name="l04896"></a>04896 <span class="comment">        OTLog::vOutput(0, &quot;Usage: %s &lt;PEM RSA Public Key File&gt;\n&quot;, argv[0]);</span>
<a name="l04897"></a>04897 <span class="comment">        exit(1);</span>
<a name="l04898"></a>04898 <span class="comment">    }</span>
<a name="l04899"></a>04899 <span class="comment"></span>
<a name="l04900"></a>04900 <span class="comment">    rsa_pkey_file = fopen(argv[1], &quot;rb&quot;);</span>
<a name="l04901"></a>04901 <span class="comment">    if (!rsa_pkey_file)</span>
<a name="l04902"></a>04902 <span class="comment">    {</span>
<a name="l04903"></a>04903 <span class="comment">        perror(argv[1]);</span>
<a name="l04904"></a>04904 <span class="comment">        OTLog::Error(&quot;Error loading PEM RSA Public Key File.\n&quot;);</span>
<a name="l04905"></a>04905 <span class="comment">        exit(2);</span>
<a name="l04906"></a>04906 <span class="comment">    }</span>
<a name="l04907"></a>04907 <span class="comment"></span>
<a name="l04908"></a>04908 <span class="comment">    rv = do_evp_seal(rsa_pkey_file, stdin, stdout);</span>
<a name="l04909"></a>04909 <span class="comment"></span>
<a name="l04910"></a>04910 <span class="comment">    fclose(rsa_pkey_file);</span>
<a name="l04911"></a>04911 <span class="comment">    return rv;</span>
<a name="l04912"></a>04912 <span class="comment">}</span>
<a name="l04913"></a>04913 <span class="comment">*/</span>
</pre></div></div><!-- contents -->
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="_o_t_crypto_8cpp.html">OTCrypto.cpp</a>      </li>

    <li class="footer">Generated on Wed May 21 2014 11:26:03 for Open-Transactions by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1 </li>
   </ul>
 </div>


</body>
</html>
