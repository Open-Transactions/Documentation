<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Open-Transactions: src/otlib/OTSmartContract.cpp Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Open-Transactions
   &#160;<span id="projectnumber">master/1066fb4910a63ee3f7de8e0807fee3eb663b66c7</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('_o_t_smart_contract_8cpp.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">src/otlib/OTSmartContract.cpp</div>  </div>
</div><!--header-->
<div class="contents">
<a href="_o_t_smart_contract_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/************************************************************</span>
<a name="l00002"></a>00002 <span class="comment"> *</span>
<a name="l00003"></a>00003 <span class="comment"> *  OTSmartContract.cpp</span>
<a name="l00004"></a>00004 <span class="comment"> *</span>
<a name="l00005"></a>00005 <span class="comment"> * OTSmartContract is derived from OTCronItem.</span>
<a name="l00006"></a>00006 <span class="comment"> * It handles re-occuring, (scriptable) smart contracts.</span>
<a name="l00007"></a>00007 <span class="comment"> *</span>
<a name="l00008"></a>00008 <span class="comment"> */</span>
<a name="l00009"></a>00009 
<a name="l00010"></a>00010 <span class="comment">/************************************************************</span>
<a name="l00011"></a>00011 <span class="comment"> -----BEGIN PGP SIGNED MESSAGE-----</span>
<a name="l00012"></a>00012 <span class="comment"> Hash: SHA1</span>
<a name="l00013"></a>00013 <span class="comment"></span>
<a name="l00014"></a>00014 <span class="comment"> *                 OPEN TRANSACTIONS</span>
<a name="l00015"></a>00015 <span class="comment"> *</span>
<a name="l00016"></a>00016 <span class="comment"> *       Financial Cryptography and Digital Cash</span>
<a name="l00017"></a>00017 <span class="comment"> *       Library, Protocol, API, Server, CLI, GUI</span>
<a name="l00018"></a>00018 <span class="comment"> *</span>
<a name="l00019"></a>00019 <span class="comment"> *       -- Anonymous Numbered Accounts.</span>
<a name="l00020"></a>00020 <span class="comment"> *       -- Untraceable Digital Cash.</span>
<a name="l00021"></a>00021 <span class="comment"> *       -- Triple-Signed Receipts.</span>
<a name="l00022"></a>00022 <span class="comment"> *       -- Cheques, Vouchers, Transfers, Inboxes.</span>
<a name="l00023"></a>00023 <span class="comment"> *       -- Basket Currencies, Markets, Payment Plans.</span>
<a name="l00024"></a>00024 <span class="comment"> *       -- Signed, XML, Ricardian-style Contracts.</span>
<a name="l00025"></a>00025 <span class="comment"> *       -- Scripted smart contracts.</span>
<a name="l00026"></a>00026 <span class="comment"> *</span>
<a name="l00027"></a>00027 <span class="comment"> *  Copyright (C) 2010-2013 by &quot;Fellow Traveler&quot; (A pseudonym)</span>
<a name="l00028"></a>00028 <span class="comment"> *</span>
<a name="l00029"></a>00029 <span class="comment"> *  EMAIL:</span>
<a name="l00030"></a>00030 <span class="comment"> *  FellowTraveler@rayservers.net</span>
<a name="l00031"></a>00031 <span class="comment"> *</span>
<a name="l00032"></a>00032 <span class="comment"> *  BITCOIN:  1NtTPVVjDsUfDWybS4BwvHpG2pdS9RnYyQ</span>
<a name="l00033"></a>00033 <span class="comment"> *</span>
<a name="l00034"></a>00034 <span class="comment"> *  KEY FINGERPRINT (PGP Key in license file):</span>
<a name="l00035"></a>00035 <span class="comment"> *  9DD5 90EB 9292 4B48 0484  7910 0308 00ED F951 BB8E</span>
<a name="l00036"></a>00036 <span class="comment"> *</span>
<a name="l00037"></a>00037 <span class="comment"> *  OFFICIAL PROJECT WIKI(s):</span>
<a name="l00038"></a>00038 <span class="comment"> *  https://github.com/FellowTraveler/Moneychanger</span>
<a name="l00039"></a>00039 <span class="comment"> *  https://github.com/FellowTraveler/Open-Transactions/wiki</span>
<a name="l00040"></a>00040 <span class="comment"> *</span>
<a name="l00041"></a>00041 <span class="comment"> *  WEBSITE:</span>
<a name="l00042"></a>00042 <span class="comment"> *  http://www.OpenTransactions.org/</span>
<a name="l00043"></a>00043 <span class="comment"> *</span>
<a name="l00044"></a>00044 <span class="comment"> *  Components and licensing:</span>
<a name="l00045"></a>00045 <span class="comment"> *   -- Moneychanger..A Java client GUI.....LICENSE:.....GPLv3</span>
<a name="l00046"></a>00046 <span class="comment"> *   -- otlib.........A class library.......LICENSE:...LAGPLv3</span>
<a name="l00047"></a>00047 <span class="comment"> *   -- otapi.........A client API..........LICENSE:...LAGPLv3</span>
<a name="l00048"></a>00048 <span class="comment"> *   -- opentxs/ot....Command-line client...LICENSE:...LAGPLv3</span>
<a name="l00049"></a>00049 <span class="comment"> *   -- otserver......Server Application....LICENSE:....AGPLv3</span>
<a name="l00050"></a>00050 <span class="comment"> *  Github.com/FellowTraveler/Open-Transactions/wiki/Components</span>
<a name="l00051"></a>00051 <span class="comment"> *</span>
<a name="l00052"></a>00052 <span class="comment"> *  All of the above OT components were designed and written by</span>
<a name="l00053"></a>00053 <span class="comment"> *  Fellow Traveler, with the exception of Moneychanger, which</span>
<a name="l00054"></a>00054 <span class="comment"> *  was contracted out to Vicky C (bitcointrader4@gmail.com).</span>
<a name="l00055"></a>00055 <span class="comment"> *  The open-source community has since actively contributed.</span>
<a name="l00056"></a>00056 <span class="comment"> *</span>
<a name="l00057"></a>00057 <span class="comment"> *  -----------------------------------------------------</span>
<a name="l00058"></a>00058 <span class="comment"> *</span>
<a name="l00059"></a>00059 <span class="comment"> *   LICENSE:</span>
<a name="l00060"></a>00060 <span class="comment"> *   This program is free software: you can redistribute it</span>
<a name="l00061"></a>00061 <span class="comment"> *   and/or modify it under the terms of the GNU Affero</span>
<a name="l00062"></a>00062 <span class="comment"> *   General Public License as published by the Free Software</span>
<a name="l00063"></a>00063 <span class="comment"> *   Foundation, either version 3 of the License, or (at your</span>
<a name="l00064"></a>00064 <span class="comment"> *   option) any later version.</span>
<a name="l00065"></a>00065 <span class="comment"> *</span>
<a name="l00066"></a>00066 <span class="comment"> *   ADDITIONAL PERMISSION under the GNU Affero GPL version 3</span>
<a name="l00067"></a>00067 <span class="comment"> *   section 7: (This paragraph applies only to the LAGPLv3</span>
<a name="l00068"></a>00068 <span class="comment"> *   components listed above.) If you modify this Program, or</span>
<a name="l00069"></a>00069 <span class="comment"> *   any covered work, by linking or combining it with other</span>
<a name="l00070"></a>00070 <span class="comment"> *   code, such other code is not for that reason alone subject</span>
<a name="l00071"></a>00071 <span class="comment"> *   to any of the requirements of the GNU Affero GPL version 3.</span>
<a name="l00072"></a>00072 <span class="comment"> *   (==&gt; This means if you are only using the OT API, then you</span>
<a name="l00073"></a>00073 <span class="comment"> *   don&#39;t have to open-source your code--only your changes to</span>
<a name="l00074"></a>00074 <span class="comment"> *   Open-Transactions itself must be open source. Similar to</span>
<a name="l00075"></a>00075 <span class="comment"> *   LGPLv3, except it applies to software-as-a-service, not</span>
<a name="l00076"></a>00076 <span class="comment"> *   just to distributing binaries.)</span>
<a name="l00077"></a>00077 <span class="comment"> *</span>
<a name="l00078"></a>00078 <span class="comment"> *   Extra WAIVER for OpenSSL, Lucre, and all other libraries</span>
<a name="l00079"></a>00079 <span class="comment"> *   used by Open Transactions: This program is released under</span>
<a name="l00080"></a>00080 <span class="comment"> *   the AGPL with the additional exemption that compiling,</span>
<a name="l00081"></a>00081 <span class="comment"> *   linking, and/or using OpenSSL is allowed. The same is true</span>
<a name="l00082"></a>00082 <span class="comment"> *   for any other open source libraries included in this</span>
<a name="l00083"></a>00083 <span class="comment"> *   project: complete waiver from the AGPL is hereby granted to</span>
<a name="l00084"></a>00084 <span class="comment"> *   compile, link, and/or use them with Open-Transactions,</span>
<a name="l00085"></a>00085 <span class="comment"> *   according to their own terms, as long as the rest of the</span>
<a name="l00086"></a>00086 <span class="comment"> *   Open-Transactions terms remain respected, with regard to</span>
<a name="l00087"></a>00087 <span class="comment"> *   the Open-Transactions code itself.</span>
<a name="l00088"></a>00088 <span class="comment"> *</span>
<a name="l00089"></a>00089 <span class="comment"> *   Lucre License:</span>
<a name="l00090"></a>00090 <span class="comment"> *   This code is also &quot;dual-license&quot;, meaning that Ben Lau-</span>
<a name="l00091"></a>00091 <span class="comment"> *   rie&#39;s license must also be included and respected, since</span>
<a name="l00092"></a>00092 <span class="comment"> *   the code for Lucre is also included with Open Transactions.</span>
<a name="l00093"></a>00093 <span class="comment"> *   See Open-Transactions/src/otlib/lucre/LUCRE_LICENSE.txt</span>
<a name="l00094"></a>00094 <span class="comment"> *   The Laurie requirements are light, but if there is any</span>
<a name="l00095"></a>00095 <span class="comment"> *   problem with his license, simply remove the Lucre code.</span>
<a name="l00096"></a>00096 <span class="comment"> *   Although there are no other blind token algorithms in Open</span>
<a name="l00097"></a>00097 <span class="comment"> *   Transactions (yet. credlib is coming), the other functions</span>
<a name="l00098"></a>00098 <span class="comment"> *   will continue to operate.</span>
<a name="l00099"></a>00099 <span class="comment"> *   See Lucre on Github:  https://github.com/benlaurie/lucre</span>
<a name="l00100"></a>00100 <span class="comment"> *   -----------------------------------------------------</span>
<a name="l00101"></a>00101 <span class="comment"> *   You should have received a copy of the GNU Affero General</span>
<a name="l00102"></a>00102 <span class="comment"> *   Public License along with this program.  If not, see:</span>
<a name="l00103"></a>00103 <span class="comment"> *   http://www.gnu.org/licenses/</span>
<a name="l00104"></a>00104 <span class="comment"> *</span>
<a name="l00105"></a>00105 <span class="comment"> *   If you would like to use this software outside of the free</span>
<a name="l00106"></a>00106 <span class="comment"> *   software license, please contact FellowTraveler.</span>
<a name="l00107"></a>00107 <span class="comment"> *   (Unfortunately many will run anonymously and untraceably,</span>
<a name="l00108"></a>00108 <span class="comment"> *   so who could really stop them?)</span>
<a name="l00109"></a>00109 <span class="comment"> *</span>
<a name="l00110"></a>00110 <span class="comment"> *   DISCLAIMER:</span>
<a name="l00111"></a>00111 <span class="comment"> *   This program is distributed in the hope that it will be</span>
<a name="l00112"></a>00112 <span class="comment"> *   useful, but WITHOUT ANY WARRANTY; without even the implied</span>
<a name="l00113"></a>00113 <span class="comment"> *   warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR</span>
<a name="l00114"></a>00114 <span class="comment"> *   PURPOSE.  See the GNU Affero General Public License for</span>
<a name="l00115"></a>00115 <span class="comment"> *   more details.</span>
<a name="l00116"></a>00116 <span class="comment"></span>
<a name="l00117"></a>00117 <span class="comment"> -----BEGIN PGP SIGNATURE-----</span>
<a name="l00118"></a>00118 <span class="comment"> Version: GnuPG v1.4.9 (Darwin)</span>
<a name="l00119"></a>00119 <span class="comment"></span>
<a name="l00120"></a>00120 <span class="comment"> iQIcBAEBAgAGBQJRSsfJAAoJEAMIAO35UbuOQT8P/RJbka8etf7wbxdHQNAY+2cC</span>
<a name="l00121"></a>00121 <span class="comment"> vDf8J3X8VI+pwMqv6wgTVy17venMZJa4I4ikXD/MRyWV1XbTG0mBXk/7AZk7Rexk</span>
<a name="l00122"></a>00122 <span class="comment"> KTvL/U1kWiez6+8XXLye+k2JNM6v7eej8xMrqEcO0ZArh/DsLoIn1y8p8qjBI7+m</span>
<a name="l00123"></a>00123 <span class="comment"> aE7lhstDiD0z8mwRRLKFLN2IH5rAFaZZUvj5ERJaoYUKdn4c+RcQVei2YOl4T0FU</span>
<a name="l00124"></a>00124 <span class="comment"> LWND3YLoH8naqJXkaOKEN4UfJINCwxhe5Ke9wyfLWLUO7NamRkWD2T7CJ0xocnD1</span>
<a name="l00125"></a>00125 <span class="comment"> sjAzlVGNgaFDRflfIF4QhBx1Ddl6wwhJfw+d08bjqblSq8aXDkmFA7HeunSFKkdn</span>
<a name="l00126"></a>00126 <span class="comment"> oIEOEgyj+veuOMRJC5pnBJ9vV+7qRdDKQWaCKotynt4sWJDGQ9kWGWm74SsNaduN</span>
<a name="l00127"></a>00127 <span class="comment"> TPMyr9kNmGsfR69Q2Zq/FLcLX/j8ESxU+HYUB4vaARw2xEOu2xwDDv6jt0j3Vqsg</span>
<a name="l00128"></a>00128 <span class="comment"> x7rWv4S/Eh18FDNDkVRChiNoOIilLYLL6c38uMf1pnItBuxP3uhgY6COm59kVaRh</span>
<a name="l00129"></a>00129 <span class="comment"> nyGTYCDYD2TK+fI9o89F1297uDCwEJ62U0Q7iTDp5QuXCoxkPfv8/kX6lS6T3y9G</span>
<a name="l00130"></a>00130 <span class="comment"> M9mqIoLbIQ1EDntFv7/t6fUTS2+46uCrdZWbQ5RjYXdrzjij02nDmJAm2BngnZvd</span>
<a name="l00131"></a>00131 <span class="comment"> kamH0Y/n11lCvo1oQxM+</span>
<a name="l00132"></a>00132 <span class="comment"> =uSzz</span>
<a name="l00133"></a>00133 <span class="comment"> -----END PGP SIGNATURE-----</span>
<a name="l00134"></a>00134 <span class="comment"> **************************************************************/</span>
<a name="l00135"></a>00135 
<a name="l00136"></a>00136 <span class="comment">// OTSmartContract is derived from OTCronItem.</span>
<a name="l00137"></a>00137 <span class="comment">//</span>
<a name="l00138"></a>00138 <span class="comment">// WHAT DOES IT DO?</span>
<a name="l00139"></a>00139 <span class="comment">//</span>
<a name="l00140"></a>00140 <span class="comment">// 1) The clauses and bylaws can be written in script language by</span>
<a name="l00141"></a>00141 <span class="comment">//    the users, without having to change OT itself. SCRIPTABLE CLAUSES!</span>
<a name="l00142"></a>00142 <span class="comment">//    Invent your own financial instruments and processes, involving</span>
<a name="l00143"></a>00143 <span class="comment">//    multiple agents and asset accounts.</span>
<a name="l00144"></a>00144 <span class="comment">// 2) Any number of parties can sign these contracts.</span>
<a name="l00145"></a>00145 <span class="comment">// 3) Each Party has a name, and can be referred to using that name</span>
<a name="l00146"></a>00146 <span class="comment">//    from within the script code. Parties can also bring accounts and</span>
<a name="l00147"></a>00147 <span class="comment">//    other assets into these agreements, and scripts can manipulate them.</span>
<a name="l00148"></a>00148 <span class="comment">// 4) A party to an agreement can be an individual nym, OR it can be a</span>
<a name="l00149"></a>00149 <span class="comment">//    fictional ENTITY formed by some prior agreement.</span>
<a name="l00150"></a>00150 <span class="comment">// 5) A party may have many agents. Since some parties are fictional</span>
<a name="l00151"></a>00151 <span class="comment">//    entities (e.g. a corporation, a democracy, an estate for a deceased</span>
<a name="l00152"></a>00152 <span class="comment">//    person, etc), parties are able to appoint agents to act on their</span>
<a name="l00153"></a>00153 <span class="comment">//    behalf. An individual Nym is really just an individual Party who</span>
<a name="l00154"></a>00154 <span class="comment">//    acts as his own agent, whereas a corporation is owned by a voting group,</span>
<a name="l00155"></a>00155 <span class="comment">//    and appoints a Nym to act as its agent. Voting groups will soon also be</span>
<a name="l00156"></a>00156 <span class="comment">//    able to act as agents IN SOME RESPECTS. (Voting groups are coming</span>
<a name="l00157"></a>00157 <span class="comment">//    next, after smart contracts.) These will be able to edit bylaws, etc.</span>
<a name="l00158"></a>00158 <span class="comment">// 6) A Smart Contract has a list of parties, each with a list of agents.</span>
<a name="l00159"></a>00159 <span class="comment">//    Parties also bring asset accounts to the agreement, for use in the scripts.</span>
<a name="l00160"></a>00160 <span class="comment">// 7) A Smart Contract also has a list of bylaws, each with a list of clauses.</span>
<a name="l00161"></a>00161 <span class="comment">//    Each set of Bylaws also has its own variables, which can be used by the</span>
<a name="l00162"></a>00162 <span class="comment">//    scripts.</span>
<a name="l00163"></a>00163 <span class="comment">// 8) A Smart Contract can be activated (provided all parties have properly</span>
<a name="l00164"></a>00164 <span class="comment">//    signed), and it can process repeatedly over time until it expires or gets</span>
<a name="l00165"></a>00165 <span class="comment">//    deactivated. While it&#39;s active, parties can trigger specific clauses and</span>
<a name="l00166"></a>00166 <span class="comment">//    the smart contract will also occasionally trigger AUTOMATICALLY (depending</span>
<a name="l00167"></a>00167 <span class="comment">//    on how it has been configured.)</span>
<a name="l00168"></a>00168 <span class="comment">// 9) Users can decide which functions will activate--and when--and which</span>
<a name="l00169"></a>00169 <span class="comment">//    powers will be vested in the various parties and agents.</span>
<a name="l00170"></a>00170 <span class="comment">//10) HOOKS -- Scripts trigger upon various EVENTS such as onActivate,</span>
<a name="l00171"></a>00171 <span class="comment">//    onDeactivate, onTrigger, etc. Perhaps a timer is set causing the custom</span>
<a name="l00172"></a>00172 <span class="comment">//    function &quot;TransferEmergencyFunds&quot; to trigger in 24 hours, or 30 days,</span>
<a name="l00173"></a>00173 <span class="comment">//    or when the price of gold reaches X... or however you code the scripted</span>
<a name="l00174"></a>00174 <span class="comment">//    clauses in your contract...</span>
<a name="l00175"></a>00175 <span class="comment">//</span>
<a name="l00176"></a>00176 <span class="comment">// The design makes it easy to swap in different script languages. (Currently</span>
<a name="l00177"></a>00177 <span class="comment">// for experimental purposes I am using chaiscript.)</span>
<a name="l00178"></a>00178 <span class="comment">//</span>
<a name="l00179"></a>00179 
<a name="l00180"></a>00180 
<a name="l00181"></a>00181 <span class="comment">/*</span>
<a name="l00182"></a>00182 <span class="comment"></span>
<a name="l00183"></a>00183 <span class="comment"> RUNNING LIST of standard hooks, functions, constants, variables, etc..</span>
<a name="l00184"></a>00184 <span class="comment"></span>
<a name="l00185"></a>00185 <span class="comment"> - I&#39;m thinking that Constants and Variables should be available in OTBylaw AND OTScriptable.</span>
<a name="l00186"></a>00186 <span class="comment"> - Ah maybe just have them in Bylaws only, and then have a &quot;library&quot; Bylaw that is &quot;global&quot; to the OTScriptable.</span>
<a name="l00187"></a>00187 <span class="comment"></span>
<a name="l00188"></a>00188 <span class="comment"> - OT Internal Functions will be available on server side inside scripts, just like OT API is</span>
<a name="l00189"></a>00189 <span class="comment">   on client side. They&#39;re written in C++.</span>
<a name="l00190"></a>00190 <span class="comment"> - Callbacks are the opposite: they&#39;re written in script, and available for the C++ to call when it needs to.</span>
<a name="l00191"></a>00191 <span class="comment"> - Script Functions can be called by all parties, unless CanTriggerClause(name, party) returns false.</span>
<a name="l00192"></a>00192 <span class="comment"> - Hooks should be stored as a list on the Bylaws. If hook &quot;OnActivate&quot; is triggered, then I ask each Bylaw to</span>
<a name="l00193"></a>00193 <span class="comment">   run any relevant scripts for that hook.</span>
<a name="l00194"></a>00194 <span class="comment"></span>
<a name="l00195"></a>00195 <span class="comment"></span>
<a name="l00196"></a>00196 <span class="comment"> VARIABLES  (These are changed values you can store inside your smart contract, which stay persistent between runs.)</span>
<a name="l00197"></a>00197 <span class="comment"></span>
<a name="l00198"></a>00198 <span class="comment"> -- The first one of these will probably be a timer variable, used with OnProcess() to trigger some</span>
<a name="l00199"></a>00199 <span class="comment">    timed clause.  You&#39;ll set it to 100, then decrement every call, then trigger when it hits zero.</span>
<a name="l00200"></a>00200 <span class="comment">    (Or trigger every time X person withdraws money, etc.)</span>
<a name="l00201"></a>00201 <span class="comment"></span>
<a name="l00202"></a>00202 <span class="comment"> -- Let&#39;s say a contract processes 100 times but only does something important the last time. Do I REALLY</span>
<a name="l00203"></a>00203 <span class="comment">    need a receipt for every fucking 100 times just because some timer variable changed? Therefore, probably</span>
<a name="l00204"></a>00204 <span class="comment">    want to strictly define two types of variables:  Those that require a receipt when they change, and those</span>
<a name="l00205"></a>00205 <span class="comment">    that do not.  Therefore:</span>
<a name="l00206"></a>00206 <span class="comment"></span>
<a name="l00207"></a>00207 <span class="comment"> TYPES:   Constant (cannot change), Persistent (stores over time; change doesn&#39;t require noticing the parties),</span>
<a name="l00208"></a>00208 <span class="comment">          Important (Stores over time; change requires notice to the parties).</span>
<a name="l00209"></a>00209 <span class="comment"></span>
<a name="l00210"></a>00210 <span class="comment"> Any notice should be accompanied by a notice # so parties can see if they missed a notice.</span>
<a name="l00211"></a>00211 <span class="comment"></span>
<a name="l00212"></a>00212 <span class="comment"> ------------------------------------------------------------------------</span>
<a name="l00213"></a>00213 <span class="comment"></span>
<a name="l00214"></a>00214 <span class="comment"></span>
<a name="l00215"></a>00215 <span class="comment"> CONSTANTS   (These are standard values available inside any script.)</span>
<a name="l00216"></a>00216 <span class="comment"></span>
<a name="l00217"></a>00217 <span class="comment"> -- ProcessInterval. (The contract will activate every X seconds. Default 30.)</span>
<a name="l00218"></a>00218 <span class="comment"></span>
<a name="l00219"></a>00219 <span class="comment"> NOTE:  I probably won&#39;t let users change this, but rather, will let them</span>
<a name="l00220"></a>00220 <span class="comment"> use a multiple of it.  Or maybe I&#39;ll let them have fine-tuned timing, but just</span>
<a name="l00221"></a>00221 <span class="comment"> charge them for it via server fees.</span>
<a name="l00222"></a>00222 <span class="comment"></span>
<a name="l00223"></a>00223 <span class="comment"> ------------------------------------------------------------------------</span>
<a name="l00224"></a>00224 <span class="comment"></span>
<a name="l00225"></a>00225 <span class="comment"> CALLBACKS   (OT will call these scripts when it needs an answer to something.)</span>
<a name="l00226"></a>00226 <span class="comment"></span>
<a name="l00227"></a>00227 <span class="comment"> -- CanDeactivate(Party). Script returns true/false whether Party is allowed to deactivate the contract.</span>
<a name="l00228"></a>00228 <span class="comment">    Anyone party to the contract can cancel it, by default. (You can change that with this callback.)</span>
<a name="l00229"></a>00229 <span class="comment"></span>
<a name="l00230"></a>00230 <span class="comment">    can_execute_clause(party_name, clause_name)</span>
<a name="l00231"></a>00231 <span class="comment"></span>
<a name="l00232"></a>00232 <span class="comment"> -- CanTriggerClause(Party, Clause).  Script returns whether Party is allowed to call this clause. Default true.</span>
<a name="l00233"></a>00233 <span class="comment"></span>
<a name="l00234"></a>00234 <span class="comment"> ------------------------------------------------------------------------</span>
<a name="l00235"></a>00235 <span class="comment"></span>
<a name="l00236"></a>00236 <span class="comment"> OT INTERNAL FUNCTIONS   (Calls into OT that you can make from inside your scripts.)</span>
<a name="l00237"></a>00237 <span class="comment"></span>
<a name="l00238"></a>00238 <span class="comment"> -- These are like the OT API calls, except on the server side. Examples?</span>
<a name="l00239"></a>00239 <span class="comment"></span>
<a name="l00240"></a>00240 <span class="comment"> -- ExecuteClause(Bylaw, Clause)</span>
<a name="l00241"></a>00241 <span class="comment"> -- ExecuteClause(Clause)</span>
<a name="l00242"></a>00242 <span class="comment"></span>
<a name="l00243"></a>00243 <span class="comment">    These allow you to, from inside a clause, execute any other clause on the same contract.</span>
<a name="l00244"></a>00244 <span class="comment"></span>
<a name="l00245"></a>00245 <span class="comment"> -- FlagForRemoval()    This removes the script from Cron. Deactivates it.</span>
<a name="l00246"></a>00246 <span class="comment"></span>
<a name="l00247"></a>00247 <span class="comment"> -- Imagine OTParty-&gt;SendMessage(OtherParty). CANNOT DO THIS. Why not? Because on the client side, the sender</span>
<a name="l00248"></a>00248 <span class="comment">    can actually sign the thing before sending it. But on the server side, the server cannot sign with someone&#39;s</span>
<a name="l00249"></a>00249 <span class="comment">    nym since it doesn&#39;t have that private key. It CAN verify contracts, and transfer money, check balances, etc.</span>
<a name="l00250"></a>00250 <span class="comment"></span>
<a name="l00251"></a>00251 <span class="comment"> -- Definitely a call that transfers money from one Party&#39;s account to another, dropping a receipt.</span>
<a name="l00252"></a>00252 <span class="comment"></span>
<a name="l00253"></a>00253 <span class="comment"> -- Calls that withdraw money and return a financial instrument. For example: &quot;Take 100 clams out of Jim&#39;s acct,</span>
<a name="l00254"></a>00254 <span class="comment">    issue a server cheque for 100 clams, and send it to George.&quot;  You might ask, why not just have the cheque come</span>
<a name="l00255"></a>00255 <span class="comment">    from Jim directly?  Answer: Because the server can&#39;t forge Jim&#39;s signature. Instead, the server justifies the</span>
<a name="l00256"></a>00256 <span class="comment">    action to Jim by providing a copy of the script contract in his inbox receipt when it takes the money. It signs</span>
<a name="l00257"></a>00257 <span class="comment">    its own cheque, which is something it actually can do, and it sends it to George. A copy is sent to all parties</span>
<a name="l00258"></a>00258 <span class="comment">    so they can prove later on whether the voucher was redeemed. But they can&#39;t redeem it themselves, since it is</span>
<a name="l00259"></a>00259 <span class="comment">    made out to George.</span>
<a name="l00260"></a>00260 <span class="comment"></span>
<a name="l00261"></a>00261 <span class="comment"> -- Interesting: Certain instruments REQUIRE the client side! The server can&#39;t withdraw cash on your behalf since</span>
<a name="l00262"></a>00262 <span class="comment">    it can&#39;t generate the prototokens, nor can it unblind them. The server can&#39;t write a cheque on your behalf since</span>
<a name="l00263"></a>00263 <span class="comment">    it can&#39;t forge your signature.  It CAN withdraw cash on its own, and send to whoever you want, but then you have</span>
<a name="l00264"></a>00264 <span class="comment">    to trust the server not trace that cash (it&#39;s traceable in that case.) It CAN write a cheque on your behalf, but</span>
<a name="l00265"></a>00265 <span class="comment">    of course you have to trust the server that the money will be there when that cheque is cashed.  It CANNOT create</span>
<a name="l00266"></a>00266 <span class="comment">    a market order on your behalf! You have to sign that when you do it.  It CANNOT activate some new smart contract</span>
<a name="l00267"></a>00267 <span class="comment">    on your behalf, since it can&#39;t forge your signature. It CANNOT initiate a transfer (since you must sign.) Instead</span>
<a name="l00268"></a>00268 <span class="comment">    it just moves the funds and leaves you a copy of the script as your receipt. (You DID sign the script, so it IS</span>
<a name="l00269"></a>00269 <span class="comment">    a good enough receipt for that.)  I suppose that it CAN exchange you in/out of a basket, although normally you&#39;d</span>
<a name="l00270"></a>00270 <span class="comment">    expect a receipt showing your request. I guess future versions of OT can be smart enough to interpret a basket</span>
<a name="l00271"></a>00271 <span class="comment">    receipt in different ways, depending on whether the InRefTo contains an exchange request or a smart contract.</span>
<a name="l00272"></a>00272 <span class="comment"></span>
<a name="l00273"></a>00273 <span class="comment"> -- A call that ADDS a script to a hook. Imagine there 100 different hooks: you don&#39;t actually have scripts for</span>
<a name="l00274"></a>00274 <span class="comment">    all of them!!! But perhaps you have a certain script, that gets ATTACHED to a hook at some point, based on</span>
<a name="l00275"></a>00275 <span class="comment">    script logic, and then THEREAFTER activates on that hook when it previously didn&#39;t. Therefore even OnActivate()</span>
<a name="l00276"></a>00276 <span class="comment">    and OnDeactivate() should have their own actual script names, and then those scripts are attached to the hooks</span>
<a name="l00277"></a>00277 <span class="comment">    known as OnActivate and OnDeactivate().  The portion of the smart contract that attaches them changes over time,</span>
<a name="l00278"></a>00278 <span class="comment">    as this call is made, adding them and removing them.</span>
<a name="l00279"></a>00279 <span class="comment">    It could be that ONE script is registered to a hook, and then some event causes it to be de-registered</span>
<a name="l00280"></a>00280 <span class="comment">    and then another one is registered to take its place!</span>
<a name="l00281"></a>00281 <span class="comment"></span>
<a name="l00282"></a>00282 <span class="comment"> -- Functions to send notices to various parties and inboxes. (The server can&#39;t forge a party&#39;s message to</span>
<a name="l00283"></a>00283 <span class="comment">    another, but it CAN send them all a message from the server itself.) Therefore NOTICES.</span>
<a name="l00284"></a>00284 <span class="comment"></span>
<a name="l00285"></a>00285 <span class="comment"> -- Anytime funds are moved between accounts, they should get a scriptReceipt aka paymentReceipt type deal.</span>
<a name="l00286"></a>00286 <span class="comment"></span>
<a name="l00287"></a>00287 <span class="comment"> ------------------------------------------------------------------------</span>
<a name="l00288"></a>00288 <span class="comment"></span>
<a name="l00289"></a>00289 <span class="comment"> SCRIPT FUNCTIONS   (Scripts you add to your smart contract, which can be triggered by parties.)</span>
<a name="l00290"></a>00290 <span class="comment"></span>
<a name="l00291"></a>00291 <span class="comment"> -- First one will probably be &quot;DisputeEscrow()&quot; for the escrow contract.</span>
<a name="l00292"></a>00292 <span class="comment"></span>
<a name="l00293"></a>00293 <span class="comment"> -- Might be nice to have clauses that are available for others to call.</span>
<a name="l00294"></a>00294 <span class="comment">    Perhaps a &quot;library&quot; Bylaw that other bylaws have access to.</span>
<a name="l00295"></a>00295 <span class="comment"></span>
<a name="l00296"></a>00296 <span class="comment"> ------------------------------------------------------------------------</span>
<a name="l00297"></a>00297 <span class="comment"></span>
<a name="l00298"></a>00298 <span class="comment"> HOOKS       (Scripts you add to your smart contract, which will trigger automatically upon specific events.)</span>
<a name="l00299"></a>00299 <span class="comment"></span>
<a name="l00300"></a>00300 <span class="comment"> -- OnActivate()        This happens when script is first activated.</span>
<a name="l00301"></a>00301 <span class="comment"> -- OnDeactivate()      This happens when script is deactivated.</span>
<a name="l00302"></a>00302 <span class="comment"> -- OnProcess()         This happens every ProcessInterval.</span>
<a name="l00303"></a>00303 <span class="comment"> -- OnExpire()          Happens when the script is deactivated due to reaching end of valid date/time range.</span>
<a name="l00304"></a>00304 <span class="comment"></span>
<a name="l00305"></a>00305 <span class="comment"></span>
<a name="l00306"></a>00306 <span class="comment"></span>
<a name="l00307"></a>00307 <span class="comment"> OTHER HOOKS?</span>
<a name="l00308"></a>00308 <span class="comment"></span>
<a name="l00309"></a>00309 <span class="comment"></span>
<a name="l00310"></a>00310 <span class="comment"> Bylaws need to have a list of hooks, where the hook name corresponds to the clause name.</span>
<a name="l00311"></a>00311 <span class="comment"> Just as they have a list of clauses, they also need a list of the hooks those clauses are triggered by.</span>
<a name="l00312"></a>00312 <span class="comment"></span>
<a name="l00313"></a>00313 <span class="comment"></span>
<a name="l00314"></a>00314 <span class="comment"></span>
<a name="l00315"></a>00315 <span class="comment"></span>
<a name="l00316"></a>00316 <span class="comment"></span>
<a name="l00317"></a>00317 <span class="comment"></span>
<a name="l00318"></a>00318 <span class="comment"> Still need todo on smart contracts:</span>
<a name="l00319"></a>00319 <span class="comment"></span>
<a name="l00320"></a>00320 <span class="comment"> -- Serialization</span>
<a name="l00321"></a>00321 <span class="comment"> -- Confirmation</span>
<a name="l00322"></a>00322 <span class="comment"> -- Verification</span>
<a name="l00323"></a>00323 <span class="comment"> -- Native Functions such as:</span>
<a name="l00324"></a>00324 <span class="comment"></span>
<a name="l00325"></a>00325 <span class="comment">    move_funds(from_acct, to_acct)              (from_acct and to_acct must be a party to the agreement)</span>
<a name="l00326"></a>00326 <span class="comment">    send_cashiers_cheque(from_acct, to_nym)     (from_acct must be a party to the agreement. to_nym doesn&#39;t have to be.)</span>
<a name="l00327"></a>00327 <span class="comment">    stash_funds(from_acct, &quot;stash_one&quot;, 100)    (&quot;stash_one&quot; is stored inside the bylaw. Server-side only.)</span>
<a name="l00328"></a>00328 <span class="comment">    unstash_funds(&quot;stash_one&quot;, to_acct, 100)    (Smartcontract must be activated with no stashes. Server creates/maintains them.)</span>
<a name="l00329"></a>00329 <span class="comment">    unstash_funds_to_nym(&quot;stash_one&quot;, to_nym, 100)  (This is like send_cashiers_cheque, except from a stash.)</span>
<a name="l00330"></a>00330 <span class="comment">    get_balance(acct)                           (acct must be party to agreement.)</span>
<a name="l00331"></a>00331 <span class="comment"></span>
<a name="l00332"></a>00332 <span class="comment">    send_notice(to_nym)                         (Like sendMessage, except it comes from the server, not another user.)</span>
<a name="l00333"></a>00333 <span class="comment">    send_notice_to_parties()                    (Does a send_notice to ALL parties.)</span>
<a name="l00334"></a>00334 <span class="comment"></span>
<a name="l00335"></a>00335 <span class="comment">    can_execute_clause(party_name, clause_name) (See if a party is allowed to execute any given clause.)</span>
<a name="l00336"></a>00336 <span class="comment"></span>
<a name="l00337"></a>00337 <span class="comment"></span>
<a name="l00338"></a>00338 <span class="comment"> -- Dirtiness:</span>
<a name="l00339"></a>00339 <span class="comment">    Important variables changed require a Nymbox notice sent. (agreementReceipt)</span>
<a name="l00340"></a>00340 <span class="comment">    Any movement of funds requires Inbox notice sent to relevant parties. (can I just use paymentReceipt? Otherwise agreementReceipt here too.)</span>
<a name="l00341"></a>00341 <span class="comment">    FinalReceipt requires Nymbox AND Inbox notices to be sent.  (finalReceipt.)</span>
<a name="l00342"></a>00342 <span class="comment"></span>
<a name="l00343"></a>00343 <span class="comment"> -- Client command to message server and activate a new SmartContract.</span>
<a name="l00344"></a>00344 <span class="comment"> -- Server functions to process said message, and activate the script on cron.</span>
<a name="l00345"></a>00345 <span class="comment"></span>
<a name="l00346"></a>00346 <span class="comment"> -- (Postponed) Make a new OTScriptable-derived class called OTTitle (which represents a registered piece of property)</span>
<a name="l00347"></a>00347 <span class="comment">    and add client commands / server functions for functionality like SmartContract, except you are registering an</span>
<a name="l00348"></a>00348 <span class="comment">    OTTitle for a static piece of property, versus activating an OTCronItem that processes and triggers repeatedly</span>
<a name="l00349"></a>00349 <span class="comment">    over time. OTTitle will probably derive from OTContract, in the same way that OTAssetContract derives from</span>
<a name="l00350"></a>00350 <span class="comment">    OTContract. You will be able to register title on a server similar to registering an asset contract. Except,</span>
<a name="l00351"></a>00351 <span class="comment">    instead of getting an issuer acct, you get a deed...</span>
<a name="l00352"></a>00352 <span class="comment"></span>
<a name="l00353"></a>00353 <span class="comment"> -- (Postponed) There are several ways to own title to property. One is to have an OTDeed class, which allows any specific Nym to</span>
<a name="l00354"></a>00354 <span class="comment">    have a title registered to him based on a specific transaction #, which is released whenever the deed is transferred.</span>
<a name="l00355"></a>00355 <span class="comment">    This enables destruction-of-acct-history similar to unit-based accounts, but it also necessitates the use of an &quot;asset</span>
<a name="l00356"></a>00356 <span class="comment">    account&quot; (with an inbox) specifically for holding deed-based property. (This is necessary in order to prove ownership</span>
<a name="l00357"></a>00357 <span class="comment">    and everything else--the same as with unit-based accounts.)  I probably will NOT code this &quot;deed&quot; piece anytime soon...</span>
<a name="l00358"></a>00358 <span class="comment"></span>
<a name="l00359"></a>00359 <span class="comment"> -- (Upcoming) ...HOWEVER, ANOTHER WAY to own title (WITHOUT A DEED) is through SHAREHOLDING. That is where my interest currently</span>
<a name="l00360"></a>00360 <span class="comment">    lies. Therefore I will add the OTEntity class. Instead of being derived from OTContract like OTTitle, it will be derived from</span>
<a name="l00361"></a>00361 <span class="comment">    OTScriptable (similar to the smart contracts.)  This will enable it to have parties and bylaws.</span>
<a name="l00362"></a>00362 <span class="comment">    Similar to cron items, which save the original copy but also save updated copies whenever something changes, I will cause</span>
<a name="l00363"></a>00363 <span class="comment">    OTEntity to generate a unique ID based on the entity as it originally appeared when first registered. The original version</span>
<a name="l00364"></a>00364 <span class="comment">    is always retrievable by a shareholder and hashing it should produce the actual entity ID.</span>
<a name="l00365"></a>00365 <span class="comment">    But from there, the Entity can evolve over time. Since it is OTScriptable-derived, it can have parties, and bylaws. The</span>
<a name="l00366"></a>00366 <span class="comment">    parties can take actions to change the bylaws and appointments.</span>
<a name="l00367"></a>00367 <span class="comment">    The political structure of the entity is determined by the parties. There might be 3 parties who are all Nyms, in which case</span>
<a name="l00368"></a>00368 <span class="comment">    you have a partnership. If the entity&#39;s charter says, &quot;Party A is a Nym: FellowTraveler&quot;, and if all parties by default have</span>
<a name="l00369"></a>00369 <span class="comment">    the power to alter the bylaws, appoint employees, activate clauses to move funds, etc, then you now have an individual</span>
<a name="l00370"></a>00370 <span class="comment">    controlling the entity.</span>
<a name="l00371"></a>00371 <span class="comment">    WHERE THIS IS GOING: A party whose agent is a voting group, whose members are determined by shareholdership in STOCK of</span>
<a name="l00372"></a>00372 <span class="comment">    the entity. (Really could be configured to stock in any stock ID, but people will WANT the stock to be in the entity.) Future</span>
<a name="l00373"></a>00373 <span class="comment">    versions of OT will allow creation of multiple classes of stock, and indeed there is nothing stopping entities now from</span>
<a name="l00374"></a>00374 <span class="comment">    issuing whatever currencies they want, with the issuer accounts controlled by them or their agents. Of course it&#39;s better</span>
<a name="l00375"></a>00375 <span class="comment">    to have it strict in the bylaws, and have OT just execute it that way, and for now that&#39;s how it will be with the DEFAULT,</span>
<a name="l00376"></a>00376 <span class="comment">    HARDCODED current path of a SINGLE class of stock for each entity, with the Entity&#39;s ID serving as the Asset Type ID. I think</span>
<a name="l00377"></a>00377 <span class="comment">    it would be a LONG TIME before we ever need more functionality than that anyway, so that&#39;s what I&#39;ll focus on.</span>
<a name="l00378"></a>00378 <span class="comment"></span>
<a name="l00379"></a>00379 <span class="comment"> -- So I need OTVotingGroup class which will determine members based on various types of groups.</span>
<a name="l00380"></a>00380 <span class="comment">    1) Shareholders. Expects a weighted vote among shareholders based on asset type ID matching entity ID.</span>
<a name="l00381"></a>00381 <span class="comment">    2) Appointed members. A list of members (NymIDs) is explicitly stored in this group. (Like the list of board members.)</span>
<a name="l00382"></a>00382 <span class="comment"></span>
<a name="l00383"></a>00383 <span class="comment">    (1) Will take advantage of existing asset account code (for weighted voting),</span>
<a name="l00384"></a>00384 <span class="comment">    and (2) will take advantage of existing digital cash code (for secret ballots.)</span>
<a name="l00385"></a>00385 <span class="comment"></span>
<a name="l00386"></a>00386 <span class="comment">    For both types of groups, votes will be possible such as Majority rules, 2/3rds, 3/4ths, 9/10ths, Unanimous, etc.</span>
<a name="l00387"></a>00387 <span class="comment">    In the case of appointed members (2), permissions can be granted to members, such as dictator, dictator subject to veto,</span>
<a name="l00388"></a>00388 <span class="comment">    veto power, etc etc. In this way, democracies, republics, corporations, etc all become possible through simple config changes.</span>
<a name="l00389"></a>00389 <span class="comment"></span>
<a name="l00390"></a>00390 <span class="comment">    But all of the actual voting will not happen until I code classes like OTBallot, OTElection, etc. That&#39;s not my current</span>
<a name="l00391"></a>00391 <span class="comment">    focus. We will get to that in time. Rather, my focus is on the use of SHAREHOLDERS to allow weighted, account-based ownership</span>
<a name="l00392"></a>00392 <span class="comment">    of STOCK in ENTITIES.  My interest right now is on the ENTITIES THEMSELVES, and their ability to be party to agreements, and</span>
<a name="l00393"></a>00393 <span class="comment">    to hire employees, and to own property and asset accounts.</span>
<a name="l00394"></a>00394 <span class="comment"></span>
<a name="l00395"></a>00395 <span class="comment">    So an EntityID is similar to a TitleID, in the sense that an entity is a piece of property that can be owned. But an EntityID</span>
<a name="l00396"></a>00396 <span class="comment">    is also similar to an AssetTypeID, since there can be a currency issued for that entity. And an entity is also similar to a smart</span>
<a name="l00397"></a>00397 <span class="comment">    contract, in the sense that it can have bylaws, and it can have &quot;parties to the agreement&quot;.</span>
<a name="l00398"></a>00398 <span class="comment"></span>
<a name="l00399"></a>00399 <span class="comment">    Beyond that, entities will also have the ability to hire employees, sign contracts, own property, etc. Distribute funds up and</span>
<a name="l00400"></a>00400 <span class="comment">    down the hierarchy, and have access the communications and receipts up and down the hierarchy.</span>
<a name="l00401"></a>00401 <span class="comment"></span>
<a name="l00402"></a>00402 <span class="comment"> -- Entity will not be derived from a Title, because they are fundamentally different enough. Entities are owned by the voting groups</span>
<a name="l00403"></a>00403 <span class="comment">    that make them up, according to their laws. Whereas Titles are owned based on holder of Deed.</span>
<a name="l00404"></a>00404 <span class="comment"></span>
<a name="l00405"></a>00405 <span class="comment"> -- Therefore, NOT needed for now: OTTitle, OTDeed, OTBallot, OTElection.</span>
<a name="l00406"></a>00406 <span class="comment"></span>
<a name="l00407"></a>00407 <span class="comment"> -- NEEDED and coming soon: OTVotingGroup, OTEntity.  I&#39;ll start on these once I have proven the first SMART CONTRACT (Escrow!!!!!)</span>
<a name="l00408"></a>00408 <span class="comment"></span>
<a name="l00409"></a>00409 <span class="comment"></span>
<a name="l00410"></a>00410 <span class="comment">===&gt; NEW THOUGHT:  I think OTAssetContract should be derived from OTScriptable instead of OTContract. There&#39;s no reason why an</span>
<a name="l00411"></a>00411 <span class="comment">     issuer shouldn&#39;t be able to attach scripts to certain aspects of a currency, right? Hooks could trigger at various currency-related</span>
<a name="l00412"></a>00412 <span class="comment">     events.  There&#39;s also no reason why an issued currency shouldn&#39;t be able to have parties. But who are the parties, if not the issuer?</span>
<a name="l00413"></a>00413 <span class="comment">     In the case of OTAssetContract, the parties will be whoever are configured to do whatever the clauses need them to do, which will often</span>
<a name="l00414"></a>00414 <span class="comment">     be nothing, though technically they could be used for AUTOMATED BAILMENT PROCESSES!! (Say one of the parties is a voting group consisting</span>
<a name="l00415"></a>00415 <span class="comment">     of anyone who holds stock. And that party has the right to trigger the &quot;bailout&quot; clause, which has the power the transfer the funds auto-</span>
<a name="l00416"></a>00416 <span class="comment">     matically (via a script) to another party or account.)  I don&#39;t know how people might use this, but it seems potentially useful.</span>
<a name="l00417"></a>00417 <span class="comment"></span>
<a name="l00418"></a>00418 <span class="comment"> ===&gt; Once this is in place, then it&#39;s easy to have OTEntity be derived from OTAssetContract!!  And that&#39;s where we&#39;ll get our Entity ID.</span>
<a name="l00419"></a>00419 <span class="comment"></span>
<a name="l00420"></a>00420 <span class="comment"> ===&gt; ANOTHER IDEA:  SHould be easy to move funds ONTO THE SMART CONTRACT ITSELF. Just have an XML tag where stored funds go, perhaps with the</span>
<a name="l00421"></a>00421 <span class="comment">      funds double in a server backing account (similar to how the cash already is.)  The script can enable peeps to move funds from an acct</span>
<a name="l00422"></a>00422 <span class="comment">      and to a safe place (inside the smart contract itself) until some other rule causes it to be moved somewhere else. This is needed for ESCROW!!!</span>
<a name="l00423"></a>00423 <span class="comment">      Perhaps I&#39;ll call this a &quot;fund&quot;.  OTFund.  The only other way for an entity to control funds is to open accounts, meaning it must trust the</span>
<a name="l00424"></a>00424 <span class="comment">      Nym who&#39;s been appointed to the role of managing that account. The entity ITSELF can&#39;t open accounts because there is no signer!!! But the</span>
<a name="l00425"></a>00425 <span class="comment">      entity CAN control FUNDS, because they are stored inside the entity itself!! (relevant parties get receipts for changes to entities...) And</span>
<a name="l00426"></a>00426 <span class="comment">      unlike a Nym, everyone can trust a cold, hard, script.</span>
<a name="l00427"></a>00427 <span class="comment"></span>
<a name="l00428"></a>00428 <span class="comment"></span>
<a name="l00429"></a>00429 <span class="comment"> ===&gt; REALIZATION:  For my audit protocol, I wanted to have some kind of DHT to store the receipts, where issuer and customer both have access to</span>
<a name="l00430"></a>00430 <span class="comment">      them, but where the system itself cannot otherwise be shut down. And you can&#39;t just put some IP address of a server into the contract (as the</span>
<a name="l00431"></a>00431 <span class="comment">      location for those receipts) because then a &quot;power that be&quot; can read the contract, and shut down the server at that IP.</span>
<a name="l00432"></a>00432 <span class="comment">        BUT NOW, possibly the solution may somehow lie in Namecoin, which is a censorship-proof DHT where I could store an I2P address. Do I still need</span>
<a name="l00433"></a>00433 <span class="comment">      a DHT for the receipts themselves, as long as DNS is safe from interference, and I can control where it points to? Since all parties (issuer and</span>
<a name="l00434"></a>00434 <span class="comment">      users) would read their receipts from the same place (whichever address is listed in Namecoin) and since it&#39;s on an anonymous network, then I</span>
<a name="l00435"></a>00435 <span class="comment">      believe the issuer and transaction server can exchange receipts in a safe way. Possibly this solves any auditing issues, though I still need to</span>
<a name="l00436"></a>00436 <span class="comment">      devise the protocol.</span>
<a name="l00437"></a>00437 <span class="comment">      But this still means that someone is running a server somewhere, and must be in order for people to get their receipts, whereas using a full DHT</span>
<a name="l00438"></a>00438 <span class="comment">      solution is more... certifiable. notarizable. Because you have the whole blockchain verifying that receipt was posted...</span>
<a name="l00439"></a>00439 <span class="comment"></span>
<a name="l00440"></a>00440 <span class="comment">        Maybe the issuer just needs to demand that all receipts are numbered sequentially? hm.</span>
<a name="l00441"></a>00441 <span class="comment"></span>
<a name="l00442"></a>00442 <span class="comment"> ===&gt; NEW THOUGHT: For Auditing protocol:  EVERY RECEIPT for any specific asset type should be sequentially numbered, AND should contain the hash of</span>
<a name="l00443"></a>00443 <span class="comment">      the receipt that came before it.  This way, the auditor can receive a verifiable stream of receipts, which can also be queried by transaction #,</span>
<a name="l00444"></a>00444 <span class="comment">      which is unique to all transactions on the transaction server, as well as queried by sequence number, which is unique to the issuer, as well as</span>
<a name="l00445"></a>00445 <span class="comment">      queried by hash value, which is used to prove sequence.</span>
<a name="l00446"></a>00446 <span class="comment">      Every receipt should be encrypted to a random key, and then that key should be encrypted to three recipients: the server, the auditor, and the</span>
<a name="l00447"></a>00447 <span class="comment">      party doing the transaction. The receipts should otherwise be publicly available (though encrypted) and auditors and parties should have to retrieve</span>
<a name="l00448"></a>00448 <span class="comment">      them from the same place.  Even if I allow the parties to keep the receipts directly in response to their server messages, they can still compare</span>
<a name="l00449"></a>00449 <span class="comment">      notes directly with the auditor and each other on the hashes for the various sequence numbers. Hm.</span>
<a name="l00450"></a>00450 <span class="comment"> */</span>
<a name="l00451"></a>00451 
<a name="l00452"></a>00452 <span class="preprocessor">#include &lt;<a class="code" href="stdafx_8hpp.html">stdafx.hpp</a>&gt;</span>
<a name="l00453"></a>00453 
<a name="l00454"></a>00454 <span class="preprocessor">#include &lt;<a class="code" href="_o_t_smart_contract_8hpp.html">OTSmartContract.hpp</a>&gt;</span>
<a name="l00455"></a>00455 
<a name="l00456"></a>00456 <span class="preprocessor">#ifdef OT_USE_SCRIPT_CHAI</span>
<a name="l00457"></a>00457 <span class="preprocessor"></span><span class="preprocessor">#include &lt;chaiscript/chaiscript.hpp&gt;</span>
<a name="l00458"></a>00458 
<a name="l00459"></a>00459 <span class="preprocessor">#ifdef OT_USE_CHAI_STDLIB</span>
<a name="l00460"></a>00460 <span class="preprocessor"></span><span class="preprocessor">#include &lt;chaiscript/chaiscript_stdlib.hpp&gt;</span>
<a name="l00461"></a>00461 
<a name="l00462"></a>00462 <span class="preprocessor">#endif</span>
<a name="l00463"></a>00463 <span class="preprocessor"></span>
<a name="l00464"></a>00464 <span class="preprocessor">#endif</span>
<a name="l00465"></a>00465 <span class="preprocessor"></span>
<a name="l00466"></a>00466 <span class="preprocessor">#include &lt;<a class="code" href="_o_t_log_8hpp.html">OTLog.hpp</a>&gt;</span>
<a name="l00467"></a>00467 <span class="preprocessor">#include &lt;<a class="code" href="_o_t_script_8hpp.html">OTScript.hpp</a>&gt;</span>
<a name="l00468"></a>00468 <span class="preprocessor">#include &lt;<a class="code" href="_o_t_cron_8hpp.html">OTCron.hpp</a>&gt;</span>
<a name="l00469"></a>00469 <span class="preprocessor">#include &lt;<a class="code" href="_o_t_pseudonym_8hpp.html">OTPseudonym.hpp</a>&gt;</span>
<a name="l00470"></a>00470 <span class="preprocessor">#include &lt;<a class="code" href="_o_t_ledger_8hpp.html">OTLedger.hpp</a>&gt;</span>
<a name="l00471"></a>00471 <span class="preprocessor">#include &lt;<a class="code" href="_o_t_paths_8hpp.html">OTPaths.hpp</a>&gt;</span>
<a name="l00472"></a>00472 
<a name="l00473"></a>00473 
<a name="l00474"></a>00474 <span class="preprocessor">#include &quot;irrxml/irrXML.hpp&quot;</span>
<a name="l00475"></a>00475 
<a name="l00476"></a>00476 
<a name="l00477"></a>00477 <span class="preprocessor">#ifndef SMART_CONTRACT_PROCESS_INTERVAL</span>
<a name="l00478"></a><a class="code" href="_o_t_smart_contract_8cpp.html#a07c91258ac71240a2059fd34c9cf5d89">00478</a> <span class="preprocessor"></span><span class="preprocessor">#define SMART_CONTRACT_PROCESS_INTERVAL     30      // 30 seconds, for testing. Should be: based on fees. Otherwise once per day should be enough... right?</span>
<a name="l00479"></a>00479 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00480"></a>00480 <span class="preprocessor"></span>
<a name="l00481"></a>00481 
<a name="l00482"></a>00482 <span class="comment">// CALLBACK:  Party may cancel contract?</span>
<a name="l00483"></a>00483 <span class="comment">//</span>
<a name="l00484"></a>00484 <span class="comment">// Called in OnRemove and OnExpire,</span>
<a name="l00485"></a>00485 <span class="comment">// at the bottom.</span>
<a name="l00486"></a>00486 <span class="comment">//</span>
<a name="l00487"></a>00487 <span class="preprocessor">#ifndef SMARTCONTRACT_CALLBACK_PARTY_MAY_CANCEL</span>
<a name="l00488"></a><a class="code" href="_o_t_smart_contract_8cpp.html#a868cf7423bbb3819f0c7af0ff701907f">00488</a> <span class="preprocessor"></span><span class="preprocessor">#define SMARTCONTRACT_CALLBACK_PARTY_MAY_CANCEL &quot;callback_party_may_cancel_contract&quot;</span>
<a name="l00489"></a>00489 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00490"></a>00490 <span class="preprocessor"></span>
<a name="l00491"></a>00491 
<a name="l00492"></a>00492 <span class="comment">// FYI:</span>
<a name="l00493"></a>00493 <span class="comment">//#ifndef SCRIPTABLE_CALLBACK_PARTY_MAY_EXECUTE</span>
<a name="l00494"></a>00494 <span class="comment">//#define SCRIPTABLE_CALLBACK_PARTY_MAY_EXECUTE     &quot;callback_party_may_execute_clause&quot;</span>
<a name="l00495"></a>00495 <span class="comment">//#endif</span>
<a name="l00496"></a>00496 
<a name="l00497"></a>00497 <span class="comment">// HOOKS</span>
<a name="l00498"></a>00498 <span class="comment">//</span>
<a name="l00499"></a>00499 <span class="comment">// The server will call these hooks, from time to time, and give you the</span>
<a name="l00500"></a>00500 <span class="comment">// opportunity to provide your own scripts linked to these names, which</span>
<a name="l00501"></a>00501 <span class="comment">// will trigger at those times. (Parties are normally disallowed from</span>
<a name="l00502"></a>00502 <span class="comment">// directly triggering these special &quot;hook&quot; scripts, as they might normally</span>
<a name="l00503"></a>00503 <span class="comment">// be allowed to trigger other clauses.)</span>
<a name="l00504"></a>00504 <span class="comment">//</span>
<a name="l00505"></a>00505 
<a name="l00506"></a>00506 <span class="comment">// Called regularly in OTSmartContract::ProcessCron()</span>
<a name="l00507"></a>00507 <span class="comment">// based on SMART_CONTRACT_PROCESS_INTERVAL.</span>
<a name="l00508"></a>00508 <span class="comment">//</span>
<a name="l00509"></a>00509 <span class="preprocessor">#ifndef SMARTCONTRACT_HOOK_ON_PROCESS</span>
<a name="l00510"></a><a class="code" href="_o_t_smart_contract_8cpp.html#a3620c2b37a2cef094ecadcc890af8383">00510</a> <span class="preprocessor"></span><span class="preprocessor">#define SMARTCONTRACT_HOOK_ON_PROCESS       &quot;cron_process&quot;</span>
<a name="l00511"></a>00511 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00512"></a>00512 <span class="preprocessor"></span>
<a name="l00513"></a>00513 
<a name="l00514"></a>00514 <span class="comment">// This is called when the contract is</span>
<a name="l00515"></a>00515 <span class="comment">// first activated. Todo.</span>
<a name="l00516"></a>00516 <span class="comment">//</span>
<a name="l00517"></a>00517 <span class="preprocessor">#ifndef SMARTCONTRACT_HOOK_ON_ACTIVATE</span>
<a name="l00518"></a><a class="code" href="_o_t_smart_contract_8cpp.html#aa3eadb54e95be5d2dbb367f6c359c469">00518</a> <span class="preprocessor"></span><span class="preprocessor">#define SMARTCONTRACT_HOOK_ON_ACTIVATE      &quot;cron_activate&quot;</span>
<a name="l00519"></a>00519 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00520"></a>00520 <span class="preprocessor"></span>
<a name="l00521"></a>00521 
<a name="l00522"></a>00522 <span class="comment">// Deprecated:</span>
<a name="l00523"></a>00523 <span class="comment">//</span>
<a name="l00524"></a>00524 <span class="comment">// (These hooks exist in the OT class library, and you CAN subclass</span>
<a name="l00525"></a>00525 <span class="comment">// OT classes to take advantage of them. But I don&#39;t see how they can</span>
<a name="l00526"></a>00526 <span class="comment">// be allowed from within the SCRIPT language itself, at least, not</span>
<a name="l00527"></a>00527 <span class="comment">// without some kinds of config options to govern the permissions.)</span>
<a name="l00528"></a>00528 <span class="comment">//</span>
<a name="l00529"></a>00529 
<a name="l00530"></a>00530 <span class="comment">// Called when a party removes the</span>
<a name="l00531"></a>00531 <span class="comment">// contract from processing.</span>
<a name="l00532"></a>00532 <span class="comment">//</span>
<a name="l00533"></a>00533 <span class="comment">// Update NOTE: script may not execute. Script has been removed. Sorry.</span>
<a name="l00534"></a>00534 <span class="comment">// (Notices are sent automatically.)</span>
<a name="l00535"></a>00535 <span class="comment">//</span>
<a name="l00536"></a>00536 <span class="preprocessor">#ifndef SMARTCONTRACT_HOOK_ON_REMOVE</span>
<a name="l00537"></a><a class="code" href="_o_t_smart_contract_8cpp.html#ac78adfdaa3cf717bc90724d023135e1c">00537</a> <span class="preprocessor"></span><span class="preprocessor">#define SMARTCONTRACT_HOOK_ON_REMOVE        &quot;cron_remove&quot;</span>
<a name="l00538"></a>00538 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00539"></a>00539 <span class="preprocessor"></span>
<a name="l00540"></a>00540 
<a name="l00541"></a>00541 <span class="comment">// When it expires due to date range.</span>
<a name="l00542"></a>00542 <span class="comment">//</span>
<a name="l00543"></a>00543 <span class="comment">// Update NOTE: script may not execute. Script has expired. Sorry.</span>
<a name="l00544"></a>00544 <span class="comment">// (Notices are sent automatically.)</span>
<a name="l00545"></a>00545 <span class="comment">//</span>
<a name="l00546"></a>00546 <span class="preprocessor">#ifndef SMARTCONTRACT_HOOK_ON_EXPIRE</span>
<a name="l00547"></a><a class="code" href="_o_t_smart_contract_8cpp.html#a42d52b5ae5e4230fcd795eb5d2af4c57">00547</a> <span class="preprocessor"></span><span class="preprocessor">#define SMARTCONTRACT_HOOK_ON_EXPIRE        &quot;cron_expire&quot;</span>
<a name="l00548"></a>00548 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00549"></a>00549 <span class="preprocessor"></span>
<a name="l00550"></a>00550 
<a name="l00551"></a>00551 <span class="comment">// Called in OnRemove and OnExpire,</span>
<a name="l00552"></a>00552 <span class="comment">// at the bottom.</span>
<a name="l00553"></a>00553 <span class="comment">//</span>
<a name="l00554"></a>00554 <span class="comment">// Update NOTE: so far script may not execute. Script has been deactivated, sorry.</span>
<a name="l00555"></a>00555 <span class="comment">// Notices are sent automatically.</span>
<a name="l00556"></a>00556 <span class="comment">//</span>
<a name="l00557"></a>00557 <span class="preprocessor">#ifndef SMARTCONTRACT_HOOK_ON_DEACTIVATE</span>
<a name="l00558"></a><a class="code" href="_o_t_smart_contract_8cpp.html#a37e3982960d2727ada2cfa2a9ea00417">00558</a> <span class="preprocessor"></span><span class="preprocessor">#define SMARTCONTRACT_HOOK_ON_DEACTIVATE    &quot;cron_deactivate&quot;</span>
<a name="l00559"></a>00559 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00560"></a>00560 <span class="preprocessor"></span>
<a name="l00561"></a>00561 
<a name="l00562"></a>00562 <span class="comment">// TODO: Finish up Smart Contracts (this file.)</span>
<a name="l00563"></a>00563 
<a name="l00564"></a>00564 <span class="comment">// DONE: Client test code, plus server message: for activating smart contracts.</span>
<a name="l00565"></a>00565 
<a name="l00566"></a>00566 <span class="comment">// DONE: OT API calls for smart contracts.</span>
<a name="l00567"></a>00567 
<a name="l00568"></a>00568 <span class="comment">// DONE: Build escrow script.</span>
<a name="l00569"></a>00569 
<a name="l00570"></a>00570 <span class="comment">// TODO: Entities and roles.  (AFTER smart contracts are working.)</span>
<a name="l00571"></a>00571 
<a name="l00572"></a>00572 <span class="comment">// TODO:  Finish move_funds, which should be super easy now. The script-callable version</span>
<a name="l00573"></a>00573 <span class="comment">// HAS to be in OTSmartContract. Why? Because it can&#39;t be in OTScriptable, since those shouldn&#39;t</span>
<a name="l00574"></a>00574 <span class="comment">// be allowed to move funds (they are unlike payment plan / trades, which have an open trans#</span>
<a name="l00575"></a>00575 <span class="comment">// that can be put onto receipts, and a final receipt with a closing trans#, which allow recurring</span>
<a name="l00576"></a>00576 <span class="comment">// processing (multiple receipts for the same transaction) -- this all fits into the &quot;destruction</span>
<a name="l00577"></a>00577 <span class="comment">// of acct history&quot; system perfectly, because it&#39;s built into OTCronItem. OTScriptable isn&#39;t derived</span>
<a name="l00578"></a>00578 <span class="comment">// from OTCronItem, so it can&#39;t do those things, therefore it can&#39;t be allowed to move money.</span>
<a name="l00579"></a>00579 <span class="comment">//</span>
<a name="l00580"></a>00580 <span class="comment">// Fair enough. But then, why not put move_funds into OTCronItem? After all, it IS derived from</span>
<a name="l00581"></a>00581 <span class="comment">// OTScriptable, if you go far enough back, and so it technically can play both sides. Here&#39;s why not:</span>
<a name="l00582"></a>00582 <span class="comment">// Because OTTrade and OTPaymentPlan were both written before I wrote all the smart contract stuff.</span>
<a name="l00583"></a>00583 <span class="comment">// It was only when I added smart contracts that I finally implemented Parties, Agents, Bylaws, Clauses,</span>
<a name="l00584"></a>00584 <span class="comment">// etc etc. This means that the way things are done is vastly different. Therefore while OTSmartContract</span>
<a name="l00585"></a>00585 <span class="comment">// is derived from OTCronItem, OTSmartContract is the first Cron Item that does it the SCRIPTABLE way,</span>
<a name="l00586"></a>00586 <span class="comment">// whereas OTTrade and OTPaymentPlan still do it the &quot;OTCronItem&quot; way.</span>
<a name="l00587"></a>00587 <span class="comment">//</span>
<a name="l00588"></a>00588 <span class="comment">// For example, in OTSmartContract, the Opening Transaction # is stored ONE FOR EACH PARTY, and the</span>
<a name="l00589"></a>00589 <span class="comment">// Closing Transaction # is stored ONE FOR EACH ASSET ACCOUNT.  You can have many many parties AND</span>
<a name="l00590"></a>00590 <span class="comment">// asset accounts on a smart contract.  This is simply not the case for OTTrade and OTPaymentPlan. They</span>
<a name="l00591"></a>00591 <span class="comment">// use their own little built-in system for managing their strict system for storing the exact numbers</span>
<a name="l00592"></a>00592 <span class="comment">// they need. They always use the exact same number of Nyms and accounts.</span>
<a name="l00593"></a>00593 <span class="comment">//</span>
<a name="l00594"></a>00594 <span class="comment">// But smart contracts obviously do much more, so a more elegant system has been crafted into OTSmartContract</span>
<a name="l00595"></a>00595 <span class="comment">// which blends the best qualities of OTScriptable AND OTCronItem, and which is the only place where you can</span>
<a name="l00596"></a>00596 <span class="comment">// have BOTH script interpretation (from OTScriptable) AND money-moving, receipts, transactions, etc (OTCronItem).</span>
<a name="l00597"></a>00597 <span class="comment">//</span>
<a name="l00598"></a>00598 <span class="comment">// Therefore, OTCronItem already has the lower-level call to MoveFunds, which you can see commented below.</span>
<a name="l00599"></a>00599 <span class="comment">// And OTSmartContract will have a higher-level version that can be available inside scripts as an &quot;OT Native call&quot;,</span>
<a name="l00600"></a>00600 <span class="comment">// and which searches the parties/accounts/agents etc so that it is able to then make the lower-level call.</span>
<a name="l00601"></a>00601 <span class="comment">// Therefore move_funds goes in OTSmartContract, and MoveFunds goes in OTCronItem.</span>
<a name="l00602"></a>00602 <span class="comment">//</span>
<a name="l00603"></a>00603 <span class="comment">//</span>
<a name="l00604"></a>00604 <span class="comment">//</span>
<a name="l00605"></a>00605 
<a name="l00606"></a>00606 <span class="comment">/*</span>
<a name="l00607"></a>00607 <span class="comment">CALLBACKS</span>
<a name="l00608"></a>00608 <span class="comment"></span>
<a name="l00609"></a>00609 <span class="comment">DONE party_may_cancel_contract(party_name)              (See if a party is allowed to cancel the contract from processing.)</span>
<a name="l00610"></a>00610 <span class="comment">DONE party_may_execute_clause(party_name, clause_name)  (See if a party is allowed to execute any given clause.)</span>
<a name="l00611"></a>00611 <span class="comment"></span>
<a name="l00612"></a>00612 <span class="comment">// ---------------------------------------------------------</span>
<a name="l00613"></a>00613 <span class="comment">NATIVE CALLS</span>
<a name="l00614"></a>00614 <span class="comment"></span>
<a name="l00615"></a>00615 <span class="comment">DONE move_funds(from_acct, to_acct, amount)     (from_acct and to_acct must be a party to the agreement)</span>
<a name="l00616"></a>00616 <span class="comment">DONE stash_funds(from_acct, &quot;stash_one&quot;, 100)   (&quot;stash_one&quot; is stored INSIDE the smartcontract! Server-side only.)</span>
<a name="l00617"></a>00617 <span class="comment">DONE unstash_funds(to_acct, &quot;stash_one&quot;, 100)   (Smartcontract must be activated with NO stashes. Server creates/maintains stashes AFTER activation.)</span>
<a name="l00618"></a>00618 <span class="comment"></span>
<a name="l00619"></a>00619 <span class="comment">DONE get_acct_balance(acct)                     Returns int64_t.     (Named acct must be party to agreement with legitimate authorized agent.)</span>
<a name="l00620"></a>00620 <span class="comment">DONE get_acct_asset_type_id(acct)               Returns std::string. (Named acct must be party to agreement with legitimate authorized agent.)</span>
<a name="l00621"></a>00621 <span class="comment">DONE get_stash_balance(stash, asset_type_id)    Returns int64_t.     (Named stash must exist.)</span>
<a name="l00622"></a>00622 <span class="comment"></span>
<a name="l00623"></a>00623 <span class="comment">DONE send_notice(to_party)      (Like sendMessage, except it comes from the server, not another user. Drops current state of smart contract to Nymbox of all agents for party named.)</span>
<a name="l00624"></a>00624 <span class="comment">DONE send_notice_to_parties()   (Does a send_notice to ALL parties.)</span>
<a name="l00625"></a>00625 <span class="comment"></span>
<a name="l00626"></a>00626 <span class="comment">DONE deactivate_contract()      (Deactivates and finalizes the smart contract.)</span>
<a name="l00627"></a>00627 <span class="comment"></span>
<a name="l00628"></a>00628 <span class="comment">// ---------------------------------------------------------</span>
<a name="l00629"></a>00629 <span class="comment">HOOKS</span>
<a name="l00630"></a>00630 <span class="comment"></span>
<a name="l00631"></a>00631 <span class="comment">DONE cron_process       (Triggers every time the smart contract &quot;processes&quot; on cron.)</span>
<a name="l00632"></a>00632 <span class="comment">DONE cron_activate      (Triggers when the smart contract is first activated.)</span>
<a name="l00633"></a>00633 <span class="comment">*/</span>
<a name="l00634"></a>00634 
<a name="l00635"></a>00635 <span class="comment">// Global version. (string parameter)</span>
<a name="l00636"></a>00636 <span class="comment">//typedef bool (*OT_SM_RetBool_ThrStr)(OTSmartContract * pContract,</span>
<a name="l00637"></a>00637 <span class="comment">//                                     const std::string from_acct_name,</span>
<a name="l00638"></a>00638 <span class="comment">//                                     const std::string to_acct_name,</span>
<a name="l00639"></a>00639 <span class="comment">//                                     const std::string str_Amount);</span>
<a name="l00640"></a>00640 <span class="comment">// Test result:  WORKS calling chaiscript</span>
<a name="l00641"></a>00641 <span class="comment">//Cron: Processing smart contract clauses for hook: cron_process</span>
<a name="l00642"></a>00642 <span class="comment">//OTSmartContract::MoveAcctFunds: error: from_acct (sSBcoTlTkYY8pPv6vh2KD6mIVrRdIwodgsWDoJzIfpV) not found on any party.  // debug this in move_funds</span>
<a name="l00643"></a>00643 <span class="comment">//OTSmartContract::ExecuteClauses: Success executing script clause: process_clause.</span>
<a name="l00644"></a>00644 
<a name="l00645"></a>00645 <span class="comment">// Global version. (int64_t parameter)</span>
<a name="l00646"></a>00646 <span class="comment">//typedef bool (*OT_SM_RetBool_TwoStr_OneL)(OTSmartContract * pContract,</span>
<a name="l00647"></a>00647 <span class="comment">//                                          const std::string from_acct_name,</span>
<a name="l00648"></a>00648 <span class="comment">//                                          const std::string to_acct_name,</span>
<a name="l00649"></a>00649 <span class="comment">//                                          const int64_t lAmount);</span>
<a name="l00650"></a>00650 <span class="comment">// TEST Result:  FAILS calling chaiscript: Cannot perform boxed_cast.   (Must be the LONG!!)</span>
<a name="l00651"></a>00651 <span class="comment">//Cron: Processing smart contract clauses for hook: cron_process</span>
<a name="l00652"></a>00652 <span class="comment">//OTScriptChai::ExecuteScript: Caught chaiscript::exception::bad_boxed_cast : Cannot perform boxed_cast.</span>
<a name="l00653"></a>00653 <span class="comment">//OTSmartContract::ExecuteClauses: Error while running script: process_clause</span>
<a name="l00654"></a>00654 
<a name="l00655"></a>00655 <span class="comment">// Class member, with string parameter.</span>
<a name="l00656"></a><a class="code" href="_o_t_smart_contract_8cpp.html#a6727e3e80e655754aacd7b5380f8fb00">00656</a> <span class="keyword">typedef</span> bool (<a class="code" href="class_o_t_smart_contract.html">OTSmartContract</a>::*<a class="code" href="_o_t_smart_contract_8cpp.html#a6727e3e80e655754aacd7b5380f8fb00">OT_SM_RetBool_ThrStr</a>)(<span class="keyword">const</span> std::string from_acct_name,
<a name="l00657"></a>00657                                                       <span class="keyword">const</span> std::string to_acct_name,
<a name="l00658"></a>00658                                                       <span class="keyword">const</span> std::string str_Amount);
<a name="l00659"></a>00659 
<a name="l00660"></a>00660 
<a name="l00661"></a>00661 <span class="comment">// TEST RESULT: WORKS calling Chaiscript</span>
<a name="l00662"></a>00662 <span class="comment">//Cron: Processing smart contract clauses for hook: cron_process</span>
<a name="l00663"></a>00663 <span class="comment">//OTSmartContract::MoveAcctFunds: error: from_acct (sSBcoTlTkYY8pPv6vh2KD6mIVrRdIwodgsWDoJzIfpV) not found on any party.</span>
<a name="l00664"></a>00664 <span class="comment">//OTSmartContract::ExecuteClauses: Success executing script clause: process_clause.</span>
<a name="l00665"></a>00665 
<a name="l00666"></a>00666 <span class="comment">// Class member, with int64_t parameter.</span>
<a name="l00667"></a>00667 <span class="comment">//typedef bool (OTSmartContract::*OT_SM_RetBool_TwoStr_OneL)(const std::string from_acct_name,</span>
<a name="l00668"></a>00668 <span class="comment">//                                                           const std::string to_acct_name,</span>
<a name="l00669"></a>00669 <span class="comment">//                                                           int64_t lAmount);</span>
<a name="l00670"></a>00670 
<a name="l00671"></a><a class="code" href="class_o_t_smart_contract.html#ad79350fe9df32d0e129e1a8b5fe28a04">00671</a> <span class="keywordtype">void</span> <a class="code" href="class_o_t_smart_contract.html#ad79350fe9df32d0e129e1a8b5fe28a04">OTSmartContract::RegisterOTNativeCallsWithScript</a>(<a class="code" href="class_o_t_script.html">OTScript</a> &amp; theScript)
<a name="l00672"></a>00672 {
<a name="l00673"></a>00673     <span class="comment">// CALL THE PARENT</span>
<a name="l00674"></a>00674     <a class="code" href="class_o_t_smart_contract.html#ad79350fe9df32d0e129e1a8b5fe28a04">OTScriptable::RegisterOTNativeCallsWithScript</a>(theScript);
<a name="l00675"></a>00675     <span class="comment">// --------------------------------</span>
<a name="l00676"></a>00676 
<a name="l00677"></a>00677 <span class="preprocessor">#ifdef OT_USE_SCRIPT_CHAI</span>
<a name="l00678"></a>00678 <span class="preprocessor"></span>    <span class="keyword">using namespace </span>chaiscript;
<a name="l00679"></a>00679 
<a name="l00680"></a>00680     OTScriptChai * pScript = <span class="keyword">dynamic_cast&lt;</span>OTScriptChai *<span class="keyword">&gt;</span> (&amp;theScript);
<a name="l00681"></a>00681 
<a name="l00682"></a>00682     <span class="comment">// *******************************************************************</span>
<a name="l00683"></a>00683     <span class="keywordflow">if</span> (NULL != pScript)
<a name="l00684"></a>00684     {
<a name="l00685"></a>00685         <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != pScript-&gt;chai)
<a name="l00686"></a>00686         <span class="comment">// ---------------------------------------------------------</span>
<a name="l00687"></a>00687         <span class="comment">// OT NATIVE FUNCTIONS</span>
<a name="l00688"></a>00688         <span class="comment">// (These functions can be called from INSIDE the scripted clauses.)</span>
<a name="l00689"></a>00689         <span class="comment">//                                                                                      // Parameters must match as described below. Return value will be as described below.</span>
<a name="l00690"></a>00690         <span class="comment">//                                                                                      // -------------------------------------------------------------</span>
<a name="l00691"></a>00691 <span class="comment">//      pScript-&gt;chai-&gt;add(base_class&lt;OTScriptable, OTSmartContract&gt;());</span>
<a name="l00692"></a>00692 
<a name="l00693"></a>00693         pScript-&gt;chai-&gt;add(fun&lt;OT_SM_RetBool_ThrStr&gt;(&amp;<a class="code" href="class_o_t_smart_contract.html#ae10051f961745a06753f5e22d9a699f1">OTSmartContract::MoveAcctFundsStr</a>,        <span class="keyword">this</span>), <span class="stringliteral">&quot;move_funds&quot;</span>);   <span class="comment">// bool MoveAcctFunds(const std::string from_acct_name, const std::string to_acct_name, const std::string str_Amount); // calls OTCronItem::MoveFunds()</span>
<a name="l00694"></a>00694 <span class="comment">//      pScript-&gt;chai-&gt;add(fun&lt;OT_SM_RetBool_TwoStr_OneL&gt;(&amp;OTSmartContract::MoveAcctFundsL, this), &quot;move_funds_L&quot;);     // static bool s_MoveAcctFunds(const std::string from_acct_name, const std::string to_acct_name, const int64_t&amp; lAmount); // calls OTCronItem::MoveFunds()</span>
<a name="l00695"></a>00695 <span class="comment">//      pScript-&gt;chai-&gt;add(fun&lt;OT_SM_RetBool_ThrStr&gt;(&amp;OTSmartContract::MoveAcctFundsStr,        this), &quot;move_funds_Str&quot;);   // static bool s_MoveAcctFunds(const std::string from_acct_name, const std::string to_acct_name, const std::string str_Amount); // calls OTCronItem::MoveFunds()</span>
<a name="l00696"></a>00696 <span class="comment">//      pScript-&gt;chai-&gt;add(fun&lt;OT_SM_RetBool_TwoStr_OneL&gt;(&amp;g_MoveAcctFundsL,    this), &quot;move_funds_L&quot;);     // global bool s_MoveAcctFunds(const std::string from_acct_name, const std::string to_acct_name, const int64_t&amp; lAmount); // calls OTCronItem::MoveFunds()</span>
<a name="l00697"></a>00697 <span class="comment">//      pScript-&gt;chai-&gt;add(fun&lt;OT_SM_RetBool_ThrStr&gt;(&amp;g_MoveAcctFundsStr,   this), &quot;move_funds_Str&quot;);   // global bool s_MoveAcctFunds(const std::string from_acct_name, const std::string to_acct_name, const std::string str_Amount); // calls OTCronItem::MoveFunds()</span>
<a name="l00698"></a>00698 
<a name="l00699"></a>00699         pScript-&gt;chai-&gt;add(fun(&amp;<a class="code" href="class_o_t_smart_contract.html#a7d4c35453914e75a252a1f4eac3ce855">OTSmartContract::StashAcctFunds</a>,                <span class="keyword">this</span>), <span class="stringliteral">&quot;stash_funds&quot;</span>);      <span class="comment">// bool StashAcctFunds(const std::string from_acct_name, const std::string to_stash_name, const std::string str_Amount); // calls StashFunds()</span>
<a name="l00700"></a>00700         pScript-&gt;chai-&gt;add(fun(&amp;<a class="code" href="class_o_t_smart_contract.html#a7be637de24a11ebd872822b84952c21a">OTSmartContract::UnstashAcctFunds</a>,          <span class="keyword">this</span>), <span class="stringliteral">&quot;unstash_funds&quot;</span>);    <span class="comment">// bool UnstashAcctFunds(const std::string to_acct_name, const std::string from_stash_name, const std::string str_Amount); // calls StashFunds( lAmount * (-1) )</span>
<a name="l00701"></a>00701 
<a name="l00702"></a>00702         pScript-&gt;chai-&gt;add(fun(&amp;<a class="code" href="class_o_t_smart_contract.html#af6c9cbe669cea11256dc7fd2a6fdddf4">OTSmartContract::GetAcctBalance</a>,                <span class="keyword">this</span>), <span class="stringliteral">&quot;get_acct_balance&quot;</span>); <span class="comment">// std::string GetAcctBalance(const std::string acct_name);</span>
<a name="l00703"></a>00703         pScript-&gt;chai-&gt;add(fun(&amp;<a class="code" href="class_o_t_smart_contract.html#aef2b64b4870a325f36df1e634f744ce9">OTSmartContract::GetAssetTypeIDofAcct</a>,      <span class="keyword">this</span>), <span class="stringliteral">&quot;get_acct_asset_type_id&quot;</span>); <span class="comment">// std::string OTSmartContract::GetAssetTypeIDofAcct(const std::string from_acct_name)</span>
<a name="l00704"></a>00704         pScript-&gt;chai-&gt;add(fun(&amp;<a class="code" href="class_o_t_smart_contract.html#a2a92d021daf88edba58aabba629d90e5">OTSmartContract::GetStashBalance</a>,           <span class="keyword">this</span>), <span class="stringliteral">&quot;get_stash_balance&quot;</span>);    <span class="comment">// std::string GetStashBalance(const std::string stash_name, const std::string asset_type_id);</span>
<a name="l00705"></a>00705 
<a name="l00706"></a>00706         pScript-&gt;chai-&gt;add(fun(&amp;<a class="code" href="class_o_t_smart_contract.html#a72762c0413197f084b36e2d0fce59e4f">OTSmartContract::SendNoticeToParty</a>,         <span class="keyword">this</span>), <span class="stringliteral">&quot;send_notice&quot;</span>);              <span class="comment">// bool SendNoticeToParty(const std::string party_name);</span>
<a name="l00707"></a>00707         pScript-&gt;chai-&gt;add(fun(&amp;<a class="code" href="class_o_t_smart_contract.html#a63aa006565fab757f33d28215b1f5e0c">OTSmartContract::SendANoticeToAllParties</a>,   <span class="keyword">this</span>), <span class="stringliteral">&quot;send_notice_to_parties&quot;</span>);   <span class="comment">// bool SendANoticeToAllParties();</span>
<a name="l00708"></a>00708 
<a name="l00709"></a>00709         pScript-&gt;chai-&gt;add(fun(&amp;<a class="code" href="class_o_t_smart_contract.html#ab039e15191e3294e6a09eaa6f5be8923">OTSmartContract::SetRemainingTimer</a>,         <span class="keyword">this</span>), <span class="stringliteral">&quot;set_seconds_until_timer&quot;</span>);  <span class="comment">// void SetNextProcessTime(const std::string str_seconds_from_now) // if this is &lt;=0, then it sets next process date to 0.</span>
<a name="l00710"></a>00710         pScript-&gt;chai-&gt;add(fun(&amp;<a class="code" href="class_o_t_smart_contract.html#a71f505b723bbb56e75a46b9836c3949c">OTSmartContract::GetRemainingTimer</a>,         <span class="keyword">this</span>), <span class="stringliteral">&quot;get_remaining_timer&quot;</span>);  <span class="comment">// std::string GetRemainingTimer() const</span>
<a name="l00711"></a>00711 
<a name="l00712"></a>00712         pScript-&gt;chai-&gt;add(fun(&amp;<a class="code" href="class_o_t_smart_contract.html#ac9ad18ccba9bb19d1ff2568d10386524">OTSmartContract::DeactivateSmartContract</a>,   <span class="keyword">this</span>), <span class="stringliteral">&quot;deactivate_contract&quot;</span>);  <span class="comment">// void DeactivateSmartContract();</span>
<a name="l00713"></a>00713         <span class="comment">// ---------------------------------------------------------</span>
<a name="l00714"></a>00714         <span class="comment">// CALLBACKS</span>
<a name="l00715"></a>00715         <span class="comment">// (Called by OT at key moments) todo security: What if these are recursive? Need to lock down, put the smack down, on these smart contracts.</span>
<a name="l00716"></a>00716         <span class="comment">//</span>
<a name="l00717"></a>00717 <span class="comment">//FYI:  pScript-&gt;chai-&gt;add(fun(&amp;(OTScriptable::CanExecuteClause),           (*this)), &quot;party_may_execute_clause&quot;);  // From OTScriptable (FYI) param_party_name and param_clause_name will be available inside script. Script must return bool.</span>
<a name="l00718"></a>00718 <span class="comment">//FYI:  #define SCRIPTABLE_CALLBACK_PARTY_MAY_EXECUTE   &quot;callback_party_may_execute_clause&quot;   &lt;=== THE CALLBACK WITH THIS NAME must be connected to a script clause, and then the clause will trigger when the callback is needed.</span>
<a name="l00719"></a>00719 
<a name="l00720"></a>00720         pScript-&gt;chai-&gt;add(fun(&amp;<a class="code" href="class_o_t_smart_contract.html#a77a75cea50a6d4e8a2b199204dc8c7a6">OTSmartContract::CanCancelContract</a>,         <span class="keyword">this</span>), <span class="stringliteral">&quot;party_may_cancel_contract&quot;</span>); <span class="comment">// param_party_name will be available inside script. Script must return bool.</span>
<a name="l00721"></a>00721 <span class="comment">//FYI:  #define SMARTCONTRACT_CALLBACK_PARTY_MAY_CANCEL &quot;callback_party_may_cancel_contract&quot;  &lt;=== THE CALLBACK WITH THIS NAME must be connected to a script clause, and then the clause will trigger when the callback is needed.</span>
<a name="l00722"></a>00722 
<a name="l00723"></a>00723         <span class="comment">// Callback USAGE:  Your clause, in your smart contract, may have whatever name you want. (Within limits.)</span>
<a name="l00724"></a>00724         <span class="comment">//                  There must be a callback entry in the smart contract, linking your clause the the appropriate callback.</span>
<a name="l00725"></a>00725         <span class="comment">//                  The CALLBACK ENTRY uses the names &quot;callback_party_may_execute_clause&quot; and &quot;callback_party_may_cancel_contract&quot;.</span>
<a name="l00726"></a>00726         <span class="comment">//                  If you want to call these from INSIDE YOUR SCRIPT, then use the names &quot;party_may_execute_clause&quot; and &quot;party_may_cancel_contract&quot;.</span>
<a name="l00727"></a>00727 
<a name="l00728"></a>00728         <span class="comment">// ---------------------------------------------------------</span>
<a name="l00729"></a>00729         <span class="comment">// HOOKS:</span>
<a name="l00730"></a>00730         <span class="comment">//</span>
<a name="l00731"></a>00731         <span class="comment">// Hooks are not native calls needing to be registered with the script. (Like the above functions are.)</span>
<a name="l00732"></a>00732         <span class="comment">// Rather, hooks are SCRIPT CLAUSES, that you have a CHOICE to provide inside your SMART CONTRACT.</span>
<a name="l00733"></a>00733         <span class="comment">// *IF* you have provided those clauses, then OT *WILL* call them, at the appropriate times. (When</span>
<a name="l00734"></a>00734         <span class="comment">// specific events occur.) Specifically, Hook entries must be in your smartcontract, linking the below</span>
<a name="l00735"></a>00735         <span class="comment">// standard hooks to your clauses.</span>
<a name="l00736"></a>00736         <span class="comment">//</span>
<a name="l00737"></a>00737 <span class="comment">//FYI:  #define SMARTCONTRACT_HOOK_ON_PROCESS       &quot;cron_process&quot;      // Called regularly in OTSmartContract::ProcessCron() based on SMART_CONTRACT_PROCESS_INTERVAL.</span>
<a name="l00738"></a>00738 <span class="comment">//FYI:  #define SMARTCONTRACT_HOOK_ON_ACTIVATE      &quot;cron_activate&quot;     // Done. This is called when the contract is first activated.</span>
<a name="l00739"></a>00739     }
<a name="l00740"></a>00740     <span class="comment">// *******************************************************************</span>
<a name="l00741"></a>00741 <span class="comment">//  else if (NULL != (pScript = dynamic_cast&lt;OTScriptSomeOtherScriptingLanguageSubClass_GOES_HERE *&gt; (&amp;theScript)) )</span>
<a name="l00742"></a>00742 <span class="comment">//  { }</span>
<a name="l00743"></a>00743     <span class="comment">// *******************************************************************</span>
<a name="l00744"></a>00744     <span class="keywordflow">else</span>
<a name="l00745"></a>00745 <span class="preprocessor">#endif // OT_USE_SCRIPT_CHAI</span>
<a name="l00746"></a>00746 <span class="preprocessor"></span>    {
<a name="l00747"></a>00747         <a class="code" href="class_o_t_log.html#a5acd90ac91c2618f395b0ff37ad4f8ee">OTLog::Error</a>(<span class="stringliteral">&quot;OTSmartContract::RegisterOTNativeCallsWithScript: Failed dynamic casting OTScript to OTScriptChai \n&quot;</span>);
<a name="l00748"></a>00748     }
<a name="l00749"></a>00749     <span class="comment">// *******************************************************************</span>
<a name="l00750"></a>00750 } <span class="comment">// void function</span>
<a name="l00751"></a>00751 
<a name="l00752"></a>00752 
<a name="l00753"></a>00753 <span class="comment">// Done.  Can be called from inside script.</span>
<a name="l00754"></a>00754 <span class="comment">// pScript-&gt;chai-&gt;add(fun(&amp;(OTSmartContract::DeactivateSmartContract),  (*this)), &quot;deactivate_smart_contract&quot;); // void DeactivateSmartContract();</span>
<a name="l00755"></a>00755 <span class="comment">//</span>
<a name="l00756"></a><a class="code" href="class_o_t_smart_contract.html#ac9ad18ccba9bb19d1ff2568d10386524">00756</a> <span class="keywordtype">void</span> <a class="code" href="class_o_t_smart_contract.html#ac9ad18ccba9bb19d1ff2568d10386524">OTSmartContract::DeactivateSmartContract</a>() <span class="comment">// Called from within script.</span>
<a name="l00757"></a>00757 {
<a name="l00758"></a>00758     <span class="comment">// WARNING: If a party has the right to execute a clause that calls DeactivateSmartContract(),</span>
<a name="l00759"></a>00759     <span class="comment">// then that party can deactivate the smartcontract by calling that clause, regardless of what</span>
<a name="l00760"></a>00760     <span class="comment">// &quot;CanPartyCancelClause()&quot; says he can do.</span>
<a name="l00761"></a>00761     <span class="comment">// (And by default, any legitimate party can trigger any clause, at any time, unless your script</span>
<a name="l00762"></a>00762     <span class="comment">// override says differently.)</span>
<a name="l00763"></a>00763 
<a name="l00764"></a>00764     <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(0, <span class="stringliteral">&quot;OTSmartContract::DeactivateSmartContract: deactivate_contract() was called from within the script. &quot;</span>
<a name="l00765"></a>00765                    <span class="stringliteral">&quot;Flagging smartcontract for removal from Cron (%lld).\n&quot;</span>, <a class="code" href="class_o_t_trackable.html#a2594d320e3b24f3210bd38a08de66a70">GetTransactionNum</a>());
<a name="l00766"></a>00766 
<a name="l00767"></a>00767     this-&gt;<a class="code" href="class_o_t_cron_item.html#a34c87380d2f8cd419c9a5cfec86427b4">FlagForRemoval</a>(); <span class="comment">// Remove it from future Cron processing, please.</span>
<a name="l00768"></a>00768 }
<a name="l00769"></a>00769 
<a name="l00770"></a>00770 
<a name="l00771"></a>00771 <span class="comment">// These are from OTScriptable (super-grandparent-class to *this):</span>
<a name="l00772"></a>00772 <span class="comment">/* ----------------------------------------------------</span>
<a name="l00773"></a>00773 <span class="comment">OTParty     * GetParty  (const std::string str_party_name);</span>
<a name="l00774"></a>00774 <span class="comment">OTBylaw     * GetBylaw  (const std::string str_bylaw_name);</span>
<a name="l00775"></a>00775 <span class="comment">OTClause    * GetClause (const std::string str_clause_name);</span>
<a name="l00776"></a>00776 <span class="comment">// ----------------------------------------------------</span>
<a name="l00777"></a>00777 <span class="comment">OTParty * FindPartyBasedOnNymAsAgent(OTPseudonym &amp; theNym, OTAgent ** ppAgent=NULL);</span>
<a name="l00778"></a>00778 <span class="comment">OTParty * FindPartyBasedOnNymAsAuthAgent(OTPseudonym &amp; theNym, OTAgent ** ppAgent=NULL);</span>
<a name="l00779"></a>00779 <span class="comment">OTParty * FindPartyBasedOnAccount(OTAccount &amp; theAccount, OTPartyAccount ** ppPartyAccount=NULL);</span>
<a name="l00780"></a>00780 <span class="comment">// ----------------------------------------------------</span>
<a name="l00781"></a>00781 <span class="comment">OTParty * FindPartyBasedOnNymIDAsAgent(const OTIdentifier &amp; theNymID, OTAgent ** ppAgent=NULL);</span>
<a name="l00782"></a>00782 <span class="comment">OTParty * FindPartyBasedOnNymIDAsAuthAgent(const OTIdentifier &amp; theNymID, OTAgent ** ppAgent=NULL);</span>
<a name="l00783"></a>00783 <span class="comment">OTParty * FindPartyBasedOnAccountID(const OTIdentifier &amp; theAcctID, OTPartyAccount ** ppPartyAccount=NULL);</span>
<a name="l00784"></a>00784 <span class="comment">// ----------------------------------------------------</span>
<a name="l00785"></a>00785 <span class="comment">OTAgent         * GetAgent(const std::string str_agent_name);</span>
<a name="l00786"></a>00786 <span class="comment">OTPartyAccount  * GetPartyAccount(const std::string str_acct_name);</span>
<a name="l00787"></a>00787 <span class="comment">OTPartyAccount  * GetPartyAccountByID(const OTIdentifier &amp; theAcctID);</span>
<a name="l00788"></a>00788 <span class="comment">*/</span>
<a name="l00789"></a>00789 
<a name="l00790"></a>00790 <span class="comment">// Returns true if it was empty (and thus successfully set.)</span>
<a name="l00791"></a>00791 <span class="comment">// Otherwise, if it wasn&#39;t empty (it had been already set) then</span>
<a name="l00792"></a>00792 <span class="comment">// it will fail to set in this call, and return false.</span>
<a name="l00793"></a>00793 <span class="comment">//</span>
<a name="l00794"></a><a class="code" href="class_o_t_smart_contract.html#aa4d0e2f242f874a9a594a31d8af26533">00794</a> <span class="keywordtype">bool</span> <a class="code" href="class_o_t_smart_contract.html#aa4d0e2f242f874a9a594a31d8af26533">OTSmartContract::SetServerIDIfEmpty</a>(<span class="keyword">const</span> <a class="code" href="class_o_t_identifier.html">OTIdentifier</a> &amp; theID)
<a name="l00795"></a>00795 {
<a name="l00796"></a>00796     <span class="keywordflow">if</span> (this-&gt;<a class="code" href="class_o_t_instrument.html#a878dd8998f7b131b85c082575e255375">GetServerID</a>().IsEmpty())
<a name="l00797"></a>00797     {
<a name="l00798"></a>00798         this-&gt;<a class="code" href="class_o_t_instrument.html#a80fc5560fdedf911ec0c184ab9fbb5b7">SetServerID</a>(theID);
<a name="l00799"></a>00799         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00800"></a>00800     }
<a name="l00801"></a>00801     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00802"></a>00802 }
<a name="l00803"></a>00803 
<a name="l00804"></a>00804 
<a name="l00805"></a><a class="code" href="class_o_t_smart_contract.html#aa5a554f7a5ca7c9a0d0d2377860ef8c2">00805</a> <span class="keywordtype">bool</span> <a class="code" href="class_o_t_smart_contract.html#aa5a554f7a5ca7c9a0d0d2377860ef8c2">OTSmartContract::IsValidOpeningNumber</a>(<span class="keyword">const</span> int64_t &amp; lOpeningNum)<span class="keyword"> const</span>
<a name="l00806"></a>00806 <span class="keyword"></span>{
<a name="l00807"></a>00807 
<a name="l00808"></a>00808     <a class="code" href="_o_t_storage_8hpp.html#a804eb881e96b7e1846d130a55a94f716">FOR_EACH_CONST</a>(<a class="code" href="_o_t_party_8hpp.html#a029bc6921acd4516530e26201cf595f2">mapOfParties</a>, <a class="code" href="class_o_t_scriptable.html#a6a7e4ef3e0ed95f90d950b1718f815ab">m_mapParties</a>)
<a name="l00809"></a>00809     {
<a name="l00810"></a>00810         <a class="code" href="class_o_t_party.html">OTParty</a> * pParty = (*it).second;
<a name="l00811"></a>00811         <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != pParty);
<a name="l00812"></a>00812         <span class="comment">// -----------------------------</span>
<a name="l00813"></a>00813 
<a name="l00814"></a>00814         <span class="keywordflow">if</span> (pParty-&gt;<a class="code" href="class_o_t_party.html#aa11f990dfe9743dd1d8e34af8bfd693a">GetOpeningTransNo</a>() == lOpeningNum)
<a name="l00815"></a>00815             <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00816"></a>00816     }
<a name="l00817"></a>00817 
<a name="l00818"></a>00818     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00819"></a>00819 }
<a name="l00820"></a>00820 
<a name="l00821"></a>00821 
<a name="l00822"></a>00822 <span class="comment">// Checks opening number on parties, and closing numbers on each party&#39;s accounts.</span>
<a name="l00823"></a>00823 <span class="comment">// Overrides from OTTrackable.</span>
<a name="l00824"></a>00824 <span class="comment">//</span>
<a name="l00825"></a><a class="code" href="class_o_t_smart_contract.html#a1952403bb15765cab19f435186b6c362">00825</a> <span class="keywordtype">bool</span> <a class="code" href="class_o_t_smart_contract.html#a1952403bb15765cab19f435186b6c362">OTSmartContract::HasTransactionNum</a>(<span class="keyword">const</span> int64_t &amp; lInput)<span class="keyword"> const</span>
<a name="l00826"></a>00826 <span class="keyword"></span>{
<a name="l00827"></a>00827     <a class="code" href="_o_t_storage_8hpp.html#a804eb881e96b7e1846d130a55a94f716">FOR_EACH_CONST</a>(<a class="code" href="_o_t_party_8hpp.html#a029bc6921acd4516530e26201cf595f2">mapOfParties</a>, <a class="code" href="class_o_t_scriptable.html#a6a7e4ef3e0ed95f90d950b1718f815ab">m_mapParties</a>)
<a name="l00828"></a>00828     {
<a name="l00829"></a>00829         <span class="keyword">const</span> <a class="code" href="class_o_t_party.html">OTParty</a> * pParty = (*it).second;
<a name="l00830"></a>00830         <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != pParty);
<a name="l00831"></a>00831         <span class="comment">// ----------------------------------</span>
<a name="l00832"></a>00832         <span class="keywordflow">if</span> (pParty-&gt;<a class="code" href="class_o_t_party.html#add612bb3dc7fdc8a9a5bc014fd42104e">HasTransactionNum</a>(lInput))
<a name="l00833"></a>00833             <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00834"></a>00834     }
<a name="l00835"></a>00835     <span class="comment">// -------------------</span>
<a name="l00836"></a>00836     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00837"></a>00837 }
<a name="l00838"></a>00838 
<a name="l00839"></a>00839 
<a name="l00840"></a><a class="code" href="class_o_t_smart_contract.html#ace4cafaf9afe3c3076271564d699cc65">00840</a> <span class="keywordtype">void</span> <a class="code" href="class_o_t_smart_contract.html#ace4cafaf9afe3c3076271564d699cc65">OTSmartContract::GetAllTransactionNumbers</a>(<a class="code" href="class_o_t_num_list.html">OTNumList</a> &amp; numlistOutput)<span class="keyword"> const</span>
<a name="l00841"></a>00841 <span class="keyword"></span>{
<a name="l00842"></a>00842     <a class="code" href="_o_t_storage_8hpp.html#a804eb881e96b7e1846d130a55a94f716">FOR_EACH_CONST</a>(<a class="code" href="_o_t_party_8hpp.html#a029bc6921acd4516530e26201cf595f2">mapOfParties</a>, <a class="code" href="class_o_t_scriptable.html#a6a7e4ef3e0ed95f90d950b1718f815ab">m_mapParties</a>)
<a name="l00843"></a>00843     {
<a name="l00844"></a>00844         <span class="keyword">const</span> <a class="code" href="class_o_t_party.html">OTParty</a> * pParty = (*it).second;
<a name="l00845"></a>00845         <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != pParty);
<a name="l00846"></a>00846         <span class="comment">// ----------------------------------</span>
<a name="l00847"></a>00847         pParty-&gt;<a class="code" href="class_o_t_party.html#ac8879e0a5d65ac273a56711336a9d45c">GetAllTransactionNumbers</a>(numlistOutput);
<a name="l00848"></a>00848     }
<a name="l00849"></a>00849 }
<a name="l00850"></a>00850 
<a name="l00851"></a>00851 
<a name="l00852"></a><a class="code" href="class_o_t_smart_contract.html#a2bb8a0f8a1ff8ddf637e5d87d5935e51">00852</a> int64_t <a class="code" href="class_o_t_smart_contract.html#a2bb8a0f8a1ff8ddf637e5d87d5935e51">OTSmartContract::GetOpeningNumber</a>(<span class="keyword">const</span> <a class="code" href="class_o_t_identifier.html">OTIdentifier</a> &amp; theNymID)<span class="keyword"> const</span>
<a name="l00853"></a>00853 <span class="keyword"></span>{
<a name="l00854"></a>00854     <a class="code" href="class_o_t_agent.html">OTAgent</a> * pAgent = NULL;
<a name="l00855"></a>00855     <a class="code" href="class_o_t_party.html">OTParty</a> * pParty = this-&gt;<a class="code" href="class_o_t_scriptable.html#af0eddbe4b88394bcc113d9333d8e0a97">FindPartyBasedOnNymIDAsAgent</a>(theNymID, &amp;pAgent);
<a name="l00856"></a>00856 
<a name="l00857"></a>00857     <span class="keywordflow">if</span> (NULL != pParty)
<a name="l00858"></a>00858     {
<a name="l00859"></a>00859         <a class="code" href="_o_t_assert_8hpp.html#a033b133f48e61f2b227c52ad2be0c882">OT_ASSERT_MSG</a>(NULL != pAgent, <span class="stringliteral">&quot;OT_ASSERT: NULL != pAgent in OTSmartContract::GetOpeningNumber.\n&quot;</span>);
<a name="l00860"></a>00860         <span class="keywordflow">return</span> pParty-&gt;<a class="code" href="class_o_t_party.html#aa11f990dfe9743dd1d8e34af8bfd693a">GetOpeningTransNo</a>();
<a name="l00861"></a>00861     }
<a name="l00862"></a>00862 
<a name="l00863"></a>00863     <span class="keywordflow">return</span> 0;
<a name="l00864"></a>00864 }
<a name="l00865"></a>00865 
<a name="l00866"></a>00866 
<a name="l00867"></a><a class="code" href="class_o_t_smart_contract.html#a3a9a2325c23aa03f4e6ce03fec6f69f7">00867</a> int64_t <a class="code" href="class_o_t_smart_contract.html#a3a9a2325c23aa03f4e6ce03fec6f69f7">OTSmartContract::GetClosingNumber</a>(<span class="keyword">const</span> <a class="code" href="class_o_t_identifier.html">OTIdentifier</a> &amp; theAcctID)<span class="keyword"> const</span>
<a name="l00868"></a>00868 <span class="keyword"></span>{
<a name="l00869"></a>00869     <a class="code" href="class_o_t_party_account.html">OTPartyAccount</a>  * pPartyAcct = this-&gt;<a class="code" href="class_o_t_scriptable.html#ae4abf1800fd193dc93835b777f40019c">GetPartyAccountByID</a>(theAcctID); <span class="comment">// from OTScriptable.</span>
<a name="l00870"></a>00870 
<a name="l00871"></a>00871     <span class="keywordflow">if</span> (NULL != pPartyAcct)
<a name="l00872"></a>00872     {
<a name="l00873"></a>00873         <span class="keywordflow">return</span> pPartyAcct-&gt;<a class="code" href="class_o_t_party_account.html#add572c3b200be9265d9dcc4a1b1f4185">GetClosingTransNo</a>();
<a name="l00874"></a>00874     }
<a name="l00875"></a>00875 
<a name="l00876"></a>00876     <span class="keywordflow">return</span> 0;
<a name="l00877"></a>00877 }
<a name="l00878"></a>00878 
<a name="l00879"></a>00879 
<a name="l00880"></a>00880 <span class="comment">/*</span>
<a name="l00881"></a>00881 <span class="comment"> &quot; 6 minutes    ==      360 seconds\n&quot;</span>
<a name="l00882"></a>00882 <span class="comment"> &quot;10 minutes    ==      600 seconds\n&quot;</span>
<a name="l00883"></a>00883 <span class="comment"> &quot; 1 hour       ==     3600 seconds\n&quot;</span>
<a name="l00884"></a>00884 <span class="comment"> &quot; 1 day        ==    86400 seconds\n&quot;</span>
<a name="l00885"></a>00885 <span class="comment"> &quot;30 days       ==  2592000 seconds\n&quot;</span>
<a name="l00886"></a>00886 <span class="comment"> &quot; 3 months     ==  7776000 seconds\n&quot;</span>
<a name="l00887"></a>00887 <span class="comment"> &quot; 6 months     == 15552000 seconds\n\n&quot;</span>
<a name="l00888"></a>00888 <span class="comment"> &quot;12 months     == 31104000 seconds\n\n&quot;</span>
<a name="l00889"></a>00889 <span class="comment"> */</span>
<a name="l00890"></a>00890 
<a name="l00891"></a>00891 <span class="comment">// onProcess will trigger X seconds from now...</span>
<a name="l00892"></a>00892 <span class="comment">//</span>
<a name="l00893"></a><a class="code" href="class_o_t_smart_contract.html#ab039e15191e3294e6a09eaa6f5be8923">00893</a> <span class="keywordtype">void</span> <a class="code" href="class_o_t_smart_contract.html#ab039e15191e3294e6a09eaa6f5be8923">OTSmartContract::SetRemainingTimer</a>(<span class="keyword">const</span> std::string str_seconds_from_now) <span class="comment">// if this is &lt;=0, then it sets next process date to 0.</span>
<a name="l00894"></a>00894 {
<a name="l00895"></a>00895     <span class="keywordflow">if</span> (str_seconds_from_now.size() &lt;= 0) <span class="comment">// string length...</span>
<a name="l00896"></a>00896     {
<a name="l00897"></a>00897         <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(0, <span class="stringliteral">&quot;OTSmartContract::%s: blank input (str_seconds_from_now).\n&quot;</span>,
<a name="l00898"></a>00898                        __FUNCTION__);
<a name="l00899"></a>00899     }
<a name="l00900"></a>00900     <span class="keywordflow">else</span>
<a name="l00901"></a>00901     {
<a name="l00902"></a>00902         <span class="keyword">const</span> int64_t tPlus = <a class="code" href="class_o_t_string.html#a3f2489a8c996db1df14479d36af3b76b">OTString::StringToLong</a>(str_seconds_from_now);
<a name="l00903"></a>00903 
<a name="l00904"></a>00904         <span class="keywordflow">if</span> (tPlus &gt; 0)
<a name="l00905"></a>00905             <a class="code" href="class_o_t_smart_contract.html#a0c0ffa47dacaa8fa79304317f8e04544">SetNextProcessDate</a>(<a class="code" href="_o_t_common_8hpp.html#a38e4e4253c3dd158ea40e6312586e6c9">OTTimeAddTimeInterval</a>(<a class="code" href="_o_t_common_8hpp.html#a1163606b2546b160d50c5f0a5afe479a">OTTimeGetCurrentTime</a>(), tPlus));
<a name="l00906"></a>00906         <span class="keywordflow">else</span>
<a name="l00907"></a>00907             <a class="code" href="class_o_t_smart_contract.html#a0c0ffa47dacaa8fa79304317f8e04544">SetNextProcessDate</a>(<a class="code" href="_o_t_common_8hpp.html#af4ca9fa2c7c290d647dd18de0a9ac25f">OT_TIME_ZERO</a>); <span class="comment">// This way, you can deactivate the timer, by setting the next process date to 0.</span>
<a name="l00908"></a>00908     }
<a name="l00909"></a>00909 }
<a name="l00910"></a>00910 
<a name="l00911"></a>00911 
<a name="l00912"></a><a class="code" href="class_o_t_smart_contract.html#a71f505b723bbb56e75a46b9836c3949c">00912</a> std::string <a class="code" href="class_o_t_smart_contract.html#a71f505b723bbb56e75a46b9836c3949c">OTSmartContract::GetRemainingTimer</a>() const <span class="comment">// returns seconds left on the timer, in string format, or &quot;0&quot;.</span>
<a name="l00913"></a>00913 {
<a name="l00914"></a>00914     <span class="keyword">const</span> <a class="code" href="_o_t_common_8hpp.html#ad28ff0a3eda18840f6bda5872819167f">time64_t</a> tNextDate    = <a class="code" href="class_o_t_smart_contract.html#a16737b147030f0aaaedc53f798c35a50">GetNextProcessDate</a>();
<a name="l00915"></a>00915     <span class="keyword">const</span> <a class="code" href="_o_t_common_8hpp.html#ad28ff0a3eda18840f6bda5872819167f">time64_t</a> tCurrent = <a class="code" href="_o_t_common_8hpp.html#a1163606b2546b160d50c5f0a5afe479a">OTTimeGetCurrentTime</a>();
<a name="l00916"></a>00916 
<a name="l00917"></a>00917     <a class="code" href="class_o_t_string.html">OTString</a> strReturnVal(<span class="stringliteral">&quot;0&quot;</span>); <span class="comment">// the default return value is &quot;0&quot;.</span>
<a name="l00918"></a>00918 
<a name="l00919"></a>00919     <span class="keywordflow">if</span> (tNextDate &gt; <a class="code" href="_o_t_common_8hpp.html#af4ca9fa2c7c290d647dd18de0a9ac25f">OT_TIME_ZERO</a>)
<a name="l00920"></a>00920     {
<a name="l00921"></a>00921         <span class="keyword">const</span> int64_t tSecondsLeft = <a class="code" href="_o_t_common_8hpp.html#a4c78edddfcabfde278fafe43149f027e">OTTimeGetTimeInterval</a>(tNextDate, tCurrent);
<a name="l00922"></a>00922         strReturnVal.<a class="code" href="class_o_t_string.html#af1c861f21033a1d583b3cb12f952422e">Format</a>(<span class="stringliteral">&quot;%&quot;</span> PRId64<span class="stringliteral">&quot;&quot;</span>, tSecondsLeft);
<a name="l00923"></a>00923     }
<a name="l00924"></a>00924 
<a name="l00925"></a>00925     <span class="keywordflow">return</span> strReturnVal.<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>();
<a name="l00926"></a>00926 }
<a name="l00927"></a>00927 
<a name="l00928"></a>00928 
<a name="l00929"></a><a class="code" href="class_o_t_smart_contract.html#ad0ed5c23badda402c9493b86bef7542e">00929</a> <span class="keywordtype">void</span> <a class="code" href="class_o_t_smart_contract.html#ad0ed5c23badda402c9493b86bef7542e">OTSmartContract::onRemovalFromCron</a>()
<a name="l00930"></a>00930 {
<a name="l00931"></a>00931     <span class="comment">// Not much needed here.  Done, I guess.</span>
<a name="l00932"></a>00932 
<a name="l00933"></a>00933     <a class="code" href="class_o_t_log.html#a5acd90ac91c2618f395b0ff37ad4f8ee">OTLog::Error</a>(<span class="stringliteral">&quot;FYI:  OTSmartContract::onRemovalFromCron was just called. \n&quot;</span>);
<a name="l00934"></a>00934 
<a name="l00935"></a>00935     <span class="comment">// Trigger a script maybe.</span>
<a name="l00936"></a>00936     <span class="comment">// OR maybe it&#39;s too late for scripts.</span>
<a name="l00937"></a>00937     <span class="comment">// I give myself an onRemoval() here in C++, but perhaps I cut</span>
<a name="l00938"></a>00938     <span class="comment">// off the SCRIPTS after onFinalReceipt(). I think that&#39;s best.</span>
<a name="l00939"></a>00939 }
<a name="l00940"></a>00940 
<a name="l00941"></a>00941 
<a name="l00942"></a>00942 <span class="comment">// Done.</span>
<a name="l00943"></a>00943 <span class="comment">// called by HookActivationOnCron().</span>
<a name="l00944"></a>00944 <span class="comment">//</span>
<a name="l00945"></a><a class="code" href="class_o_t_smart_contract.html#a986e939aa9f6e838afc66426cbc0eb12">00945</a> <span class="keywordtype">void</span> <a class="code" href="class_o_t_smart_contract.html#a986e939aa9f6e838afc66426cbc0eb12">OTSmartContract::onActivate</a>()
<a name="l00946"></a>00946 {
<a name="l00947"></a>00947     <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != <a class="code" href="class_o_t_cron_item.html#af734ad5d309fcc9b4a60d40d6c30f55a">GetCron</a>());
<a name="l00948"></a>00948     <span class="comment">// -----------------------------------------------------------------------------</span>
<a name="l00949"></a>00949     <span class="keywordflow">if</span> (<a class="code" href="class_o_t_cron_item.html#af734ad5d309fcc9b4a60d40d6c30f55a">GetCron</a>()-&gt;GetTransactionCount() &lt; 1)
<a name="l00950"></a>00950     {
<a name="l00951"></a>00951         <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(0, <span class="stringliteral">&quot;%s: Failed to process smart contract %lld: Out of transaction numbers for receipts! Flagging for removal.\n&quot;</span>,
<a name="l00952"></a>00952                        __FUNCTION__, <a class="code" href="class_o_t_trackable.html#a2594d320e3b24f3210bd38a08de66a70">GetTransactionNum</a>());
<a name="l00953"></a>00953         <a class="code" href="class_o_t_cron_item.html#a34c87380d2f8cd419c9a5cfec86427b4">FlagForRemoval</a>();
<a name="l00954"></a>00954         <span class="keywordflow">return</span>;
<a name="l00955"></a>00955     }
<a name="l00956"></a>00956 
<a name="l00957"></a>00957     <span class="comment">// *****************************************************************************</span>
<a name="l00958"></a>00958     <span class="comment">//</span>
<a name="l00959"></a>00959     <span class="comment">// Execute the scripts (clauses) that have registered for this hook.</span>
<a name="l00960"></a>00960 
<a name="l00961"></a>00961     <span class="keyword">const</span> std::string   str_HookName(<a class="code" href="_o_t_smart_contract_8cpp.html#aa3eadb54e95be5d2dbb367f6c359c469">SMARTCONTRACT_HOOK_ON_ACTIVATE</a>);
<a name="l00962"></a>00962     <a class="code" href="_o_t_clause_8hpp.html#a40c16432fa9c16826c026b74351425ad">mapOfClauses</a>        theMatchingClauses;
<a name="l00963"></a>00963 
<a name="l00964"></a>00964     <span class="keywordflow">if</span> (this-&gt;<a class="code" href="class_o_t_scriptable.html#a298d8fdb0982df3c36e8ae194f228009">GetHooks</a>(str_HookName, theMatchingClauses))
<a name="l00965"></a>00965     {
<a name="l00966"></a>00966         <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(0, <span class="stringliteral">&quot;Cron: Processing smart contract clauses for hook: %s \n&quot;</span>, <a class="code" href="_o_t_smart_contract_8cpp.html#aa3eadb54e95be5d2dbb367f6c359c469">SMARTCONTRACT_HOOK_ON_ACTIVATE</a>);
<a name="l00967"></a>00967 
<a name="l00968"></a>00968         this-&gt;<a class="code" href="class_o_t_smart_contract.html#a83282de7074313974d0db0f50b3b6e09">ExecuteClauses</a>(theMatchingClauses); <span class="comment">// &lt;============================================</span>
<a name="l00969"></a>00969     }
<a name="l00970"></a>00970     <span class="comment">//</span>
<a name="l00971"></a>00971     <span class="comment">// *****************************************************************************</span>
<a name="l00972"></a>00972 }
<a name="l00973"></a>00973 
<a name="l00974"></a>00974 
<a name="l00975"></a>00975 <span class="comment">// Done:</span>
<a name="l00976"></a>00976 <span class="comment">//</span>
<a name="l00977"></a>00977 <span class="comment">//pScript-&gt;chai-&gt;add(fun(&amp;(OTSmartContract::GetAcctBalance),    (*this)), &quot;get_acct_balance&quot;);  // int64_t GetAcctBalance(const std::string acct_name);</span>
<a name="l00978"></a>00978 <span class="comment">//</span>
<a name="l00979"></a><a class="code" href="class_o_t_smart_contract.html#af6c9cbe669cea11256dc7fd2a6fdddf4">00979</a> std::string <a class="code" href="class_o_t_smart_contract.html#af6c9cbe669cea11256dc7fd2a6fdddf4">OTSmartContract::GetAcctBalance</a>(<span class="keyword">const</span> std::string from_acct_name)
<a name="l00980"></a>00980 {
<a name="l00981"></a>00981     <a class="code" href="class_o_t_cron.html">OTCron</a> * pCron  = <a class="code" href="class_o_t_cron_item.html#af734ad5d309fcc9b4a60d40d6c30f55a">GetCron</a>();
<a name="l00982"></a>00982     <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != pCron);
<a name="l00983"></a>00983     <span class="comment">// ----------------------------------</span>
<a name="l00984"></a>00984     <a class="code" href="class_o_t_pseudonym.html">OTPseudonym</a> * pServerNym = pCron-&gt;<a class="code" href="class_o_t_cron.html#a7756d0dcc047209ca87632939dc11db3">GetServerNym</a>();
<a name="l00985"></a>00985     <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != pServerNym);
<a name="l00986"></a>00986     <span class="comment">// ---------------------------------------------------</span>
<a name="l00987"></a>00987     <span class="comment">// Below this point, these are all good:</span>
<a name="l00988"></a>00988     <span class="comment">//</span>
<a name="l00989"></a>00989     <span class="comment">//      pServerNym, pCron.</span>
<a name="l00990"></a>00990     <span class="comment">//</span>
<a name="l00991"></a>00991     <span class="comment">// ---------------------------------------------------</span>
<a name="l00992"></a>00992 
<a name="l00993"></a>00993     <span class="keywordflow">if</span> (from_acct_name.size() &lt;= 0)
<a name="l00994"></a>00994     {
<a name="l00995"></a>00995         <a class="code" href="class_o_t_log.html#a5acd90ac91c2618f395b0ff37ad4f8ee">OTLog::Error</a>(<span class="stringliteral">&quot;OTSmartContract::GetAcctBalance: error: from_acct_name is non-existent.\n&quot;</span>);
<a name="l00996"></a>00996         <span class="keywordflow">return</span> 0;
<a name="l00997"></a>00997     }
<a name="l00998"></a>00998     <span class="comment">// ---------------------------------------------------</span>
<a name="l00999"></a>00999     <span class="comment">// Below this point, these are all good:</span>
<a name="l01000"></a>01000     <span class="comment">//</span>
<a name="l01001"></a>01001     <span class="comment">//      from_acct_name,</span>
<a name="l01002"></a>01002     <span class="comment">//      pServerNym, pCron.</span>
<a name="l01003"></a>01003     <span class="comment">//</span>
<a name="l01004"></a>01004     <span class="comment">// ---------------------------------------------------</span>
<a name="l01005"></a>01005 
<a name="l01006"></a>01006     <a class="code" href="class_o_t_party_account.html">OTPartyAccount</a>  * pFromAcct = this-&gt;<a class="code" href="class_o_t_scriptable.html#a94c9e55f78357e04e4b9781ab662370f">GetPartyAccount</a>(from_acct_name);
<a name="l01007"></a>01007 
<a name="l01008"></a>01008     <span class="keywordflow">if</span> (NULL == pFromAcct)
<a name="l01009"></a>01009     {
<a name="l01010"></a>01010         <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(0, <span class="stringliteral">&quot;OTSmartContract::GetAcctBalances: error: from_acct (%s) not found on any party.\n&quot;</span>,
<a name="l01011"></a>01011                        from_acct_name.c_str());
<a name="l01012"></a>01012         <span class="keywordflow">return</span> 0;
<a name="l01013"></a>01013     }
<a name="l01014"></a>01014     <span class="comment">// ---------------------------------------------------</span>
<a name="l01015"></a>01015     <span class="comment">//</span>
<a name="l01016"></a>01016     <span class="comment">// Below this point, these are all good:</span>
<a name="l01017"></a>01017     <span class="comment">//</span>
<a name="l01018"></a>01018     <span class="comment">//      pFromAcct,  from_acct_name,</span>
<a name="l01019"></a>01019     <span class="comment">//      pServerNym, pCron.</span>
<a name="l01020"></a>01020     <span class="comment">//</span>
<a name="l01021"></a>01021     <span class="comment">// ---------------------------------------------------</span>
<a name="l01022"></a>01022 
<a name="l01023"></a>01023     <a class="code" href="class_o_t_agent.html">OTAgent</a> * pFromAgent    = pFromAcct-&gt;   GetAuthorizedAgent(); <span class="comment">// This searches the account&#39;s party for the account&#39;s authorized agent.</span>
<a name="l01024"></a>01024     <span class="comment">// (That way it&#39;s impossible to get an agent for any other party.)</span>
<a name="l01025"></a>01025 
<a name="l01026"></a>01026     <span class="keywordflow">if</span> (NULL == pFromAgent)
<a name="l01027"></a>01027     {
<a name="l01028"></a>01028         <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(0, <span class="stringliteral">&quot;OTSmartContract::GetAcctBalance: error: authorized agent (%s) not found for from_acct (%s) on acct&#39;s party.\n&quot;</span>,
<a name="l01029"></a>01029                        pFromAcct-&gt;<a class="code" href="class_o_t_party_account.html#a86975046b18ac6d6c5841f5ba0befe69">GetAgentName</a>().<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>(), from_acct_name.c_str());
<a name="l01030"></a>01030         <span class="keywordflow">return</span> 0;
<a name="l01031"></a>01031     }
<a name="l01032"></a>01032     <span class="comment">// ---------</span>
<a name="l01033"></a>01033     <span class="keywordflow">if</span> (<span class="keyword">false</span> == pFromAgent-&gt;<a class="code" href="class_o_t_agent.html#a1969e4f8a5f13ee34ba0a68d8f082956">IsAnIndividual</a>())
<a name="l01034"></a>01034     {
<a name="l01035"></a>01035         <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(0, <span class="stringliteral">&quot;OTSmartContract::GetAcctBalance: error: authorized agent (%s) for from_acct (%s) is not an active agent.\n&quot;</span>,
<a name="l01036"></a>01036                        pFromAcct-&gt;<a class="code" href="class_o_t_party_account.html#a86975046b18ac6d6c5841f5ba0befe69">GetAgentName</a>().<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>(), from_acct_name.c_str());
<a name="l01037"></a>01037         <span class="keywordflow">return</span> 0;
<a name="l01038"></a>01038     }
<a name="l01039"></a>01039     <span class="comment">//</span>
<a name="l01040"></a>01040     <span class="comment">// Below this point, these are all good:</span>
<a name="l01041"></a>01041     <span class="comment">//</span>
<a name="l01042"></a>01042     <span class="comment">//      pFromAcct,  from_acct_name, pFromAgent,</span>
<a name="l01043"></a>01043     <span class="comment">//      pServerNym, pCron.</span>
<a name="l01044"></a>01044     <span class="comment">//</span>
<a name="l01045"></a>01045     <span class="comment">// ---------------------------------------------------</span>
<a name="l01046"></a>01046 
<a name="l01047"></a>01047     <a class="code" href="class_o_t_party.html">OTParty</a> * pFromParty    = pFromAgent-&gt;<a class="code" href="class_o_t_agent.html#a929a2489984f5487bd1819ed6d8862f2">GetParty</a>();
<a name="l01048"></a>01048 
<a name="l01049"></a>01049     <span class="keywordflow">if</span> (NULL == pFromParty)
<a name="l01050"></a>01050     {
<a name="l01051"></a>01051         <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;OTSmartContract::GetAcctBalance: error: Party pointer NULL on authorized agent (%s) for from_acct (%s).\n&quot;</span>,
<a name="l01052"></a>01052                       pFromAcct-&gt;<a class="code" href="class_o_t_party_account.html#a86975046b18ac6d6c5841f5ba0befe69">GetAgentName</a>().<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>(), from_acct_name.c_str());
<a name="l01053"></a>01053         <span class="keywordflow">return</span> 0;
<a name="l01054"></a>01054     }
<a name="l01055"></a>01055     <span class="comment">//</span>
<a name="l01056"></a>01056     <span class="comment">// Below this point, these are all good:</span>
<a name="l01057"></a>01057     <span class="comment">//</span>
<a name="l01058"></a>01058     <span class="comment">//      pFromAcct,  from_acct_name, pFromAgent, pFromParty,</span>
<a name="l01059"></a>01059     <span class="comment">//      pServerNym, pCron.</span>
<a name="l01060"></a>01060     <span class="comment">//</span>
<a name="l01061"></a>01061     <span class="comment">// ---------------------------------------------------</span>
<a name="l01062"></a>01062 
<a name="l01063"></a>01063 
<a name="l01064"></a>01064     <span class="comment">// Done: I can see that THIS VERIFICATION CODE WILL GET CALLED EVERY SINGLE TIME THE SCRIPT</span>
<a name="l01065"></a>01065     <span class="comment">// CALLS MOVE FUNDS.  Maybe that&#39;s good, but since technically this only needs to be verified before the</span>
<a name="l01066"></a>01066     <span class="comment">// first call, and not for EVERY call during any of a script&#39;s runs, I should probably move this verification</span>
<a name="l01067"></a>01067     <span class="comment">// higher, such as each time the OTCronItem triggers, plus each time a party triggers a clause directly</span>
<a name="l01068"></a>01068     <span class="comment">// through the API (server message). As long as those are covered, I will be able to remove it from here</span>
<a name="l01069"></a>01069     <span class="comment">// which should be a significant improvement for performance.</span>
<a name="l01070"></a>01070     <span class="comment">// It will be at the bottom of those same functions that &quot;ClearTemporaryPointers()&quot; should finally be called.</span>
<a name="l01071"></a>01071     <span class="comment">//</span>
<a name="l01072"></a>01072     <span class="comment">//</span>
<a name="l01073"></a>01073     <span class="comment">//  FINAL DECISION: Redundant, already verified upon activation on cron.</span>
<a name="l01074"></a>01074     <span class="comment">//  See longer comment in OTSmartContract::StashAcctFunds()</span>
<a name="l01075"></a>01075     <span class="comment">//</span>
<a name="l01076"></a>01076 <span class="comment">//  const OTString strServerID(GetServerID());</span>
<a name="l01077"></a>01077 <span class="comment">//</span>
<a name="l01078"></a>01078 <span class="comment">//  mapOfNyms   map_Nyms_Already_Loaded;</span>
<a name="l01079"></a>01079 <span class="comment">//  this-&gt;RetrieveNymPointers(map_Nyms_Already_Loaded);</span>
<a name="l01080"></a>01080 <span class="comment">//  // --------------------------------------------------</span>
<a name="l01081"></a>01081 <span class="comment">//</span>
<a name="l01082"></a>01082 <span class="comment">//  if (false == this-&gt;VerifyPartyAuthorization(*pFromParty, *pServerNym, strServerID, &amp;map_Nyms_Already_Loaded))</span>
<a name="l01083"></a>01083 <span class="comment">//  {</span>
<a name="l01084"></a>01084 <span class="comment">//      OTLog::vError(&quot;OTSmartContract::GetAcctBalance: error: &#39;From&#39; Party (%s) not authorized for this contract.\n&quot;,</span>
<a name="l01085"></a>01085 <span class="comment">//                    pFromParty-&gt;GetPartyName().c_str());</span>
<a name="l01086"></a>01086 <span class="comment">//      return 0;</span>
<a name="l01087"></a>01087 <span class="comment">//  }</span>
<a name="l01088"></a>01088     <span class="comment">// *****************************************************************************</span>
<a name="l01089"></a>01089 
<a name="l01090"></a>01090     <span class="comment">// A party might have many agents who are only voting groups, and cannot actually sign for things</span>
<a name="l01091"></a>01091     <span class="comment">// the way that nyms can. But at least ONE of those agents IS a Nym -- because there must have been</span>
<a name="l01092"></a>01092     <span class="comment">// an authorizing agent who initially signed to accept the agreement, and who fronted the opening</span>
<a name="l01093"></a>01093     <span class="comment">// transaction number that activated it.</span>
<a name="l01094"></a>01094     <span class="comment">//</span>
<a name="l01095"></a>01095     <span class="comment">// Similarly, the authorized agent for any given party&#39;s account (each account has its own authorized</span>
<a name="l01096"></a>01096     <span class="comment">// agent) MUST be an active agent (an active agent is one with a Nym--whether that Nym is representing</span>
<a name="l01097"></a>01097     <span class="comment">// himself as the party, or whether representing some entity as an employee in a role). Why MUST the</span>
<a name="l01098"></a>01098     <span class="comment">// authorized agent be an active agent? Because when funds are moved, that Nym must be loaded since</span>
<a name="l01099"></a>01099     <span class="comment">// the account must show that Nym as a legal owner/agent. The MoveFunds will cause a paymentReceipt to</span>
<a name="l01100"></a>01100     <span class="comment">// drop into the Inbox for the relevant asset accounts, and that paymentReceipt can ONLY be accepted</span>
<a name="l01101"></a>01101     <span class="comment">// by that same Nym, who must use a transaction # that he signed for previously and received through</span>
<a name="l01102"></a>01102     <span class="comment">// his nymbox. There is actually no justification at all to take funds from that account, since the</span>
<a name="l01103"></a>01103     <span class="comment">// new balance has not yet been signed, UNLESS THE PAYMENTRECEIPT CONTAINS A VALID, SIGNED AUTHORIZATION</span>
<a name="l01104"></a>01104     <span class="comment">// FROM THE ACCOUNT HOLDER. *That* is why the authorizing agent must either be the Party&#39;s Owner himself</span>
<a name="l01105"></a>01105     <span class="comment">// (representing himself as an agent, which most will do) in which case he will appear as the valid</span>
<a name="l01106"></a>01106     <span class="comment">// owner of the account, OR he MUST be a Nym working in a Valid Role for an Entity, where said Entity is</span>
<a name="l01107"></a>01107     <span class="comment">// the valid owner on the account in question. Either OT, it will be possible in OT for him to sign for</span>
<a name="l01108"></a>01108     <span class="comment">// the paymentReceipts when they come in, and impossible for him to escape liability for them.</span>
<a name="l01109"></a>01109     <span class="comment">// (That&#39;s the idea anyway.)</span>
<a name="l01110"></a>01110     <span class="comment">//</span>
<a name="l01111"></a>01111     <span class="comment">// Since we know that the Authorized Agent for an account must be an ACTIVE agent (one way or the other)</span>
<a name="l01112"></a>01112     <span class="comment">// then we can error out here if he&#39;s not.  We can then pass in his Nym ID.</span>
<a name="l01113"></a>01113     <span class="comment">//</span>
<a name="l01114"></a>01114 
<a name="l01115"></a>01115     <a class="code" href="class_o_t_identifier.html">OTIdentifier</a> theFromAgentID;
<a name="l01116"></a>01116     <span class="keyword">const</span> <span class="keywordtype">bool</span> bFromAgentID = pFromAgent-&gt;<a class="code" href="class_o_t_agent.html#a7750c7f5840047c5413d95e92ad87578">GetSignerID</a>(theFromAgentID);
<a name="l01117"></a>01117 
<a name="l01118"></a>01118     <span class="keywordflow">if</span> ( ! bFromAgentID )
<a name="l01119"></a>01119     {
<a name="l01120"></a>01120         <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;OTSmartContract::GetAcctBalance: Failed to find FromAgent&#39;s Signer ID: %s \n&quot;</span>,
<a name="l01121"></a>01121                       pFromAgent-&gt;<a class="code" href="class_o_t_agent.html#a123d27f05e46977ecdbe0b83de3c119d">GetName</a>().<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>());
<a name="l01122"></a>01122         <span class="keywordflow">return</span> 0;
<a name="l01123"></a>01123     }
<a name="l01124"></a>01124     <span class="comment">// --------------------------------------</span>
<a name="l01125"></a>01125 
<a name="l01126"></a>01126     <span class="keywordflow">if</span> (!pFromAcct-&gt;<a class="code" href="class_o_t_party_account.html#aa5e4e0cc77853d08b3708017fe694876">GetAcctID</a>().<a class="code" href="class_o_t_string.html#adf7489cd917d4ae5bf30853a3ad78daf">Exists</a>())
<a name="l01127"></a>01127     {
<a name="l01128"></a>01128         <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;OTSmartContract::GetAcctBalance: Error: FromAcct has empty AcctID: %s \n&quot;</span>,
<a name="l01129"></a>01129                       from_acct_name.c_str());
<a name="l01130"></a>01130         <span class="keywordflow">return</span> 0;
<a name="l01131"></a>01131     }
<a name="l01132"></a>01132 
<a name="l01133"></a>01133     <span class="keyword">const</span> <a class="code" href="class_o_t_identifier.html">OTIdentifier</a> theFromAcctID(pFromAcct-&gt;<a class="code" href="class_o_t_party_account.html#aa5e4e0cc77853d08b3708017fe694876">GetAcctID</a>());
<a name="l01134"></a>01134     <span class="comment">//</span>
<a name="l01135"></a>01135     <span class="comment">// BELOW THIS POINT, theFromAcctID and theFromAgentID available.</span>
<a name="l01136"></a>01136     <span class="comment">// --------------------------------------</span>
<a name="l01137"></a>01137 
<a name="l01138"></a>01138     <span class="keyword">const</span> <a class="code" href="class_o_t_identifier.html">OTIdentifier</a>  SERVER_ID(pCron-&gt;<a class="code" href="class_o_t_cron.html#a93b52f56c0de94e53bb05a610830ba4b">GetServerID</a>());
<a name="l01139"></a>01139     <span class="keyword">const</span> <a class="code" href="class_o_t_identifier.html">OTIdentifier</a>  SERVER_USER_ID(*pServerNym);
<a name="l01140"></a>01140 
<a name="l01141"></a>01141     <span class="keyword">const</span> std::string   str_party_id = pFromParty-&gt;<a class="code" href="class_o_t_party.html#a4aa12384e93bd6c2f6d437cf8ca97dfa">GetPartyID</a>();
<a name="l01142"></a>01142     <span class="keyword">const</span> <a class="code" href="class_o_t_string.html">OTString</a>      strPartyID(str_party_id);
<a name="l01143"></a>01143     <span class="keyword">const</span> <a class="code" href="class_o_t_identifier.html">OTIdentifier</a>  PARTY_USER_ID(strPartyID);
<a name="l01144"></a>01144 
<a name="l01145"></a>01145     <span class="keyword">const</span> <a class="code" href="class_o_t_identifier.html">OTIdentifier</a> PARTY_ACCT_ID(pFromAcct-&gt;<a class="code" href="class_o_t_party_account.html#aa5e4e0cc77853d08b3708017fe694876">GetAcctID</a>());
<a name="l01146"></a>01146 
<a name="l01147"></a>01147     <span class="comment">// --------------------------------------------------------</span>
<a name="l01148"></a>01148     <span class="comment">// Load up the party&#39;s account so we can get the balance.</span>
<a name="l01149"></a>01149     <span class="comment">//</span>
<a name="l01150"></a>01150     <a class="code" href="class_o_t_account.html">OTAccount</a> * pPartyAssetAcct = <a class="code" href="class_o_t_account.html#a6574057f6e3415546d3a9f7d7e445e4f">OTAccount::LoadExistingAccount</a>(PARTY_ACCT_ID, SERVER_ID);
<a name="l01151"></a>01151 
<a name="l01152"></a>01152     <span class="keywordflow">if</span> (NULL == pPartyAssetAcct)
<a name="l01153"></a>01153     {
<a name="l01154"></a>01154         <a class="code" href="class_o_t_log.html#a1f7549d776ee919dcb6517f611ded015">OTLog::Output</a>(0, <span class="stringliteral">&quot;OTSmartContract::GetAcctBalance: ERROR verifying existence of source account.\n&quot;</span>);
<a name="l01155"></a>01155         <a class="code" href="class_o_t_cron_item.html#a34c87380d2f8cd419c9a5cfec86427b4">FlagForRemoval</a>(); <span class="comment">// Remove it from future Cron processing, please.</span>
<a name="l01156"></a>01156         <span class="keywordflow">return</span> 0;
<a name="l01157"></a>01157     }
<a name="l01158"></a>01158     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!pPartyAssetAcct-&gt;VerifySignature(*pServerNym))
<a name="l01159"></a>01159     {
<a name="l01160"></a>01160         <a class="code" href="class_o_t_log.html#a1f7549d776ee919dcb6517f611ded015">OTLog::Output</a>(0, <span class="stringliteral">&quot;OTSmartContract::GetAcctBalance: ERROR failed to verify the server&#39;s signature on the party&#39;s account.\n&quot;</span>);
<a name="l01161"></a>01161         <a class="code" href="class_o_t_cron_item.html#a34c87380d2f8cd419c9a5cfec86427b4">FlagForRemoval</a>(); <span class="comment">// Remove it from future Cron processing, please.</span>
<a name="l01162"></a>01162         <span class="keywordflow">return</span> 0;
<a name="l01163"></a>01163     }
<a name="l01164"></a>01164     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!pPartyAssetAcct-&gt;VerifyOwnerByID(PARTY_USER_ID))
<a name="l01165"></a>01165     {
<a name="l01166"></a>01166         <a class="code" href="class_o_t_log.html#a1f7549d776ee919dcb6517f611ded015">OTLog::Output</a>(0, <span class="stringliteral">&quot;OTSmartContract::GetAcctBalance: ERROR failed to verify party user ownership of party account.\n&quot;</span>);
<a name="l01167"></a>01167         <a class="code" href="class_o_t_cron_item.html#a34c87380d2f8cd419c9a5cfec86427b4">FlagForRemoval</a>(); <span class="comment">// Remove it from future Cron processing, please.</span>
<a name="l01168"></a>01168         <span class="keywordflow">return</span> 0;
<a name="l01169"></a>01169     }
<a name="l01170"></a>01170     <span class="comment">// Past this point we know pPartyAssetAcct is good and will clean itself up.</span>
<a name="l01171"></a>01171     <a class="code" href="class_o_t_cleanup.html">OTCleanup&lt;OTAccount&gt;</a>    theSourceAcctSmrtPtr(*pPartyAssetAcct);
<a name="l01172"></a>01172     <span class="comment">// -----------------------------------------------------------------</span>
<a name="l01173"></a>01173 
<a name="l01174"></a>01174     <a class="code" href="class_o_t_string.html">OTString</a> strBalance;
<a name="l01175"></a>01175     strBalance.<a class="code" href="class_o_t_string.html#af1c861f21033a1d583b3cb12f952422e">Format</a>(<span class="stringliteral">&quot;%lld&quot;</span>, pPartyAssetAcct-&gt;GetBalance());
<a name="l01176"></a>01176 
<a name="l01177"></a>01177     <span class="keywordflow">return</span> strBalance.<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>();
<a name="l01178"></a>01178 }
<a name="l01179"></a>01179 
<a name="l01180"></a>01180 
<a name="l01181"></a><a class="code" href="class_o_t_smart_contract.html#aef2b64b4870a325f36df1e634f744ce9">01181</a> std::string <a class="code" href="class_o_t_smart_contract.html#aef2b64b4870a325f36df1e634f744ce9">OTSmartContract::GetAssetTypeIDofAcct</a>(<span class="keyword">const</span> std::string from_acct_name)
<a name="l01182"></a>01182 {
<a name="l01183"></a>01183     <a class="code" href="class_o_t_cron.html">OTCron</a> * pCron  = <a class="code" href="class_o_t_cron_item.html#af734ad5d309fcc9b4a60d40d6c30f55a">GetCron</a>();
<a name="l01184"></a>01184     <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != pCron);
<a name="l01185"></a>01185     <span class="comment">// ----------------------------------</span>
<a name="l01186"></a>01186     <a class="code" href="class_o_t_pseudonym.html">OTPseudonym</a> * pServerNym = pCron-&gt;<a class="code" href="class_o_t_cron.html#a7756d0dcc047209ca87632939dc11db3">GetServerNym</a>();
<a name="l01187"></a>01187     <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != pServerNym);
<a name="l01188"></a>01188     <span class="comment">// ---------------------------------------------------</span>
<a name="l01189"></a>01189     <span class="comment">// Below this point, these are all good:</span>
<a name="l01190"></a>01190     <span class="comment">//</span>
<a name="l01191"></a>01191     <span class="comment">//      pServerNym, pCron.</span>
<a name="l01192"></a>01192     <span class="comment">//</span>
<a name="l01193"></a>01193     <span class="comment">// ---------------------------------------------------</span>
<a name="l01194"></a>01194 
<a name="l01195"></a>01195     std::string str_return_value;
<a name="l01196"></a>01196 
<a name="l01197"></a>01197     <span class="comment">// ---------------------------------------------------</span>
<a name="l01198"></a>01198     <span class="keywordflow">if</span> (from_acct_name.size() &lt;= 0)
<a name="l01199"></a>01199     {
<a name="l01200"></a>01200         <a class="code" href="class_o_t_log.html#a5acd90ac91c2618f395b0ff37ad4f8ee">OTLog::Error</a>(<span class="stringliteral">&quot;OTSmartContract::GetAssetTypeIDofAcct: error: from_acct_name is non-existent.\n&quot;</span>);
<a name="l01201"></a>01201         <span class="keywordflow">return</span> str_return_value;
<a name="l01202"></a>01202     }
<a name="l01203"></a>01203     <span class="comment">// ---------------------------------------------------</span>
<a name="l01204"></a>01204     <span class="comment">// Below this point, these are all good:</span>
<a name="l01205"></a>01205     <span class="comment">//</span>
<a name="l01206"></a>01206     <span class="comment">//      from_acct_name,</span>
<a name="l01207"></a>01207     <span class="comment">//      pServerNym, pCron.</span>
<a name="l01208"></a>01208     <span class="comment">//</span>
<a name="l01209"></a>01209     <span class="comment">// ---------------------------------------------------</span>
<a name="l01210"></a>01210 
<a name="l01211"></a>01211     <a class="code" href="class_o_t_party_account.html">OTPartyAccount</a>  * pFromAcct = this-&gt;<a class="code" href="class_o_t_scriptable.html#a94c9e55f78357e04e4b9781ab662370f">GetPartyAccount</a>(from_acct_name);
<a name="l01212"></a>01212 
<a name="l01213"></a>01213     <span class="keywordflow">if</span> (NULL == pFromAcct)
<a name="l01214"></a>01214     {
<a name="l01215"></a>01215         <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(0, <span class="stringliteral">&quot;OTSmartContract::GetAssetTypeIDofAcct: error: from_acct (%s) not found on any party.\n&quot;</span>,
<a name="l01216"></a>01216                        from_acct_name.c_str());
<a name="l01217"></a>01217         <span class="keywordflow">return</span> str_return_value;
<a name="l01218"></a>01218     }
<a name="l01219"></a>01219     <span class="comment">// ---------------------------------------------------</span>
<a name="l01220"></a>01220     <span class="comment">//</span>
<a name="l01221"></a>01221     <span class="comment">// Below this point, these are all good:</span>
<a name="l01222"></a>01222     <span class="comment">//</span>
<a name="l01223"></a>01223     <span class="comment">//      pFromAcct,  from_acct_name,</span>
<a name="l01224"></a>01224     <span class="comment">//      pServerNym, pCron.</span>
<a name="l01225"></a>01225     <span class="comment">//</span>
<a name="l01226"></a>01226     <span class="comment">// ---------------------------------------------------</span>
<a name="l01227"></a>01227 
<a name="l01228"></a>01228     <a class="code" href="class_o_t_agent.html">OTAgent</a> * pFromAgent = pFromAcct-&gt;<a class="code" href="class_o_t_party_account.html#ad8c523b08a478e4071bb2b3ca85749b1">GetAuthorizedAgent</a>(); <span class="comment">// This searches the account&#39;s party for the account&#39;s authorized agent.</span>
<a name="l01229"></a>01229     <span class="comment">// (That way it&#39;s impossible to get an agent for any other party.)</span>
<a name="l01230"></a>01230 
<a name="l01231"></a>01231     <span class="keywordflow">if</span> (NULL == pFromAgent)
<a name="l01232"></a>01232     {
<a name="l01233"></a>01233         <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(0, <span class="stringliteral">&quot;OTSmartContract::GetAssetTypeIDofAcct: error: authorized agent (%s) not found for from_acct (%s) on acct&#39;s party.\n&quot;</span>,
<a name="l01234"></a>01234                        pFromAcct-&gt;<a class="code" href="class_o_t_party_account.html#a86975046b18ac6d6c5841f5ba0befe69">GetAgentName</a>().<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>(), from_acct_name.c_str());
<a name="l01235"></a>01235         <span class="keywordflow">return</span> str_return_value;
<a name="l01236"></a>01236     }
<a name="l01237"></a>01237     <span class="comment">// ---------</span>
<a name="l01238"></a>01238     <span class="keywordflow">if</span> (<span class="keyword">false</span> == pFromAgent-&gt;<a class="code" href="class_o_t_agent.html#a1969e4f8a5f13ee34ba0a68d8f082956">IsAnIndividual</a>())
<a name="l01239"></a>01239     {
<a name="l01240"></a>01240         <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(0, <span class="stringliteral">&quot;OTSmartContract::GetAssetTypeIDofAcct: error: authorized agent (%s) for from_acct (%s) is not an active agent.\n&quot;</span>,
<a name="l01241"></a>01241                        pFromAcct-&gt;<a class="code" href="class_o_t_party_account.html#a86975046b18ac6d6c5841f5ba0befe69">GetAgentName</a>().<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>(), from_acct_name.c_str());
<a name="l01242"></a>01242         <span class="keywordflow">return</span> str_return_value;
<a name="l01243"></a>01243     }
<a name="l01244"></a>01244     <span class="comment">//</span>
<a name="l01245"></a>01245     <span class="comment">// Below this point, these are all good:</span>
<a name="l01246"></a>01246     <span class="comment">//</span>
<a name="l01247"></a>01247     <span class="comment">//      pFromAcct,  from_acct_name, pFromAgent,</span>
<a name="l01248"></a>01248     <span class="comment">//      pServerNym, pCron.</span>
<a name="l01249"></a>01249     <span class="comment">//</span>
<a name="l01250"></a>01250     <span class="comment">// ---------------------------------------------------</span>
<a name="l01251"></a>01251 
<a name="l01252"></a>01252     <a class="code" href="class_o_t_party.html">OTParty</a> * pFromParty    = pFromAgent-&gt;<a class="code" href="class_o_t_agent.html#a929a2489984f5487bd1819ed6d8862f2">GetParty</a>();
<a name="l01253"></a>01253 
<a name="l01254"></a>01254     <span class="keywordflow">if</span> (NULL == pFromParty)
<a name="l01255"></a>01255     {
<a name="l01256"></a>01256         <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;OTSmartContract::GetAssetTypeIDofAcct: error: Party pointer NULL on authorized agent (%s) for from_acct (%s).\n&quot;</span>,
<a name="l01257"></a>01257                       pFromAcct-&gt;<a class="code" href="class_o_t_party_account.html#a86975046b18ac6d6c5841f5ba0befe69">GetAgentName</a>().<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>(), from_acct_name.c_str());
<a name="l01258"></a>01258         <span class="keywordflow">return</span> str_return_value;
<a name="l01259"></a>01259     }
<a name="l01260"></a>01260     <span class="comment">//</span>
<a name="l01261"></a>01261     <span class="comment">// Below this point, these are all good:</span>
<a name="l01262"></a>01262     <span class="comment">//</span>
<a name="l01263"></a>01263     <span class="comment">//      pFromAcct,  from_acct_name, pFromAgent, pFromParty,</span>
<a name="l01264"></a>01264     <span class="comment">//      pServerNym, pCron.</span>
<a name="l01265"></a>01265     <span class="comment">//</span>
<a name="l01266"></a>01266     <span class="comment">// ---------------------------------------------------</span>
<a name="l01267"></a>01267 
<a name="l01268"></a>01268 
<a name="l01269"></a>01269     <span class="comment">// Done: I can see that THIS VERIFICATION CODE WILL GET CALLED EVERY SINGLE TIME THE SCRIPT</span>
<a name="l01270"></a>01270     <span class="comment">// CALLS MOVE FUNDS.  Maybe that&#39;s good, but since technically this only needs to be verified before the</span>
<a name="l01271"></a>01271     <span class="comment">// first call, and not for EVERY call during any of a script&#39;s runs, I should probably move this verification</span>
<a name="l01272"></a>01272     <span class="comment">// higher, such as each time the OTCronItem triggers, plus each time a party triggers a clause directly</span>
<a name="l01273"></a>01273     <span class="comment">// through the API (server message). As long as those are covered, I will be able to remove it from here</span>
<a name="l01274"></a>01274     <span class="comment">// which should be a significant improvement for performance.</span>
<a name="l01275"></a>01275     <span class="comment">// It will be at the bottom of those same functions that &quot;ClearTemporaryPointers()&quot; should finally be called.</span>
<a name="l01276"></a>01276     <span class="comment">//</span>
<a name="l01277"></a>01277     <span class="comment">//</span>
<a name="l01278"></a>01278     <span class="comment">// FINAL DECISION: Redunant, already done upon activation onto cron. Furthermore, expects no stashes to exist,</span>
<a name="l01279"></a>01279     <span class="comment">// since they can only be created after activation. (Interfered with script operations by complaining whenever</span>
<a name="l01280"></a>01280     <span class="comment">// there was a stash.) See longer comment in StashAcctFunds().</span>
<a name="l01281"></a>01281     <span class="comment">//</span>
<a name="l01282"></a>01282 <span class="comment">//  const OTString strServerID(GetServerID());</span>
<a name="l01283"></a>01283 <span class="comment">//</span>
<a name="l01284"></a>01284 <span class="comment">//  mapOfNyms   map_Nyms_Already_Loaded;</span>
<a name="l01285"></a>01285 <span class="comment">//  this-&gt;RetrieveNymPointers(map_Nyms_Already_Loaded);</span>
<a name="l01286"></a>01286 <span class="comment">//  // --------------------------------------------------</span>
<a name="l01287"></a>01287 <span class="comment">//</span>
<a name="l01288"></a>01288 <span class="comment">//  if (false == this-&gt;VerifyPartyAuthorization(*pFromParty, *pServerNym, strServerID, &amp;map_Nyms_Already_Loaded))</span>
<a name="l01289"></a>01289 <span class="comment">//  {</span>
<a name="l01290"></a>01290 <span class="comment">//      OTLog::vError(&quot;OTSmartContract::GetAssetTypeIDofAcct: error: &#39;From&#39; Party (%s) not authorized for this contract.\n&quot;,</span>
<a name="l01291"></a>01291 <span class="comment">//                    pFromParty-&gt;GetPartyName().c_str());</span>
<a name="l01292"></a>01292 <span class="comment">//      return str_return_value;</span>
<a name="l01293"></a>01293 <span class="comment">//  }</span>
<a name="l01294"></a>01294     <span class="comment">// *****************************************************************************</span>
<a name="l01295"></a>01295 
<a name="l01296"></a>01296     <span class="comment">// A party might have many agents who are only voting groups, and cannot actually sign for things</span>
<a name="l01297"></a>01297     <span class="comment">// the way that nyms can. But at least ONE of those agents IS a Nym -- because there must have been</span>
<a name="l01298"></a>01298     <span class="comment">// an authorizing agent who initially signed to accept the agreement, and who fronted the opening</span>
<a name="l01299"></a>01299     <span class="comment">// transaction number that activated it.</span>
<a name="l01300"></a>01300     <span class="comment">//</span>
<a name="l01301"></a>01301     <span class="comment">// Similarly, the authorized agent for any given party&#39;s account (each account has its own authorized</span>
<a name="l01302"></a>01302     <span class="comment">// agent) MUST be an active agent (an active agent is one with a Nym--whether that Nym is representing</span>
<a name="l01303"></a>01303     <span class="comment">// himself as the party, or whether representing some entity as an employee in a role). Why MUST the</span>
<a name="l01304"></a>01304     <span class="comment">// authorized agent be an active agent? Because when funds are moved, that Nym must be loaded since</span>
<a name="l01305"></a>01305     <span class="comment">// the account must show that Nym as a legal owner/agent. The MoveFunds will cause a paymentReceipt to</span>
<a name="l01306"></a>01306     <span class="comment">// drop into the Inbox for the relevant asset accounts, and that paymentReceipt can ONLY be accepted</span>
<a name="l01307"></a>01307     <span class="comment">// by that same Nym, who must use a transaction # that he signed for previously and received through</span>
<a name="l01308"></a>01308     <span class="comment">// his nymbox. There is actually no justification at all to take funds from that account, since the</span>
<a name="l01309"></a>01309     <span class="comment">// new balance has not yet been signed, UNLESS THE PAYMENTRECEIPT CONTAINS A VALID, SIGNED AUTHORIZATION</span>
<a name="l01310"></a>01310     <span class="comment">// FROM THE ACCOUNT HOLDER. *That* is why the authorizing agent must either be the Party&#39;s Owner himself</span>
<a name="l01311"></a>01311     <span class="comment">// (representing himself as an agent, which most will do) in which case he will appear as the valid</span>
<a name="l01312"></a>01312     <span class="comment">// owner of the account, OR he MUST be a Nym working in a Valid Role for an Entity, where said Entity is</span>
<a name="l01313"></a>01313     <span class="comment">// the valid owner on the account in question. Either OT, it will be possible in OT for him to sign for</span>
<a name="l01314"></a>01314     <span class="comment">// the paymentReceipts when they come in, and impossible for him to escape liability for them.</span>
<a name="l01315"></a>01315     <span class="comment">// (That&#39;s the idea anyway.)</span>
<a name="l01316"></a>01316     <span class="comment">//</span>
<a name="l01317"></a>01317     <span class="comment">// Since we know that the Authorized Agent for an account must be an ACTIVE agent (one way or the other)</span>
<a name="l01318"></a>01318     <span class="comment">// then we can error out here if he&#39;s not.  We can then pass in his Nym ID.</span>
<a name="l01319"></a>01319     <span class="comment">//</span>
<a name="l01320"></a>01320 
<a name="l01321"></a>01321     <a class="code" href="class_o_t_identifier.html">OTIdentifier</a> theFromAgentID;
<a name="l01322"></a>01322     <span class="keyword">const</span> <span class="keywordtype">bool</span> bFromAgentID = pFromAgent-&gt;<a class="code" href="class_o_t_agent.html#a7750c7f5840047c5413d95e92ad87578">GetSignerID</a>(theFromAgentID);
<a name="l01323"></a>01323 
<a name="l01324"></a>01324     <span class="keywordflow">if</span> ( ! bFromAgentID )
<a name="l01325"></a>01325     {
<a name="l01326"></a>01326         <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;OTSmartContract::GetAssetTypeIDofAcct: Failed to find FromAgent&#39;s Signer ID: %s \n&quot;</span>,
<a name="l01327"></a>01327                       pFromAgent-&gt;<a class="code" href="class_o_t_agent.html#a123d27f05e46977ecdbe0b83de3c119d">GetName</a>().<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>());
<a name="l01328"></a>01328         <span class="keywordflow">return</span> str_return_value;
<a name="l01329"></a>01329     }
<a name="l01330"></a>01330     <span class="comment">// --------------------------------------</span>
<a name="l01331"></a>01331 
<a name="l01332"></a>01332     <span class="keywordflow">if</span> (!pFromAcct-&gt;<a class="code" href="class_o_t_party_account.html#aa5e4e0cc77853d08b3708017fe694876">GetAcctID</a>().<a class="code" href="class_o_t_string.html#adf7489cd917d4ae5bf30853a3ad78daf">Exists</a>())
<a name="l01333"></a>01333     {
<a name="l01334"></a>01334         <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;OTSmartContract::GetAssetTypeIDofAcct: Error: FromAcct has empty AcctID: %s \n&quot;</span>,
<a name="l01335"></a>01335                       from_acct_name.c_str());
<a name="l01336"></a>01336         <span class="keywordflow">return</span> str_return_value;
<a name="l01337"></a>01337     }
<a name="l01338"></a>01338 
<a name="l01339"></a>01339     <span class="keyword">const</span> <a class="code" href="class_o_t_identifier.html">OTIdentifier</a> theFromAcctID(pFromAcct-&gt;<a class="code" href="class_o_t_party_account.html#aa5e4e0cc77853d08b3708017fe694876">GetAcctID</a>());
<a name="l01340"></a>01340     <span class="comment">//</span>
<a name="l01341"></a>01341     <span class="comment">// BELOW THIS POINT, theFromAcctID and theFromAgentID available.</span>
<a name="l01342"></a>01342     <span class="comment">// --------------------------------------</span>
<a name="l01343"></a>01343 
<a name="l01344"></a>01344     <span class="keyword">const</span> <a class="code" href="class_o_t_identifier.html">OTIdentifier</a>  SERVER_ID(pCron-&gt;<a class="code" href="class_o_t_cron.html#a93b52f56c0de94e53bb05a610830ba4b">GetServerID</a>());
<a name="l01345"></a>01345     <span class="keyword">const</span> <a class="code" href="class_o_t_identifier.html">OTIdentifier</a>  SERVER_USER_ID(*pServerNym);
<a name="l01346"></a>01346 
<a name="l01347"></a>01347     <span class="keyword">const</span> std::string   str_party_id = pFromParty-&gt;<a class="code" href="class_o_t_party.html#a4aa12384e93bd6c2f6d437cf8ca97dfa">GetPartyID</a>();
<a name="l01348"></a>01348     <span class="keyword">const</span> <a class="code" href="class_o_t_string.html">OTString</a>      strPartyID(str_party_id);
<a name="l01349"></a>01349     <span class="keyword">const</span> <a class="code" href="class_o_t_identifier.html">OTIdentifier</a>  PARTY_USER_ID(strPartyID);
<a name="l01350"></a>01350 
<a name="l01351"></a>01351     <span class="keyword">const</span> <a class="code" href="class_o_t_identifier.html">OTIdentifier</a> PARTY_ACCT_ID(pFromAcct-&gt;<a class="code" href="class_o_t_party_account.html#aa5e4e0cc77853d08b3708017fe694876">GetAcctID</a>());
<a name="l01352"></a>01352 
<a name="l01353"></a>01353     <span class="comment">// --------------------------------------------------------</span>
<a name="l01354"></a>01354     <span class="comment">// Load up the party&#39;s account and get the asset type.</span>
<a name="l01355"></a>01355     <span class="comment">//</span>
<a name="l01356"></a>01356     <a class="code" href="class_o_t_account.html">OTAccount</a> * pPartyAssetAcct = <a class="code" href="class_o_t_account.html#a6574057f6e3415546d3a9f7d7e445e4f">OTAccount::LoadExistingAccount</a>(PARTY_ACCT_ID, SERVER_ID);
<a name="l01357"></a>01357 
<a name="l01358"></a>01358     <span class="keywordflow">if</span> (NULL == pPartyAssetAcct)
<a name="l01359"></a>01359     {
<a name="l01360"></a>01360         <a class="code" href="class_o_t_log.html#a1f7549d776ee919dcb6517f611ded015">OTLog::Output</a>(0, <span class="stringliteral">&quot;OTSmartContract::GetAssetTypeIDofAcct: ERROR verifying existence of source account.\n&quot;</span>);
<a name="l01361"></a>01361         <a class="code" href="class_o_t_cron_item.html#a34c87380d2f8cd419c9a5cfec86427b4">FlagForRemoval</a>(); <span class="comment">// Remove it from future Cron processing, please.</span>
<a name="l01362"></a>01362         <span class="keywordflow">return</span> str_return_value;
<a name="l01363"></a>01363     }
<a name="l01364"></a>01364     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!pPartyAssetAcct-&gt;VerifySignature(*pServerNym))
<a name="l01365"></a>01365     {
<a name="l01366"></a>01366         <a class="code" href="class_o_t_log.html#a1f7549d776ee919dcb6517f611ded015">OTLog::Output</a>(0, <span class="stringliteral">&quot;OTSmartContract::GetAssetTypeIDofAcct: ERROR failed to verify the server&#39;s signature on the party&#39;s account.\n&quot;</span>);
<a name="l01367"></a>01367         <a class="code" href="class_o_t_cron_item.html#a34c87380d2f8cd419c9a5cfec86427b4">FlagForRemoval</a>(); <span class="comment">// Remove it from future Cron processing, please.</span>
<a name="l01368"></a>01368         <span class="keywordflow">return</span> str_return_value;
<a name="l01369"></a>01369     }
<a name="l01370"></a>01370     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!pPartyAssetAcct-&gt;VerifyOwnerByID(PARTY_USER_ID))
<a name="l01371"></a>01371     {
<a name="l01372"></a>01372         <a class="code" href="class_o_t_log.html#a1f7549d776ee919dcb6517f611ded015">OTLog::Output</a>(0, <span class="stringliteral">&quot;OTSmartContract::GetAssetTypeIDofAcct: ERROR failed to verify party user ownership of party account.\n&quot;</span>);
<a name="l01373"></a>01373         <a class="code" href="class_o_t_cron_item.html#a34c87380d2f8cd419c9a5cfec86427b4">FlagForRemoval</a>(); <span class="comment">// Remove it from future Cron processing, please.</span>
<a name="l01374"></a>01374         <span class="keywordflow">return</span> str_return_value;
<a name="l01375"></a>01375     }
<a name="l01376"></a>01376     <span class="comment">// Past this point we know pPartyAssetAcct is good and will clean itself up.</span>
<a name="l01377"></a>01377     <a class="code" href="class_o_t_cleanup.html">OTCleanup&lt;OTAccount&gt;</a>    theSourceAcctSmrtPtr(*pPartyAssetAcct);
<a name="l01378"></a>01378     <span class="comment">// -----------------------------------------------------------------</span>
<a name="l01379"></a>01379 
<a name="l01380"></a>01380     <span class="keyword">const</span> <a class="code" href="class_o_t_string.html">OTString</a> strAssetTypeID(pPartyAssetAcct-&gt;GetAssetTypeID());
<a name="l01381"></a>01381     str_return_value = strAssetTypeID.<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>();
<a name="l01382"></a>01382 
<a name="l01383"></a>01383     <span class="keywordflow">return</span> str_return_value;
<a name="l01384"></a>01384 }
<a name="l01385"></a>01385 
<a name="l01386"></a>01386 
<a name="l01387"></a>01387 <span class="comment">// done</span>
<a name="l01388"></a>01388 <span class="comment">//</span>
<a name="l01389"></a>01389 <span class="comment">//pScript-&gt;chai-&gt;add(fun(&amp;(OTSmartContract::GetStashBalance),   (*this)), &quot;get_stash_balance&quot;); // int64_t GetStashBalance(const std::string stash_name);</span>
<a name="l01390"></a>01390 <span class="comment">//</span>
<a name="l01391"></a><a class="code" href="class_o_t_smart_contract.html#a2a92d021daf88edba58aabba629d90e5">01391</a> std::string <a class="code" href="class_o_t_smart_contract.html#a2a92d021daf88edba58aabba629d90e5">OTSmartContract::GetStashBalance</a>(<span class="keyword">const</span> std::string from_stash_name, <span class="keyword">const</span> std::string asset_type_id)
<a name="l01392"></a>01392 {
<a name="l01393"></a>01393     <a class="code" href="class_o_t_cron.html">OTCron</a> * pCron  = <a class="code" href="class_o_t_cron_item.html#af734ad5d309fcc9b4a60d40d6c30f55a">GetCron</a>();
<a name="l01394"></a>01394     <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != pCron);
<a name="l01395"></a>01395     <span class="comment">// ----------------------------------</span>
<a name="l01396"></a>01396     <a class="code" href="class_o_t_pseudonym.html">OTPseudonym</a> * pServerNym = pCron-&gt;<a class="code" href="class_o_t_cron.html#a7756d0dcc047209ca87632939dc11db3">GetServerNym</a>();
<a name="l01397"></a>01397     <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != pServerNym);
<a name="l01398"></a>01398     <span class="comment">// ---------------------------------------------------</span>
<a name="l01399"></a>01399     <span class="comment">// Below this point, these are all good:</span>
<a name="l01400"></a>01400     <span class="comment">//</span>
<a name="l01401"></a>01401     <span class="comment">//      pServerNym, pCron.</span>
<a name="l01402"></a>01402     <span class="comment">//</span>
<a name="l01403"></a>01403     <span class="comment">// ---------------------------------------------------</span>
<a name="l01404"></a>01404     <span class="keywordflow">if</span> (from_stash_name.size() &lt;= 0)
<a name="l01405"></a>01405     {
<a name="l01406"></a>01406         <a class="code" href="class_o_t_log.html#a5acd90ac91c2618f395b0ff37ad4f8ee">OTLog::Error</a>(<span class="stringliteral">&quot;OTSmartContract::GetStashBalance: error: from_stash_name is non-existent.\n&quot;</span>);
<a name="l01407"></a>01407         <span class="keywordflow">return</span> 0;
<a name="l01408"></a>01408     }
<a name="l01409"></a>01409     <span class="keywordflow">if</span> (asset_type_id.size() &lt;= 0)
<a name="l01410"></a>01410     {
<a name="l01411"></a>01411         <a class="code" href="class_o_t_log.html#a5acd90ac91c2618f395b0ff37ad4f8ee">OTLog::Error</a>(<span class="stringliteral">&quot;OTSmartContract::GetStashBalance: error: asset_type_id is non-existent.\n&quot;</span>);
<a name="l01412"></a>01412         <span class="keywordflow">return</span> 0;
<a name="l01413"></a>01413     }
<a name="l01414"></a>01414     <span class="comment">// ---------------------------------------------------</span>
<a name="l01415"></a>01415     <span class="comment">// Below this point, these are all good:</span>
<a name="l01416"></a>01416     <span class="comment">//</span>
<a name="l01417"></a>01417     <span class="comment">//      from_stash_name,</span>
<a name="l01418"></a>01418     <span class="comment">//      asset_type_id</span>
<a name="l01419"></a>01419     <span class="comment">//      pServerNym, pCron.</span>
<a name="l01420"></a>01420     <span class="comment">//</span>
<a name="l01421"></a>01421     <span class="comment">// ---------------------------------------------------</span>
<a name="l01422"></a>01422 
<a name="l01423"></a>01423     <a class="code" href="class_o_t_stash.html">OTStash</a> * pStash = this-&gt;<a class="code" href="class_o_t_smart_contract.html#af7305d13e0ac4c2bef284658bdd9ec67">GetStash</a>(from_stash_name); <span class="comment">// This ALWAYS succeeds. (It will OT_ASSERT() if failure.)</span>
<a name="l01424"></a>01424 
<a name="l01425"></a>01425     <span class="comment">// ---------------------------------------------------</span>
<a name="l01426"></a>01426     <span class="comment">//</span>
<a name="l01427"></a>01427     <span class="comment">// Below this point, these are all good:</span>
<a name="l01428"></a>01428     <span class="comment">//</span>
<a name="l01429"></a>01429     <span class="comment">//      pStash,     from_stash_name,</span>
<a name="l01430"></a>01430     <span class="comment">//      asset_type_id</span>
<a name="l01431"></a>01431     <span class="comment">//      pServerNym, pCron.</span>
<a name="l01432"></a>01432     <span class="comment">//</span>
<a name="l01433"></a>01433     <span class="comment">// ****************************************************************************</span>
<a name="l01434"></a>01434     <a class="code" href="class_o_t_string.html">OTString</a> strBalance;
<a name="l01435"></a>01435     strBalance.<a class="code" href="class_o_t_string.html#af1c861f21033a1d583b3cb12f952422e">Format</a>(<span class="stringliteral">&quot;%lld&quot;</span>, pStash-&gt;<a class="code" href="class_o_t_stash.html#ab89b0a67cc8308afa8b77e399ac368a4">GetAmount</a>(asset_type_id));
<a name="l01436"></a>01436     <span class="keywordflow">return</span> strBalance.<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>();
<a name="l01437"></a>01437 }
<a name="l01438"></a>01438 
<a name="l01439"></a>01439 
<a name="l01440"></a>01440 <span class="comment">// done</span>
<a name="l01441"></a>01441 <span class="comment">// pScript-&gt;chai-&gt;add(fun(&amp;(OTSmartContract::SendANoticeToAllParties),  (*this)), &quot;send_notice_to_parties&quot;);    // bool SendANoticeToAllParties();</span>
<a name="l01442"></a>01442 <span class="comment">//</span>
<a name="l01443"></a><a class="code" href="class_o_t_smart_contract.html#a63aa006565fab757f33d28215b1f5e0c">01443</a> <span class="keywordtype">bool</span> <a class="code" href="class_o_t_smart_contract.html#a63aa006565fab757f33d28215b1f5e0c">OTSmartContract::SendANoticeToAllParties</a>()
<a name="l01444"></a>01444 {
<a name="l01445"></a>01445     <a class="code" href="class_o_t_cron.html">OTCron</a> * pCron  = <a class="code" href="class_o_t_cron_item.html#af734ad5d309fcc9b4a60d40d6c30f55a">GetCron</a>();
<a name="l01446"></a>01446     <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != pCron);
<a name="l01447"></a>01447     <span class="comment">// ----------------------------------</span>
<a name="l01448"></a>01448     <a class="code" href="class_o_t_pseudonym.html">OTPseudonym</a> * pServerNym = pCron-&gt;<a class="code" href="class_o_t_cron.html#a7756d0dcc047209ca87632939dc11db3">GetServerNym</a>();
<a name="l01449"></a>01449     <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != pServerNym);
<a name="l01450"></a>01450     <span class="comment">// ---------------------------------------------------</span>
<a name="l01451"></a>01451     <span class="comment">// Below this point, these are all good:</span>
<a name="l01452"></a>01452     <span class="comment">//</span>
<a name="l01453"></a>01453     <span class="comment">//      pServerNym, pCron.</span>
<a name="l01454"></a>01454     <span class="comment">//</span>
<a name="l01455"></a>01455     <span class="comment">// ---------------------------------------------------</span>
<a name="l01456"></a>01456     <span class="keyword">const</span> int64_t lNewTransactionNumber = pCron-&gt;<a class="code" href="class_o_t_cron.html#a22822e0aeced441b6404cd8a2c8e00da">GetNextTransactionNumber</a>();
<a name="l01457"></a>01457     <span class="keywordtype">bool</span> bDroppedNotice = <span class="keyword">false</span>;
<a name="l01458"></a>01458 
<a name="l01459"></a>01459 <span class="comment">//  OT_ASSERT(lNewTransactionNumber &gt; 0); // this can be my reminder.</span>
<a name="l01460"></a>01460     <span class="keywordflow">if</span> (0 == lNewTransactionNumber)
<a name="l01461"></a>01461     {
<a name="l01462"></a>01462         <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;%s: ** ERROR: Notice not sent to parties, since no transaction numbers were available!\n&quot;</span>);
<a name="l01463"></a>01463     }
<a name="l01464"></a>01464     <span class="keywordflow">else</span>
<a name="l01465"></a>01465     {
<a name="l01466"></a>01466         this-&gt;<a class="code" href="class_o_t_contract.html#aae54340526fbd8eb8a18de27a4b97c83">ReleaseSignatures</a>();
<a name="l01467"></a>01467         this-&gt;<a class="code" href="class_o_t_contract.html#abd60037fe655ee8cae9a3ece5d1e2ea6">SignContract</a>(*pServerNym);
<a name="l01468"></a>01468         this-&gt;<a class="code" href="class_o_t_contract.html#a363ae430d4fd9256ab8364dbafb95444">SaveContract</a>();
<a name="l01469"></a>01469 
<a name="l01470"></a>01470         <span class="keyword">const</span> <a class="code" href="class_o_t_string.html">OTString</a> strReference(*<span class="keyword">this</span>);
<a name="l01471"></a>01471         bDroppedNotice = this-&gt;<a class="code" href="class_o_t_scriptable.html#a03d724ec348f2dc140c9ed45d6133429">SendNoticeToAllParties</a>(<span class="keyword">true</span>, <span class="comment">// bSuccessMsg=true</span>
<a name="l01472"></a>01472                                                       *pServerNym, <a class="code" href="class_o_t_instrument.html#a878dd8998f7b131b85c082575e255375">GetServerID</a>(), lNewTransactionNumber,
<a name="l01473"></a>01473                                                       <span class="comment">//GetTransactionNum(), // each party has its own opening number.</span>
<a name="l01474"></a>01474                                                       strReference); <span class="comment">// pstrNote and pstrAttachment aren&#39;t used in this case.</span>
<a name="l01475"></a>01475 
<a name="l01476"></a>01476         <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(0, <span class="stringliteral">&quot;%s: Dropping notifications into all parties&#39; nymboxes: %s\n&quot;</span>,
<a name="l01477"></a>01477                        __FUNCTION__, bDroppedNotice ? <span class="stringliteral">&quot;Success&quot;</span> : <span class="stringliteral">&quot;Failure&quot;</span>);
<a name="l01478"></a>01478     }
<a name="l01479"></a>01479     <span class="comment">// ---------------------------------------------------</span>
<a name="l01480"></a>01480 
<a name="l01481"></a>01481     <span class="keywordflow">return</span> bDroppedNotice;
<a name="l01482"></a>01482 }
<a name="l01483"></a>01483 
<a name="l01484"></a>01484 
<a name="l01485"></a>01485 <span class="comment">// Done:</span>
<a name="l01486"></a>01486 <span class="comment">// pScript-&gt;chai-&gt;add(fun(&amp;(OTSmartContract::SendNoticeToParty),        (*this)), &quot;send_notice&quot;);   // bool SendNoticeToParty(const std::string party_name);</span>
<a name="l01487"></a>01487 <span class="comment">//</span>
<a name="l01488"></a><a class="code" href="class_o_t_smart_contract.html#a72762c0413197f084b36e2d0fce59e4f">01488</a> <span class="keywordtype">bool</span> <a class="code" href="class_o_t_smart_contract.html#a72762c0413197f084b36e2d0fce59e4f">OTSmartContract::SendNoticeToParty</a>(<span class="keyword">const</span> std::string party_name)
<a name="l01489"></a>01489 {
<a name="l01490"></a>01490     <a class="code" href="class_o_t_cron.html">OTCron</a> * pCron  = <a class="code" href="class_o_t_cron_item.html#af734ad5d309fcc9b4a60d40d6c30f55a">GetCron</a>();
<a name="l01491"></a>01491     <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != pCron);
<a name="l01492"></a>01492     <span class="comment">// ----------------------------------</span>
<a name="l01493"></a>01493     <a class="code" href="class_o_t_pseudonym.html">OTPseudonym</a> * pServerNym = pCron-&gt;<a class="code" href="class_o_t_cron.html#a7756d0dcc047209ca87632939dc11db3">GetServerNym</a>();
<a name="l01494"></a>01494     <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != pServerNym);
<a name="l01495"></a>01495     <span class="comment">// ---------------------------------------------------</span>
<a name="l01496"></a>01496     <span class="comment">// Below this point, these are all good:</span>
<a name="l01497"></a>01497     <span class="comment">//</span>
<a name="l01498"></a>01498     <span class="comment">//      pServerNym, pCron.</span>
<a name="l01499"></a>01499     <span class="comment">//</span>
<a name="l01500"></a>01500     <span class="comment">// ---------------------------------------------------</span>
<a name="l01501"></a>01501     <a class="code" href="class_o_t_party.html">OTParty</a> * pParty = this-&gt;<a class="code" href="class_o_t_scriptable.html#acd0f8e884ed00f1d082fa498323d8894">GetParty</a>(party_name);
<a name="l01502"></a>01502 
<a name="l01503"></a>01503     <span class="keywordflow">if</span> (NULL == pParty)
<a name="l01504"></a>01504     {
<a name="l01505"></a>01505         <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(0, <span class="stringliteral">&quot;%s: Unable to find this party: %s\n&quot;</span>,
<a name="l01506"></a>01506                        __FUNCTION__, party_name.c_str());
<a name="l01507"></a>01507         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01508"></a>01508     }
<a name="l01509"></a>01509     <span class="comment">// Below this point, pParty is good.</span>
<a name="l01510"></a>01510     <span class="comment">// ------------------------------------------------</span>
<a name="l01511"></a>01511 
<a name="l01512"></a>01512     <span class="comment">// ...This WILL check to see if pParty has its Opening number verified as issued.</span>
<a name="l01513"></a>01513     <span class="comment">// (If the opening number is &gt; 0 then VerifyPartyAuthorization() is smart enough to verify it.)</span>
<a name="l01514"></a>01514     <span class="comment">//</span>
<a name="l01515"></a>01515     <span class="comment">// To KNOW that a party has the right to even ASK the script to cancel a contract, MEANS that</span>
<a name="l01516"></a>01516     <span class="comment">// (1) The party is listed as a party on the contract. (2) The party&#39;s copy of that contract</span>
<a name="l01517"></a>01517     <span class="comment">// is signed by the authorizing agent for that party. and (3) The opening transaction number for</span>
<a name="l01518"></a>01518     <span class="comment">// that party is verified as issued for authorizing agent. (2 and 3 are both performed at the same</span>
<a name="l01519"></a>01519     <span class="comment">// time, in VerifyPartyAuthorization(), since the agent may need to be loaded in order to verify</span>
<a name="l01520"></a>01520     <span class="comment">// them.) 1 is already done by this point, as it&#39;s performed above.</span>
<a name="l01521"></a>01521     <span class="comment">//</span>
<a name="l01522"></a>01522     <span class="comment">// Done: notice this code appears in CanCancelContract() (this function) as well as</span>
<a name="l01523"></a>01523     <span class="comment">// OTScriptable::CanExecuteClause.</span>
<a name="l01524"></a>01524     <span class="comment">// Therefore I can see that THIS VERIFICATION CODE WILL GET CALLED EVERY SINGLE TIME THE SCRIPT</span>
<a name="l01525"></a>01525     <span class="comment">// CALLS ANY CLAUSE OR OT NATIVE FUNCTION.  Since technically this only needs to be verified before the</span>
<a name="l01526"></a>01526     <span class="comment">// first call, and not for EVERY call during any of a script&#39;s runs, I should probably move this verification</span>
<a name="l01527"></a>01527     <span class="comment">// higher, such as each time the OTCronItem triggers, plus each time a party triggers a clause directly</span>
<a name="l01528"></a>01528     <span class="comment">// through the API (server message). As long as those are covered, I will be able to remove it from here</span>
<a name="l01529"></a>01529     <span class="comment">// which should be a significant improvement for performance.</span>
<a name="l01530"></a>01530     <span class="comment">// It will be at the bottom of those same functions that &quot;ClearTemporaryPointers()&quot; should finally be called.</span>
<a name="l01531"></a>01531     <span class="comment">//</span>
<a name="l01532"></a>01532     <span class="comment">// Also todo:  Need to implement MOVE CONSTRUCTORS and MOVE COPY CONSTRUCTORS all over the place,</span>
<a name="l01533"></a>01533     <span class="comment">// once I&#39;m sure C++0x build environments are available for all of the various OT platforms. That should</span>
<a name="l01534"></a>01534     <span class="comment">// be another great performance boost!</span>
<a name="l01535"></a>01535     <span class="comment">//</span>
<a name="l01536"></a>01536     <span class="comment">//  FINAL DECISION: See longer comment in OTSmartContract::StashAcctFunds(). This is redundant and was</span>
<a name="l01537"></a>01537     <span class="comment">//  removed. It expects itself to be executed only upon the initial activation of a smart contract, and</span>
<a name="l01538"></a>01538     <span class="comment">//  not again after. (For example, it disallows stashes, which cannot exist prior to activation.)</span>
<a name="l01539"></a>01539     <span class="comment">//</span>
<a name="l01540"></a>01540 <span class="comment">//  const OTString strServerID(GetServerID());</span>
<a name="l01541"></a>01541 <span class="comment">//</span>
<a name="l01542"></a>01542 <span class="comment">//  mapOfNyms   map_Nyms_Already_Loaded;</span>
<a name="l01543"></a>01543 <span class="comment">//  this-&gt;RetrieveNymPointers(map_Nyms_Already_Loaded);</span>
<a name="l01544"></a>01544 <span class="comment">//</span>
<a name="l01545"></a>01545 <span class="comment">//  bool bVerifiedAuthorization =</span>
<a name="l01546"></a>01546 <span class="comment">//      this-&gt;VerifyPartyAuthorization(*pParty, *pServerNym, strServerID, &amp;map_Nyms_Already_Loaded);</span>
<a name="l01547"></a>01547 <span class="comment">//</span>
<a name="l01548"></a>01548 <span class="comment">//  if (!bVerifiedAuthorization)</span>
<a name="l01549"></a>01549 <span class="comment">//  {</span>
<a name="l01550"></a>01550 <span class="comment">//      OTLog::vOutput(0, &quot;OTSmartContract::SendNoticeToParty: Unable to verify this party: %s\n&quot;,</span>
<a name="l01551"></a>01551 <span class="comment">//                     party_name.c_str());</span>
<a name="l01552"></a>01552 <span class="comment">//      return false;</span>
<a name="l01553"></a>01553 <span class="comment">//  }</span>
<a name="l01554"></a>01554 
<a name="l01555"></a>01555     <span class="comment">// *****************************************************************************</span>
<a name="l01556"></a>01556 
<a name="l01557"></a>01557             <span class="keywordtype">bool</span> bDroppedNotice         = <span class="keyword">false</span>;
<a name="l01558"></a>01558     <span class="keyword">const</span>   int64_t lNewTransactionNumber   = pCron-&gt;<a class="code" href="class_o_t_cron.html#a22822e0aeced441b6404cd8a2c8e00da">GetNextTransactionNumber</a>();
<a name="l01559"></a>01559 
<a name="l01560"></a>01560 <span class="comment">//  OT_ASSERT(lNewTransactionNumber &gt; 0); // this can be my reminder.</span>
<a name="l01561"></a>01561     <span class="keywordflow">if</span> (0 == lNewTransactionNumber)
<a name="l01562"></a>01562     {
<a name="l01563"></a>01563         <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;%s: ** ERROR: Notice not sent to party, since no transaction numbers were available!\n&quot;</span>,
<a name="l01564"></a>01564                       __FUNCTION__);
<a name="l01565"></a>01565     }
<a name="l01566"></a>01566     <span class="keywordflow">else</span>
<a name="l01567"></a>01567     {
<a name="l01568"></a>01568         this-&gt;<a class="code" href="class_o_t_contract.html#aae54340526fbd8eb8a18de27a4b97c83">ReleaseSignatures</a>();
<a name="l01569"></a>01569         this-&gt;<a class="code" href="class_o_t_contract.html#abd60037fe655ee8cae9a3ece5d1e2ea6">SignContract</a>(*pServerNym);
<a name="l01570"></a>01570         this-&gt;<a class="code" href="class_o_t_contract.html#a363ae430d4fd9256ab8364dbafb95444">SaveContract</a>();
<a name="l01571"></a>01571 
<a name="l01572"></a>01572         <span class="keyword">const</span> <a class="code" href="class_o_t_string.html">OTString</a> strReference(*<span class="keyword">this</span>);
<a name="l01573"></a>01573 
<a name="l01574"></a>01574         bDroppedNotice = pParty-&gt;<a class="code" href="class_o_t_party.html#a7419b9a17e72819156005dd976b2dd1e">SendNoticeToParty</a>(<span class="keyword">true</span>, <span class="comment">//bSuccessMsg=true. True in general means &quot;success&quot; and false means &quot;failure.&quot;</span>
<a name="l01575"></a>01575                                                    *pServerNym, <a class="code" href="class_o_t_instrument.html#a878dd8998f7b131b85c082575e255375">GetServerID</a>(), lNewTransactionNumber,
<a name="l01576"></a>01576                                                    <span class="comment">//GetTransactionNum(), // each party has its own opening trans # and supplies it internally.</span>
<a name="l01577"></a>01577                                                    strReference);
<a name="l01578"></a>01578 
<a name="l01579"></a>01579         <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(0, <span class="stringliteral">&quot;%s: %s dropping notification into party&#39;s nymbox: %s\n&quot;</span>, __FUNCTION__,
<a name="l01580"></a>01580                        bDroppedNotice ? <span class="stringliteral">&quot;Success&quot;</span> : <span class="stringliteral">&quot;Failure&quot;</span>, pParty-&gt;<a class="code" href="class_o_t_party.html#ad823a9d89b3d8d0d87bc85114eefcead">GetPartyName</a>().c_str());
<a name="l01581"></a>01581     }
<a name="l01582"></a>01582     <span class="comment">// ---------------------------------------------------</span>
<a name="l01583"></a>01583 
<a name="l01584"></a>01584     <span class="keywordflow">return</span> bDroppedNotice;
<a name="l01585"></a>01585 }
<a name="l01586"></a>01586 
<a name="l01587"></a>01587 
<a name="l01588"></a>01588 <span class="comment">// Higher-level. Can be called from inside scripts.</span>
<a name="l01589"></a>01589 <span class="comment">//</span>
<a name="l01590"></a>01590 <span class="comment">// Returns success if funds were moved.</span>
<a name="l01591"></a>01591 <span class="comment">// This function does not run any scripts, but it CAN be executed from within the scripts.</span>
<a name="l01592"></a>01592 <span class="comment">// Any movement of funds to-or-from any account will automatically try to load/use the</span>
<a name="l01593"></a>01593 <span class="comment">// appropriate authorizing agent for that account (or use him, if he&#39;s already loaded on</span>
<a name="l01594"></a>01594 <span class="comment">// this smart contract.)</span>
<a name="l01595"></a>01595 <span class="comment">//</span>
<a name="l01596"></a>01596 <span class="comment">// DONE: audit security. Whenever I add any funds to a stash, there should be an internal</span>
<a name="l01597"></a>01597 <span class="comment">// server account where the backing funds are stored, the same as with cash. This is so that</span>
<a name="l01598"></a>01598 <span class="comment">// stashed funds will show up properly on an audit.</span>
<a name="l01599"></a>01599 <span class="comment">//</span>
<a name="l01600"></a><a class="code" href="class_o_t_smart_contract.html#a7d4c35453914e75a252a1f4eac3ce855">01600</a> <span class="keywordtype">bool</span> <a class="code" href="class_o_t_smart_contract.html#a7d4c35453914e75a252a1f4eac3ce855">OTSmartContract::StashAcctFunds</a>(<span class="keyword">const</span> std::string from_acct_name, <span class="keyword">const</span> std::string to_stash_name, <span class="keyword">const</span> std::string str_Amount)
<a name="l01601"></a>01601 {
<a name="l01602"></a>01602     <a class="code" href="class_o_t_cron.html">OTCron</a> * pCron  = <a class="code" href="class_o_t_cron_item.html#af734ad5d309fcc9b4a60d40d6c30f55a">GetCron</a>();
<a name="l01603"></a>01603     <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != pCron);
<a name="l01604"></a>01604     <span class="comment">// ----------------------------------</span>
<a name="l01605"></a>01605     <a class="code" href="class_o_t_pseudonym.html">OTPseudonym</a> * pServerNym = pCron-&gt;<a class="code" href="class_o_t_cron.html#a7756d0dcc047209ca87632939dc11db3">GetServerNym</a>();
<a name="l01606"></a>01606     <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != pServerNym);
<a name="l01607"></a>01607     <span class="comment">// ---------------------------------------------------</span>
<a name="l01608"></a>01608     <span class="comment">// Below this point, these are all good:</span>
<a name="l01609"></a>01609     <span class="comment">//</span>
<a name="l01610"></a>01610     <span class="comment">//      pServerNym, pCron.</span>
<a name="l01611"></a>01611     <span class="comment">//</span>
<a name="l01612"></a>01612     <span class="comment">// ---------------------------------------------------</span>
<a name="l01613"></a>01613     <span class="keywordflow">if</span> (str_Amount.size() &lt; 1)
<a name="l01614"></a>01614     {
<a name="l01615"></a>01615         <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(0, <span class="stringliteral">&quot;OTSmartContract::StashAcctFunds: Error: empty amount.\n&quot;</span>);
<a name="l01616"></a>01616         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01617"></a>01617     }
<a name="l01618"></a>01618 
<a name="l01619"></a>01619     <span class="keyword">const</span> int64_t lAmount =  atol(str_Amount.c_str());
<a name="l01620"></a>01620 
<a name="l01621"></a>01621     <span class="keywordflow">if</span> (lAmount &lt;= 0)
<a name="l01622"></a>01622     {
<a name="l01623"></a>01623         <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(0, <span class="stringliteral">&quot;OTSmartContract::StashAcctFunds: Error: lAmount cannot be 0 or &lt;0. (Value passed in was %lld.)\n&quot;</span>,
<a name="l01624"></a>01624                        lAmount);
<a name="l01625"></a>01625         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01626"></a>01626     }
<a name="l01627"></a>01627     <span class="comment">// -----------------------------</span>
<a name="l01628"></a>01628     <span class="keywordflow">if</span> (from_acct_name.size() &lt;= 0)
<a name="l01629"></a>01629     {
<a name="l01630"></a>01630         <a class="code" href="class_o_t_log.html#a5acd90ac91c2618f395b0ff37ad4f8ee">OTLog::Error</a>(<span class="stringliteral">&quot;OTSmartContract::StashAcctFunds: error: from_acct_name is non-existent.\n&quot;</span>);
<a name="l01631"></a>01631         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01632"></a>01632     }
<a name="l01633"></a>01633     <span class="keywordflow">if</span> (to_stash_name.size() &lt;= 0)
<a name="l01634"></a>01634     {
<a name="l01635"></a>01635         <a class="code" href="class_o_t_log.html#a5acd90ac91c2618f395b0ff37ad4f8ee">OTLog::Error</a>(<span class="stringliteral">&quot;OTSmartContract::StashAcctFunds: error: to_stash_name is non-existent.\n&quot;</span>);
<a name="l01636"></a>01636         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01637"></a>01637     }
<a name="l01638"></a>01638     <span class="comment">// ---------------------------------------------------</span>
<a name="l01639"></a>01639     <span class="comment">// Below this point, these are all good:</span>
<a name="l01640"></a>01640     <span class="comment">//</span>
<a name="l01641"></a>01641     <span class="comment">//      from_acct_name,</span>
<a name="l01642"></a>01642     <span class="comment">//      to_stash_name,</span>
<a name="l01643"></a>01643     <span class="comment">//      pServerNym, pCron.</span>
<a name="l01644"></a>01644     <span class="comment">//</span>
<a name="l01645"></a>01645     <span class="comment">// ---------------------------------------------------</span>
<a name="l01646"></a>01646 
<a name="l01647"></a>01647     <a class="code" href="class_o_t_party_account.html">OTPartyAccount</a>  * pFromAcct = this-&gt;<a class="code" href="class_o_t_scriptable.html#a94c9e55f78357e04e4b9781ab662370f">GetPartyAccount</a>(from_acct_name);
<a name="l01648"></a>01648     <a class="code" href="class_o_t_stash.html">OTStash</a>         * pStash    = this-&gt;<a class="code" href="class_o_t_smart_contract.html#af7305d13e0ac4c2bef284658bdd9ec67">GetStash</a>(to_stash_name); <span class="comment">// This ALWAYS succeeds. (It will OT_ASSERT() if failure.)</span>
<a name="l01649"></a>01649 
<a name="l01650"></a>01650     <span class="keywordflow">if</span> (NULL == pFromAcct)
<a name="l01651"></a>01651     {
<a name="l01652"></a>01652         <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(0, <span class="stringliteral">&quot;OTSmartContract::StashAcctFunds: error: from_acct (%s) not found on any party.\n&quot;</span>,
<a name="l01653"></a>01653                        from_acct_name.c_str());
<a name="l01654"></a>01654         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01655"></a>01655     }
<a name="l01656"></a>01656     <span class="comment">// ---------------------------------------------------</span>
<a name="l01657"></a>01657     <span class="comment">//</span>
<a name="l01658"></a>01658     <span class="comment">// Below this point, these are all good:</span>
<a name="l01659"></a>01659     <span class="comment">//</span>
<a name="l01660"></a>01660     <span class="comment">//      pFromAcct,  from_acct_name,</span>
<a name="l01661"></a>01661     <span class="comment">//      pStash,     to_stash_name,</span>
<a name="l01662"></a>01662     <span class="comment">//      pServerNym, pCron.</span>
<a name="l01663"></a>01663     <span class="comment">//</span>
<a name="l01664"></a>01664     <span class="comment">// ---------------------------------------------------</span>
<a name="l01665"></a>01665 
<a name="l01666"></a>01666     <a class="code" href="class_o_t_agent.html">OTAgent</a> * pFromAgent    = pFromAcct-&gt;   GetAuthorizedAgent(); <span class="comment">// This searches the account&#39;s party for the account&#39;s authorized agent.</span>
<a name="l01667"></a>01667     <span class="comment">// (That way it&#39;s impossible to get an agent for any other party.)</span>
<a name="l01668"></a>01668 
<a name="l01669"></a>01669     <span class="keywordflow">if</span> (NULL == pFromAgent)
<a name="l01670"></a>01670     {
<a name="l01671"></a>01671         <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(0, <span class="stringliteral">&quot;OTSmartContract::StashAcctFunds: error: authorized agent (%s) not found for from_acct (%s) on acct&#39;s party.\n&quot;</span>,
<a name="l01672"></a>01672                        pFromAcct-&gt;<a class="code" href="class_o_t_party_account.html#a86975046b18ac6d6c5841f5ba0befe69">GetAgentName</a>().<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>(), from_acct_name.c_str());
<a name="l01673"></a>01673         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01674"></a>01674     }
<a name="l01675"></a>01675     <span class="comment">// ---------</span>
<a name="l01676"></a>01676     <span class="keywordflow">if</span> (<span class="keyword">false</span> == pFromAgent-&gt;<a class="code" href="class_o_t_agent.html#a1969e4f8a5f13ee34ba0a68d8f082956">IsAnIndividual</a>())
<a name="l01677"></a>01677     {
<a name="l01678"></a>01678         <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(0, <span class="stringliteral">&quot;OTSmartContract::StashAcctFunds: error: authorized agent (%s) for from_acct (%s) is not an active agent.\n&quot;</span>,
<a name="l01679"></a>01679                        pFromAcct-&gt;<a class="code" href="class_o_t_party_account.html#a86975046b18ac6d6c5841f5ba0befe69">GetAgentName</a>().<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>(), from_acct_name.c_str());
<a name="l01680"></a>01680         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01681"></a>01681     }
<a name="l01682"></a>01682     <span class="comment">//</span>
<a name="l01683"></a>01683     <span class="comment">// Below this point, these are all good:</span>
<a name="l01684"></a>01684     <span class="comment">//</span>
<a name="l01685"></a>01685     <span class="comment">//      pFromAcct,  from_acct_name, pFromAgent,</span>
<a name="l01686"></a>01686     <span class="comment">//      pStash,     to_stash_name,</span>
<a name="l01687"></a>01687     <span class="comment">//      pServerNym, pCron.</span>
<a name="l01688"></a>01688     <span class="comment">//</span>
<a name="l01689"></a>01689     <span class="comment">// ---------------------------------------------------</span>
<a name="l01690"></a>01690 
<a name="l01691"></a>01691     <a class="code" href="class_o_t_party.html">OTParty</a> * pFromParty    = pFromAgent-&gt;<a class="code" href="class_o_t_agent.html#a929a2489984f5487bd1819ed6d8862f2">GetParty</a>();
<a name="l01692"></a>01692 
<a name="l01693"></a>01693     <span class="keywordflow">if</span> (NULL == pFromParty)
<a name="l01694"></a>01694     {
<a name="l01695"></a>01695         <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;OTSmartContract::StashAcctFunds: error: Party pointer NULL on authorized agent (%s) for from_acct (%s).\n&quot;</span>,
<a name="l01696"></a>01696                       pFromAcct-&gt;<a class="code" href="class_o_t_party_account.html#a86975046b18ac6d6c5841f5ba0befe69">GetAgentName</a>().<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>(), from_acct_name.c_str());
<a name="l01697"></a>01697         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01698"></a>01698     }
<a name="l01699"></a>01699     <span class="comment">//</span>
<a name="l01700"></a>01700     <span class="comment">// Below this point, these are all good:</span>
<a name="l01701"></a>01701     <span class="comment">//</span>
<a name="l01702"></a>01702     <span class="comment">//      pFromAcct,  from_acct_name, pFromAgent, pFromParty,</span>
<a name="l01703"></a>01703     <span class="comment">//      pStash,     to_stash_name,</span>
<a name="l01704"></a>01704     <span class="comment">//      pServerNym, pCron.</span>
<a name="l01705"></a>01705     <span class="comment">//</span>
<a name="l01706"></a>01706     <span class="comment">// ---------------------------------------------------</span>
<a name="l01707"></a>01707 
<a name="l01708"></a>01708 
<a name="l01709"></a>01709     <span class="comment">// DONE: Problem: I can see that THIS VERIFICATION CODE WILL GET CALLED EVERY SINGLE TIME THE SCRIPT</span>
<a name="l01710"></a>01710     <span class="comment">// CALLS MOVE FUNDS.  Maybe that&#39;s good, but since technically this only needs to be verified before the</span>
<a name="l01711"></a>01711     <span class="comment">// first call, and not for EVERY call during any of a script&#39;s runs, I should probably move this verification</span>
<a name="l01712"></a>01712     <span class="comment">// higher, such as each time the OTCronItem triggers, plus each time a party triggers a clause directly</span>
<a name="l01713"></a>01713     <span class="comment">// through the API (server message). As long as those are covered, I will be able to remove it from here</span>
<a name="l01714"></a>01714     <span class="comment">// which should be a significant improvement for performance.</span>
<a name="l01715"></a>01715     <span class="comment">// It will be at the bottom of those same functions that &quot;ClearTemporaryPointers()&quot; should finally be called.</span>
<a name="l01716"></a>01716     <span class="comment">//</span>
<a name="l01717"></a>01717     <span class="comment">//</span>
<a name="l01718"></a>01718 <span class="comment">//  const OTString strServerID(GetServerID());</span>
<a name="l01719"></a>01719 
<a name="l01720"></a>01720 <span class="comment">//  mapOfNyms   map_Nyms_Already_Loaded;</span>
<a name="l01721"></a>01721 <span class="comment">//  this-&gt;RetrieveNymPointers(map_Nyms_Already_Loaded);</span>
<a name="l01722"></a>01722     <span class="comment">// --------------------------------------------------</span>
<a name="l01723"></a>01723 
<a name="l01724"></a>01724     <span class="comment">// FINAL DECISION: Since this verification is already done for the smart contract to have been activated onto</span>
<a name="l01725"></a>01725     <span class="comment">// cron in the first place, it is redundant to have it here.</span>
<a name="l01726"></a>01726     <span class="comment">// Furthermore, what if a single clause calls stash_funds 30 times in a loop? Does that mean we need to verify</span>
<a name="l01727"></a>01727     <span class="comment">// all the parties and accounts 30 times, every single time we call that clause? CLearly such is redundant, and</span>
<a name="l01728"></a>01728     <span class="comment">// would be targeted in any optimization effort.</span>
<a name="l01729"></a>01729     <span class="comment">// Furthermore, since actually running the software, it&#39;s become apparent that it is no longer even appropriate</span>
<a name="l01730"></a>01730     <span class="comment">// to Verify anymore, since stashes can exist after a smartcontract has been activated, while this function</span>
<a name="l01731"></a>01731     <span class="comment">// specifically verifies that no stashes exist, since it presumes that it is only called during the initial</span>
<a name="l01732"></a>01732     <span class="comment">// activation of the cron item, when no stashes SHOULD exist (since they are only created after activation, by</span>
<a name="l01733"></a>01733     <span class="comment">// the server itself, at the behest of the scripts.)</span>
<a name="l01734"></a>01734 
<a name="l01735"></a>01735 <span class="comment">//  if (false == this-&gt;VerifyPartyAuthorization(*pFromParty, *pServerNym, strServerID, &amp;map_Nyms_Already_Loaded))</span>
<a name="l01736"></a>01736 <span class="comment">//  {</span>
<a name="l01737"></a>01737 <span class="comment">//      OTLog::vError(&quot;OTSmartContract::StashAcctFunds: error: &#39;From&#39; Party (%s) not authorized for this contract.\n&quot;,</span>
<a name="l01738"></a>01738 <span class="comment">//                    pFromParty-&gt;GetPartyName().c_str());</span>
<a name="l01739"></a>01739 <span class="comment">//      return false;</span>
<a name="l01740"></a>01740 <span class="comment">//  }</span>
<a name="l01741"></a>01741     <span class="comment">// *****************************************************************************</span>
<a name="l01742"></a>01742 
<a name="l01743"></a>01743     <span class="comment">// A party might have many agents who are only voting groups, and cannot actually sign for things</span>
<a name="l01744"></a>01744     <span class="comment">// the way that nyms can. But at least ONE of those agents IS a Nym -- because there must have been</span>
<a name="l01745"></a>01745     <span class="comment">// an authorizing agent who initially signed to accept the agreement, and who fronted the opening</span>
<a name="l01746"></a>01746     <span class="comment">// transaction number that activated it.</span>
<a name="l01747"></a>01747     <span class="comment">//</span>
<a name="l01748"></a>01748     <span class="comment">// Similarly, the authorized agent for any given party&#39;s account (each account has its own authorized</span>
<a name="l01749"></a>01749     <span class="comment">// agent) MUST be an active agent (an active agent is one with a Nym--whether that Nym is representing</span>
<a name="l01750"></a>01750     <span class="comment">// himself as the party, or whether representing some entity as an employee in a role). Why MUST the</span>
<a name="l01751"></a>01751     <span class="comment">// authorized agent be an active agent? Because when funds are moved, that Nym must be loaded since</span>
<a name="l01752"></a>01752     <span class="comment">// the account must show that Nym as a legal owner/agent. The MoveFunds will cause a paymentReceipt to</span>
<a name="l01753"></a>01753     <span class="comment">// drop into the Inbox for the relevant asset accounts, and that paymentReceipt can ONLY be accepted</span>
<a name="l01754"></a>01754     <span class="comment">// by that same Nym, who must use a transaction # that he signed for previously and received through</span>
<a name="l01755"></a>01755     <span class="comment">// his nymbox. There is actually no justification at all to take funds from that account, since the</span>
<a name="l01756"></a>01756     <span class="comment">// new balance has not yet been signed, UNLESS THE PAYMENTRECEIPT CONTAINS A VALID, SIGNED AUTHORIZATION</span>
<a name="l01757"></a>01757     <span class="comment">// FROM THE ACCOUNT HOLDER. *That* is why the authorizing agent must either be the Party&#39;s Owner himself</span>
<a name="l01758"></a>01758     <span class="comment">// (representing himself as an agent, which most will do) in which case he will appear as the valid</span>
<a name="l01759"></a>01759     <span class="comment">// owner of the account, OR he MUST be a Nym working in a Valid Role for an Entity, where said Entity is</span>
<a name="l01760"></a>01760     <span class="comment">// the valid owner on the account in question. Either OT, it will be possible in OT for him to sign for</span>
<a name="l01761"></a>01761     <span class="comment">// the paymentReceipts when they come in, and impossible for him to escape liability for them.</span>
<a name="l01762"></a>01762     <span class="comment">// (That&#39;s the idea anyway.)</span>
<a name="l01763"></a>01763     <span class="comment">//</span>
<a name="l01764"></a>01764     <span class="comment">// Since we know that the Authorized Agent for an account must be an ACTIVE agent (one way or the other)</span>
<a name="l01765"></a>01765     <span class="comment">// then we can error out here if he&#39;s not.  We can then pass in his Nym ID.</span>
<a name="l01766"></a>01766     <span class="comment">//</span>
<a name="l01767"></a>01767 
<a name="l01768"></a>01768     <a class="code" href="class_o_t_identifier.html">OTIdentifier</a> theFromAgentID;
<a name="l01769"></a>01769     <span class="keyword">const</span> <span class="keywordtype">bool</span> bFromAgentID = pFromAgent-&gt;<a class="code" href="class_o_t_agent.html#a7750c7f5840047c5413d95e92ad87578">GetSignerID</a>(theFromAgentID);
<a name="l01770"></a>01770 
<a name="l01771"></a>01771     <span class="keywordflow">if</span> ( ! bFromAgentID )
<a name="l01772"></a>01772     {
<a name="l01773"></a>01773         <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;OTSmartContract::StashAcctFunds: Failed to find FromAgent&#39;s Signer ID: %s \n&quot;</span>,
<a name="l01774"></a>01774                       pFromAgent-&gt;<a class="code" href="class_o_t_agent.html#a123d27f05e46977ecdbe0b83de3c119d">GetName</a>().<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>());
<a name="l01775"></a>01775         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01776"></a>01776     }
<a name="l01777"></a>01777     <span class="comment">// --------------------------------------</span>
<a name="l01778"></a>01778 
<a name="l01779"></a>01779     <span class="keywordflow">if</span> (!pFromAcct-&gt;<a class="code" href="class_o_t_party_account.html#aa5e4e0cc77853d08b3708017fe694876">GetAcctID</a>().<a class="code" href="class_o_t_string.html#adf7489cd917d4ae5bf30853a3ad78daf">Exists</a>())
<a name="l01780"></a>01780     {
<a name="l01781"></a>01781         <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;OTSmartContract::StashAcctFunds: Error: FromAcct has empty AcctID: %s \n&quot;</span>,
<a name="l01782"></a>01782                       from_acct_name.c_str());
<a name="l01783"></a>01783         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01784"></a>01784     }
<a name="l01785"></a>01785 
<a name="l01786"></a>01786     <span class="keyword">const</span> <a class="code" href="class_o_t_identifier.html">OTIdentifier</a> theFromAcctID(pFromAcct-&gt;<a class="code" href="class_o_t_party_account.html#aa5e4e0cc77853d08b3708017fe694876">GetAcctID</a>());
<a name="l01787"></a>01787     <span class="comment">//</span>
<a name="l01788"></a>01788     <span class="comment">// BELOW THIS POINT, theFromAcctID and theFromAgentID available.</span>
<a name="l01789"></a>01789     <span class="comment">// --------------------------------------</span>
<a name="l01790"></a>01790 
<a name="l01791"></a>01791     <span class="comment">// WE SET THESE HERE SO THE RECEIPT SHOWS, SUCCESS OR FAIL,</span>
<a name="l01792"></a>01792     <span class="comment">// WHO THE INTENDED SENDER / RECIPIENT ARE FOR THAT RECEIPT.</span>
<a name="l01793"></a>01793     <span class="comment">//</span>
<a name="l01794"></a>01794     <a class="code" href="class_o_t_smart_contract.html#a09de789ac2e616e2119feb9ddf416c9d">ReleaseLastSenderRecipientIDs</a>();
<a name="l01795"></a>01795     <span class="comment">// -------------------------</span>
<a name="l01796"></a>01796     theFromAgentID.<a class="code" href="class_o_t_identifier.html#a4bccb30446b4b515d9d6016b86b260bb">GetString</a>(m_strLastSenderUser);  <span class="comment">// This is the last User ID of a party who SENT money.</span>
<a name="l01797"></a>01797     theFromAcctID.GetString(m_strLastSenderAcct);   <span class="comment">// This is the last Acct ID of a party who SENT money.</span>
<a name="l01798"></a>01798 <span class="comment">//  theToAgentID.GetString(m_strLastRecipientUser); // This is the last User ID of a party who RECEIVED money.</span>
<a name="l01799"></a>01799 <span class="comment">//  theToAcctID.GetString(m_strLastRecipientAcct);  // This is the last Acct ID of a party who RECEIVED money.</span>
<a name="l01800"></a>01800     <span class="comment">// Above: the ToAgent and ToAcct are commented out,</span>
<a name="l01801"></a>01801     <span class="comment">// since the funds are going into a stash.</span>
<a name="l01802"></a>01802     <span class="comment">// ----------------------------------------------------------</span>
<a name="l01803"></a>01803 
<a name="l01804"></a>01804     <a class="code" href="_o_t_agent_8hpp.html#ac89892658f6bc83e354078647b704e8f">mapOfNyms</a>   map_Nyms_Already_Loaded;
<a name="l01805"></a>01805     this-&gt;<a class="code" href="class_o_t_scriptable.html#a9e41bb939fd5dbfe1f2442e5919a5079">RetrieveNymPointers</a>(map_Nyms_Already_Loaded);
<a name="l01806"></a>01806 
<a name="l01807"></a>01807 
<a name="l01808"></a>01808 <span class="comment">//  OTLog::vError(&quot;OTSmartContract::StashAcctFunds: DEBUGGING: lAmount is %lld.\n&quot;, lAmount);</span>
<a name="l01809"></a>01809 
<a name="l01810"></a>01810 
<a name="l01811"></a>01811     <span class="keywordtype">bool</span> bMoved = this-&gt;<a class="code" href="class_o_t_smart_contract.html#abaebc7e1d2416290139c883698c91025">StashFunds</a>(map_Nyms_Already_Loaded,
<a name="l01812"></a>01812                                    lAmount,
<a name="l01813"></a>01813                                    theFromAcctID,   theFromAgentID,
<a name="l01814"></a>01814                                    *pStash);
<a name="l01815"></a>01815     <span class="keywordflow">if</span> (!bMoved)
<a name="l01816"></a>01816     {
<a name="l01817"></a>01817         <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(0, <span class="stringliteral">&quot;OTSmartContract::StashAcctFunds: Failed in final call. Values: from_acct: %s, to_stash: %s, lAmount: %lld. \n&quot;</span>,
<a name="l01818"></a>01818                        from_acct_name.c_str(), to_stash_name.c_str(), lAmount);
<a name="l01819"></a>01819         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01820"></a>01820     }
<a name="l01821"></a>01821 
<a name="l01822"></a>01822     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01823"></a>01823 }
<a name="l01824"></a>01824 
<a name="l01825"></a>01825 
<a name="l01826"></a>01826 <span class="comment">// Higher-level. Can be called from inside scripts.</span>
<a name="l01827"></a>01827 <span class="comment">//</span>
<a name="l01828"></a>01828 <span class="comment">// Returns success if funds were moved.</span>
<a name="l01829"></a>01829 <span class="comment">// This function does not run any scripts, but it CAN be executed from within the scripts.</span>
<a name="l01830"></a>01830 <span class="comment">// Any movement of funds to-or-from any account will automatically try to load/use the</span>
<a name="l01831"></a>01831 <span class="comment">// appropriate authorizing agent for that account (or use him, if he&#39;s already loaded on</span>
<a name="l01832"></a>01832 <span class="comment">// this smart contract.)</span>
<a name="l01833"></a>01833 <span class="comment">//</span>
<a name="l01834"></a>01834 <span class="comment">// DONE: audit security. Whenever I add any funds to a stash, there should be an internal</span>
<a name="l01835"></a>01835 <span class="comment">// server account where the backing funds are stored, the same as with cash. This is so that</span>
<a name="l01836"></a>01836 <span class="comment">// stashed funds will show up properly on an audit.</span>
<a name="l01837"></a>01837 <span class="comment">//</span>
<a name="l01838"></a><a class="code" href="class_o_t_smart_contract.html#a7be637de24a11ebd872822b84952c21a">01838</a> <span class="keywordtype">bool</span> <a class="code" href="class_o_t_smart_contract.html#a7be637de24a11ebd872822b84952c21a">OTSmartContract::UnstashAcctFunds</a>(<span class="keyword">const</span> std::string to_acct_name, <span class="keyword">const</span> std::string from_stash_name, <span class="keyword">const</span> std::string str_Amount)
<a name="l01839"></a>01839 {
<a name="l01840"></a>01840     <a class="code" href="class_o_t_cron.html">OTCron</a> * pCron  = <a class="code" href="class_o_t_cron_item.html#af734ad5d309fcc9b4a60d40d6c30f55a">GetCron</a>();
<a name="l01841"></a>01841     <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != pCron);
<a name="l01842"></a>01842     <span class="comment">// ----------------------------------</span>
<a name="l01843"></a>01843     <a class="code" href="class_o_t_pseudonym.html">OTPseudonym</a> * pServerNym = pCron-&gt;<a class="code" href="class_o_t_cron.html#a7756d0dcc047209ca87632939dc11db3">GetServerNym</a>();
<a name="l01844"></a>01844     <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != pServerNym);
<a name="l01845"></a>01845     <span class="comment">// ---------------------------------------------------</span>
<a name="l01846"></a>01846     <span class="comment">// Below this point, these are all good:</span>
<a name="l01847"></a>01847     <span class="comment">//</span>
<a name="l01848"></a>01848     <span class="comment">//      pServerNym, pCron.</span>
<a name="l01849"></a>01849     <span class="comment">//</span>
<a name="l01850"></a>01850     <span class="comment">// ---------------------------------------------------</span>
<a name="l01851"></a>01851     <span class="keywordflow">if</span> (str_Amount.size() &lt; 1)
<a name="l01852"></a>01852     {
<a name="l01853"></a>01853         <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(0, <span class="stringliteral">&quot;OTSmartContract::UnstashAcctFunds: Error: empty amount.\n&quot;</span>);
<a name="l01854"></a>01854         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01855"></a>01855     }
<a name="l01856"></a>01856 
<a name="l01857"></a>01857     <span class="keyword">const</span> int64_t lAmount =  atol(str_Amount.c_str());
<a name="l01858"></a>01858 
<a name="l01859"></a>01859     <span class="keywordflow">if</span> (lAmount &lt;= 0)
<a name="l01860"></a>01860     {
<a name="l01861"></a>01861         <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(0, <span class="stringliteral">&quot;OTSmartContract::UnstashAcctFunds: Error: lAmount cannot be 0 or &lt;0. (Value passed in was %lld.)\n&quot;</span>,
<a name="l01862"></a>01862                        lAmount);
<a name="l01863"></a>01863         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01864"></a>01864     }
<a name="l01865"></a>01865     <span class="comment">// -----------------------------</span>
<a name="l01866"></a>01866     <span class="keywordflow">if</span> (to_acct_name.size() &lt;= 0)
<a name="l01867"></a>01867     {
<a name="l01868"></a>01868         <a class="code" href="class_o_t_log.html#a5acd90ac91c2618f395b0ff37ad4f8ee">OTLog::Error</a>(<span class="stringliteral">&quot;OTSmartContract::UnstashAcctFunds: error: to_acct_name is non-existent.\n&quot;</span>);
<a name="l01869"></a>01869         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01870"></a>01870     }
<a name="l01871"></a>01871     <span class="keywordflow">if</span> (from_stash_name.size() &lt;= 0)
<a name="l01872"></a>01872     {
<a name="l01873"></a>01873         <a class="code" href="class_o_t_log.html#a5acd90ac91c2618f395b0ff37ad4f8ee">OTLog::Error</a>(<span class="stringliteral">&quot;OTSmartContract::UnstashAcctFunds: error: from_stash_name is non-existent.\n&quot;</span>);
<a name="l01874"></a>01874         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01875"></a>01875     }
<a name="l01876"></a>01876     <span class="comment">// ---------------------------------------------------</span>
<a name="l01877"></a>01877     <span class="comment">// Below this point, these are all good:</span>
<a name="l01878"></a>01878     <span class="comment">//</span>
<a name="l01879"></a>01879     <span class="comment">//      to_acct_name,</span>
<a name="l01880"></a>01880     <span class="comment">//      from_stash_name,</span>
<a name="l01881"></a>01881     <span class="comment">//      pServerNym, pCron.</span>
<a name="l01882"></a>01882     <span class="comment">//</span>
<a name="l01883"></a>01883     <span class="comment">// ---------------------------------------------------</span>
<a name="l01884"></a>01884 
<a name="l01885"></a>01885     <a class="code" href="class_o_t_party_account.html">OTPartyAccount</a>  * pToAcct   = this-&gt;<a class="code" href="class_o_t_scriptable.html#a94c9e55f78357e04e4b9781ab662370f">GetPartyAccount</a>(to_acct_name);
<a name="l01886"></a>01886     <a class="code" href="class_o_t_stash.html">OTStash</a>         * pStash    = this-&gt;<a class="code" href="class_o_t_smart_contract.html#af7305d13e0ac4c2bef284658bdd9ec67">GetStash</a>(from_stash_name); <span class="comment">// This ALWAYS succeeds. (It will OT_ASSERT() if failure.)</span>
<a name="l01887"></a>01887 
<a name="l01888"></a>01888     <span class="keywordflow">if</span> (NULL == pToAcct)
<a name="l01889"></a>01889     {
<a name="l01890"></a>01890         <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(0, <span class="stringliteral">&quot;OTSmartContract::UnstashAcctFunds: error: to_acct (%s) not found on any party.\n&quot;</span>,
<a name="l01891"></a>01891                        to_acct_name.c_str());
<a name="l01892"></a>01892         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01893"></a>01893     }
<a name="l01894"></a>01894     <span class="comment">// ---------------------------------------------------</span>
<a name="l01895"></a>01895     <span class="comment">//</span>
<a name="l01896"></a>01896     <span class="comment">// Below this point, these are all good:</span>
<a name="l01897"></a>01897     <span class="comment">//</span>
<a name="l01898"></a>01898     <span class="comment">//      pToAcct,    to_acct_name,</span>
<a name="l01899"></a>01899     <span class="comment">//      pStash,     from_stash_name,</span>
<a name="l01900"></a>01900     <span class="comment">//      pServerNym, pCron.</span>
<a name="l01901"></a>01901     <span class="comment">//</span>
<a name="l01902"></a>01902     <span class="comment">// ---------------------------------------------------</span>
<a name="l01903"></a>01903 
<a name="l01904"></a>01904     <a class="code" href="class_o_t_agent.html">OTAgent</a> * pToAgent  = pToAcct-&gt; GetAuthorizedAgent(); <span class="comment">// This searches the account&#39;s party for the account&#39;s authorized agent.</span>
<a name="l01905"></a>01905     <span class="comment">// (That way it&#39;s impossible to get an agent for any other party.)</span>
<a name="l01906"></a>01906 
<a name="l01907"></a>01907     <span class="keywordflow">if</span> (NULL == pToAgent)
<a name="l01908"></a>01908     {
<a name="l01909"></a>01909         <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(0, <span class="stringliteral">&quot;OTSmartContract::UnstashAcctFunds: error: authorized agent (%s) not found for to_acct (%s) on acct&#39;s party.\n&quot;</span>,
<a name="l01910"></a>01910                        pToAcct-&gt;<a class="code" href="class_o_t_party_account.html#a86975046b18ac6d6c5841f5ba0befe69">GetAgentName</a>().<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>(), to_acct_name.c_str());
<a name="l01911"></a>01911         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01912"></a>01912     }
<a name="l01913"></a>01913     <span class="comment">// ---------</span>
<a name="l01914"></a>01914     <span class="keywordflow">if</span> (<span class="keyword">false</span> == pToAgent-&gt;<a class="code" href="class_o_t_agent.html#a1969e4f8a5f13ee34ba0a68d8f082956">IsAnIndividual</a>())
<a name="l01915"></a>01915     {
<a name="l01916"></a>01916         <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(0, <span class="stringliteral">&quot;OTSmartContract::UnstashAcctFunds: error: authorized agent (%s) for to_acct (%s) is not an active agent.\n&quot;</span>,
<a name="l01917"></a>01917                        pToAcct-&gt;<a class="code" href="class_o_t_party_account.html#a86975046b18ac6d6c5841f5ba0befe69">GetAgentName</a>().<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>(), to_acct_name.c_str());
<a name="l01918"></a>01918         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01919"></a>01919     }
<a name="l01920"></a>01920     <span class="comment">//</span>
<a name="l01921"></a>01921     <span class="comment">// Below this point, these are all good:</span>
<a name="l01922"></a>01922     <span class="comment">//</span>
<a name="l01923"></a>01923     <span class="comment">//      pToAcct,    to_acct_name,       pToAgent,</span>
<a name="l01924"></a>01924     <span class="comment">//      pStash,     from_stash_name,</span>
<a name="l01925"></a>01925     <span class="comment">//      pServerNym, pCron.</span>
<a name="l01926"></a>01926     <span class="comment">//</span>
<a name="l01927"></a>01927     <span class="comment">// ---------------------------------------------------</span>
<a name="l01928"></a>01928 
<a name="l01929"></a>01929     <a class="code" href="class_o_t_party.html">OTParty</a> * pToParty  = pToAgent-&gt;<a class="code" href="class_o_t_agent.html#a929a2489984f5487bd1819ed6d8862f2">GetParty</a>();
<a name="l01930"></a>01930 
<a name="l01931"></a>01931     <span class="keywordflow">if</span> (NULL == pToParty)
<a name="l01932"></a>01932     {
<a name="l01933"></a>01933         <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;OTSmartContract::UnstashAcctFunds: error: Party pointer NULL on authorized agent (%s) for to_acct (%s).\n&quot;</span>,
<a name="l01934"></a>01934                       pToAcct-&gt;<a class="code" href="class_o_t_party_account.html#a86975046b18ac6d6c5841f5ba0befe69">GetAgentName</a>().<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>(), to_acct_name.c_str());
<a name="l01935"></a>01935         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01936"></a>01936     }
<a name="l01937"></a>01937     <span class="comment">//</span>
<a name="l01938"></a>01938     <span class="comment">// Below this point, these are all good:</span>
<a name="l01939"></a>01939     <span class="comment">//</span>
<a name="l01940"></a>01940     <span class="comment">//      pToAcct,    to_acct_name,       pToAgent,   pToParty,</span>
<a name="l01941"></a>01941     <span class="comment">//      pStash,     from_stash_name,</span>
<a name="l01942"></a>01942     <span class="comment">//      pServerNym, pCron.</span>
<a name="l01943"></a>01943     <span class="comment">//</span>
<a name="l01944"></a>01944     <span class="comment">// ---------------------------------------------------</span>
<a name="l01945"></a>01945 
<a name="l01946"></a>01946 
<a name="l01947"></a>01947     <span class="comment">// Done: I can see that THIS VERIFICATION CODE WILL GET CALLED EVERY SINGLE TIME THE SCRIPT</span>
<a name="l01948"></a>01948     <span class="comment">// CALLS MOVE FUNDS.  Maybe that&#39;s good, but since technically this only needs to be verified before the</span>
<a name="l01949"></a>01949     <span class="comment">// first call, and not for EVERY call during any of a script&#39;s runs, I should probably move this verification</span>
<a name="l01950"></a>01950     <span class="comment">// higher, such as each time the OTCronItem triggers, plus each time a party triggers a clause directly</span>
<a name="l01951"></a>01951     <span class="comment">// through the API (server message). As long as those are covered, I will be able to remove it from here</span>
<a name="l01952"></a>01952     <span class="comment">// which should be a significant improvement for performance.</span>
<a name="l01953"></a>01953     <span class="comment">// It will be at the bottom of those same functions that &quot;ClearTemporaryPointers()&quot; should finally be called.</span>
<a name="l01954"></a>01954     <span class="comment">//</span>
<a name="l01955"></a>01955     <span class="comment">// FINAL DECISION: Redundant, removed. See comments in StashAcctFunds().</span>
<a name="l01956"></a>01956     <span class="comment">//</span>
<a name="l01957"></a>01957 <span class="comment">//  const OTString strServerID(GetServerID());</span>
<a name="l01958"></a>01958 <span class="comment">//</span>
<a name="l01959"></a>01959 <span class="comment">//  mapOfNyms   map_Nyms_Already_Loaded;</span>
<a name="l01960"></a>01960 <span class="comment">//  this-&gt;RetrieveNymPointers(map_Nyms_Already_Loaded);</span>
<a name="l01961"></a>01961 <span class="comment">//  // --------------------------------------------------</span>
<a name="l01962"></a>01962 <span class="comment">//</span>
<a name="l01963"></a>01963 <span class="comment">//  if (false == this-&gt;VerifyPartyAuthorization(*pToParty, *pServerNym, strServerID, &amp;map_Nyms_Already_Loaded))</span>
<a name="l01964"></a>01964 <span class="comment">//  {</span>
<a name="l01965"></a>01965 <span class="comment">//      OTLog::vError(&quot;OTSmartContract::UnstashAcctFunds: error: &#39;To&#39; Party (%s) not authorized for this contract.\n&quot;,</span>
<a name="l01966"></a>01966 <span class="comment">//                    pToParty-&gt;GetPartyName().c_str());</span>
<a name="l01967"></a>01967 <span class="comment">//      return false;</span>
<a name="l01968"></a>01968 <span class="comment">//  }</span>
<a name="l01969"></a>01969     <span class="comment">// *****************************************************************************</span>
<a name="l01970"></a>01970 
<a name="l01971"></a>01971     <span class="comment">// A party might have many agents who are only voting groups, and cannot actually sign for things</span>
<a name="l01972"></a>01972     <span class="comment">// the way that nyms can. But at least ONE of those agents IS a Nym -- because there must have been</span>
<a name="l01973"></a>01973     <span class="comment">// an authorizing agent who initially signed to accept the agreement, and who fronted the opening</span>
<a name="l01974"></a>01974     <span class="comment">// transaction number that activated it.</span>
<a name="l01975"></a>01975     <span class="comment">//</span>
<a name="l01976"></a>01976     <span class="comment">// Similarly, the authorized agent for any given party&#39;s account (each account has its own authorized</span>
<a name="l01977"></a>01977     <span class="comment">// agent) MUST be an active agent (an active agent is one with a Nym--whether that Nym is representing</span>
<a name="l01978"></a>01978     <span class="comment">// himself as the party, or whether representing some entity as an employee in a role). Why MUST the</span>
<a name="l01979"></a>01979     <span class="comment">// authorized agent be an active agent? Because when funds are moved, that Nym must be loaded since</span>
<a name="l01980"></a>01980     <span class="comment">// the account must show that Nym as a legal owner/agent. The MoveFunds will cause a paymentReceipt to</span>
<a name="l01981"></a>01981     <span class="comment">// drop into the Inbox for the relevant asset accounts, and that paymentReceipt can ONLY be accepted</span>
<a name="l01982"></a>01982     <span class="comment">// by that same Nym, who must use a transaction # that he signed for previously and received through</span>
<a name="l01983"></a>01983     <span class="comment">// his nymbox. There is actually no justification at all to take funds from that account, since the</span>
<a name="l01984"></a>01984     <span class="comment">// new balance has not yet been signed, UNLESS THE PAYMENTRECEIPT CONTAINS A VALID, SIGNED AUTHORIZATION</span>
<a name="l01985"></a>01985     <span class="comment">// FROM THE ACCOUNT HOLDER. *That* is why the authorizing agent must either be the Party&#39;s Owner himself</span>
<a name="l01986"></a>01986     <span class="comment">// (representing himself as an agent, which most will do) in which case he will appear as the valid</span>
<a name="l01987"></a>01987     <span class="comment">// owner of the account, OR he MUST be a Nym working in a Valid Role for an Entity, where said Entity is</span>
<a name="l01988"></a>01988     <span class="comment">// the valid owner on the account in question. Either OT, it will be possible in OT for him to sign for</span>
<a name="l01989"></a>01989     <span class="comment">// the paymentReceipts when they come in, and impossible for him to escape liability for them.</span>
<a name="l01990"></a>01990     <span class="comment">// (That&#39;s the idea anyway.)</span>
<a name="l01991"></a>01991     <span class="comment">//</span>
<a name="l01992"></a>01992     <span class="comment">// Since we know that the Authorized Agent for an account must be an ACTIVE agent (one way or the other)</span>
<a name="l01993"></a>01993     <span class="comment">// then we can error out here if he&#39;s not.  We can then pass in his Nym ID.</span>
<a name="l01994"></a>01994     <span class="comment">//</span>
<a name="l01995"></a>01995 
<a name="l01996"></a>01996     <a class="code" href="class_o_t_identifier.html">OTIdentifier</a> theToAgentID;
<a name="l01997"></a>01997     <span class="keyword">const</span> <span class="keywordtype">bool</span> bToAgentID   = pToAgent-&gt;<a class="code" href="class_o_t_agent.html#a7750c7f5840047c5413d95e92ad87578">GetSignerID</a>(theToAgentID);
<a name="l01998"></a>01998 
<a name="l01999"></a>01999     <span class="keywordflow">if</span> ( ! bToAgentID )
<a name="l02000"></a>02000     {
<a name="l02001"></a>02001         <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;OTSmartContract::UnstashAcctFunds: Failed to find &#39;To&#39; Agent&#39;s Signer ID: %s \n&quot;</span>,
<a name="l02002"></a>02002                       pToAgent-&gt;<a class="code" href="class_o_t_agent.html#a123d27f05e46977ecdbe0b83de3c119d">GetName</a>().<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>());
<a name="l02003"></a>02003         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02004"></a>02004     }
<a name="l02005"></a>02005     <span class="comment">// --------------------------------------</span>
<a name="l02006"></a>02006 
<a name="l02007"></a>02007     <span class="keywordflow">if</span> (!pToAcct-&gt;<a class="code" href="class_o_t_party_account.html#aa5e4e0cc77853d08b3708017fe694876">GetAcctID</a>().<a class="code" href="class_o_t_string.html#adf7489cd917d4ae5bf30853a3ad78daf">Exists</a>())
<a name="l02008"></a>02008     {
<a name="l02009"></a>02009         <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;OTSmartContract::UnstashAcctFunds: Error: ToAcct has empty AcctID: %s \n&quot;</span>,
<a name="l02010"></a>02010                       to_acct_name.c_str());
<a name="l02011"></a>02011         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02012"></a>02012     }
<a name="l02013"></a>02013 
<a name="l02014"></a>02014     <span class="keyword">const</span> <a class="code" href="class_o_t_identifier.html">OTIdentifier</a> theToAcctID(pToAcct-&gt;<a class="code" href="class_o_t_party_account.html#aa5e4e0cc77853d08b3708017fe694876">GetAcctID</a>());
<a name="l02015"></a>02015     <span class="comment">//</span>
<a name="l02016"></a>02016     <span class="comment">// BELOW THIS POINT, theToAcctID and theToAgentID available.</span>
<a name="l02017"></a>02017     <span class="comment">// --------------------------------------</span>
<a name="l02018"></a>02018 
<a name="l02019"></a>02019     <span class="comment">// WE SET THESE HERE SO THE RECEIPT SHOWS, SUCCESS OR FAIL,</span>
<a name="l02020"></a>02020     <span class="comment">// WHO THE INTENDED SENDER / RECIPIENT ARE FOR THAT RECEIPT.</span>
<a name="l02021"></a>02021     <span class="comment">//</span>
<a name="l02022"></a>02022     <a class="code" href="class_o_t_smart_contract.html#a09de789ac2e616e2119feb9ddf416c9d">ReleaseLastSenderRecipientIDs</a>();
<a name="l02023"></a>02023     <span class="comment">// -------------------------</span>
<a name="l02024"></a>02024 <span class="comment">//  theFromAgentID.GetString(m_strLastSenderUser);  // This is the last User ID of a party who SENT money.</span>
<a name="l02025"></a>02025 <span class="comment">//  theFromAcctID.GetString(m_strLastSenderAcct);   // This is the last Acct ID of a party who SENT money.</span>
<a name="l02026"></a>02026     theToAgentID.<a class="code" href="class_o_t_identifier.html#a4bccb30446b4b515d9d6016b86b260bb">GetString</a>(m_strLastRecipientUser); <span class="comment">// This is the last User ID of a party who RECEIVED money.</span>
<a name="l02027"></a>02027     theToAcctID.GetString(m_strLastRecipientAcct);  <span class="comment">// This is the last Acct ID of a party who RECEIVED money.</span>
<a name="l02028"></a>02028     <span class="comment">// Above: the FromAgent and FromAcct are commented out,</span>
<a name="l02029"></a>02029     <span class="comment">// since the funds are coming from a stash.</span>
<a name="l02030"></a>02030     <span class="comment">// ----------------------------------------------------------</span>
<a name="l02031"></a>02031 
<a name="l02032"></a>02032     <span class="keyword">const</span> int64_t lNegativeAmount = (lAmount * (-1));
<a name="l02033"></a>02033 
<a name="l02034"></a>02034     <a class="code" href="_o_t_agent_8hpp.html#ac89892658f6bc83e354078647b704e8f">mapOfNyms</a>   map_Nyms_Already_Loaded;
<a name="l02035"></a>02035     this-&gt;<a class="code" href="class_o_t_scriptable.html#a9e41bb939fd5dbfe1f2442e5919a5079">RetrieveNymPointers</a>(map_Nyms_Already_Loaded);
<a name="l02036"></a>02036 
<a name="l02037"></a>02037 
<a name="l02038"></a>02038 <span class="comment">//  OTLog::vError(&quot;OTSmartContract::UnstashAcctFunds: DEBUGGING: lAmount is %lld.\n&quot;, lNegativeAmount);</span>
<a name="l02039"></a>02039 
<a name="l02040"></a>02040 
<a name="l02041"></a>02041     <span class="keywordtype">bool</span> bMoved = this-&gt;<a class="code" href="class_o_t_smart_contract.html#abaebc7e1d2416290139c883698c91025">StashFunds</a>(map_Nyms_Already_Loaded,
<a name="l02042"></a>02042                                    lNegativeAmount,
<a name="l02043"></a>02043                                    theToAcctID, theToAgentID,
<a name="l02044"></a>02044                                    *pStash);
<a name="l02045"></a>02045     <span class="keywordflow">if</span> (!bMoved)
<a name="l02046"></a>02046     {
<a name="l02047"></a>02047         <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(0, <span class="stringliteral">&quot;OTSmartContract::UnstashAcctFunds: Failed in final call. Values: to_acct: %s, from_stash: %s, lAmount: %lld. \n&quot;</span>,
<a name="l02048"></a>02048                       to_acct_name.c_str(), from_stash_name.c_str(), lAmount);
<a name="l02049"></a>02049         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02050"></a>02050     }
<a name="l02051"></a>02051 
<a name="l02052"></a>02052     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l02053"></a>02053 }
<a name="l02054"></a>02054 
<a name="l02055"></a>02055 
<a name="l02056"></a>02056 <span class="comment">// OTSmartContract::StashFunds is lower-level; it&#39;s used inside StashAcctFunds()</span>
<a name="l02057"></a>02057 <span class="comment">// and UnstashAcctFunds(). (Similarly to how OTCronItem::MoveFunds() is used in-</span>
<a name="l02058"></a>02058 <span class="comment">// side OTSmartContract::MoveAcctFunds().</span>
<a name="l02059"></a>02059 <span class="comment">//</span>
<a name="l02060"></a>02060 <span class="comment">// true == success, false == failure.</span>
<a name="l02061"></a>02061 <span class="comment">//</span>
<a name="l02062"></a><a class="code" href="class_o_t_smart_contract.html#abaebc7e1d2416290139c883698c91025">02062</a> <span class="keywordtype">bool</span> <a class="code" href="class_o_t_smart_contract.html#abaebc7e1d2416290139c883698c91025">OTSmartContract::StashFunds</a>(<span class="keyword">const</span> <a class="code" href="_o_t_agent_8hpp.html#ac89892658f6bc83e354078647b704e8f">mapOfNyms</a>    &amp;   map_NymsAlreadyLoaded,
<a name="l02063"></a>02063                                  <span class="keyword">const</span> int64_t          &amp;   lAmount,    <span class="comment">// negative amount here means UNstash. Positive means STASH.</span>
<a name="l02064"></a>02064                                  <span class="keyword">const</span> <a class="code" href="class_o_t_identifier.html">OTIdentifier</a> &amp;   PARTY_ACCT_ID,
<a name="l02065"></a>02065                                  <span class="keyword">const</span> <a class="code" href="class_o_t_identifier.html">OTIdentifier</a> &amp;   PARTY_USER_ID,
<a name="l02066"></a>02066                                        <a class="code" href="class_o_t_stash.html">OTStash</a>      &amp;   theStash)
<a name="l02067"></a>02067 {
<a name="l02068"></a>02068     <a class="code" href="class_o_t_cron.html">OTCron</a> * pCron = <a class="code" href="class_o_t_cron_item.html#af734ad5d309fcc9b4a60d40d6c30f55a">GetCron</a>();
<a name="l02069"></a>02069     <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != pCron);
<a name="l02070"></a>02070 
<a name="l02071"></a>02071     <a class="code" href="class_o_t_pseudonym.html">OTPseudonym</a> * pServerNym = pCron-&gt;<a class="code" href="class_o_t_cron.html#a7756d0dcc047209ca87632939dc11db3">GetServerNym</a>();
<a name="l02072"></a>02072     <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != pServerNym);
<a name="l02073"></a>02073     <span class="comment">// --------------------------------------------------------</span>
<a name="l02074"></a>02074     <span class="keywordflow">if</span> (0 == lAmount)
<a name="l02075"></a>02075     {
<a name="l02076"></a>02076         <a class="code" href="class_o_t_log.html#a1f7549d776ee919dcb6517f611ded015">OTLog::Output</a>(0, <span class="stringliteral">&quot;OTSmartContract::StashFunds: a zero amount is not allowed.\n&quot;</span>);
<a name="l02077"></a>02077         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02078"></a>02078     }
<a name="l02079"></a>02079     <span class="comment">// --------------------------------------------------------</span>
<a name="l02080"></a>02080     <span class="keyword">const</span> <a class="code" href="class_o_t_identifier.html">OTIdentifier</a>  SERVER_ID(pCron-&gt;<a class="code" href="class_o_t_cron.html#a93b52f56c0de94e53bb05a610830ba4b">GetServerID</a>());
<a name="l02081"></a>02081     <span class="keyword">const</span> <a class="code" href="class_o_t_identifier.html">OTIdentifier</a>  SERVER_USER_ID(*pServerNym);
<a name="l02082"></a>02082     <span class="comment">// --------------------------------------------------------</span>
<a name="l02083"></a>02083     <span class="comment">// Load up the party&#39;s account and get the asset type, so we know which stash to get off the stash.</span>
<a name="l02084"></a>02084     <span class="comment">//</span>
<a name="l02085"></a>02085     <a class="code" href="class_o_t_account.html">OTAccount</a> * pPartyAssetAcct = <a class="code" href="class_o_t_account.html#a6574057f6e3415546d3a9f7d7e445e4f">OTAccount::LoadExistingAccount</a>(PARTY_ACCT_ID, SERVER_ID);
<a name="l02086"></a>02086 
<a name="l02087"></a>02087     <span class="keywordflow">if</span> (NULL == pPartyAssetAcct)
<a name="l02088"></a>02088     {
<a name="l02089"></a>02089         <a class="code" href="class_o_t_log.html#a1f7549d776ee919dcb6517f611ded015">OTLog::Output</a>(0, <span class="stringliteral">&quot;OTSmartContract::StashFunds: ERROR verifying existence of source account.\n&quot;</span>);
<a name="l02090"></a>02090         <a class="code" href="class_o_t_cron_item.html#a34c87380d2f8cd419c9a5cfec86427b4">FlagForRemoval</a>(); <span class="comment">// Remove it from future Cron processing, please.</span>
<a name="l02091"></a>02091         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02092"></a>02092     }
<a name="l02093"></a>02093     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!pPartyAssetAcct-&gt;<a class="code" href="class_o_t_contract.html#a38f51d593b6dfc8a75d1c5a535965392">VerifySignature</a>(*pServerNym))
<a name="l02094"></a>02094     {
<a name="l02095"></a>02095         <a class="code" href="class_o_t_log.html#a1f7549d776ee919dcb6517f611ded015">OTLog::Output</a>(0, <span class="stringliteral">&quot;OTSmartContract::StashFunds: ERROR failed to verify the server&#39;s signature on the party&#39;s account.\n&quot;</span>);
<a name="l02096"></a>02096         <a class="code" href="class_o_t_cron_item.html#a34c87380d2f8cd419c9a5cfec86427b4">FlagForRemoval</a>(); <span class="comment">// Remove it from future Cron processing, please.</span>
<a name="l02097"></a>02097         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02098"></a>02098     }
<a name="l02099"></a>02099     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!pPartyAssetAcct-&gt;<a class="code" href="class_o_t_account.html#a4b6aa9e72c2ad3e395f9fe6cea00dd4d">VerifyOwnerByID</a>(PARTY_USER_ID))
<a name="l02100"></a>02100     {
<a name="l02101"></a>02101         <a class="code" href="class_o_t_log.html#a1f7549d776ee919dcb6517f611ded015">OTLog::Output</a>(0, <span class="stringliteral">&quot;OTSmartContract::StashFunds: ERROR failed to verify party user ownership of party account.\n&quot;</span>);
<a name="l02102"></a>02102         <a class="code" href="class_o_t_cron_item.html#a34c87380d2f8cd419c9a5cfec86427b4">FlagForRemoval</a>(); <span class="comment">// Remove it from future Cron processing, please.</span>
<a name="l02103"></a>02103         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02104"></a>02104     }
<a name="l02105"></a>02105     <span class="comment">// Past this point we know pPartyAssetAcct is good and will clean itself up.</span>
<a name="l02106"></a>02106     <a class="code" href="class_o_t_cleanup.html">OTCleanup&lt;OTAccount&gt;</a>    theSourceAcctSmrtPtr(*pPartyAssetAcct);
<a name="l02107"></a>02107     <span class="comment">// -----------------------------------------------------------------</span>
<a name="l02108"></a>02108     <span class="comment">//</span>
<a name="l02109"></a>02109     <span class="comment">// There could be many stashes, each with a name. (One was passed in here...)</span>
<a name="l02110"></a>02110     <span class="comment">// And inside each one is a stash for each asset type. So let&#39;s get the one</span>
<a name="l02111"></a>02111     <span class="comment">// for the asset type matching the party&#39;s account.</span>
<a name="l02112"></a>02112     <span class="comment">//</span>
<a name="l02113"></a>02113     <span class="keyword">const</span> <a class="code" href="class_o_t_string.html">OTString</a>          strAssetTypeID(pPartyAssetAcct-&gt;<a class="code" href="class_o_t_account.html#a3b933b8c929e071a68ec4a29ad5797d6">GetAssetTypeID</a>());
<a name="l02114"></a>02114     <span class="keyword">const</span> std::string       str_asset_type_id = strAssetTypeID.<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>();
<a name="l02115"></a>02115 
<a name="l02116"></a>02116     <a class="code" href="class_o_t_stash_item.html">OTStashItem</a> * pStashItem = theStash.<a class="code" href="class_o_t_stash.html#a21bdce4995350ae964704ad6662a0035">GetStash</a>(str_asset_type_id);
<a name="l02117"></a>02117     <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != pStashItem); <span class="comment">// should never happen. Creates if non-existent.</span>
<a name="l02118"></a>02118     <span class="comment">// -----------------------------------------------------------------------</span>
<a name="l02119"></a>02119     <span class="comment">// Below this point, pStashItem is good, and has the right asset_type_id.</span>
<a name="l02120"></a>02120     <span class="comment">// --------------------------------------------------------</span>
<a name="l02121"></a>02121     <span class="comment">//</span>
<a name="l02122"></a>02122     <span class="keyword">const</span> <span class="keywordtype">bool</span> bUnstashing      = (lAmount &lt; 0); <span class="comment">// If the amount is negative, then we&#39;re UNSTASHING.</span>
<a name="l02123"></a>02123     <span class="keyword">const</span> int64_t lAbsoluteAmount   = bUnstashing ? (lAmount*(-1)) : lAmount;   <span class="comment">// NEGATIVE AMOUNT SHOULD BEHAVE AS &quot;UNSTASH FUNDS&quot; !!</span>
<a name="l02124"></a>02124 
<a name="l02125"></a>02125     <span class="comment">// Normally if you stash 10 clams, then your account is -10 clams, and your stash is +10 clams.</span>
<a name="l02126"></a>02126     <span class="comment">// Therefore if you unstash 5 gg, then your gg acct is +5 grams and your stash is -5 grams.</span>
<a name="l02127"></a>02127     <span class="comment">//</span>
<a name="l02128"></a>02128     <span class="comment">// Thus if lAmount is &gt; 0, as normal, that amount should be DEBITED from the Party Acct, and CREDITED to the Stash Acct.</span>
<a name="l02129"></a>02129     <span class="comment">// Whereas if lAmount were &lt; 0, then that amount should be DEBITED from the Stash Acct, and CREDITED to the Party Acct.</span>
<a name="l02130"></a>02130     <span class="comment">// ------------------------------------------------------------------</span>
<a name="l02131"></a>02131 
<a name="l02132"></a>02132     <span class="comment">// Below this point, lAbsoluteAmount is always a positive number.</span>
<a name="l02133"></a>02133     <span class="comment">// Whereas if lAmount &lt; 0, that means we are doing an UNSTASH in this function.</span>
<a name="l02134"></a>02134     <span class="comment">//</span>
<a name="l02135"></a>02135     <span class="comment">// -------------------------------</span>
<a name="l02136"></a>02136 
<a name="l02137"></a>02137     <span class="comment">// Whether the funds are coming from the party&#39;s acct, or from the stash, WHEREVER they</span>
<a name="l02138"></a>02138     <span class="comment">// are coming from, is that source LARGE enough to accommodate the amount we&#39;re trying to move?</span>
<a name="l02139"></a>02139     <span class="comment">//</span>
<a name="l02140"></a>02140 
<a name="l02141"></a>02141     <span class="keyword">const</span> int64_t lPartyAssetBalance    = pPartyAssetAcct-&gt;<a class="code" href="class_o_t_account.html#a77fbaae9496caec7cd899721971a89c0">GetBalance</a>();
<a name="l02142"></a>02142     <span class="keyword">const</span> int64_t lStashItemAmount      = pStashItem-&gt;<a class="code" href="class_o_t_stash_item.html#a74c88fa90fafada9e6e44c46174381dd">GetAmount</a>();
<a name="l02143"></a>02143 
<a name="l02144"></a>02144     <span class="keyword">const</span> int64_t lSourceAmount = bUnstashing ? lStashItemAmount : lPartyAssetBalance;
<a name="l02145"></a>02145 
<a name="l02146"></a>02146     <span class="comment">// If the source, minus amount, is less than 0, then it CANNOT accommodate the action.</span>
<a name="l02147"></a>02147     <span class="comment">//</span>
<a name="l02148"></a>02148     <span class="keywordflow">if</span> ((lSourceAmount - lAbsoluteAmount) &lt; 0)
<a name="l02149"></a>02149     {
<a name="l02150"></a>02150         <a class="code" href="class_o_t_log.html#a1f7549d776ee919dcb6517f611ded015">OTLog::Output</a>(0, <span class="stringliteral">&quot;OTSmartContract::StashFunds: Not enough funds available in the source to accommodate this action.\n&quot;</span>);
<a name="l02151"></a>02151         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02152"></a>02152     }
<a name="l02153"></a>02153     <span class="comment">// ------------------------------------------------------</span>
<a name="l02154"></a>02154     <span class="comment">// Load up the actual Stash ACCOUNT</span>
<a name="l02155"></a>02155     <span class="comment">//</span>
<a name="l02156"></a>02156 <span class="preprocessor">#ifndef OT_USE_TR1</span>
<a name="l02157"></a>02157 <span class="preprocessor"></span>    _SharedPtr&lt;OTAccount&gt; pStashAccount(NULL);
<a name="l02158"></a>02158 <span class="preprocessor">#else</span>
<a name="l02159"></a>02159 <span class="preprocessor"></span>    _SharedPtr&lt;OTAccount&gt; pStashAccount;
<a name="l02160"></a>02160 <span class="preprocessor">#endif</span>
<a name="l02161"></a>02161 <span class="preprocessor"></span>
<a name="l02162"></a>02162     <span class="keywordtype">bool</span> bWasAcctCreated = <span class="keyword">false</span>;   <span class="comment">// GetOrCreateAccount() will verifyContractID and verifySignature on the account internally.</span>
<a name="l02163"></a>02163     pStashAccount = m_StashAccts.<a class="code" href="class_o_t_acct_list.html#ad525fafc311107c6a158030c3d429538">GetOrCreateAccount</a>(*pServerNym, SERVER_USER_ID, pPartyAssetAcct-&gt;<a class="code" href="class_o_t_account.html#a3b933b8c929e071a68ec4a29ad5797d6">GetAssetTypeID</a>(),
<a name="l02164"></a>02164                                                     SERVER_ID, bWasAcctCreated, <a class="code" href="class_o_t_trackable.html#a2594d320e3b24f3210bd38a08de66a70">GetTransactionNum</a>());
<a name="l02165"></a>02165 
<a name="l02166"></a>02166     <span class="keywordflow">if</span> (!pStashAccount) { <a class="code" href="_o_t_assert_8hpp.html#aa86aeed4e57eecded96d5955b5cc23c5">OT_FAIL_MSG</a>(<span class="stringliteral">&quot;ASSERT in OTSmartContract::StashFunds: returned NULL pointer (should never happen.)\n&quot;</span>); }
<a name="l02167"></a>02167 
<a name="l02168"></a>02168     <span class="keywordflow">if</span> (bWasAcctCreated)
<a name="l02169"></a>02169     {
<a name="l02170"></a>02170         <a class="code" href="class_o_t_string.html">OTString</a> strAcctID;
<a name="l02171"></a>02171         pStashAccount-&gt;GetIdentifier(strAcctID);
<a name="l02172"></a>02172 
<a name="l02173"></a>02173         <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(0, <span class="stringliteral">&quot;OTSmartContract::StashFunds: Successfully created stash account ID: %s\n (Stash acct has Asset Type ID: %s) \n&quot;</span>,
<a name="l02174"></a>02174                        strAcctID.<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>(), strAssetTypeID.Get());
<a name="l02175"></a>02175 
<a name="l02176"></a>02176         <span class="comment">// Todo: Some kind of save here?</span>
<a name="l02177"></a>02177         <span class="comment">// It&#39;s kind of unnecessary, since I&#39;ve already verified that there&#39;s enough funds at the source</span>
<a name="l02178"></a>02178         <span class="comment">// to successfully do the transfer, AND I will already save at the end of this call, since funds are</span>
<a name="l02179"></a>02179         <span class="comment">// being moved.</span>
<a name="l02180"></a>02180     }
<a name="l02181"></a>02181 
<a name="l02182"></a>02182     <span class="keywordflow">if</span> (!pStashAccount) { <a class="code" href="_o_t_assert_8hpp.html#aa86aeed4e57eecded96d5955b5cc23c5">OT_FAIL_MSG</a>(<span class="stringliteral">&quot;ASSERT in OTSmartContract::StashFunds: returned NULL pointer (should never happen.)\n&quot;</span>); }
<a name="l02183"></a>02183 
<a name="l02184"></a>02184     <span class="comment">// ------------------------------------------------------------</span>
<a name="l02185"></a>02185     <span class="comment">//</span>
<a name="l02186"></a>02186     <span class="comment">// This code is similar to above, but it checks the stash ACCT itself instead of the stash entry.</span>
<a name="l02187"></a>02187     <span class="comment">//</span>
<a name="l02188"></a>02188     <span class="comment">// Whether the funds are coming from the party&#39;s acct, or from the stash acct, WHEREVER they</span>
<a name="l02189"></a>02189     <span class="comment">// are coming from, is that source LARGE enough to accommodate the amount we&#39;re trying to move?</span>
<a name="l02190"></a>02190     <span class="comment">//</span>
<a name="l02191"></a>02191     <span class="keyword">const</span> int64_t lSourceAmount2 = bUnstashing ? pStashAccount-&gt;GetBalance() : pPartyAssetAcct-&gt;<a class="code" href="class_o_t_account.html#a77fbaae9496caec7cd899721971a89c0">GetBalance</a>();
<a name="l02192"></a>02192 
<a name="l02193"></a>02193 
<a name="l02194"></a>02194     <span class="comment">// If the source, minus amount, is less than 0, then it CANNOT accommodate the action.</span>
<a name="l02195"></a>02195     <span class="comment">//</span>
<a name="l02196"></a>02196     <span class="keywordflow">if</span> ((lSourceAmount2 - lAbsoluteAmount) &lt; 0)
<a name="l02197"></a>02197     {
<a name="l02198"></a>02198         <a class="code" href="class_o_t_log.html#a1f7549d776ee919dcb6517f611ded015">OTLog::Output</a>(0, <span class="stringliteral">&quot;OTSmartContract::StashFunds: Not enough funds available in the stash acct to accommodate this action.\n&quot;</span>);
<a name="l02199"></a>02199         <span class="keywordflow">return</span> <span class="keyword">false</span>;   <span class="comment">// THIS SHOULD NEVER HAPPEN, SINCE WE ALREADY VERIFIED THE AMOUNT BEFORE LOADING THE ACCOUNT. FYI.</span>
<a name="l02200"></a>02200     }
<a name="l02201"></a>02201     <span class="comment">// ------------------------------------------------------</span>
<a name="l02202"></a>02202     <span class="comment">//</span>
<a name="l02203"></a>02203     <span class="comment">// Make sure they&#39;re not the same Account IDs ...</span>
<a name="l02204"></a>02204     <span class="comment">// Otherwise we would have to take care not to load them twice, like with the Nyms below.</span>
<a name="l02205"></a>02205     <span class="comment">// (Instead I just disallow it entirely. After all, even if I DID allow the account to transfer</span>
<a name="l02206"></a>02206     <span class="comment">// to itself, there would be no difference in balance than disallowing it.)</span>
<a name="l02207"></a>02207     <span class="comment">//</span>
<a name="l02208"></a>02208     <span class="keyword">const</span> <a class="code" href="class_o_t_identifier.html">OTIdentifier</a> STASH_ACCT_ID (pStashAccount-&gt;GetRealAccountID());
<a name="l02209"></a>02209 
<a name="l02210"></a>02210     <span class="keywordflow">if</span> (PARTY_ACCT_ID == STASH_ACCT_ID)
<a name="l02211"></a>02211     {
<a name="l02212"></a>02212         <a class="code" href="class_o_t_log.html#a5acd90ac91c2618f395b0ff37ad4f8ee">OTLog::Error</a>(<span class="stringliteral">&quot;OTSmartContract::StashFunds: ERROR: both account IDs were identical.\n&quot;</span>);
<a name="l02213"></a>02213         <a class="code" href="class_o_t_cron_item.html#a34c87380d2f8cd419c9a5cfec86427b4">FlagForRemoval</a>(); <span class="comment">// Remove from Cron</span>
<a name="l02214"></a>02214         <span class="keywordflow">return</span> <span class="keyword">false</span>; <span class="comment">// TODO: should have a &quot;Validate Scripts&quot; function that weeds this crap out before we even get here. (There are other examples...)</span>
<a name="l02215"></a>02215     }
<a name="l02216"></a>02216     <span class="comment">// -----------------------------------------------------------------</span>
<a name="l02217"></a>02217     <span class="comment">// SHOULD NEVER HAPPEN</span>
<a name="l02218"></a>02218     <span class="keywordflow">if</span> (pPartyAssetAcct-&gt;<a class="code" href="class_o_t_account.html#a3b933b8c929e071a68ec4a29ad5797d6">GetAssetTypeID</a>() != pStashAccount-&gt;GetAssetTypeID())
<a name="l02219"></a>02219     {
<a name="l02220"></a>02220         <a class="code" href="class_o_t_log.html#a5acd90ac91c2618f395b0ff37ad4f8ee">OTLog::Error</a>(<span class="stringliteral">&quot;OTSmartContract::StashFunds: Aborted stash: Asset type ID doesn&#39;t match. THIS SHOULD NEVER HAPPEN.\n&quot;</span>);
<a name="l02221"></a>02221         <a class="code" href="class_o_t_cron_item.html#a34c87380d2f8cd419c9a5cfec86427b4">FlagForRemoval</a>(); <span class="comment">// Remove from Cron</span>
<a name="l02222"></a>02222         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02223"></a>02223     }
<a name="l02224"></a>02224     <span class="comment">// -----------------------------------------------------------------</span>
<a name="l02225"></a>02225 
<a name="l02226"></a>02226     <span class="keywordflow">if</span> (!pStashAccount-&gt;VerifyOwnerByID(SERVER_USER_ID))
<a name="l02227"></a>02227     {
<a name="l02228"></a>02228         <a class="code" href="class_o_t_log.html#a5acd90ac91c2618f395b0ff37ad4f8ee">OTLog::Error</a>(<span class="stringliteral">&quot;OTSmartContract::StashFunds: Error: Somehow the stash account isn&#39;t server-nym owned.\n&quot;</span>);
<a name="l02229"></a>02229         <a class="code" href="class_o_t_cron_item.html#a34c87380d2f8cd419c9a5cfec86427b4">FlagForRemoval</a>(); <span class="comment">// Remove from Cron</span>
<a name="l02230"></a>02230         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02231"></a>02231     }
<a name="l02232"></a>02232     <span class="keyword">const</span> <a class="code" href="class_o_t_identifier.html">OTIdentifier</a> STASH_USER_ID (pStashAccount-&gt;GetUserID());
<a name="l02233"></a>02233     <span class="comment">// ---------------------------------------------------</span>
<a name="l02234"></a>02234 
<a name="l02235"></a>02235     <span class="keywordtype">bool</span>        bSuccess = <span class="keyword">false</span>;   <span class="comment">// The return value.</span>
<a name="l02236"></a>02236     <span class="comment">// --------------------------------------------------------</span>
<a name="l02237"></a>02237 
<a name="l02238"></a>02238     <a class="code" href="class_o_t_string.html">OTString</a>    strPartyUserID(PARTY_USER_ID), strStashUserID(STASH_USER_ID),
<a name="l02239"></a>02239                 strPartyAcctID(PARTY_ACCT_ID), strStashAcctID(STASH_ACCT_ID),
<a name="l02240"></a>02240                 strServerNymID(SERVER_USER_ID);
<a name="l02241"></a>02241 
<a name="l02242"></a>02242     <span class="comment">// Need to load up the ORIGINAL VERSION OF THIS SMART CONTRACT</span>
<a name="l02243"></a>02243     <span class="comment">// Will need to verify the party&#39;s signature, as well as attach a copy of it to the receipt.</span>
<a name="l02244"></a>02244 
<a name="l02245"></a>02245     <a class="code" href="class_o_t_cron_item.html">OTCronItem</a> * pOrigCronItem  = NULL;
<a name="l02246"></a>02246 
<a name="l02247"></a>02247     <span class="comment">// OTCronItem::LoadCronReceipt loads the original version with the user&#39;s signature.</span>
<a name="l02248"></a>02248     <span class="comment">// (Updated versions, as processing occurs, are signed by the server.)</span>
<a name="l02249"></a>02249     pOrigCronItem   = <a class="code" href="class_o_t_cron_item.html#a368603ca2196ecb8817d42a24138f5d7">OTCronItem::LoadCronReceipt</a>(<a class="code" href="class_o_t_trackable.html#a2594d320e3b24f3210bd38a08de66a70">GetTransactionNum</a>());
<a name="l02250"></a>02250 
<a name="l02251"></a>02251     <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != pOrigCronItem);   <span class="comment">// How am I processing it now if the receipt wasn&#39;t saved in the first place??</span>
<a name="l02252"></a>02252     <span class="comment">// TODO: Decide global policy for handling situations where the hard drive stops working, etc.</span>
<a name="l02253"></a>02253 
<a name="l02254"></a>02254     <span class="comment">// When theOrigPlanGuardian goes out of scope, pOrigCronItem gets deleted automatically.</span>
<a name="l02255"></a>02255     <a class="code" href="class_o_t_cleanup.html">OTCleanup&lt;OTCronItem&gt;</a>   theOrigPlanGuardian(*pOrigCronItem);
<a name="l02256"></a>02256 
<a name="l02257"></a>02257     <span class="comment">// strOrigPlan is a String copy (a PGP-signed XML file, in string form) of the original smart contract activation request...</span>
<a name="l02258"></a>02258     <a class="code" href="class_o_t_string.html">OTString</a> strOrigPlan(*pOrigCronItem); <span class="comment">// &lt;====== Farther down in the code, I attach this string to the receipts.</span>
<a name="l02259"></a>02259 
<a name="l02260"></a>02260 
<a name="l02261"></a>02261     <span class="comment">// -------------- Make sure have both nyms loaded and checked out. --------------------------------------------------</span>
<a name="l02262"></a>02262     <span class="comment">// WARNING: The party&#39;s Nym could be also the Server Nym. But the Stash Nym is ALWAYS the server.</span>
<a name="l02263"></a>02263     <span class="comment">// In all of those different cases, I don&#39;t want to load the same file twice and overwrite it with itself, losing</span>
<a name="l02264"></a>02264     <span class="comment">// half of all my changes. I have to check all three IDs carefully and set the pointers accordingly, and then operate</span>
<a name="l02265"></a>02265     <span class="comment">// using the pointers from there.</span>
<a name="l02266"></a>02266 
<a name="l02267"></a>02267     <a class="code" href="class_o_t_pseudonym.html">OTPseudonym</a> thePartyNym;
<a name="l02268"></a>02268 
<a name="l02269"></a>02269     <span class="comment">// Find out if party Nym is actually also the server nym.</span>
<a name="l02270"></a>02270     <span class="keyword">const</span> <span class="keywordtype">bool</span> bPartyNymIsServerNym = ((PARTY_USER_ID   == SERVER_USER_ID) ? <span class="keyword">true</span> : <span class="keyword">false</span>);
<a name="l02271"></a>02271 
<a name="l02272"></a>02272     <span class="comment">// -----------------------------------------------------</span>
<a name="l02273"></a>02273 
<a name="l02274"></a>02274     <a class="code" href="class_o_t_pseudonym.html">OTPseudonym</a> * pPartyNym         = NULL;
<a name="l02275"></a>02275 <span class="comment">//  OTPseudonym * pStashNym         = pServerNym;</span>
<a name="l02276"></a>02276     <span class="comment">// --------------------------</span>
<a name="l02277"></a>02277     <span class="keyword">const</span> std::string           str_party_id = strPartyUserID.Get();
<a name="l02278"></a>02278     mapOfNyms::const_iterator   it_party     = map_NymsAlreadyLoaded.find(str_party_id);
<a name="l02279"></a>02279 
<a name="l02280"></a>02280     <span class="keywordflow">if</span> (map_NymsAlreadyLoaded.end() != it_party) <span class="comment">// found the party in list of Nyms that are already loaded.</span>
<a name="l02281"></a>02281     {
<a name="l02282"></a>02282         pPartyNym = (*it_party).second;
<a name="l02283"></a>02283         <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>((NULL != pPartyNym) &amp;&amp; (pPartyNym-&gt;<a class="code" href="class_o_t_pseudonym.html#a5ec9340b8d1d0fcd32f754ea63f9915a">CompareID</a>(PARTY_USER_ID)));
<a name="l02284"></a>02284     }
<a name="l02285"></a>02285     <span class="comment">// ------------------</span>
<a name="l02286"></a>02286 
<a name="l02287"></a>02287     <span class="comment">// Figure out if party Nym is also Server Nym.</span>
<a name="l02288"></a>02288     <span class="keywordflow">if</span> (bPartyNymIsServerNym)
<a name="l02289"></a>02289     {
<a name="l02290"></a>02290         <span class="comment">// If the First Nym is the server, then just point to that.</span>
<a name="l02291"></a>02291         pPartyNym = pServerNym;
<a name="l02292"></a>02292     }
<a name="l02293"></a>02293     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (NULL == pPartyNym) <span class="comment">// Else load the First Nym from storage, if still not found.</span>
<a name="l02294"></a>02294     {
<a name="l02295"></a>02295         thePartyNym.<a class="code" href="class_o_t_pseudonym.html#a4b5f98378bb2ff1c48c5410f7283aff6">SetIdentifier</a>(PARTY_USER_ID);  <span class="comment">// thePartyNym is pPartyNym</span>
<a name="l02296"></a>02296 
<a name="l02297"></a>02297         <span class="keywordflow">if</span> (<span class="keyword">false</span> == thePartyNym.<a class="code" href="class_o_t_pseudonym.html#aeb1c675ec72d6450e5c151d1f3eb95bf">LoadPublicKey</a>())
<a name="l02298"></a>02298         {
<a name="l02299"></a>02299             <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;OTSmartContract::StashFunds: Failure loading party Nym public key: %s\n&quot;</span>,
<a name="l02300"></a>02300                           strPartyUserID.Get());
<a name="l02301"></a>02301             <a class="code" href="class_o_t_cron_item.html#a34c87380d2f8cd419c9a5cfec86427b4">FlagForRemoval</a>(); <span class="comment">// Remove it from future Cron processing, please.</span>
<a name="l02302"></a>02302             <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02303"></a>02303         }
<a name="l02304"></a>02304 
<a name="l02305"></a>02305         <span class="keywordflow">if</span> (thePartyNym.<a class="code" href="class_o_t_pseudonym.html#aae8a707c7799efb6944d485be31a7c3e">VerifyPseudonym</a>()   &amp;&amp;
<a name="l02306"></a>02306             thePartyNym.<a class="code" href="class_o_t_pseudonym.html#ad24db39caa89399f659f414b19903f90">LoadSignedNymfile</a>(*pServerNym)) <span class="comment">// ServerNym here is not thePartyNym&#39;s identity, but merely the signer on this file.</span>
<a name="l02307"></a>02307         {
<a name="l02308"></a>02308             <a class="code" href="class_o_t_log.html#a1f7549d776ee919dcb6517f611ded015">OTLog::Output</a>(1, <span class="stringliteral">&quot;OTSmartContract::StashFunds: Loading party Nym, since he apparently wasn&#39;t already loaded.\n&quot;</span>
<a name="l02309"></a>02309                           <span class="stringliteral">&quot;(On a cron item processing, this is normal. But if you triggered a clause directly, then your Nym SHOULD be already loaded...)\n&quot;</span>);
<a name="l02310"></a>02310             pPartyNym = &amp;thePartyNym; <span class="comment">//  &lt;=====</span>
<a name="l02311"></a>02311         }
<a name="l02312"></a>02312         <span class="keywordflow">else</span>
<a name="l02313"></a>02313         {
<a name="l02314"></a>02314             <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;OTSmartContract::StashFunds: Failure loading or verifying party Nym public key: %s\n&quot;</span>,
<a name="l02315"></a>02315                           strPartyUserID.Get());
<a name="l02316"></a>02316             <a class="code" href="class_o_t_cron_item.html#a34c87380d2f8cd419c9a5cfec86427b4">FlagForRemoval</a>(); <span class="comment">// Remove it from future Cron processing, please.</span>
<a name="l02317"></a>02317             <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02318"></a>02318         }
<a name="l02319"></a>02319     }
<a name="l02320"></a>02320     <span class="comment">// Below this point, both Nyms are loaded and good-to-go.</span>
<a name="l02321"></a>02321     <span class="comment">// -----------------------------------------------------------------</span>
<a name="l02322"></a>02322 
<a name="l02323"></a>02323     <a class="code" href="_o_t_agent_8hpp.html#ac89892658f6bc83e354078647b704e8f">mapOfNyms</a> map_ALREADY_LOADED; <span class="comment">// I know I passed in one of these, but now I have processed the Nym pointers (above) and have better data here now.</span>
<a name="l02324"></a>02324     mapOfNyms::iterator it_temp;
<a name="l02325"></a>02325 
<a name="l02326"></a>02326     map_ALREADY_LOADED.insert(std::pair&lt;std::string,OTPseudonym*&gt;(strServerNymID.<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>(), pServerNym));  <span class="comment">// Add Server Nym to list of Nyms already loaded.</span>
<a name="l02327"></a>02327 
<a name="l02328"></a>02328     it_temp = map_ALREADY_LOADED.find(strPartyUserID.Get());
<a name="l02329"></a>02329     <span class="keywordflow">if</span> (map_ALREADY_LOADED.end() == it_temp)
<a name="l02330"></a>02330         map_ALREADY_LOADED.insert(std::pair&lt;std::string,OTPseudonym*&gt;(strPartyUserID.Get(), pPartyNym));  <span class="comment">// Add party Nym to list of Nyms already loaded.</span>
<a name="l02331"></a>02331 
<a name="l02332"></a>02332     <span class="comment">// In this function, pStashNym and pServerNym are always the same.</span>
<a name="l02333"></a>02333     <span class="comment">//</span>
<a name="l02334"></a>02334     <span class="comment">// ------------------------------------------</span>
<a name="l02335"></a>02335     <span class="comment">//</span>
<a name="l02336"></a>02336     <span class="keywordflow">if</span> (!pOrigCronItem-&gt;<a class="code" href="class_o_t_scriptable.html#a242f30ff4c6deccf285930efa15638eb">VerifyNymAsAgent</a>(*pPartyNym, *pServerNym,
<a name="l02337"></a>02337                                          <span class="comment">// In case it needs to load the AUTHORIZING agent, and that agent is already loaded, it will have access here.</span>
<a name="l02338"></a>02338                                          &amp;map_ALREADY_LOADED))
<a name="l02339"></a>02339     {
<a name="l02340"></a>02340         <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;OTSmartContract::StashFunds: Failed authorization for party Nym: %s\n&quot;</span>, strPartyUserID.Get());
<a name="l02341"></a>02341         <a class="code" href="class_o_t_cron_item.html#a34c87380d2f8cd419c9a5cfec86427b4">FlagForRemoval</a>(); <span class="comment">// Remove it from Cron.</span>
<a name="l02342"></a>02342         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02343"></a>02343     }
<a name="l02344"></a>02344 
<a name="l02345"></a>02345     <span class="comment">// AT THIS POINT, I have:   pServerNym, pPartyNym, and pStashNym,</span>
<a name="l02346"></a>02346     <span class="comment">// PLUS:                    pStashAccount and pPartyAssetAcct</span>
<a name="l02347"></a>02347     <span class="comment">// -----------------------------------------------------------------</span>
<a name="l02348"></a>02348     <span class="comment">// VerifySignature, VerifyContractID, and VerifyOwner have all been called already</span>
<a name="l02349"></a>02349     <span class="comment">// by this point. This is new:</span>
<a name="l02350"></a>02350     <span class="comment">// (They might fall away in favor of this, once I start building.)</span>
<a name="l02351"></a>02351     <span class="comment">//</span>
<a name="l02352"></a>02352     <span class="keywordflow">if</span> (!this-&gt;<a class="code" href="class_o_t_scriptable.html#a844de5b0eb2560a28bf795c2c4da3f3b">VerifyNymAsAgentForAccount</a>(*pPartyNym, *pPartyAssetAcct) )
<a name="l02353"></a>02353     {
<a name="l02354"></a>02354         <a class="code" href="class_o_t_log.html#a1f7549d776ee919dcb6517f611ded015">OTLog::Output</a>(0, <span class="stringliteral">&quot;OTSmartContract::StashFunds: ERROR verifying ownership on source account.\n&quot;</span>);
<a name="l02355"></a>02355         <a class="code" href="class_o_t_cron_item.html#a34c87380d2f8cd419c9a5cfec86427b4">FlagForRemoval</a>(); <span class="comment">// Remove it from future Cron processing, please.</span>
<a name="l02356"></a>02356         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02357"></a>02357     }
<a name="l02358"></a>02358     <span class="comment">// -------------------------------------------------------------------------</span>
<a name="l02359"></a>02359 
<a name="l02360"></a>02360     <span class="keywordflow">else</span>
<a name="l02361"></a>02361     {
<a name="l02362"></a>02362         <span class="comment">// Okay then, everything checks out. Let&#39;s add a receipt to the party&#39;s inbox.</span>
<a name="l02363"></a>02363         <span class="comment">// (No need for the stash&#39;s inbox -- the server owns it.)</span>
<a name="l02364"></a>02364 
<a name="l02365"></a>02365         <span class="comment">// Load the inbox in case it already exists</span>
<a name="l02366"></a>02366         <a class="code" href="class_o_t_ledger.html">OTLedger</a>    thePartyInbox   (PARTY_USER_ID, PARTY_ACCT_ID,  SERVER_ID);
<a name="l02367"></a>02367 
<a name="l02368"></a>02368         <span class="comment">// ALL inboxes -- no outboxes. All will receive notification of something ALREADY DONE.</span>
<a name="l02369"></a>02369         <span class="keywordtype">bool</span> bSuccessLoadingPartyInbox  = thePartyInbox.<a class="code" href="class_o_t_ledger.html#a383560406c46ae01bc5992c4928b45b6">LoadInbox</a>();
<a name="l02370"></a>02370         <span class="comment">// -------------------------------------------------------------------</span>
<a name="l02371"></a>02371         <span class="comment">// ...or generate them otherwise...</span>
<a name="l02372"></a>02372 
<a name="l02373"></a>02373         <span class="keywordflow">if</span> (<span class="keyword">true</span> == bSuccessLoadingPartyInbox)
<a name="l02374"></a>02374             bSuccessLoadingPartyInbox       = thePartyInbox.<a class="code" href="class_o_t_ledger.html#a3511c200c6eaa50c6cf249c8995fcb7e">VerifyAccount</a>(*pServerNym);
<a name="l02375"></a>02375         <span class="keywordflow">else</span>
<a name="l02376"></a>02376             <a class="code" href="class_o_t_log.html#a5acd90ac91c2618f395b0ff37ad4f8ee">OTLog::Error</a>(<span class="stringliteral">&quot;OTSmartContract::StashFunds: Failed trying to load party&#39;s inbox.\n&quot;</span>);
<a name="l02377"></a>02377 <span class="comment">//          OT_FAIL_MSG(&quot;ASSERT:  TRYING TO GENERATE INBOX IN STASH FUNDS!!!\n&quot;);</span>
<a name="l02378"></a>02378 <span class="comment">//          bSuccessLoadingPartyInbox       = thePartyInbox.GenerateLedger(PARTY_ACCT_ID, SERVER_ID, OTLedger::inbox, true); // bGenerateFile=true</span>
<a name="l02379"></a>02379         <span class="comment">// --------------------------------------------------------------------</span>
<a name="l02380"></a>02380 
<a name="l02381"></a>02381         <span class="keywordflow">if</span> (<span class="keyword">false</span> == bSuccessLoadingPartyInbox)
<a name="l02382"></a>02382         {
<a name="l02383"></a>02383             <a class="code" href="class_o_t_log.html#a5acd90ac91c2618f395b0ff37ad4f8ee">OTLog::Error</a>(<span class="stringliteral">&quot;OTSmartContract::StashFunds: ERROR loading or generating inbox ledger.\n&quot;</span>);
<a name="l02384"></a>02384         }
<a name="l02385"></a>02385         <span class="keywordflow">else</span>
<a name="l02386"></a>02386         {
<a name="l02387"></a>02387             <span class="comment">// Generate new transaction numbers for these new transactions</span>
<a name="l02388"></a>02388             int64_t lNewTransactionNumber = pCron-&gt;<a class="code" href="class_o_t_cron.html#a22822e0aeced441b6404cd8a2c8e00da">GetNextTransactionNumber</a>();
<a name="l02389"></a>02389 
<a name="l02390"></a>02390 <span class="comment">//          OT_ASSERT(lNewTransactionNumber &gt; 0); // this can be my reminder.</span>
<a name="l02391"></a>02391             <span class="keywordflow">if</span> (0 == lNewTransactionNumber)
<a name="l02392"></a>02392             {
<a name="l02393"></a>02393                 <a class="code" href="class_o_t_log.html#a1f7549d776ee919dcb6517f611ded015">OTLog::Output</a>(0, <span class="stringliteral">&quot;OTSmartContract::StashFunds: Aborted move: There are no more transaction numbers available in Cron.\n&quot;</span>);
<a name="l02394"></a>02394                 <span class="comment">// (Here I do NOT flag for removal.)</span>
<a name="l02395"></a>02395                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02396"></a>02396             }
<a name="l02397"></a>02397 
<a name="l02398"></a>02398             <a class="code" href="class_o_t_transaction.html">OTTransaction</a> * pTransParty = <a class="code" href="class_o_t_transaction.html#a5bfc7ce34aa67cf9dad96e661e118020">OTTransaction::GenerateTransaction</a>(thePartyInbox,
<a name="l02399"></a>02399                                                                              <a class="code" href="class_o_t_transaction.html#af6b54636f1000e09f19d1c7a7886e1f8aac41b416522c9ba6453c787607c6c68d">OTTransaction::paymentReceipt</a>,
<a name="l02400"></a>02400                                                                              lNewTransactionNumber);
<a name="l02401"></a>02401             <span class="comment">// (No need to OT_ASSERT on the above new transaction since it occurs in GenerateTransaction().)</span>
<a name="l02402"></a>02402 
<a name="l02403"></a>02403 
<a name="l02404"></a>02404             <span class="comment">// The party&#39;s inbox will get a receipt with a new transaction ID on it, owned by the server.</span>
<a name="l02405"></a>02405             <span class="comment">// It will have a &quot;In reference to&quot; field containing the original signed smart contract.</span>
<a name="l02406"></a>02406             <span class="comment">// (with all party&#39;s signatures from their authorizing agents.)</span>
<a name="l02407"></a>02407 
<a name="l02408"></a>02408             <span class="comment">// set up the transaction item (each transaction may have multiple items... but not in this case.)</span>
<a name="l02409"></a>02409             <span class="comment">//</span>
<a name="l02410"></a>02410             <a class="code" href="class_o_t_item.html">OTItem</a> * pItemParty = <a class="code" href="class_o_t_item.html#a2376ee56b6c536a63a59e2bfebada0b3">OTItem::CreateItemFromTransaction</a>(*pTransParty, <a class="code" href="class_o_t_item.html#a03db091faaab100aadc455f4ebe2c5d1abcb18b39d8a5da830bdc9b52a825d47b">OTItem::paymentReceipt</a>);
<a name="l02411"></a>02411             <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != pItemParty);  <span class="comment">//  may be unnecessary, I&#39;ll have to check CreateItemFromTransaction. I&#39;ll leave for now.</span>
<a name="l02412"></a>02412 
<a name="l02413"></a>02413             pItemParty-&gt;<a class="code" href="class_o_t_item.html#a789aa4148a0add3092e16c4221bf5844">SetStatus</a>(<a class="code" href="class_o_t_item.html#a61e86f5b6c64a518664123907235f376adbeae2ab1504a5ef318da097d21119db">OTItem::rejection</a>); <span class="comment">// the default.</span>
<a name="l02414"></a>02414             <span class="comment">// -------------------------------------</span>
<a name="l02415"></a>02415 <span class="comment">//          const int64_t lPartyTransRefNo  = GetTransactionNum();</span>
<a name="l02416"></a>02416             <span class="keyword">const</span> int64_t lPartyTransRefNo  = this-&gt;<a class="code" href="class_o_t_smart_contract.html#a2bb8a0f8a1ff8ddf637e5d87d5935e51">GetOpeningNumber</a>(PARTY_USER_ID);
<a name="l02417"></a>02417 
<a name="l02418"></a>02418             <span class="comment">// Here I make sure that each receipt (each inbox notice) references the original</span>
<a name="l02419"></a>02419             <span class="comment">// transaction number that was used to set the cron item into place...</span>
<a name="l02420"></a>02420             <span class="comment">// This number is used to track all cron items. (All Cron items require a transaction</span>
<a name="l02421"></a>02421             <span class="comment">// number from the user in order to add them to Cron in the first place.)</span>
<a name="l02422"></a>02422             <span class="comment">//</span>
<a name="l02423"></a>02423             <span class="comment">// The number is also used to uniquely identify all other transactions, as you</span>
<a name="l02424"></a>02424             <span class="comment">// might guess from its name.</span>
<a name="l02425"></a>02425             <span class="comment">//</span>
<a name="l02426"></a>02426             <span class="comment">// UPDATE: Notice I&#39;m now looking up a different number based on the UserID.</span>
<a name="l02427"></a>02427             <span class="comment">// This is to support smart contracts, which have many parties, agents, and accounts.</span>
<a name="l02428"></a>02428             <span class="comment">//</span>
<a name="l02429"></a>02429 <span class="comment">//          pItemParty-&gt;SetReferenceToNum(lPartyTransRefNo);</span>
<a name="l02430"></a>02430             pTransParty-&gt;<a class="code" href="class_o_t_transaction_type.html#ab0f87cd43699c20eddd70b5970c092d1">SetReferenceToNum</a>(lPartyTransRefNo);
<a name="l02431"></a>02431 
<a name="l02432"></a>02432             <span class="comment">// The TRANSACTION (a receipt in my inbox) will be sent with &quot;In Reference To&quot; information</span>
<a name="l02433"></a>02433             <span class="comment">// containing the ORIGINAL SIGNED SMARTCONTRACT. (With all parties&#39; original signatures on it.)</span>
<a name="l02434"></a>02434             <span class="comment">//</span>
<a name="l02435"></a>02435             <span class="comment">// Whereas the TRANSACTION ITEM will include an &quot;attachment&quot; containing the UPDATED</span>
<a name="l02436"></a>02436             <span class="comment">// SMART CONTRACT (this time with the SERVER&#39;s signature on it.)</span>
<a name="l02437"></a>02437             <span class="comment">//</span>
<a name="l02438"></a>02438             <span class="comment">// Here&#39;s the original one going onto the transaction:</span>
<a name="l02439"></a>02439             <span class="comment">//</span>
<a name="l02440"></a>02440             pTransParty-&gt;<a class="code" href="class_o_t_transaction_type.html#a9dd50265579347d2e8fa3ea36ca66320">SetReferenceString</a>(strOrigPlan);
<a name="l02441"></a>02441 
<a name="l02442"></a>02442 
<a name="l02443"></a>02443             <span class="comment">// --------------------------------------------------------------------------</span>
<a name="l02444"></a>02444             <span class="comment">//</span>
<a name="l02445"></a>02445             <span class="comment">// MOVE THE DIGITAL ASSETS FROM ONE ACCOUNT TO ANOTHER...</span>
<a name="l02446"></a>02446             <span class="comment">//</span>
<a name="l02447"></a>02447             <span class="comment">// Calculate the amount and debit/ credit the accounts</span>
<a name="l02448"></a>02448             <span class="comment">// Make sure each Account can afford it, and roll back in case of failure.</span>
<a name="l02449"></a>02449 
<a name="l02450"></a>02450 
<a name="l02451"></a>02451             <span class="comment">// Normally if you stash 10 clams, then your account is -10 clams, and your stash is +10 clams.</span>
<a name="l02452"></a>02452             <span class="comment">// Therefore if you unstash 5 gg, then your gg acct is +5 grams and your stash is -5 grams.</span>
<a name="l02453"></a>02453             <span class="comment">//</span>
<a name="l02454"></a>02454             <span class="comment">// Thus if lAmount is &gt; 0, as normal, that amount should be DEBITED from the Party Acct, and CREDITED to the Stash Acct.</span>
<a name="l02455"></a>02455             <span class="comment">// Whereas if lAmount were &lt; 0, then that amount should be DEBITED from the Stash Acct, and CREDITED to the Party Acct.</span>
<a name="l02456"></a>02456 
<a name="l02457"></a>02457             <span class="keywordtype">bool</span> bMoveParty = <span class="keyword">false</span>;
<a name="l02458"></a>02458             <span class="keywordtype">bool</span> bMoveStash = <span class="keyword">false</span>;
<a name="l02459"></a>02459 
<a name="l02460"></a>02460             <span class="comment">// ----------------------------------------------------------------------</span>
<a name="l02461"></a>02461             <span class="keywordflow">if</span> (bUnstashing)  <span class="comment">//  Debit Stash, Credit Party</span>
<a name="l02462"></a>02462             {
<a name="l02463"></a>02463                 <span class="keywordflow">if</span> (pStashAccount-&gt;GetBalance() &gt;= lAbsoluteAmount)
<a name="l02464"></a>02464                 {
<a name="l02465"></a>02465                     <span class="comment">// Debit the stash account.</span>
<a name="l02466"></a>02466                     bMoveStash  = pStashAccount-&gt;Debit(lAbsoluteAmount); <span class="comment">// &lt;====== DEBIT FUNDS</span>
<a name="l02467"></a>02467 
<a name="l02468"></a>02468                     <span class="comment">// IF success, credit the party.</span>
<a name="l02469"></a>02469                     <span class="keywordflow">if</span> (bMoveStash)
<a name="l02470"></a>02470                     {
<a name="l02471"></a>02471                         bMoveParty  = pPartyAssetAcct-&gt;<a class="code" href="class_o_t_account.html#a9ae37832775933112ad874a9a9110c8b">Credit</a>(lAbsoluteAmount); <span class="comment">// &lt;=== CREDIT FUNDS</span>
<a name="l02472"></a>02472 
<a name="l02473"></a>02473                         <span class="comment">// Okay, we already took it from the stash account.</span>
<a name="l02474"></a>02474                         <span class="comment">// But if we FAIL to credit the party, then we need to PUT IT BACK in the stash acct.</span>
<a name="l02475"></a>02475                         <span class="comment">// (EVEN THOUGH we&#39;ll just &quot;NOT SAVE&quot; after any failure, so it&#39;s really superfluous.)</span>
<a name="l02476"></a>02476                         <span class="comment">//</span>
<a name="l02477"></a>02477                         <span class="keywordflow">if</span> (! bMoveParty )
<a name="l02478"></a>02478                         {
<a name="l02479"></a>02479                             <span class="keywordtype">bool</span> bErr = pStashAccount-&gt;Credit(lAbsoluteAmount); <span class="comment">// put the money back</span>
<a name="l02480"></a>02480 
<a name="l02481"></a>02481                             <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;OTSmartContract::StashFunds: While succeeded debiting the stash account, FAILED in: pPartyAssetAcct-&gt;Credit(lAbsoluteAmount); \n&quot;</span>
<a name="l02482"></a>02482                                           <span class="stringliteral">&quot;Also, tried to credit stash account back again. Result: %s.\n&quot;</span>, bErr ? <span class="stringliteral">&quot;success&quot;</span> : <span class="stringliteral">&quot;failure&quot;</span>);
<a name="l02483"></a>02483                         }
<a name="l02484"></a>02484                         <span class="keywordflow">else</span>
<a name="l02485"></a>02485                         {   <span class="comment">// SUCCESS!</span>
<a name="l02486"></a>02486                             <span class="comment">//</span>
<a name="l02487"></a>02487                             <span class="keywordtype">bool</span> bStashSuccess = pStashItem-&gt;<a class="code" href="class_o_t_stash_item.html#a71317c63628ef272f79ccd00a1e77876">DebitStash</a>(lAbsoluteAmount); <span class="comment">// we already verified above that this stash item has enough funds to successfully debit.</span>
<a name="l02488"></a>02488 
<a name="l02489"></a>02489                             <span class="keywordflow">if</span> (bStashSuccess)
<a name="l02490"></a>02490                                 bSuccess = <span class="keyword">true</span>;
<a name="l02491"></a>02491                             <span class="keywordflow">else</span>
<a name="l02492"></a>02492                                 <a class="code" href="class_o_t_log.html#a5acd90ac91c2618f395b0ff37ad4f8ee">OTLog::Error</a>(<span class="stringliteral">&quot;OTSmartContract::StashFunds: ERROR: Debited stash account and credited party account, but &quot;</span>
<a name="l02493"></a>02493                                              <span class="stringliteral">&quot;then unable to debit the stash record inside the smart contract itself.\n&quot;</span>);
<a name="l02494"></a>02494                         }
<a name="l02495"></a>02495                     }
<a name="l02496"></a>02496                     <span class="keywordflow">else</span>
<a name="l02497"></a>02497                     {
<a name="l02498"></a>02498                         <a class="code" href="class_o_t_log.html#a5acd90ac91c2618f395b0ff37ad4f8ee">OTLog::Error</a>(<span class="stringliteral">&quot;OTSmartContract::StashFunds: FAILED in:  pStashAccount-&gt;Debit(lAbsoluteAmount);\n&quot;</span>);
<a name="l02499"></a>02499                     }
<a name="l02500"></a>02500                 }
<a name="l02501"></a>02501             }
<a name="l02502"></a>02502             <span class="comment">// --------------------------------------------------------------------------</span>
<a name="l02503"></a>02503             <span class="keywordflow">else</span> <span class="comment">// Debit party, Credit Stash</span>
<a name="l02504"></a>02504             {
<a name="l02505"></a>02505                 <span class="keywordflow">if</span> (pPartyAssetAcct-&gt;<a class="code" href="class_o_t_account.html#a77fbaae9496caec7cd899721971a89c0">GetBalance</a>() &gt;= lAbsoluteAmount)
<a name="l02506"></a>02506                 {
<a name="l02507"></a>02507                     <span class="comment">// Debit the party account.</span>
<a name="l02508"></a>02508                     bMoveParty  = pPartyAssetAcct-&gt;<a class="code" href="class_o_t_account.html#a893c8f197912e9270495f960804b7a5f">Debit</a>(lAbsoluteAmount); <span class="comment">// &lt;====== DEBIT FUNDS</span>
<a name="l02509"></a>02509 
<a name="l02510"></a>02510                     <span class="comment">// IF success, credit the Stash.</span>
<a name="l02511"></a>02511                     <span class="keywordflow">if</span> (bMoveParty)
<a name="l02512"></a>02512                     {
<a name="l02513"></a>02513                         bMoveStash  = pStashAccount-&gt;Credit(lAbsoluteAmount); <span class="comment">// &lt;=== CREDIT FUNDS</span>
<a name="l02514"></a>02514 
<a name="l02515"></a>02515                         <span class="comment">// Okay, we already took it from the party account.</span>
<a name="l02516"></a>02516                         <span class="comment">// But if we FAIL to credit the Stash, then we need to PUT IT BACK in the party acct.</span>
<a name="l02517"></a>02517                         <span class="comment">// (EVEN THOUGH we&#39;ll just &quot;NOT SAVE&quot; after any failure, so it&#39;s really superfluous.)</span>
<a name="l02518"></a>02518                         <span class="comment">//</span>
<a name="l02519"></a>02519                         <span class="keywordflow">if</span> (!bMoveStash)
<a name="l02520"></a>02520                         {
<a name="l02521"></a>02521                             <span class="keywordtype">bool</span> bErr = pPartyAssetAcct-&gt;<a class="code" href="class_o_t_account.html#a9ae37832775933112ad874a9a9110c8b">Credit</a>(lAbsoluteAmount); <span class="comment">// put the money back</span>
<a name="l02522"></a>02522 
<a name="l02523"></a>02523                             <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;OTSmartContract::StashFunds: While succeeded debiting the asset account, FAILED in: pStashAccount-&gt;Credit(lAbsoluteAmount); \n&quot;</span>
<a name="l02524"></a>02524                                           <span class="stringliteral">&quot;Also, tried to credit asset account back again. Result: %s.\n&quot;</span>, bErr ? <span class="stringliteral">&quot;success&quot;</span> : <span class="stringliteral">&quot;failure&quot;</span>);
<a name="l02525"></a>02525                         }
<a name="l02526"></a>02526                         <span class="keywordflow">else</span>
<a name="l02527"></a>02527                         {   <span class="comment">// SUCCESS!</span>
<a name="l02528"></a>02528                             <span class="comment">//</span>
<a name="l02529"></a>02529                             <span class="keywordtype">bool</span> bStashSuccess = pStashItem-&gt;<a class="code" href="class_o_t_stash_item.html#a15a43b1d15d5d924f5f5116ea82d290e">CreditStash</a>(lAbsoluteAmount); <span class="comment">// we already verified above that this stash item has enough funds to successfully debit.</span>
<a name="l02530"></a>02530 
<a name="l02531"></a>02531                             <span class="keywordflow">if</span> (bStashSuccess)
<a name="l02532"></a>02532                                 bSuccess = <span class="keyword">true</span>;
<a name="l02533"></a>02533                             <span class="keywordflow">else</span>
<a name="l02534"></a>02534                                 <a class="code" href="class_o_t_log.html#a5acd90ac91c2618f395b0ff37ad4f8ee">OTLog::Error</a>(<span class="stringliteral">&quot;OTSmartContract::StashFunds: ERROR: Debited party account and credited stash account, but &quot;</span>
<a name="l02535"></a>02535                                              <span class="stringliteral">&quot;then unable to credit the stash record inside the smart contract itself.\n&quot;</span>);
<a name="l02536"></a>02536                         }
<a name="l02537"></a>02537                     }
<a name="l02538"></a>02538                     <span class="keywordflow">else</span>
<a name="l02539"></a>02539                     {
<a name="l02540"></a>02540                         <a class="code" href="class_o_t_log.html#a5acd90ac91c2618f395b0ff37ad4f8ee">OTLog::Error</a>(<span class="stringliteral">&quot;OTSmartContract::StashFunds: FAILED in:  pPartyAssetAcct-&gt;Debit(lAbsoluteAmount);\n&quot;</span>);
<a name="l02541"></a>02541                     }
<a name="l02542"></a>02542                 }
<a name="l02543"></a>02543             }
<a name="l02544"></a>02544             <span class="comment">// ----------------------------------------------------------------------</span>
<a name="l02545"></a>02545             <span class="comment">//</span>
<a name="l02546"></a>02546             <span class="comment">// If ANY of these failed, then roll them all back and break.</span>
<a name="l02547"></a>02547             <span class="comment">// (In fact we could just be checking bSuccess here, I wager.</span>
<a name="l02548"></a>02548             <span class="comment">// Might as well be thorough.)</span>
<a name="l02549"></a>02549             <span class="comment">//</span>
<a name="l02550"></a>02550             <span class="keywordflow">if</span> (!bMoveParty || !bMoveStash)
<a name="l02551"></a>02551             {
<a name="l02552"></a>02552                 <span class="comment">// No need to roll back pStashItem here, since it is never changed in the</span>
<a name="l02553"></a>02553                 <span class="comment">// first place unless BOTH of the above bools were successful.</span>
<a name="l02554"></a>02554 
<a name="l02555"></a>02555                 <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;OTSmartContract::StashFunds: Very strange! Funds were available but &quot;</span>
<a name="l02556"></a>02556                               <span class="stringliteral">&quot;debit %s or credit %s failed while performing move.\n&quot;</span>,
<a name="l02557"></a>02557                               (bUnstashing) ? <span class="stringliteral">&quot;stash&quot;</span> : <span class="stringliteral">&quot;party&quot;</span>,
<a name="l02558"></a>02558                               (bUnstashing) ? <span class="stringliteral">&quot;party&quot;</span> : <span class="stringliteral">&quot;stash&quot;</span>);
<a name="l02559"></a>02559                 <span class="comment">// We won&#39;t save the files anyway, if this failed.</span>
<a name="l02560"></a>02560                 bSuccess = <span class="keyword">false</span>;
<a name="l02561"></a>02561             }
<a name="l02562"></a>02562             <span class="comment">// --------------------------------------------------------------------------</span>
<a name="l02563"></a>02563             <span class="comment">//</span>
<a name="l02564"></a>02564             <span class="comment">// DO NOT SAVE ACCOUNTS if bSuccess is false.</span>
<a name="l02565"></a>02565             <span class="comment">// We only save these accounts if bSuccess == true.</span>
<a name="l02566"></a>02566             <span class="comment">// (But we do save the inboxes either way, since payment failures always merit an inbox notice.)</span>
<a name="l02567"></a>02567             <span class="comment">//</span>
<a name="l02568"></a>02568             <span class="keywordflow">if</span> (<span class="keyword">true</span> == bSuccess) <span class="comment">// The payment succeeded.</span>
<a name="l02569"></a>02569             {
<a name="l02570"></a>02570                 <span class="comment">// The party needs to get a receipt in his inbox.</span>
<a name="l02571"></a>02571                 <span class="comment">//</span>
<a name="l02572"></a>02572                 pItemParty-&gt;<a class="code" href="class_o_t_item.html#a789aa4148a0add3092e16c4221bf5844">SetStatus</a>(<a class="code" href="class_o_t_item.html#a61e86f5b6c64a518664123907235f376aa099f14a8a9ef5987b1161b764895cdf">OTItem::acknowledgement</a>); <span class="comment">// pPartyAssetAcct</span>
<a name="l02573"></a>02573 
<a name="l02574"></a>02574                 <span class="keyword">const</span> int64_t lReceiptAmount = (lAmount*(-1));
<a name="l02575"></a>02575 
<a name="l02576"></a>02576 <span class="comment">//              pItemParty-&gt;SetAmount(lAmount); // lAmount is already negative or positive by the time it&#39;s passed into this function.</span>
<a name="l02577"></a>02577                 pItemParty-&gt;<a class="code" href="class_o_t_item.html#a81d53d2910a45fdbb11d92ae680519fb">SetAmount</a>(lReceiptAmount);  <span class="comment">// However, if we are stashing 100, that means my account is -100. Therefore multiply by (-1) EITHER WAY.</span>
<a name="l02578"></a>02578 <span class="comment">//              pItemParty-&gt;SetAmount(lAbsoluteAmount*(-1));    // &quot;paymentReceipt&quot; is otherwise ambigious about whether you are paying or being paid.</span>
<a name="l02579"></a>02579                 <span class="comment">// This is also like market receipts, which use negative and positive amounts.</span>
<a name="l02580"></a>02580 
<a name="l02581"></a>02581                 <a class="code" href="class_o_t_log.html#a1f7549d776ee919dcb6517f611ded015">OTLog::Output</a>(0, <span class="stringliteral">&quot;OTSmartContract::StashFunds: Move performed.\n&quot;</span>);
<a name="l02582"></a>02582 
<a name="l02583"></a>02583                 <span class="comment">// (I do NOT save m_pCron here, since that already occurs after this function is called.)</span>
<a name="l02584"></a>02584             }
<a name="l02585"></a>02585             <span class="keywordflow">else</span> <span class="comment">// bSuccess = false.  The payment failed.</span>
<a name="l02586"></a>02586             {
<a name="l02587"></a>02587                 pItemParty-&gt;<a class="code" href="class_o_t_item.html#a789aa4148a0add3092e16c4221bf5844">SetStatus</a>(<a class="code" href="class_o_t_item.html#a61e86f5b6c64a518664123907235f376adbeae2ab1504a5ef318da097d21119db">OTItem::rejection</a>);<span class="comment">// pPartyAssetAcct     // These are already initialized to false.</span>
<a name="l02588"></a>02588                 pItemParty-&gt;<a class="code" href="class_o_t_item.html#a81d53d2910a45fdbb11d92ae680519fb">SetAmount</a>(0);       <span class="comment">// No money changed hands. Just being explicit.</span>
<a name="l02589"></a>02589 
<a name="l02590"></a>02590                 <a class="code" href="class_o_t_log.html#a1f7549d776ee919dcb6517f611ded015">OTLog::Output</a>(0, <span class="stringliteral">&quot;OTSmartContract::StashFunds: Move failed.\n&quot;</span>);
<a name="l02591"></a>02591             }
<a name="l02592"></a>02592 
<a name="l02593"></a>02593             <span class="comment">// Everytime a payment processes, a receipt is put in the user&#39;s inbox, containing a</span>
<a name="l02594"></a>02594             <span class="comment">// CURRENT copy of the cron item (which took just money from the user&#39;s acct, or not,</span>
<a name="l02595"></a>02595             <span class="comment">// and either way thus updated its status -- so its internal state has changed.)</span>
<a name="l02596"></a>02596             <span class="comment">//</span>
<a name="l02597"></a>02597             <span class="comment">// It will also contain a copy of the user&#39;s ORIGINAL signed cron item, where the data</span>
<a name="l02598"></a>02598             <span class="comment">// has NOT changed, (so the user&#39;s original signature is still good.) Although in the case of</span>
<a name="l02599"></a>02599             <span class="comment">// smart contracts, each party stores their own signed copy anyway, so it doesn&#39;t matter as</span>
<a name="l02600"></a>02600             <span class="comment">// much.</span>
<a name="l02601"></a>02601             <span class="comment">//</span>
<a name="l02602"></a>02602             <span class="comment">// In order for it to export the RIGHT VERSION of the CURRENT smart contract, which has just</span>
<a name="l02603"></a>02603             <span class="comment">// changed (above), then I need to re-sign it and save it first. (The original version I&#39;ll</span>
<a name="l02604"></a>02604             <span class="comment">// load from a separate file using OTSmartContract::LoadCronReceipt(lTransactionNum).</span>
<a name="l02605"></a>02605             <span class="comment">//</span>
<a name="l02606"></a>02606             <span class="comment">// I should be able to call a method on the original cronitem, where I ask it to verify a certain</span>
<a name="l02607"></a>02607             <span class="comment">// nym as being acceptable to that cron item as an agent, based on the signature of the original</span>
<a name="l02608"></a>02608             <span class="comment">// authorizing agent for that party. UPDATE: I believe the function described in this paragraph</span>
<a name="l02609"></a>02609             <span class="comment">// is now done.</span>
<a name="l02610"></a>02610             <span class="comment">//</span>
<a name="l02611"></a>02611 
<a name="l02612"></a>02612             this-&gt;<a class="code" href="class_o_t_contract.html#aae54340526fbd8eb8a18de27a4b97c83">ReleaseSignatures</a>();
<a name="l02613"></a>02613             this-&gt;<a class="code" href="class_o_t_contract.html#abd60037fe655ee8cae9a3ece5d1e2ea6">SignContract</a>(*pServerNym);
<a name="l02614"></a>02614             this-&gt;<a class="code" href="class_o_t_contract.html#a363ae430d4fd9256ab8364dbafb95444">SaveContract</a>();
<a name="l02615"></a>02615 
<a name="l02616"></a>02616             <span class="comment">// -----------------------------------------------------------------</span>
<a name="l02617"></a>02617             <span class="comment">//</span>
<a name="l02618"></a>02618             <span class="comment">// EVERYTHING BELOW is just about notifying the party, by dropping the receipt in his</span>
<a name="l02619"></a>02619             <span class="comment">// inbox. The rest is done.  The two accounts and the inbox will all be saved at the same time.</span>
<a name="l02620"></a>02620             <span class="comment">//</span>
<a name="l02621"></a>02621             <span class="comment">// The Smart Contract is entirely updated and saved by this point, and Cron will</span>
<a name="l02622"></a>02622             <span class="comment">// also be saved in the calling function once we return (no matter what.)</span>
<a name="l02623"></a>02623             <span class="comment">//</span>
<a name="l02624"></a>02624             <span class="comment">// ----------------------------------------------------------------</span>
<a name="l02625"></a>02625 
<a name="l02626"></a>02626             <span class="comment">// Basically I load up the INBOX, which is actually a LEDGER, and then I create</span>
<a name="l02627"></a>02627             <span class="comment">// a new transaction, with a new transaction item, for that ledger.</span>
<a name="l02628"></a>02628             <span class="comment">// (That&#39;s where the receipt information goes.)</span>
<a name="l02629"></a>02629             <span class="comment">//</span>
<a name="l02630"></a>02630             <span class="comment">// -----------------------------------------------------------------</span>
<a name="l02631"></a>02631 
<a name="l02632"></a>02632             <span class="comment">// The TRANSACTION will be sent with &quot;In Reference To&quot; information containing the</span>
<a name="l02633"></a>02633             <span class="comment">// ORIGINAL SIGNED SMART CONTRACT. (With both of the users&#39; original signatures on it.)</span>
<a name="l02634"></a>02634             <span class="comment">//</span>
<a name="l02635"></a>02635             <span class="comment">// Whereas the TRANSACTION ITEM will include an &quot;attachment&quot; containing the UPDATED</span>
<a name="l02636"></a>02636             <span class="comment">// SMART CONTRACT (this time with the SERVER&#39;s signature on it.)</span>
<a name="l02637"></a>02637 
<a name="l02638"></a>02638             <span class="comment">// (Lucky I just signed and saved the updated smart contract (above), or it would still have</span>
<a name="l02639"></a>02639             <span class="comment">// have the old data in it.)</span>
<a name="l02640"></a>02640 
<a name="l02641"></a>02641             <span class="comment">// I also already loaded the original smart contact. Remember this from above,</span>
<a name="l02642"></a>02642             <span class="comment">// near the top of the function:</span>
<a name="l02643"></a>02643             <span class="comment">//  OTSmartContract * pOrigCronItem = NULL;</span>
<a name="l02644"></a>02644             <span class="comment">//  OTString strOrigPlan(*pOrigCronItem); // &lt;====== Farther down in the code, I attach this string to the receipts.</span>
<a name="l02645"></a>02645             <span class="comment">//  ... then lower down...</span>
<a name="l02646"></a>02646             <span class="comment">// pTransParty-&gt;SetReferenceString(strOrigPlan);</span>
<a name="l02647"></a>02647             <span class="comment">//</span>
<a name="l02648"></a>02648             <span class="comment">// So the original plan is already loaded and copied to the Transaction as the &quot;In Reference To&quot;</span>
<a name="l02649"></a>02649             <span class="comment">// Field. Now let&#39;s add the UPDATED plan as an ATTACHMENT on the Transaction ITEM:</span>
<a name="l02650"></a>02650             <span class="comment">//</span>
<a name="l02651"></a>02651             <span class="comment">// -----------------------------------------------------</span>
<a name="l02652"></a>02652             <span class="comment">//</span>
<a name="l02653"></a>02653 
<a name="l02654"></a>02654             <a class="code" href="class_o_t_string.html">OTString</a>    strUpdatedCronItem(*<span class="keyword">this</span>);
<a name="l02655"></a>02655 
<a name="l02656"></a>02656             <span class="comment">// Set the updated cron item as the attachment on the transaction item.</span>
<a name="l02657"></a>02657             <span class="comment">// (With the SERVER&#39;s signature on it!)</span>
<a name="l02658"></a>02658             <span class="comment">// (As a receipt for the party, so they can see their smartcontract updating.)</span>
<a name="l02659"></a>02659             <span class="comment">//</span>
<a name="l02660"></a>02660             pItemParty-&gt;<a class="code" href="class_o_t_item.html#a6e5e9b0c04cb1eca8acaec5b0be1d641">SetAttachment</a>(strUpdatedCronItem);
<a name="l02661"></a>02661 
<a name="l02662"></a>02662             <span class="comment">// -----------------------------------------------------------------</span>
<a name="l02663"></a>02663 
<a name="l02664"></a>02664             <span class="comment">// Success OR failure, either way I want a receipt in the inbox.</span>
<a name="l02665"></a>02665             <span class="comment">// ===&gt; But if FAILURE, I do NOT want to save the Accounts, JUST the inbox!!</span>
<a name="l02666"></a>02666             <span class="comment">//</span>
<a name="l02667"></a>02667             <span class="comment">// (So the inbox happens either way, but the accounts are saved only on success.)</span>
<a name="l02668"></a>02668 
<a name="l02669"></a>02669             <span class="comment">// sign the item</span>
<a name="l02670"></a>02670             pItemParty-&gt;<a class="code" href="class_o_t_contract.html#abd60037fe655ee8cae9a3ece5d1e2ea6">SignContract</a>(*pServerNym);
<a name="l02671"></a>02671             pItemParty-&gt;<a class="code" href="class_o_t_contract.html#a363ae430d4fd9256ab8364dbafb95444">SaveContract</a>();
<a name="l02672"></a>02672 
<a name="l02673"></a>02673             <span class="comment">// the Transaction &quot;owns&quot; the item now and will handle cleaning it up.</span>
<a name="l02674"></a>02674             pTransParty-&gt;<a class="code" href="class_o_t_transaction.html#a5abc071b7eeddc40ea151cccd011e4d6">AddItem</a>(*pItemParty);
<a name="l02675"></a>02675             pTransParty-&gt;<a class="code" href="class_o_t_contract.html#abd60037fe655ee8cae9a3ece5d1e2ea6">SignContract</a>(*pServerNym);
<a name="l02676"></a>02676             pTransParty-&gt;<a class="code" href="class_o_t_contract.html#a363ae430d4fd9256ab8364dbafb95444">SaveContract</a>();
<a name="l02677"></a>02677 
<a name="l02678"></a>02678             <span class="comment">// -------------------------------------------</span>
<a name="l02679"></a>02679             <span class="comment">// Here, the transaction we just created is actually added to the inbox ledger.</span>
<a name="l02680"></a>02680             <span class="comment">// This happens either way, success or fail.</span>
<a name="l02681"></a>02681 
<a name="l02682"></a>02682             thePartyInbox.<a class="code" href="class_o_t_ledger.html#a6befecfc9199e90d459f3c89f2f0dc14">AddTransaction</a>(*pTransParty);
<a name="l02683"></a>02683 
<a name="l02684"></a>02684             <span class="comment">// -------------------------------------------</span>
<a name="l02685"></a>02685             <span class="comment">// Release any signatures that were there before (They won&#39;t</span>
<a name="l02686"></a>02686             <span class="comment">// verify anymore anyway, since the content has changed.)</span>
<a name="l02687"></a>02687             <span class="comment">//</span>
<a name="l02688"></a>02688             thePartyInbox.<a class="code" href="class_o_t_contract.html#aae54340526fbd8eb8a18de27a4b97c83">ReleaseSignatures</a>();
<a name="l02689"></a>02689             thePartyInbox.<a class="code" href="class_o_t_contract.html#abd60037fe655ee8cae9a3ece5d1e2ea6">SignContract</a>(*pServerNym);
<a name="l02690"></a>02690             thePartyInbox.<a class="code" href="class_o_t_contract.html#a363ae430d4fd9256ab8364dbafb95444">SaveContract</a>();
<a name="l02691"></a>02691             <span class="comment">// ------------------------------</span>
<a name="l02692"></a>02692 
<a name="l02693"></a>02693             pPartyAssetAcct-&gt;<a class="code" href="class_o_t_account.html#a81e503e95310da5ac9c2003cb00d6d2e">SaveInbox</a>(thePartyInbox);
<a name="l02694"></a>02694 
<a name="l02695"></a>02695             <span class="comment">// This corresponds to the AddTransaction() call just above.</span>
<a name="l02696"></a>02696             <span class="comment">// These are stored in a separate file now.</span>
<a name="l02697"></a>02697             <span class="comment">//</span>
<a name="l02698"></a>02698             pTransParty-&gt;<a class="code" href="class_o_t_transaction.html#a2f991feb7c6178ffabefc7fef312d26e">SaveBoxReceipt</a>(thePartyInbox);
<a name="l02699"></a>02699 
<a name="l02700"></a>02700             <span class="comment">// temp remove todo</span>
<a name="l02701"></a>02701 <span class="comment">//          OTString strTempDebug(PARTY_ACCT_ID), strTempDebug2(PARTY_USER_ID), strTempDebug3(thePartyInbox);</span>
<a name="l02702"></a>02702 <span class="comment">//          OTLog::vError(&quot;OTSmartContract::StashFunds: Finished saving Inbox with new receipt %lld (re: trans %lld by way of %lld) in it, for account: %s, user: %s. Status: %s\n&quot;</span>
<a name="l02703"></a>02703 <span class="comment">//                        &quot;INBOX CONTENTS: \n\n%s\n\n&quot;,</span>
<a name="l02704"></a>02704 <span class="comment">//                        lNewTransactionNumber, GetTransactionNum(), lPartyTransRefNo, strTempDebug.Get(), strTempDebug2.Get(), bSuccess ? &quot;SUCCESS&quot; : &quot;FAILURE&quot;,</span>
<a name="l02705"></a>02705 <span class="comment">//                        strTempDebug3.Get());</span>
<a name="l02706"></a>02706 
<a name="l02707"></a>02707 
<a name="l02708"></a>02708 
<a name="l02709"></a>02709             <span class="comment">// If success, save the accounts with new balance. (Save inboxes with receipts either way,</span>
<a name="l02710"></a>02710             <span class="comment">// and the receipts will contain a rejection or acknowledgment stamped by the Server Nym.)</span>
<a name="l02711"></a>02711             <span class="comment">//</span>
<a name="l02712"></a>02712             <span class="keywordflow">if</span> (<span class="keyword">true</span> == bSuccess)
<a name="l02713"></a>02713             {
<a name="l02714"></a>02714                 <span class="comment">// SAVE THE ACCOUNTS.</span>
<a name="l02715"></a>02715                 <span class="comment">// -------------------------------------------</span>
<a name="l02716"></a>02716                 <span class="comment">// Release any signatures that were there before (They won&#39;t</span>
<a name="l02717"></a>02717                 <span class="comment">// verify anymore anyway, since the content has changed.)</span>
<a name="l02718"></a>02718                 <span class="comment">//</span>
<a name="l02719"></a>02719                 pPartyAssetAcct-&gt;   <a class="code" href="class_o_t_contract.html#aae54340526fbd8eb8a18de27a4b97c83">ReleaseSignatures</a>();
<a name="l02720"></a>02720                 pStashAccount-&gt;     <a class="code" href="class_o_t_contract.html#aae54340526fbd8eb8a18de27a4b97c83">ReleaseSignatures</a>();
<a name="l02721"></a>02721 
<a name="l02722"></a>02722                 <span class="comment">// Sign both of them.</span>
<a name="l02723"></a>02723                 pPartyAssetAcct-&gt;   <a class="code" href="class_o_t_contract.html#abd60037fe655ee8cae9a3ece5d1e2ea6">SignContract</a>(*pServerNym);
<a name="l02724"></a>02724                 pStashAccount-&gt;     <a class="code" href="class_o_t_contract.html#abd60037fe655ee8cae9a3ece5d1e2ea6">SignContract</a>(*pServerNym);
<a name="l02725"></a>02725 
<a name="l02726"></a>02726                 <span class="comment">// Save both of them internally</span>
<a name="l02727"></a>02727                 pPartyAssetAcct-&gt;   <a class="code" href="class_o_t_contract.html#a363ae430d4fd9256ab8364dbafb95444">SaveContract</a>();
<a name="l02728"></a>02728                 pStashAccount-&gt;     <a class="code" href="class_o_t_contract.html#a363ae430d4fd9256ab8364dbafb95444">SaveContract</a>();
<a name="l02729"></a>02729 
<a name="l02730"></a>02730                 <span class="comment">// TODO: Better rollback capabilities in case of failures here:</span>
<a name="l02731"></a>02731 
<a name="l02732"></a>02732                 <span class="comment">// Save both accounts to storage.</span>
<a name="l02733"></a>02733                 pPartyAssetAcct-&gt;   SaveAccount();
<a name="l02734"></a>02734                 pStashAccount-&gt;     SaveAccount();
<a name="l02735"></a>02735                 <span class="comment">// NO NEED TO LOG HERE, since success / failure is already logged above.</span>
<a name="l02736"></a>02736             }
<a name="l02737"></a>02737         } <span class="comment">// the inbox was successfully loaded or generated.</span>
<a name="l02738"></a>02738     } <span class="comment">// By the time we enter this block, accounts and nyms are already loaded. As we begin, inboxes are instantiated.</span>
<a name="l02739"></a>02739 
<a name="l02740"></a>02740 
<a name="l02741"></a>02741     <span class="comment">// Either way, Cron should save, since it just updated.</span>
<a name="l02742"></a>02742     <span class="comment">// The above function call WILL change this smart contract</span>
<a name="l02743"></a>02743     <span class="comment">// and re-sign it and save it, no matter what. So I just</span>
<a name="l02744"></a>02744     <span class="comment">// call this here to keep it simple:</span>
<a name="l02745"></a>02745 
<a name="l02746"></a>02746     pCron-&gt;<a class="code" href="class_o_t_cron.html#a24df32b4bf36e48867e7afda0955bb72">SaveCron</a>();  <span class="comment">// TODO No need to call this here if I can make sure it&#39;s being called higher up somewhere</span>
<a name="l02747"></a>02747                         <span class="comment">// (Imagine a script that has 10 account moves in it -- maybe don&#39;t need to save cron until</span>
<a name="l02748"></a>02748                         <span class="comment">// after all 10 are done. Or maybe DO need to do in between. Todo research this. Optimization.)</span>
<a name="l02749"></a>02749     <span class="keywordflow">return</span> bSuccess;
<a name="l02750"></a>02750 }
<a name="l02751"></a>02751 
<a name="l02752"></a>02752 
<a name="l02753"></a>02753 <span class="comment">// Higher level. Can be executed from inside scripts.</span>
<a name="l02754"></a>02754 <span class="comment">//</span>
<a name="l02755"></a>02755 <span class="comment">// Returns success if funds were moved.</span>
<a name="l02756"></a>02756 <span class="comment">// This function does not run any scripts, but it CAN be executed from within the scripts.</span>
<a name="l02757"></a>02757 <span class="comment">// Any movement of funds to-or-from any account will automatically try to load/use the</span>
<a name="l02758"></a>02758 <span class="comment">// appropriate authorizing agent for that account (or use him, if he&#39;s already loaded on</span>
<a name="l02759"></a>02759 <span class="comment">// this smart contract.)</span>
<a name="l02760"></a>02760 <span class="comment">//</span>
<a name="l02761"></a>02761 
<a name="l02762"></a>02762 <span class="comment">//global (debugging)</span>
<a name="l02763"></a>02763 <span class="comment">//bool g_MoveAcctFundsL(OTSmartContract * pContract,</span>
<a name="l02764"></a>02764 <span class="comment">//                    const std::string from_acct_name,</span>
<a name="l02765"></a>02765 <span class="comment">//                    const std::string to_acct_name,</span>
<a name="l02766"></a>02766 <span class="comment">//                    const int64_t lAmount)</span>
<a name="l02767"></a>02767 <span class="comment">//{</span>
<a name="l02768"></a>02768 <span class="comment">//  OT_ASSERT(NULL != pContract);</span>
<a name="l02769"></a>02769 <span class="comment">//</span>
<a name="l02770"></a>02770 <span class="comment">//  return pContract-&gt;MoveAcctFundsL(from_acct_name, to_acct_name, lAmount);</span>
<a name="l02771"></a>02771 <span class="comment">//}</span>
<a name="l02772"></a>02772 <span class="comment">//</span>
<a name="l02773"></a>02773 <span class="comment">//</span>
<a name="l02774"></a>02774 <span class="comment">//</span>
<a name="l02776"></a>02776 <span class="comment"></span><span class="comment">//bool g_MoveAcctFundsStr(OTSmartContract * pContract,</span>
<a name="l02777"></a>02777 <span class="comment">//                      const std::string from_acct_name,</span>
<a name="l02778"></a>02778 <span class="comment">//                      const std::string to_acct_name,</span>
<a name="l02779"></a>02779 <span class="comment">//                      const std::string str_Amount)</span>
<a name="l02780"></a>02780 <span class="comment">//{</span>
<a name="l02781"></a>02781 <span class="comment">//  OT_ASSERT(NULL != pContract);</span>
<a name="l02782"></a>02782 <span class="comment">//</span>
<a name="l02783"></a>02783 <span class="comment">//  if (str_Amount.size() &lt; 1)</span>
<a name="l02784"></a>02784 <span class="comment">//  {</span>
<a name="l02785"></a>02785 <span class="comment">//      OTLog::vOutput(0, &quot;OTSmartContract::g_MoveAcctFundsStr: Error: empty amount.\n&quot;);</span>
<a name="l02786"></a>02786 <span class="comment">//      return false;</span>
<a name="l02787"></a>02787 <span class="comment">//  }</span>
<a name="l02788"></a>02788 <span class="comment">//</span>
<a name="l02789"></a>02789 <span class="comment">//  const int64_t lAmount =  atol(str_Amount.c_str());</span>
<a name="l02790"></a>02790 <span class="comment">//</span>
<a name="l02791"></a>02791 <span class="comment">//  return pContract-&gt;MoveAcctFundsL(from_acct_name, to_acct_name, lAmount);</span>
<a name="l02792"></a>02792 <span class="comment">//}</span>
<a name="l02793"></a>02793 
<a name="l02794"></a><a class="code" href="class_o_t_smart_contract.html#ae10051f961745a06753f5e22d9a699f1">02794</a> <span class="keywordtype">bool</span> <a class="code" href="class_o_t_smart_contract.html#ae10051f961745a06753f5e22d9a699f1">OTSmartContract::MoveAcctFundsStr</a>(<span class="keyword">const</span> std::string from_acct_name, <span class="keyword">const</span> std::string to_acct_name, <span class="keyword">const</span> std::string str_Amount)
<a name="l02795"></a>02795 <span class="comment">//bool OTSmartContract::MoveAcctFundsL(const std::string from_acct_name, const std::string to_acct_name, const int64_t lAmount) // int64_t was the problem. Switching to string.</span>
<a name="l02796"></a>02796 {
<a name="l02797"></a>02797     <a class="code" href="class_o_t_cron.html">OTCron</a> * pCron  = <a class="code" href="class_o_t_cron_item.html#af734ad5d309fcc9b4a60d40d6c30f55a">GetCron</a>();
<a name="l02798"></a>02798     <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != pCron);
<a name="l02799"></a>02799     <span class="comment">// ----------------------------------</span>
<a name="l02800"></a>02800     <a class="code" href="class_o_t_pseudonym.html">OTPseudonym</a> * pServerNym = pCron-&gt;<a class="code" href="class_o_t_cron.html#a7756d0dcc047209ca87632939dc11db3">GetServerNym</a>();
<a name="l02801"></a>02801     <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != pServerNym);
<a name="l02802"></a>02802     <span class="comment">// ---------------------------------------------------</span>
<a name="l02803"></a>02803     <span class="comment">// Below this point, these are all good:</span>
<a name="l02804"></a>02804     <span class="comment">//</span>
<a name="l02805"></a>02805     <span class="comment">//      pServerNym, pCron.</span>
<a name="l02806"></a>02806     <span class="comment">//</span>
<a name="l02807"></a>02807     <span class="comment">// ---------------------------------------------------</span>
<a name="l02808"></a>02808     <span class="keywordflow">if</span> (str_Amount.size() &lt; 1)
<a name="l02809"></a>02809     {
<a name="l02810"></a>02810         <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(0, <span class="stringliteral">&quot;OTSmartContract::MoveAcctFunds: Error: empty amount.\n&quot;</span>);
<a name="l02811"></a>02811         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02812"></a>02812     }
<a name="l02813"></a>02813 
<a name="l02814"></a>02814     <span class="keyword">const</span> int64_t lAmount =  atol(str_Amount.c_str());
<a name="l02815"></a>02815 
<a name="l02816"></a>02816     <span class="keywordflow">if</span> (lAmount &lt;= 0)
<a name="l02817"></a>02817     {
<a name="l02818"></a>02818         <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(0, <span class="stringliteral">&quot;OTSmartContract::MoveAcctFunds: Error: lAmount cannot be 0 or &lt;0. (Value passed in was %lld.)\n&quot;</span>,
<a name="l02819"></a>02819                        lAmount);
<a name="l02820"></a>02820         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02821"></a>02821     }
<a name="l02822"></a>02822     <span class="comment">// -----------------------------</span>
<a name="l02823"></a>02823     <span class="keywordflow">if</span> (from_acct_name.size() &lt;= 0)
<a name="l02824"></a>02824     {
<a name="l02825"></a>02825         <a class="code" href="class_o_t_log.html#a5acd90ac91c2618f395b0ff37ad4f8ee">OTLog::Error</a>(<span class="stringliteral">&quot;OTSmartContract::MoveAcctFunds: error: from_acct_name is non-existent.\n&quot;</span>);
<a name="l02826"></a>02826         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02827"></a>02827     }
<a name="l02828"></a>02828     <span class="keywordflow">if</span> (to_acct_name.size() &lt;= 0)
<a name="l02829"></a>02829     {
<a name="l02830"></a>02830         <a class="code" href="class_o_t_log.html#a5acd90ac91c2618f395b0ff37ad4f8ee">OTLog::Error</a>(<span class="stringliteral">&quot;OTSmartContract::MoveAcctFunds: error: to_acct_name is non-existent.\n&quot;</span>);
<a name="l02831"></a>02831         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02832"></a>02832     }
<a name="l02833"></a>02833     <span class="comment">// ---------------------------------------------------</span>
<a name="l02834"></a>02834     <span class="comment">// Below this point, these are all good:</span>
<a name="l02835"></a>02835     <span class="comment">//</span>
<a name="l02836"></a>02836     <span class="comment">//      from_acct_name,</span>
<a name="l02837"></a>02837     <span class="comment">//      to_acct_name,</span>
<a name="l02838"></a>02838     <span class="comment">//      pServerNym, pCron.</span>
<a name="l02839"></a>02839     <span class="comment">//</span>
<a name="l02840"></a>02840     <span class="comment">// ---------------------------------------------------</span>
<a name="l02841"></a>02841 
<a name="l02842"></a>02842     <a class="code" href="class_o_t_party_account.html">OTPartyAccount</a>  * pFromAcct = this-&gt;<a class="code" href="class_o_t_scriptable.html#a94c9e55f78357e04e4b9781ab662370f">GetPartyAccount</a>(from_acct_name);
<a name="l02843"></a>02843     <a class="code" href="class_o_t_party_account.html">OTPartyAccount</a>  * pToAcct   = this-&gt;<a class="code" href="class_o_t_scriptable.html#a94c9e55f78357e04e4b9781ab662370f">GetPartyAccount</a>(to_acct_name);
<a name="l02844"></a>02844 
<a name="l02845"></a>02845     <span class="keywordflow">if</span> (NULL == pFromAcct)
<a name="l02846"></a>02846     {
<a name="l02847"></a>02847         <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(0, <span class="stringliteral">&quot;OTSmartContract::MoveAcctFunds: error: from_acct (%s) not found on any party.\n&quot;</span>,
<a name="l02848"></a>02848                       from_acct_name.c_str());
<a name="l02849"></a>02849         <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(0, <span class="stringliteral">&quot;FULL CONTRACT:  \n%s \n\n&quot;</span>, <a class="code" href="class_o_t_contract.html#a087fc09cfa4b2fd9076088360a5e5039">m_xmlUnsigned</a>.<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>());
<a name="l02850"></a>02850         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02851"></a>02851     }
<a name="l02852"></a>02852     <span class="keywordflow">if</span> (NULL == pToAcct)
<a name="l02853"></a>02853     {
<a name="l02854"></a>02854         <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(0, <span class="stringliteral">&quot;OTSmartContract::MoveAcctFunds: error: to_acct (%s) not found on any party.\n&quot;</span>,
<a name="l02855"></a>02855                       to_acct_name.c_str());
<a name="l02856"></a>02856         <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(0, <span class="stringliteral">&quot;FULL CONTRACT:  \n%s \n\n&quot;</span>, <a class="code" href="class_o_t_contract.html#a087fc09cfa4b2fd9076088360a5e5039">m_xmlUnsigned</a>.<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>());
<a name="l02857"></a>02857 
<a name="l02858"></a>02858         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02859"></a>02859     }
<a name="l02860"></a>02860     <span class="comment">// ---------------------------------------------------</span>
<a name="l02861"></a>02861     <span class="comment">//</span>
<a name="l02862"></a>02862     <span class="comment">// Below this point, these are all good:</span>
<a name="l02863"></a>02863     <span class="comment">//</span>
<a name="l02864"></a>02864     <span class="comment">//      pFromAcct,  from_acct_name,</span>
<a name="l02865"></a>02865     <span class="comment">//      pToAcct,    to_acct_name,</span>
<a name="l02866"></a>02866     <span class="comment">//      pServerNym, pCron.</span>
<a name="l02867"></a>02867     <span class="comment">//</span>
<a name="l02868"></a>02868     <span class="comment">// ---------------------------------------------------</span>
<a name="l02869"></a>02869 
<a name="l02870"></a>02870     <a class="code" href="class_o_t_agent.html">OTAgent</a> * pFromAgent    = pFromAcct-&gt;   GetAuthorizedAgent(); <span class="comment">// This searches the account&#39;s party for the account&#39;s authorized agent.</span>
<a name="l02871"></a>02871     <a class="code" href="class_o_t_agent.html">OTAgent</a> * pToAgent      = pToAcct-&gt;     GetAuthorizedAgent(); <span class="comment">// (That way it&#39;s impossible to get an agent for any other party.)</span>
<a name="l02872"></a>02872 
<a name="l02873"></a>02873     <span class="keywordflow">if</span> (NULL == pFromAgent)
<a name="l02874"></a>02874     {
<a name="l02875"></a>02875         <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(0, <span class="stringliteral">&quot;OTSmartContract::MoveAcctFunds: error: authorized agent (%s) not found for from_acct (%s) on acct&#39;s party.\n&quot;</span>,
<a name="l02876"></a>02876                       pFromAcct-&gt;<a class="code" href="class_o_t_party_account.html#a86975046b18ac6d6c5841f5ba0befe69">GetAgentName</a>().<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>(), from_acct_name.c_str());
<a name="l02877"></a>02877         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02878"></a>02878     }
<a name="l02879"></a>02879     <span class="keywordflow">if</span> (NULL == pToAgent)
<a name="l02880"></a>02880     {
<a name="l02881"></a>02881         <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(0, <span class="stringliteral">&quot;OTSmartContract::MoveAcctFunds: error: authorized agent (%s) not found for to_acct (%s) on acct&#39;s party.\n&quot;</span>,
<a name="l02882"></a>02882                       pToAcct-&gt;<a class="code" href="class_o_t_party_account.html#a86975046b18ac6d6c5841f5ba0befe69">GetAgentName</a>().<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>(), to_acct_name.c_str());
<a name="l02883"></a>02883         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02884"></a>02884     }
<a name="l02885"></a>02885     <span class="comment">// ---------</span>
<a name="l02886"></a>02886     <span class="keywordflow">if</span> (<span class="keyword">false</span> == pFromAgent-&gt;<a class="code" href="class_o_t_agent.html#a1969e4f8a5f13ee34ba0a68d8f082956">IsAnIndividual</a>())
<a name="l02887"></a>02887     {
<a name="l02888"></a>02888         <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(0, <span class="stringliteral">&quot;OTSmartContract::MoveAcctFunds: error: authorized agent (%s) for from_acct (%s) is not an active agent.\n&quot;</span>,
<a name="l02889"></a>02889                       pFromAcct-&gt;<a class="code" href="class_o_t_party_account.html#a86975046b18ac6d6c5841f5ba0befe69">GetAgentName</a>().<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>(), from_acct_name.c_str());
<a name="l02890"></a>02890         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02891"></a>02891     }
<a name="l02892"></a>02892     <span class="keywordflow">if</span> (<span class="keyword">false</span> == pToAgent-&gt;<a class="code" href="class_o_t_agent.html#a1969e4f8a5f13ee34ba0a68d8f082956">IsAnIndividual</a>())
<a name="l02893"></a>02893     {
<a name="l02894"></a>02894         <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(0, <span class="stringliteral">&quot;OTSmartContract::MoveAcctFunds: error: authorized agent (%s) for to_acct (%s) is not an active agent.\n&quot;</span>,
<a name="l02895"></a>02895                       pToAcct-&gt;<a class="code" href="class_o_t_party_account.html#a86975046b18ac6d6c5841f5ba0befe69">GetAgentName</a>().<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>(), to_acct_name.c_str());
<a name="l02896"></a>02896         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02897"></a>02897     }
<a name="l02898"></a>02898     <span class="comment">//</span>
<a name="l02899"></a>02899     <span class="comment">// Below this point, these are all good:</span>
<a name="l02900"></a>02900     <span class="comment">//</span>
<a name="l02901"></a>02901     <span class="comment">//      pFromAcct,  from_acct_name, pFromAgent,</span>
<a name="l02902"></a>02902     <span class="comment">//      pToAcct,    to_acct_name,   pToAgent,</span>
<a name="l02903"></a>02903     <span class="comment">//      pServerNym, pCron.</span>
<a name="l02904"></a>02904     <span class="comment">//</span>
<a name="l02905"></a>02905     <span class="comment">// ---------------------------------------------------</span>
<a name="l02906"></a>02906 
<a name="l02907"></a>02907     <a class="code" href="class_o_t_party.html">OTParty</a> * pFromParty    = pFromAgent-&gt;<a class="code" href="class_o_t_agent.html#a929a2489984f5487bd1819ed6d8862f2">GetParty</a>();
<a name="l02908"></a>02908     <a class="code" href="class_o_t_party.html">OTParty</a> * pToParty      = pToAgent-&gt;<a class="code" href="class_o_t_agent.html#a929a2489984f5487bd1819ed6d8862f2">GetParty</a>();
<a name="l02909"></a>02909 
<a name="l02910"></a>02910     <span class="keywordflow">if</span> (NULL == pFromParty)
<a name="l02911"></a>02911     {
<a name="l02912"></a>02912         <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;OTSmartContract::MoveAcctFunds: error: Party pointer NULL on authorized agent (%s) for from_acct (%s).\n&quot;</span>,
<a name="l02913"></a>02913                       pFromAcct-&gt;<a class="code" href="class_o_t_party_account.html#a86975046b18ac6d6c5841f5ba0befe69">GetAgentName</a>().<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>(), from_acct_name.c_str());
<a name="l02914"></a>02914         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02915"></a>02915     }
<a name="l02916"></a>02916     <span class="keywordflow">if</span> (NULL == pToParty)
<a name="l02917"></a>02917     {
<a name="l02918"></a>02918         <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;OTSmartContract::MoveAcctFunds: error: Party pointer NULL on authorized agent (%s) for to_acct (%s).\n&quot;</span>,
<a name="l02919"></a>02919                       pToAcct-&gt;<a class="code" href="class_o_t_party_account.html#a86975046b18ac6d6c5841f5ba0befe69">GetAgentName</a>().<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>(), to_acct_name.c_str());
<a name="l02920"></a>02920         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02921"></a>02921     }
<a name="l02922"></a>02922     <span class="comment">//</span>
<a name="l02923"></a>02923     <span class="comment">// Below this point, these are all good:</span>
<a name="l02924"></a>02924     <span class="comment">//</span>
<a name="l02925"></a>02925     <span class="comment">//      pFromAcct,  from_acct_name, pFromAgent, pFromParty,</span>
<a name="l02926"></a>02926     <span class="comment">//      pToAcct,    to_acct_name,   pToAgent,   pToParty,</span>
<a name="l02927"></a>02927     <span class="comment">//      pServerNym, pCron.</span>
<a name="l02928"></a>02928     <span class="comment">//</span>
<a name="l02929"></a>02929     <span class="comment">// ---------------------------------------------------</span>
<a name="l02930"></a>02930 
<a name="l02931"></a>02931 
<a name="l02932"></a>02932     <span class="comment">// Done: I can see that THIS VERIFICATION CODE WILL GET CALLED EVERY SINGLE TIME THE SCRIPT</span>
<a name="l02933"></a>02933     <span class="comment">// CALLS MOVE FUNDS.  Maybe that&#39;s good, but since technically this only needs to be verified before the</span>
<a name="l02934"></a>02934     <span class="comment">// first call, and not for EVERY call during any of a script&#39;s runs, I should probably move this verification</span>
<a name="l02935"></a>02935     <span class="comment">// higher, such as each time the OTCronItem triggers, plus each time a party triggers a clause directly</span>
<a name="l02936"></a>02936     <span class="comment">// through the API (server message). As long as those are covered, I will be able to remove it from here</span>
<a name="l02937"></a>02937     <span class="comment">// which should be a significant improvement for performance.</span>
<a name="l02938"></a>02938     <span class="comment">// It will be at the bottom of those same functions that &quot;ClearTemporaryPointers()&quot; should finally be called.</span>
<a name="l02939"></a>02939     <span class="comment">//</span>
<a name="l02940"></a>02940     <span class="comment">// FINAL DECISION: Redundant.  See comment in OTSmartContract::StashAcctFunds()</span>
<a name="l02941"></a>02941     <span class="comment">//</span>
<a name="l02942"></a>02942 <span class="comment">//  const OTString strServerID(GetServerID());</span>
<a name="l02943"></a>02943 <span class="comment">//</span>
<a name="l02944"></a>02944 <span class="comment">//  mapOfNyms   map_Nyms_Already_Loaded;</span>
<a name="l02945"></a>02945 <span class="comment">//  this-&gt;RetrieveNymPointers(map_Nyms_Already_Loaded);</span>
<a name="l02946"></a>02946 <span class="comment">//  // --------------------------------------------------</span>
<a name="l02947"></a>02947 <span class="comment">//</span>
<a name="l02948"></a>02948 <span class="comment">//  if (false == this-&gt;VerifyPartyAuthorization(*pFromParty, *pServerNym, strServerID, &amp;map_Nyms_Already_Loaded))</span>
<a name="l02949"></a>02949 <span class="comment">//  {</span>
<a name="l02950"></a>02950 <span class="comment">//      OTLog::vError(&quot;OTSmartContract::MoveAcctFunds: error: &#39;From&#39; Party (%s) not authorized for this contract.\n&quot;,</span>
<a name="l02951"></a>02951 <span class="comment">//                   pFromParty-&gt;GetPartyName().c_str());</span>
<a name="l02952"></a>02952 <span class="comment">//      return false;</span>
<a name="l02953"></a>02953 <span class="comment">//  }</span>
<a name="l02954"></a>02954 <span class="comment">//  // --------------------------------------------------</span>
<a name="l02955"></a>02955 <span class="comment">//</span>
<a name="l02956"></a>02956 <span class="comment">//  if (false == this-&gt;VerifyPartyAuthorization(*pToParty, *pServerNym, strServerID, &amp;map_Nyms_Already_Loaded))</span>
<a name="l02957"></a>02957 <span class="comment">//  {</span>
<a name="l02958"></a>02958 <span class="comment">//      OTLog::vError(&quot;OTSmartContract::MoveAcctFunds: error: &#39;To&#39; Party (%s) not authorized for this contract.\n&quot;,</span>
<a name="l02959"></a>02959 <span class="comment">//                   pToParty-&gt;GetPartyName().c_str());</span>
<a name="l02960"></a>02960 <span class="comment">//      return false;</span>
<a name="l02961"></a>02961 <span class="comment">//  }</span>
<a name="l02962"></a>02962     <span class="comment">// *****************************************************************************</span>
<a name="l02963"></a>02963 
<a name="l02964"></a>02964     <span class="comment">// A party might have many agents who are only voting groups, and cannot actually sign for things</span>
<a name="l02965"></a>02965     <span class="comment">// the way that nyms can. But at least ONE of those agents IS a Nym -- because there must have been</span>
<a name="l02966"></a>02966     <span class="comment">// an authorizing agent who initially signed to accept the agreement, and who fronted the opening</span>
<a name="l02967"></a>02967     <span class="comment">// transaction number that activated it.</span>
<a name="l02968"></a>02968     <span class="comment">//</span>
<a name="l02969"></a>02969     <span class="comment">// Similarly, the authorized agent for any given party&#39;s account (each account has its own authorized</span>
<a name="l02970"></a>02970     <span class="comment">// agent) MUST be an active agent (an active agent is one with a Nym--whether that Nym is representing</span>
<a name="l02971"></a>02971     <span class="comment">// himself as the party, or whether representing some entity as an employee in a role). Why MUST the</span>
<a name="l02972"></a>02972     <span class="comment">// authorized agent be an active agent? Because when funds are moved, that Nym must be loaded since</span>
<a name="l02973"></a>02973     <span class="comment">// the account must show that Nym as a legal owner/agent. The MoveFunds will cause a paymentReceipt to</span>
<a name="l02974"></a>02974     <span class="comment">// drop into the Inbox for the relevant asset accounts, and that paymentReceipt can ONLY be accepted</span>
<a name="l02975"></a>02975     <span class="comment">// by that same Nym, who must use a transaction # that he signed for previously and received through</span>
<a name="l02976"></a>02976     <span class="comment">// his nymbox. There is actually no justification at all to take funds from that account, since the</span>
<a name="l02977"></a>02977     <span class="comment">// new balance has not yet been signed, UNLESS THE PAYMENTRECEIPT CONTAINS A VALID, SIGNED AUTHORIZATION</span>
<a name="l02978"></a>02978     <span class="comment">// FROM THE ACCOUNT HOLDER. *That* is why the authorizing agent must either be the Party&#39;s Owner himself</span>
<a name="l02979"></a>02979     <span class="comment">// (representing himself as an agent, which most will do) in which case he will appear as the valid</span>
<a name="l02980"></a>02980     <span class="comment">// owner of the account, OR he MUST be a Nym working in a Valid Role for an Entity, where said Entity is</span>
<a name="l02981"></a>02981     <span class="comment">// the valid owner on the account in question. Either OT, it will be possible in OT for him to sign for</span>
<a name="l02982"></a>02982     <span class="comment">// the paymentReceipts when they come in, and impossible for him to escape liability for them.</span>
<a name="l02983"></a>02983     <span class="comment">// (That&#39;s the idea anyway.)</span>
<a name="l02984"></a>02984     <span class="comment">//</span>
<a name="l02985"></a>02985     <span class="comment">// Since we know that the Authorized Agent for an account must be an ACTIVE agent (one way or the other)</span>
<a name="l02986"></a>02986     <span class="comment">// then we can error out here if he&#39;s not.  We can then pass in his Nym ID</span>
<a name="l02987"></a>02987     <span class="comment">//</span>
<a name="l02988"></a>02988 
<a name="l02989"></a>02989     <a class="code" href="class_o_t_identifier.html">OTIdentifier</a> theFromAgentID, theToAgentID;
<a name="l02990"></a>02990     <span class="keyword">const</span> <span class="keywordtype">bool</span> bFromAgentID = pFromAgent-&gt;<a class="code" href="class_o_t_agent.html#a7750c7f5840047c5413d95e92ad87578">GetSignerID</a>(theFromAgentID);
<a name="l02991"></a>02991     <span class="keyword">const</span> <span class="keywordtype">bool</span> bToAgentID   = pToAgent-&gt;<a class="code" href="class_o_t_agent.html#a7750c7f5840047c5413d95e92ad87578">GetSignerID</a>(theToAgentID);
<a name="l02992"></a>02992 
<a name="l02993"></a>02993     <span class="keywordflow">if</span> ( ! bFromAgentID )
<a name="l02994"></a>02994     {
<a name="l02995"></a>02995         <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;OTSmartContract::MoveAcctFunds: Failed to find FromAgent&#39;s Signer ID: %s \n&quot;</span>,
<a name="l02996"></a>02996                       pFromAgent-&gt;<a class="code" href="class_o_t_agent.html#a123d27f05e46977ecdbe0b83de3c119d">GetName</a>().<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>());
<a name="l02997"></a>02997         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02998"></a>02998     }
<a name="l02999"></a>02999     <span class="keywordflow">if</span> ( ! bToAgentID )
<a name="l03000"></a>03000     {
<a name="l03001"></a>03001         <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;OTSmartContract::MoveAcctFunds: Failed to find ToAgent&#39;s Signer ID: %s \n&quot;</span>,
<a name="l03002"></a>03002                       pToAgent-&gt;<a class="code" href="class_o_t_agent.html#a123d27f05e46977ecdbe0b83de3c119d">GetName</a>().<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>());
<a name="l03003"></a>03003         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l03004"></a>03004     }
<a name="l03005"></a>03005     <span class="comment">// --------------------------------------</span>
<a name="l03006"></a>03006 
<a name="l03007"></a>03007     <span class="keywordflow">if</span> (!pFromAcct-&gt;<a class="code" href="class_o_t_party_account.html#aa5e4e0cc77853d08b3708017fe694876">GetAcctID</a>().<a class="code" href="class_o_t_string.html#adf7489cd917d4ae5bf30853a3ad78daf">Exists</a>())
<a name="l03008"></a>03008     {
<a name="l03009"></a>03009         <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;OTSmartContract::MoveAcctFunds: Error: FromAcct has empty AcctID: %s \n&quot;</span>, from_acct_name.c_str());
<a name="l03010"></a>03010         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l03011"></a>03011     }
<a name="l03012"></a>03012     <span class="keywordflow">if</span> (!pToAcct-&gt;<a class="code" href="class_o_t_party_account.html#aa5e4e0cc77853d08b3708017fe694876">GetAcctID</a>().<a class="code" href="class_o_t_string.html#adf7489cd917d4ae5bf30853a3ad78daf">Exists</a>())
<a name="l03013"></a>03013     {
<a name="l03014"></a>03014         <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;OTSmartContract::MoveAcctFunds: Error: ToAcct has empty AcctID: %s \n&quot;</span>, to_acct_name.c_str());
<a name="l03015"></a>03015         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l03016"></a>03016     }
<a name="l03017"></a>03017 
<a name="l03018"></a>03018     <span class="keyword">const</span> <a class="code" href="class_o_t_identifier.html">OTIdentifier</a> theFromAcctID(pFromAcct-&gt;<a class="code" href="class_o_t_party_account.html#aa5e4e0cc77853d08b3708017fe694876">GetAcctID</a>()), theToAcctID(pToAcct-&gt;<a class="code" href="class_o_t_party_account.html#aa5e4e0cc77853d08b3708017fe694876">GetAcctID</a>());
<a name="l03019"></a>03019     <span class="comment">//</span>
<a name="l03020"></a>03020     <span class="comment">// BELOW THIS POINT, theFromAcctID, theFromAgentID, theToAcctID, and theToAgentID are all available.</span>
<a name="l03021"></a>03021     <span class="comment">// --------------------------------------</span>
<a name="l03022"></a>03022 
<a name="l03023"></a>03023 <span class="comment">//   bool OTCronItem::MoveFunds(</span>
<a name="l03024"></a>03024 <span class="comment">//                              const mapOfNyms     &amp;   map_NymsAlreadyLoaded,</span>
<a name="l03025"></a>03025 <span class="comment">//                              const int64_t           &amp;   lAmount,</span>
<a name="l03026"></a>03026 <span class="comment">//                              const OTIdentifier &amp;    SOURCE_ACCT_ID,     // GetSenderAcctID();</span>
<a name="l03027"></a>03027 <span class="comment">//                              const OTIdentifier &amp;    SENDER_USER_ID,     // GetSenderUserID();</span>
<a name="l03028"></a>03028 <span class="comment">//                              const OTIdentifier &amp;    RECIPIENT_ACCT_ID,  // GetRecipientAcctID();</span>
<a name="l03029"></a>03029 <span class="comment">//                              const OTIdentifier &amp;    RECIPIENT_USER_ID)  // GetRecipientUserID();</span>
<a name="l03030"></a>03030 
<a name="l03031"></a>03031 
<a name="l03032"></a>03032     <span class="comment">// ----------------------------------------------------------</span>
<a name="l03033"></a>03033     <span class="comment">// WE SET THESE HERE SO THE RECEIPT SHOWS, SUCCESS OR FAIL,</span>
<a name="l03034"></a>03034     <span class="comment">// WHO THE INTENDED SENDER / RECIPIENT ARE FOR THAT RECEIPT.</span>
<a name="l03035"></a>03035     <span class="comment">//</span>
<a name="l03036"></a>03036     <a class="code" href="class_o_t_smart_contract.html#a09de789ac2e616e2119feb9ddf416c9d">ReleaseLastSenderRecipientIDs</a>();
<a name="l03037"></a>03037     <span class="comment">// -------------------------</span>
<a name="l03038"></a>03038     theFromAgentID.<a class="code" href="class_o_t_identifier.html#a4bccb30446b4b515d9d6016b86b260bb">GetString</a>(m_strLastSenderUser);  <span class="comment">// This is the last User ID of a party who SENT money.</span>
<a name="l03039"></a>03039     theFromAcctID.GetString(m_strLastSenderAcct);   <span class="comment">// This is the last Acct ID of a party who SENT money.</span>
<a name="l03040"></a>03040     theToAgentID.<a class="code" href="class_o_t_identifier.html#a4bccb30446b4b515d9d6016b86b260bb">GetString</a>(m_strLastRecipientUser); <span class="comment">// This is the last User ID of a party who RECEIVED money.</span>
<a name="l03041"></a>03041     theToAcctID.GetString(m_strLastRecipientAcct);  <span class="comment">// This is the last Acct ID of a party who RECEIVED money.</span>
<a name="l03042"></a>03042     <span class="comment">// ----------------------------------------------------------</span>
<a name="l03043"></a>03043 
<a name="l03044"></a>03044     <a class="code" href="_o_t_agent_8hpp.html#ac89892658f6bc83e354078647b704e8f">mapOfNyms</a>   map_Nyms_Already_Loaded;
<a name="l03045"></a>03045     this-&gt;<a class="code" href="class_o_t_scriptable.html#a9e41bb939fd5dbfe1f2442e5919a5079">RetrieveNymPointers</a>(map_Nyms_Already_Loaded);
<a name="l03046"></a>03046 
<a name="l03047"></a>03047     <span class="keywordtype">bool</span> bMoved = this-&gt;<a class="code" href="class_o_t_cron_item.html#a45b93f38aa36e1b0e4c3ab01e1682119">MoveFunds</a>(map_Nyms_Already_Loaded,
<a name="l03048"></a>03048                                   lAmount,
<a name="l03049"></a>03049                                   theFromAcctID,    theFromAgentID,
<a name="l03050"></a>03050                                   theToAcctID,      theToAgentID);
<a name="l03051"></a>03051     <span class="keywordflow">if</span> (!bMoved)
<a name="l03052"></a>03052     {
<a name="l03053"></a>03053         <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(0, <span class="stringliteral">&quot;OTSmartContract::MoveAcctFunds: Failed in call to MoveFunds. from_acct: %s   to_acct: %s\n&quot;</span>,
<a name="l03054"></a>03054                       from_acct_name.c_str(), to_acct_name.c_str());
<a name="l03055"></a>03055         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l03056"></a>03056     }
<a name="l03057"></a>03057 
<a name="l03058"></a>03058     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l03059"></a>03059 }
<a name="l03060"></a>03060 
<a name="l03061"></a>03061 
<a name="l03062"></a>03062 <span class="comment">// This is called by OTCronItem::HookRemovalFromCron</span>
<a name="l03063"></a>03063 <span class="comment">//</span>
<a name="l03064"></a>03064 <span class="comment">// (After calling this method, HookRemovalFromCron then calls onRemovalFromCron.)</span>
<a name="l03065"></a>03065 <span class="comment">//</span>
<a name="l03066"></a><a class="code" href="class_o_t_smart_contract.html#ac956b09210f8037018cd06f11f965df4">03066</a> <span class="keywordtype">void</span> <a class="code" href="class_o_t_smart_contract.html#ac956b09210f8037018cd06f11f965df4">OTSmartContract::onFinalReceipt</a>(<a class="code" href="class_o_t_cron_item.html">OTCronItem</a> &amp; theOrigCronItem, <span class="keyword">const</span> int64_t &amp; lNewTransactionNumber,
<a name="l03067"></a>03067                                      <a class="code" href="class_o_t_pseudonym.html">OTPseudonym</a> &amp; theOriginator,
<a name="l03068"></a>03068                                      <a class="code" href="class_o_t_pseudonym.html">OTPseudonym</a> * pActingNym) <span class="comment">// AKA &quot;pRemover&quot; in any other onFinalReceipt. Could be NULL.</span>
<a name="l03069"></a>03069 {
<a name="l03070"></a>03070     <a class="code" href="class_o_t_cron.html">OTCron</a> * pCron  = <a class="code" href="class_o_t_cron_item.html#af734ad5d309fcc9b4a60d40d6c30f55a">GetCron</a>();
<a name="l03071"></a>03071     <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != pCron);
<a name="l03072"></a>03072 
<a name="l03073"></a>03073     <span class="comment">// ----------------------------------</span>
<a name="l03074"></a>03074 
<a name="l03075"></a>03075     <a class="code" href="class_o_t_pseudonym.html">OTPseudonym</a> * pServerNym = pCron-&gt;<a class="code" href="class_o_t_cron.html#a7756d0dcc047209ca87632939dc11db3">GetServerNym</a>();
<a name="l03076"></a>03076     <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != pServerNym);
<a name="l03077"></a>03077     <span class="comment">// ------------------------------------------</span>
<a name="l03078"></a>03078     <span class="keyword">const</span> <a class="code" href="class_o_t_string.html">OTString</a> strServerID(<a class="code" href="class_o_t_instrument.html#a878dd8998f7b131b85c082575e255375">GetServerID</a>());
<a name="l03079"></a>03079 
<a name="l03080"></a>03080     <span class="comment">// -------------------------------------------------</span>
<a name="l03081"></a>03081 
<a name="l03082"></a>03082     <span class="comment">// The finalReceipt Item&#39;s ATTACHMENT contains the UPDATED Cron Item.</span>
<a name="l03083"></a>03083     <span class="comment">// (With the SERVER&#39;s signature on it!)</span>
<a name="l03084"></a>03084     <span class="comment">//</span>
<a name="l03085"></a>03085     <a class="code" href="class_o_t_string.html">OTString</a> strUpdatedCronItem(*<span class="keyword">this</span>);
<a name="l03086"></a>03086     <a class="code" href="class_o_t_string.html">OTString</a> * pstrAttachment=&amp;strUpdatedCronItem;
<a name="l03087"></a>03087 
<a name="l03088"></a>03088     <span class="keyword">const</span> <a class="code" href="class_o_t_string.html">OTString</a> strOrigCronItem(theOrigCronItem);
<a name="l03089"></a>03089     <span class="comment">// -----------------------------------------------------------------</span>
<a name="l03090"></a>03090 
<a name="l03091"></a>03091     <span class="comment">// IF server is originator and/or remover then swap it in for it/them so I don&#39;t load it twice.</span>
<a name="l03092"></a>03092     <span class="comment">// (already handled before this function is called.)</span>
<a name="l03093"></a>03093     <span class="comment">// ----------------------------------------</span>
<a name="l03094"></a>03094     <span class="comment">// THIS FUNCTION:</span>
<a name="l03095"></a>03095     <span class="comment">//</span>
<a name="l03096"></a>03096     <span class="comment">//</span>
<a name="l03097"></a>03097     <span class="comment">// LOOP through all parties.</span>
<a name="l03098"></a>03098     <span class="comment">// For each party:</span>
<a name="l03099"></a>03099     <span class="comment">// If party is server or originator or ActingNym, etc then set pointer appropriately for that party.</span>
<a name="l03100"></a>03100     <span class="comment">// Find opening and closing numbers for that party.</span>
<a name="l03101"></a>03101     <span class="comment">// Drop finalReceipt to Inboxes for each asset account, using closing numbers.</span>
<a name="l03102"></a>03102     <span class="comment">// Drop finalReceipt to Nymbox for that party, using opening number.</span>
<a name="l03103"></a>03103     <span class="comment">//</span>
<a name="l03104"></a>03104     <span class="comment">// A similar process should happen whenever ANY contract action occurs. (Not just finalReceipt)</span>
<a name="l03105"></a>03105     <span class="comment">// We loop through all the parties and give them a receipt in the relevant accounts.</span>
<a name="l03106"></a>03106     <span class="comment">// And perhaps all notices should be numbered (similar to request number) so that</span>
<a name="l03107"></a>03107     <span class="comment">// people can prove which notices they have received.</span>
<a name="l03108"></a>03108     <span class="comment">// Receipts are given based on?</span>
<a name="l03109"></a>03109     <span class="comment">// The asset accounts that are CHANGED should definitely get an agreementReceipt for the</span>
<a name="l03110"></a>03110     <span class="comment">// balance change.  + All Nymboxes should receive a notice at that time. They should receive</span>
<a name="l03111"></a>03111     <span class="comment">// additional notice for any change in any variable as well. Maybe let parties register for</span>
<a name="l03112"></a>03112     <span class="comment">// various notices.</span>
<a name="l03113"></a>03113     <span class="comment">// What about if a clause processes, but no asset accounts are changed, (no inbox notice)</span>
<a name="l03114"></a>03114     <span class="comment">// and no other variables are changed (no nymbox notices at all...) In that case,</span>
<a name="l03115"></a>03115     <span class="comment">// no other receipts are dropped, right? There will be some standard by which DIRTY flags</span>
<a name="l03116"></a>03116     <span class="comment">// are set onto the various parties and asset accounts, and then notices will be sent based</span>
<a name="l03117"></a>03117     <span class="comment">// upon those.</span>
<a name="l03118"></a>03118     <span class="comment">//</span>
<a name="l03119"></a>03119     <span class="comment">// For those, instead of:</span>
<a name="l03120"></a>03120     <span class="comment">// &quot;theOriginator&quot; (GetSenderUserID()) and &quot;pRemover&quot; and pRecipient,</span>
<a name="l03121"></a>03121     <span class="comment">//</span>
<a name="l03122"></a>03122     <span class="comment">// We would have:</span>
<a name="l03123"></a>03123     <span class="comment">// &quot;theOriginator&quot; (GetSenderUserID()) and &quot;pActingNym&quot; and pParty / pPartyNym (FOR_EACH Party[0..n])</span>
<a name="l03124"></a>03124     <span class="comment">//</span>
<a name="l03125"></a>03125     <span class="comment">// Just like here:</span>
<a name="l03126"></a>03126     <span class="comment">//</span>
<a name="l03127"></a>03127 
<a name="l03128"></a>03128     <a class="code" href="_o_t_storage_8hpp.html#aa135ed03585fa4b246d7907afbd5873d">FOR_EACH</a>(<a class="code" href="_o_t_party_8hpp.html#a029bc6921acd4516530e26201cf595f2">mapOfParties</a>, <a class="code" href="class_o_t_scriptable.html#a6a7e4ef3e0ed95f90d950b1718f815ab">m_mapParties</a>)
<a name="l03129"></a>03129     {
<a name="l03130"></a>03130         <a class="code" href="class_o_t_party.html">OTParty</a> * pParty = (*it).second;
<a name="l03131"></a>03131         <a class="code" href="_o_t_assert_8hpp.html#a033b133f48e61f2b227c52ad2be0c882">OT_ASSERT_MSG</a>(NULL != pParty, <span class="stringliteral">&quot;Unexpected NULL pointer in party map.&quot;</span>);
<a name="l03132"></a>03132         <span class="comment">// --------------------------------------------</span>
<a name="l03133"></a>03133 
<a name="l03134"></a>03134         <span class="comment">// The Nym who is actively requesting to remove a cron item will be passed in as pActingNym.</span>
<a name="l03135"></a>03135         <span class="comment">// However, sometimes there is no Nym... perhaps it just expired and pActingNym is NULL.</span>
<a name="l03136"></a>03136         <span class="comment">// The originating Nym (if different than pActingNym) is loaded up. Otherwise theOriginator</span>
<a name="l03137"></a>03137         <span class="comment">// just points to *pActingNym also.</span>
<a name="l03138"></a>03138         <span class="comment">//</span>
<a name="l03139"></a>03139         <a class="code" href="class_o_t_pseudonym.html">OTPseudonym</a> * pPartyNym = NULL;
<a name="l03140"></a>03140         <a class="code" href="class_o_t_cleanup.html">OTCleanup&lt;OTPseudonym&gt;</a> thePartyNymAngel; <span class="comment">// In case we have to allocate.</span>
<a name="l03141"></a>03141 
<a name="l03142"></a>03142         <span class="comment">// ---------------------------</span>
<a name="l03143"></a>03143 
<a name="l03144"></a>03144         <span class="comment">// See if the serverNym is an agent on this party.</span>
<a name="l03145"></a>03145         <span class="comment">//</span>
<a name="l03146"></a>03146         <span class="keywordflow">if</span> (pParty-&gt;<a class="code" href="class_o_t_party.html#aa34fe1901531ed5056633b99fade0f93">HasAuthorizingAgent</a>(*pServerNym)) <span class="comment">// This should set the temp nym ptr inside the agent also, so I don&#39;t have to search twice.</span>
<a name="l03147"></a>03147         {
<a name="l03148"></a>03148             pPartyNym = pServerNym; <span class="comment">// Just in case the party&#39;s agent&#39;s Nym is also the server Nym.</span>
<a name="l03149"></a>03149         }
<a name="l03150"></a>03150         <span class="comment">// *******************************************************</span>
<a name="l03151"></a>03151         <span class="comment">//</span>
<a name="l03152"></a>03152         <span class="comment">// If pActingNym is NOT NULL, and HE is an agent on this party...</span>
<a name="l03153"></a>03153         <span class="comment">// then set the pointer accordingly.</span>
<a name="l03154"></a>03154         <span class="comment">//</span>
<a name="l03155"></a>03155         <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((NULL != pActingNym) &amp;&amp; pParty-&gt;<a class="code" href="class_o_t_party.html#aa34fe1901531ed5056633b99fade0f93">HasAuthorizingAgent</a>(*pActingNym)) <span class="comment">// There is only one authorizing agent per party.</span>
<a name="l03156"></a>03156         {
<a name="l03157"></a>03157             pPartyNym = pActingNym; <span class="comment">// &lt;======== now both pointers are set (to same Nym). DONE!</span>
<a name="l03158"></a>03158         }
<a name="l03159"></a>03159         <span class="comment">// --------------------------------------------------------------------------------------------------</span>
<a name="l03160"></a>03160 
<a name="l03161"></a>03161         <span class="comment">// Still not found?</span>
<a name="l03162"></a>03162         <span class="keywordflow">if</span> (NULL == pPartyNym)
<a name="l03163"></a>03163         {
<a name="l03164"></a>03164             <span class="comment">// Of all of a party&#39;s Agents, the &quot;authorizing agent&quot; is the one who originally activated</span>
<a name="l03165"></a>03165             <span class="comment">// the agreement for this party (and fronted the opening trans#.) If we&#39;re ending the agreement,</span>
<a name="l03166"></a>03166             <span class="comment">// Then we need to free that number from him. (Even if he was since fired from the role!)</span>
<a name="l03167"></a>03167             <span class="comment">//</span>
<a name="l03168"></a>03168             <span class="comment">// Perhaps need to figure out if the Role itself stores the opening number, and if so, treat</span>
<a name="l03169"></a>03169             <span class="comment">// the Nym&#39;s signature as the role&#39;s, even though the Nym himself doesn&#39;t actually store the #.</span>
<a name="l03170"></a>03170             <span class="comment">// Anyway, I&#39;ll deal with that when I get to entities and roles. Todo.</span>
<a name="l03171"></a>03171             <span class="comment">//</span>
<a name="l03172"></a>03172             pPartyNym = pParty-&gt;<a class="code" href="class_o_t_party.html#a01988fe0bfd917703214f7f7bf3ba66f">LoadAuthorizingAgentNym</a>(*pServerNym);
<a name="l03173"></a>03173 
<a name="l03174"></a>03174             <span class="keywordflow">if</span> (NULL != pPartyNym)
<a name="l03175"></a>03175                 thePartyNymAngel.<a class="code" href="class_o_t_cleanup.html#a00a399db45f730439d2263d4429d00c1">SetCleanupTarget</a>(*pPartyNym);
<a name="l03176"></a>03176         }
<a name="l03177"></a>03177 
<a name="l03178"></a>03178         <span class="comment">// Every party SHOULD have an authorizing agent (otherwise how did that party sign on in the first</span>
<a name="l03179"></a>03179         <span class="comment">// place??) So this should never fail. That&#39;s why there&#39;s an error message below if it&#39;s still NULL.</span>
<a name="l03180"></a>03180         <span class="comment">//</span>
<a name="l03181"></a>03181         <span class="comment">// ***********************************************</span>
<a name="l03182"></a>03182 
<a name="l03183"></a>03183         <span class="keywordflow">if</span> ((NULL != pPartyNym) &amp;&amp;
<a name="l03184"></a>03184             (pParty-&gt;<a class="code" href="class_o_t_party.html#aa11f990dfe9743dd1d8e34af8bfd693a">GetOpeningTransNo</a>() &gt; 0) &amp;&amp;
<a name="l03185"></a>03185             <span class="comment">// Todo: once entities and roles are added, Parties should have their OWN &quot;verify&quot; function</span>
<a name="l03186"></a>03186             <span class="comment">// (Instead of me having to directly find the Nym and verify it myself.)</span>
<a name="l03187"></a>03187             <span class="comment">//</span>
<a name="l03188"></a>03188             pPartyNym-&gt;<a class="code" href="class_o_t_pseudonym.html#a66cf3b97f1769f9d422bad8787a6c1a0">VerifyIssuedNum</a>(strServerID, pParty-&gt;<a class="code" href="class_o_t_party.html#aa11f990dfe9743dd1d8e34af8bfd693a">GetOpeningTransNo</a>()) <span class="comment">// &lt;=====================</span>
<a name="l03189"></a>03189             )
<a name="l03190"></a>03190         {
<a name="l03191"></a>03191             <span class="comment">// The Nym (server side) stores a list of all opening and closing cron #s.</span>
<a name="l03192"></a>03192             <span class="comment">// So when the number is released from the Nym, we also take it off that list.</span>
<a name="l03193"></a>03193             <span class="comment">//</span>
<a name="l03194"></a>03194             std::set&lt;int64_t&gt; &amp; theIDSet = pPartyNym-&gt;<a class="code" href="class_o_t_pseudonym.html#a92abc7a6b6253681f3379f135597f5a9">GetSetOpenCronItems</a>();
<a name="l03195"></a>03195             theIDSet.erase(pParty-&gt;<a class="code" href="class_o_t_party.html#aa11f990dfe9743dd1d8e34af8bfd693a">GetOpeningTransNo</a>());
<a name="l03196"></a>03196 
<a name="l03197"></a>03197             <span class="comment">// the RemoveIssued call means the original transaction# (to find this cron item on cron) is now CLOSED.</span>
<a name="l03198"></a>03198             <span class="comment">// But the Transaction itself is still OPEN. How? Because the CLOSING number is still signed out.</span>
<a name="l03199"></a>03199             <span class="comment">// The closing number is also USED, since the smart contract was initially activated, but it remains</span>
<a name="l03200"></a>03200             <span class="comment">// ISSUED, until the final receipt itself is accepted during a process inbox.</span>
<a name="l03201"></a>03201             <span class="comment">//</span>
<a name="l03202"></a>03202             pPartyNym-&gt;<a class="code" href="class_o_t_pseudonym.html#a17f25f5eb52440cc3ffc139dcbff75fe">RemoveIssuedNum</a>(*pServerNym, strServerID, pParty-&gt;<a class="code" href="class_o_t_party.html#aa11f990dfe9743dd1d8e34af8bfd693a">GetOpeningTransNo</a>(), <span class="keyword">false</span>); <span class="comment">//bSave=false</span>
<a name="l03203"></a>03203             pPartyNym-&gt;<a class="code" href="class_o_t_pseudonym.html#a5d08ef86097db038c2c4fd30034f5dc8">SaveSignedNymfile</a>(*pServerNym);
<a name="l03204"></a>03204         }
<a name="l03205"></a>03205         <span class="keywordflow">else</span>
<a name="l03206"></a>03206         {
<a name="l03207"></a>03207             <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;OTSmartContract::%s: Failed verifying &quot;</span>
<a name="l03208"></a>03208                           <span class="stringliteral">&quot;pPartyNym != NULL &amp;&amp; pParty-&gt;GetOpeningTransNo() &gt; 0 &amp;&amp;  &quot;</span>
<a name="l03209"></a>03209                           <span class="stringliteral">&quot;pPartyNym-&gt;VerifyIssuedNum(pParty-&gt;GetOpeningTransNo())\n&quot;</span>, __FUNCTION__);
<a name="l03210"></a>03210         }
<a name="l03211"></a>03211         <span class="comment">// -------------------------</span>
<a name="l03212"></a>03212         <span class="comment">//</span>
<a name="l03213"></a>03213         <span class="comment">// NOTIFY ALL AGENTS for this party, with a copy of the finalReceipt in their Nymbox.</span>
<a name="l03214"></a>03214         <span class="comment">//</span>
<a name="l03215"></a>03215         <span class="comment">// TOdo: if the above block fails, should I still go dropping these receipts?</span>
<a name="l03216"></a>03216         <span class="comment">//</span>
<a name="l03217"></a>03217         <span class="keywordflow">if</span> ((<span class="keyword">false</span> == pParty-&gt;<a class="code" href="class_o_t_party.html#a6a98b5bb7fb58bd31fa3aa94b53023f6">DropFinalReceiptToNymboxes</a>(lNewTransactionNumber, <span class="comment">// new, owned by the server. For notices.</span>
<a name="l03218"></a>03218                                                          strOrigCronItem,
<a name="l03219"></a>03219                                                          NULL,
<a name="l03220"></a>03220                                                          pstrAttachment,
<a name="l03221"></a>03221                                                          pPartyNym)))
<a name="l03222"></a>03222         {
<a name="l03223"></a>03223             <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;OTSmartContract::%s: Failure dropping final receipt into nymbox for even a single agent.\n&quot;</span>,
<a name="l03224"></a>03224                           __FUNCTION__);
<a name="l03225"></a>03225         }
<a name="l03226"></a>03226 
<a name="l03227"></a>03227         <span class="comment">// -----------------------------------------------------------------</span>
<a name="l03228"></a>03228         <span class="comment">// So the same Nym doesn&#39;t get loaded twice on accident. (We pass in pointers to nyms that</span>
<a name="l03229"></a>03229         <span class="comment">// are already loaded, so the called function can use them instead of loading, if it came</span>
<a name="l03230"></a>03230         <span class="comment">// to that.)</span>
<a name="l03231"></a>03231         <span class="comment">//</span>
<a name="l03232"></a>03232 <span class="comment">//      typedef std::map    &lt;std::string, OTPseudonym *&gt;    mapOfNyms;</span>
<a name="l03233"></a>03233 
<a name="l03234"></a>03234         <a class="code" href="_o_t_agent_8hpp.html#ac89892658f6bc83e354078647b704e8f">mapOfNyms</a>   nym_map;
<a name="l03235"></a>03235 
<a name="l03236"></a>03236         <span class="comment">// -----------------------------------------------------------------------------------------</span>
<a name="l03237"></a>03237         <span class="comment">// pServerNym</span>
<a name="l03238"></a>03238         {
<a name="l03239"></a>03239             <span class="keyword">const</span> <a class="code" href="class_o_t_identifier.html">OTIdentifier</a>  theServerNymID (*pServerNym);
<a name="l03240"></a>03240             <span class="keyword">const</span> <a class="code" href="class_o_t_string.html">OTString</a>      strServerNymID (theServerNymID); <span class="comment">// &lt;--</span>
<a name="l03241"></a>03241 
<a name="l03242"></a>03242             mapOfNyms::iterator iiii = nym_map.find(strServerNymID.<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>());
<a name="l03243"></a>03243 
<a name="l03244"></a>03244             <span class="keywordflow">if</span> ( nym_map.end() == iiii) <span class="comment">// wasn&#39;t already there</span>
<a name="l03245"></a>03245                 nym_map.insert(std::pair&lt;std::string, OTPseudonym *&gt;(strServerNymID.<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>(), pServerNym));
<a name="l03246"></a>03246         }
<a name="l03247"></a>03247         <span class="comment">// -----------------------------------------------------------------------------------------</span>
<a name="l03248"></a>03248         <span class="comment">// theOriginator</span>
<a name="l03249"></a>03249         {
<a name="l03250"></a>03250             <span class="keyword">const</span> <a class="code" href="class_o_t_identifier.html">OTIdentifier</a>  theOriginatorNymID (theOriginator);
<a name="l03251"></a>03251             <span class="keyword">const</span> <a class="code" href="class_o_t_string.html">OTString</a>      strOriginatorNymID (theOriginatorNymID); <span class="comment">// &lt;--</span>
<a name="l03252"></a>03252 
<a name="l03253"></a>03253             mapOfNyms::iterator iiii = nym_map.find(strOriginatorNymID.<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>());
<a name="l03254"></a>03254 
<a name="l03255"></a>03255             <span class="keywordflow">if</span> ( nym_map.end() ==  iiii)<span class="comment">// wasn&#39;t already there</span>
<a name="l03256"></a>03256                 nym_map.insert(std::pair&lt;std::string, OTPseudonym *&gt;(strOriginatorNymID.<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>(), &amp;theOriginator));
<a name="l03257"></a>03257         }
<a name="l03258"></a>03258         <span class="comment">// -----------------------------------------------------------------------------------------</span>
<a name="l03259"></a>03259         <span class="keywordflow">if</span> (NULL != pActingNym)
<a name="l03260"></a>03260         {
<a name="l03261"></a>03261             <span class="keyword">const</span> <a class="code" href="class_o_t_identifier.html">OTIdentifier</a>  theActingNymID (*pActingNym);
<a name="l03262"></a>03262             <span class="keyword">const</span> <a class="code" href="class_o_t_string.html">OTString</a>      strActingNymID (theActingNymID); <span class="comment">// &lt;--</span>
<a name="l03263"></a>03263 
<a name="l03264"></a>03264             mapOfNyms::iterator iiii = nym_map.find(strActingNymID.<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>());
<a name="l03265"></a>03265 
<a name="l03266"></a>03266             <span class="keywordflow">if</span> ( nym_map.end() ==  iiii) <span class="comment">// wasn&#39;t already there</span>
<a name="l03267"></a>03267                 nym_map.insert(std::pair&lt;std::string, OTPseudonym *&gt;(strActingNymID.<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>(), pActingNym));
<a name="l03268"></a>03268         }
<a name="l03269"></a>03269         <span class="comment">// -----------------------------------------------------------------------------------------</span>
<a name="l03270"></a>03270         <span class="keywordflow">if</span> (NULL != pPartyNym)
<a name="l03271"></a>03271         {
<a name="l03272"></a>03272             <span class="keyword">const</span> <a class="code" href="class_o_t_identifier.html">OTIdentifier</a>  thePartyNymID (*pPartyNym);
<a name="l03273"></a>03273             <span class="keyword">const</span> <a class="code" href="class_o_t_string.html">OTString</a>      strPartyNymID (thePartyNymID); <span class="comment">// &lt;--</span>
<a name="l03274"></a>03274 
<a name="l03275"></a>03275 
<a name="l03276"></a>03276             mapOfNyms::iterator iiii = nym_map.find(strPartyNymID.<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>());
<a name="l03277"></a>03277 
<a name="l03278"></a>03278             <span class="keywordflow">if</span> ( nym_map.end() ==  iiii)<span class="comment">// wasn&#39;t already there</span>
<a name="l03279"></a>03279                 nym_map.insert(std::pair&lt;std::string, OTPseudonym *&gt;(strPartyNymID.<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>(), pPartyNym));
<a name="l03280"></a>03280         }
<a name="l03281"></a>03281         <span class="comment">// -----------------------------------------------------------------------------------------</span>
<a name="l03282"></a>03282 
<a name="l03283"></a>03283         <span class="comment">//</span>
<a name="l03284"></a>03284         <span class="comment">// NOTIFY the agent for EACH ACCOUNT listed by this party,</span>
<a name="l03285"></a>03285         <span class="comment">// with a copy of the finalReceipt in the Inbox for each asset acct.</span>
<a name="l03286"></a>03286         <span class="comment">//</span>
<a name="l03287"></a>03287         <span class="comment">// Also for each, if he has a Nym (HE SHOULD), and if</span>
<a name="l03288"></a>03288         <span class="comment">// (CLOSING_NUMBER_HERE &gt; 0), then call:</span>
<a name="l03289"></a>03289         <span class="comment">//</span>
<a name="l03290"></a>03290         <span class="comment">// pNym-&gt;VerifyIssuedNum(strServerID, lClosingNumber)</span>
<a name="l03291"></a>03291         <span class="comment">// (This happens in OTAgent::DropFinalReceipt, FYI.)</span>
<a name="l03292"></a>03292         <span class="comment">//</span>
<a name="l03293"></a>03293 
<a name="l03294"></a>03294         <span class="keywordflow">if</span> (<span class="keyword">false</span> == pParty-&gt;<a class="code" href="class_o_t_party.html#a8144d9376f00f992e0df6f4cfd3a31f1">DropFinalReceiptToInboxes</a>(&amp;nym_map,    <span class="comment">// contains any Nyms who might already be loaded, mapped by ID.</span>
<a name="l03295"></a>03295                                                        strServerID,
<a name="l03296"></a>03296                                                        *pServerNym,
<a name="l03297"></a>03297                                                        lNewTransactionNumber,
<a name="l03298"></a>03298                                                        strOrigCronItem,
<a name="l03299"></a>03299                                                        NULL,
<a name="l03300"></a>03300                                                        pstrAttachment))
<a name="l03301"></a>03301         {
<a name="l03302"></a>03302             <a class="code" href="class_o_t_log.html#a5acd90ac91c2618f395b0ff37ad4f8ee">OTLog::Error</a>(<span class="stringliteral">&quot;OTSmartContract::onFinalReceipt: Failure dropping final receipt into all inboxes. (Missed at least one.)\n&quot;</span>);
<a name="l03303"></a>03303         }
<a name="l03304"></a>03304 
<a name="l03305"></a>03305         <span class="comment">// -----------------------------------------------------------------</span>
<a name="l03306"></a>03306 
<a name="l03307"></a>03307         pParty-&gt;<a class="code" href="class_o_t_party.html#a41a428ded2f0477cf8752648cbe51e4e">ClearTemporaryPointers</a>();
<a name="l03308"></a>03308 
<a name="l03309"></a>03309     } <span class="comment">// FOR_EACH m_mapParties</span>
<a name="l03310"></a>03310 }
<a name="l03311"></a>03311 
<a name="l03312"></a>03312 
<a name="l03313"></a>03313 <span class="comment">// OTCron calls this regularly, which is my chance to expire, etc.</span>
<a name="l03314"></a>03314 <span class="comment">// Return True if I should stay on the Cron list for more processing.</span>
<a name="l03315"></a>03315 <span class="comment">// Return False if I should be removed and deleted.</span>
<a name="l03316"></a><a class="code" href="class_o_t_smart_contract.html#a717de2aa486b22c8ccde06c25bbb64f5">03316</a> <span class="keywordtype">bool</span> <a class="code" href="class_o_t_smart_contract.html#a717de2aa486b22c8ccde06c25bbb64f5">OTSmartContract::ProcessCron</a>()
<a name="l03317"></a>03317 {
<a name="l03318"></a>03318     <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != <a class="code" href="class_o_t_cron_item.html#af734ad5d309fcc9b4a60d40d6c30f55a">GetCron</a>());
<a name="l03319"></a>03319 
<a name="l03320"></a>03320     <span class="comment">// -----------------------------------------------------------------</span>
<a name="l03321"></a>03321     <span class="comment">// Right now Cron is called 10 times per second.</span>
<a name="l03322"></a>03322     <span class="comment">// I&#39;m going to slow down all trades so they are once every GetProcessInterval()</span>
<a name="l03323"></a>03323     <span class="comment">// Todo: Create separate lists in Cron.  10*/sec list, 1/second list, 1 min list, 1 hour, 1 day, 1 month.</span>
<a name="l03324"></a>03324     <span class="comment">// That way I&#39;m not looping through ALL cron items 10*/second, but only the ones who are paying for those</span>
<a name="l03325"></a>03325     <span class="comment">// kinds of resources. (Different lists will cost different server fees.)</span>
<a name="l03326"></a>03326     <span class="comment">//</span>
<a name="l03327"></a>03327     <span class="keywordflow">if</span> (<a class="code" href="class_o_t_cron_item.html#ad8f19edf794a54644ed4822d0bc120a4">GetLastProcessDate</a>() &gt; <a class="code" href="_o_t_common_8hpp.html#af4ca9fa2c7c290d647dd18de0a9ac25f">OT_TIME_ZERO</a>)
<a name="l03328"></a>03328     {
<a name="l03329"></a>03329         <span class="comment">// Default ProcessInternal is 1 second, but Trades will use 10 seconds, and Payment</span>
<a name="l03330"></a>03330         <span class="comment">// Plans will use an hour or day. Smart contracts are currently 30 seconds. (For testing.)</span>
<a name="l03331"></a>03331         <span class="comment">//</span>
<a name="l03332"></a>03332         <span class="keywordflow">if</span> (<a class="code" href="_o_t_common_8hpp.html#a4c78edddfcabfde278fafe43149f027e">OTTimeGetTimeInterval</a>(<a class="code" href="_o_t_common_8hpp.html#a1163606b2546b160d50c5f0a5afe479a">OTTimeGetCurrentTime</a>(), <a class="code" href="class_o_t_cron_item.html#ad8f19edf794a54644ed4822d0bc120a4">GetLastProcessDate</a>()) &lt;= <a class="code" href="class_o_t_cron_item.html#a39dce8a744a7dc6914e130bdde334a97">GetProcessInterval</a>())
<a name="l03333"></a>03333             <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l03334"></a>03334     }
<a name="l03335"></a>03335     <span class="comment">// Keep a record of the last time this was processed.</span>
<a name="l03336"></a>03336     <span class="comment">// (NOT saved to storage, only used while the software is running.)</span>
<a name="l03337"></a>03337     <span class="comment">// (Thus no need to release signatures, sign contract, save contract, etc.)</span>
<a name="l03338"></a>03338     <a class="code" href="class_o_t_cron_item.html#aac4ad32d864f5b6e8ce07a28432bf1ef">SetLastProcessDate</a>(<a class="code" href="_o_t_common_8hpp.html#a1163606b2546b160d50c5f0a5afe479a">OTTimeGetCurrentTime</a>());
<a name="l03339"></a>03339     <span class="comment">// -----------------------------------------------------------------</span>
<a name="l03340"></a>03340 
<a name="l03341"></a>03341     <span class="comment">// END DATE --------------------------------</span>
<a name="l03342"></a>03342     <span class="comment">// First call the parent&#39;s version (which this overrides) so it has</span>
<a name="l03343"></a>03343     <span class="comment">// a chance to check its stuff.</span>
<a name="l03344"></a>03344     <span class="comment">// Currently it calls IsExpired().</span>
<a name="l03345"></a>03345     <span class="comment">//</span>
<a name="l03346"></a>03346     <span class="keywordflow">if</span> (<span class="keyword">false</span> == <a class="code" href="class_o_t_cron_item.html#afe5c6a9af86b637fd8b2b3459825565b">ot_super::ProcessCron</a>())
<a name="l03347"></a>03347     {
<a name="l03348"></a>03348         <a class="code" href="class_o_t_log.html#a1f7549d776ee919dcb6517f611ded015">OTLog::Output</a>(3, <span class="stringliteral">&quot;Cron job has expired.\n&quot;</span>);
<a name="l03349"></a>03349         <span class="keywordflow">return</span> <span class="keyword">false</span>;   <span class="comment">// It&#39;s expired or flagged for removal--remove it from Cron.</span>
<a name="l03350"></a>03350     }
<a name="l03351"></a>03351 
<a name="l03352"></a>03352     <span class="comment">// START DATE --------------------------------</span>
<a name="l03353"></a>03353     <span class="comment">// Okay, so it&#39;s not expired. But might not have reached START DATE yet...</span>
<a name="l03354"></a>03354     <span class="keywordflow">if</span> (!<a class="code" href="class_o_t_instrument.html#a8a90b4e37984058d8e6fb836311c5dd9">VerifyCurrentDate</a>())
<a name="l03355"></a>03355         <span class="keywordflow">return</span> <span class="keyword">true</span>;    <span class="comment">// The Payment Plan is not yet valid, so we return. BUT, we also</span>
<a name="l03356"></a>03356     <span class="comment">// return TRUE, so it will STAY on Cron until it BECOMES valid.</span>
<a name="l03357"></a>03357 
<a name="l03358"></a>03358     <span class="comment">// -----------------------------------------------------------------------------</span>
<a name="l03359"></a>03359     <span class="comment">// Make sure there are transaction numbers available in Cron.</span>
<a name="l03360"></a>03360     <span class="comment">// (Can&#39;t do anything without those....)</span>
<a name="l03361"></a>03361     <span class="comment">//</span>
<a name="l03362"></a>03362     <span class="keywordflow">if</span> (<a class="code" href="class_o_t_cron_item.html#af734ad5d309fcc9b4a60d40d6c30f55a">GetCron</a>()-&gt;GetTransactionCount() &lt; 1)
<a name="l03363"></a>03363     {
<a name="l03364"></a>03364         <a class="code" href="class_o_t_log.html#a1f7549d776ee919dcb6517f611ded015">OTLog::Output</a>(0, <span class="stringliteral">&quot;Failed to process smart contract: Cron is out of transaction numbers!\n&quot;</span>);
<a name="l03365"></a>03365         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l03366"></a>03366     }
<a name="l03367"></a>03367 
<a name="l03368"></a>03368     <span class="comment">// -----------------------------------------------------------------------------</span>
<a name="l03369"></a>03369     <span class="comment">// Make sure, if the script set a timer, that we don&#39;t process Cron until that timer</span>
<a name="l03370"></a>03370     <span class="comment">// is reached. (If the timer&#39;s not set, then we go ahead and process every time.)</span>
<a name="l03371"></a>03371     <span class="comment">//</span>
<a name="l03372"></a>03372     <span class="keyword">const</span> <a class="code" href="_o_t_common_8hpp.html#ad28ff0a3eda18840f6bda5872819167f">time64_t</a> tNextProcessDate = <a class="code" href="class_o_t_smart_contract.html#a16737b147030f0aaaedc53f798c35a50">GetNextProcessDate</a>();
<a name="l03373"></a>03373 
<a name="l03374"></a>03374     <span class="keywordflow">if</span> (tNextProcessDate &gt; <a class="code" href="_o_t_common_8hpp.html#af4ca9fa2c7c290d647dd18de0a9ac25f">OT_TIME_ZERO</a>) <span class="comment">// IF there is a timer set (as to when the next &quot;onProcess&quot; should occur)...</span>
<a name="l03375"></a>03375     {
<a name="l03376"></a>03376         <span class="keywordflow">if</span> (<a class="code" href="_o_t_common_8hpp.html#a1163606b2546b160d50c5f0a5afe479a">OTTimeGetCurrentTime</a>() &lt;= tNextProcessDate) <span class="comment">// AND if the current time has NOT YET reached that date (the date in the timer)...</span>
<a name="l03377"></a>03377         {
<a name="l03378"></a>03378             <span class="comment">// ...Then RETURN (since the timer hasn&#39;t popped yet)</span>
<a name="l03379"></a>03379             <span class="comment">// But return TRUE, so that this cron item stays active for now.</span>
<a name="l03380"></a>03380             <span class="comment">//</span>
<a name="l03381"></a>03381             <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l03382"></a>03382         }
<a name="l03383"></a>03383         <span class="keywordflow">else</span> <span class="comment">// else it HAS now reached the official timer date...</span>
<a name="l03384"></a>03384         {
<a name="l03385"></a>03385             <a class="code" href="class_o_t_smart_contract.html#a0c0ffa47dacaa8fa79304317f8e04544">SetNextProcessDate</a>(<a class="code" href="_o_t_common_8hpp.html#af4ca9fa2c7c290d647dd18de0a9ac25f">OT_TIME_ZERO</a>);   <span class="comment">// Therefore timer has triggered, so we will continue processing.</span>
<a name="l03386"></a>03386         }                           <span class="comment">// We also reset timer to 0 again since it has now &quot;binged&quot;.</span>
<a name="l03387"></a>03387     }   <span class="comment">// Continuing on....</span>
<a name="l03388"></a>03388     <span class="comment">// *****************************************************************************</span>
<a name="l03389"></a>03389     <span class="comment">//</span>
<a name="l03390"></a>03390     <span class="comment">// Execute the scripts (clauses) that have registered for this hook.</span>
<a name="l03391"></a>03391 
<a name="l03392"></a>03392     <span class="keyword">const</span> std::string   str_HookName(<a class="code" href="_o_t_smart_contract_8cpp.html#a3620c2b37a2cef094ecadcc890af8383">SMARTCONTRACT_HOOK_ON_PROCESS</a>);
<a name="l03393"></a>03393     <a class="code" href="_o_t_clause_8hpp.html#a40c16432fa9c16826c026b74351425ad">mapOfClauses</a>        theMatchingClauses;
<a name="l03394"></a>03394 
<a name="l03395"></a>03395     <span class="keywordflow">if</span> (this-&gt;<a class="code" href="class_o_t_scriptable.html#a298d8fdb0982df3c36e8ae194f228009">GetHooks</a>(str_HookName, theMatchingClauses))
<a name="l03396"></a>03396     {
<a name="l03397"></a>03397         <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(0, <span class="stringliteral">&quot;Cron: Processing smart contract clauses for hook: %s \n&quot;</span>, <a class="code" href="_o_t_smart_contract_8cpp.html#a3620c2b37a2cef094ecadcc890af8383">SMARTCONTRACT_HOOK_ON_PROCESS</a>);
<a name="l03398"></a>03398 
<a name="l03399"></a>03399         this-&gt;<a class="code" href="class_o_t_smart_contract.html#a83282de7074313974d0db0f50b3b6e09">ExecuteClauses</a>(theMatchingClauses); <span class="comment">// &lt;============================================</span>
<a name="l03400"></a>03400     }
<a name="l03401"></a>03401     <span class="comment">//</span>
<a name="l03402"></a>03402     <span class="comment">// *****************************************************************************</span>
<a name="l03403"></a>03403 
<a name="l03404"></a>03404 
<a name="l03405"></a>03405     <span class="keywordflow">if</span> (<a class="code" href="class_o_t_cron_item.html#a5fd32eb6600ee9740e5e99acebcaa2d8">IsFlaggedForRemoval</a>())
<a name="l03406"></a>03406     {
<a name="l03407"></a>03407         <a class="code" href="class_o_t_log.html#a1f7549d776ee919dcb6517f611ded015">OTLog::Output</a>(3, <span class="stringliteral">&quot;OTSmartContract::ProcessCron: Removing smart contract from cron processing...\n&quot;</span>);
<a name="l03408"></a>03408         <span class="keywordflow">return</span> <span class="keyword">false</span>; <span class="comment">// false means &quot;remove this cron item from cron&quot;</span>
<a name="l03409"></a>03409     }
<a name="l03410"></a>03410 
<a name="l03411"></a>03411     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l03412"></a>03412 }
<a name="l03413"></a>03413 
<a name="l03414"></a>03414 
<a name="l03415"></a>03415 <span class="comment">//virtual</span>
<a name="l03416"></a><a class="code" href="class_o_t_smart_contract.html#a0724be6ceeab338be3d9ea1469e82114">03416</a> <span class="keywordtype">void</span> <a class="code" href="class_o_t_smart_contract.html#a0724be6ceeab338be3d9ea1469e82114">OTSmartContract::SetDisplayLabel</a>(<span class="keyword">const</span> std::string * pstrLabel<span class="comment">/*=NULL*/</span>)
<a name="l03417"></a>03417 {
<a name="l03418"></a>03418     <a class="code" href="class_o_t_scriptable.html#a9e1d9c7e46bab582ea1922026a21b357">m_strLabel</a>.<a class="code" href="class_o_t_string.html#af1c861f21033a1d583b3cb12f952422e">Format</a>(<span class="stringliteral">&quot;smartcontract trans# %lld, clause: %s&quot;</span>,
<a name="l03419"></a>03419                               <a class="code" href="class_o_t_trackable.html#a2594d320e3b24f3210bd38a08de66a70">GetTransactionNum</a>(),
<a name="l03420"></a>03420                               (NULL != pstrLabel) ? pstrLabel-&gt;c_str() : <span class="stringliteral">&quot;&quot;</span>);
<a name="l03421"></a>03421 }
<a name="l03422"></a>03422 
<a name="l03423"></a>03423 
<a name="l03424"></a><a class="code" href="class_o_t_smart_contract.html#a83282de7074313974d0db0f50b3b6e09">03424</a> <span class="keywordtype">void</span> <a class="code" href="class_o_t_smart_contract.html#a83282de7074313974d0db0f50b3b6e09">OTSmartContract::ExecuteClauses</a> (<a class="code" href="_o_t_clause_8hpp.html#a40c16432fa9c16826c026b74351425ad">mapOfClauses</a> &amp; theClauses, <a class="code" href="class_o_t_string.html">OTString</a> * pParam<span class="comment">/*=NULL*/</span>) <span class="comment">// someday pParam could be a stringMap instead of a single param.</span>
<a name="l03425"></a>03425 {
<a name="l03426"></a>03426     <span class="comment">// Loop through the clauses passed in, and execute them all.</span>
<a name="l03427"></a>03427     <span class="comment">//</span>
<a name="l03428"></a>03428     <a class="code" href="_o_t_storage_8hpp.html#a4a94c3435a932ed34e5755f3f472547c">FOR_EACH_IT</a>(<a class="code" href="_o_t_clause_8hpp.html#a40c16432fa9c16826c026b74351425ad">mapOfClauses</a>, theClauses, it_clauses)
<a name="l03429"></a>03429     {
<a name="l03430"></a>03430         <span class="keyword">const</span> std::string str_clause_name   = (*it_clauses).first;
<a name="l03431"></a>03431         <a class="code" href="class_o_t_clause.html">OTClause</a> * pClause                  = (*it_clauses).second;
<a name="l03432"></a>03432         <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>((NULL != pClause) &amp;&amp; (str_clause_name.size() &gt; 0));
<a name="l03433"></a>03433         <a class="code" href="class_o_t_bylaw.html">OTBylaw</a> * pBylaw = pClause-&gt;<a class="code" href="class_o_t_clause.html#adcfc1603deba61e670b5d1374147bd6a">GetBylaw</a>();
<a name="l03434"></a>03434         <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != pBylaw);
<a name="l03435"></a>03435         <span class="comment">// -------------------------------------------------</span>
<a name="l03436"></a>03436         <span class="comment">// By this point, we have the clause we are executing as pClause,</span>
<a name="l03437"></a>03437         <span class="comment">// and we have the Bylaw it belongs to, as pBylaw.</span>
<a name="l03438"></a>03438         <span class="comment">// ----------------------------------------</span>
<a name="l03439"></a>03439         <span class="keyword">const</span> std::string str_code      =   pClause-&gt;<a class="code" href="class_o_t_clause.html#a29dced05f7ab1026ef191dbc013dddd6">GetCode</a>();     <span class="comment">// source code for the script.</span>
<a name="l03440"></a>03440         <span class="keyword">const</span> std::string str_language  =   pBylaw-&gt;<a class="code" href="class_o_t_bylaw.html#a9227cd44b9e3bab6efdf0dcb719e126c">GetLanguage</a>();  <span class="comment">// language it&#39;s in. (Default is &quot;chai&quot;)</span>
<a name="l03441"></a>03441 
<a name="l03442"></a>03442         _SharedPtr&lt;OTScript&gt; pScript = <a class="code" href="_o_t_script_8hpp.html#af97c0dd6a02e33a9ff1c837a6d006b88">OTScriptFactory</a>(str_language, str_code);
<a name="l03443"></a>03443 
<a name="l03444"></a>03444         <a class="code" href="class_o_t_cleanup.html">OTCleanup&lt;OTVariable&gt;</a> theVarAngel;
<a name="l03445"></a>03445         <span class="comment">// ---------------------------------------------------------------</span>
<a name="l03446"></a>03446         <span class="comment">//</span>
<a name="l03447"></a>03447         <span class="comment">// SET UP THE NATIVE CALLS, REGISTER THE PARTIES, REGISTER THE VARIABLES, AND EXECUTE THE SCRIPT.</span>
<a name="l03448"></a>03448         <span class="comment">//</span>
<a name="l03449"></a>03449         <span class="keywordflow">if</span> (pScript)
<a name="l03450"></a>03450         {
<a name="l03451"></a>03451             <span class="comment">// Register the special server-side native OT calls we make available to all scripts.</span>
<a name="l03452"></a>03452             <span class="comment">//</span>
<a name="l03453"></a>03453             <a class="code" href="class_o_t_smart_contract.html#ad79350fe9df32d0e129e1a8b5fe28a04">RegisterOTNativeCallsWithScript</a>(*pScript);
<a name="l03454"></a>03454 
<a name="l03455"></a>03455             <span class="comment">// ---------------------------------------</span>
<a name="l03456"></a>03456             <span class="comment">// Register all the parties with the script.</span>
<a name="l03457"></a>03457             <span class="comment">//</span>
<a name="l03458"></a>03458             <a class="code" href="_o_t_storage_8hpp.html#aa135ed03585fa4b246d7907afbd5873d">FOR_EACH</a>(<a class="code" href="_o_t_party_8hpp.html#a029bc6921acd4516530e26201cf595f2">mapOfParties</a>, <a class="code" href="class_o_t_scriptable.html#a6a7e4ef3e0ed95f90d950b1718f815ab">m_mapParties</a>)
<a name="l03459"></a>03459             {
<a name="l03460"></a>03460                 <span class="keyword">const</span> std::string str_party_name    = (*it).first;
<a name="l03461"></a>03461                 <a class="code" href="class_o_t_party.html">OTParty</a> * pParty                    = (*it).second;
<a name="l03462"></a>03462                 <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>((NULL != pParty) &amp;&amp; (str_party_name.size() &gt; 0));
<a name="l03463"></a>03463                 <span class="comment">// -----------------------</span>
<a name="l03464"></a>03464 
<a name="l03465"></a>03465                 pScript-&gt;AddParty(str_party_name, *pParty);  <span class="comment">// This also registers all of Party&#39;s accounts with pScript.</span>
<a name="l03466"></a>03466                 <span class="comment">// -----------------------</span>
<a name="l03467"></a>03467             }
<a name="l03468"></a>03468             <span class="comment">// ---------------------------------------</span>
<a name="l03469"></a>03469             <span class="comment">// Also need to loop through the Variables on pBylaw and register those as well.</span>
<a name="l03470"></a>03470             <span class="comment">//</span>
<a name="l03471"></a>03471             pBylaw-&gt;<a class="code" href="class_o_t_bylaw.html#aa9a5296f71c28edb48988fe0a8b4bf65">RegisterVariablesForExecution</a>(*pScript); <span class="comment">// This also sets all the variables as CLEAN so we can check for dirtiness after execution.</span>
<a name="l03472"></a>03472             <span class="comment">// ---------------------------------------</span>
<a name="l03473"></a>03473             <span class="comment">// A parameter might also be passed in, so we add that to the script as well.</span>
<a name="l03474"></a>03474             <span class="comment">// (Like if a client is sending a triggerClause message to a server, and passing</span>
<a name="l03475"></a>03475             <span class="comment">// a string parameter to that clause as input.)</span>
<a name="l03476"></a>03476             <span class="comment">//</span>
<a name="l03477"></a>03477             <a class="code" href="class_o_t_variable.html">OTVariable</a> * pVar = NULL;
<a name="l03478"></a>03478             <span class="keyword">const</span> std::string str_Name(<span class="stringliteral">&quot;param_string&quot;</span>);
<a name="l03479"></a>03479             std::string str_Value(<span class="stringliteral">&quot;&quot;</span>);
<a name="l03480"></a>03480 
<a name="l03481"></a>03481             <span class="comment">// See if param_string variable is already found on the bylaw...</span>
<a name="l03482"></a>03482             <span class="comment">//</span>
<a name="l03483"></a>03483             <span class="keywordflow">if</span> (NULL != pBylaw-&gt;<a class="code" href="class_o_t_bylaw.html#aae26ff96d920fcc17ef69e9f0c762710">GetVariable</a>(str_Name)) <span class="comment">// disallow duplicate names.</span>
<a name="l03484"></a>03484             {
<a name="l03485"></a>03485                 <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;OTSmartContract::ExecuteClauses: While preparing to run smartcontract trans# %lld, clause: %s.  Error: &quot;</span>
<a name="l03486"></a>03486                               <span class="stringliteral">&quot;Parameter variable named %s already exists. (Skipping the parameter actually passed in.)\n&quot;</span>,
<a name="l03487"></a>03487                               <a class="code" href="class_o_t_trackable.html#a2594d320e3b24f3210bd38a08de66a70">GetTransactionNum</a>(), str_clause_name.c_str(), str_Name.c_str());
<a name="l03488"></a>03488             }
<a name="l03489"></a>03489             <span class="keywordflow">else</span> <span class="comment">// The param_string variable isn&#39;t already there. (So we add it as blank, if a value wasn&#39;t passed in.)</span>
<a name="l03490"></a>03490             {
<a name="l03491"></a>03491                 <span class="keywordflow">if</span> (NULL != pParam) <span class="comment">// if a param was passed in...</span>
<a name="l03492"></a>03492                     str_Value = pParam-&gt;<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>();
<a name="l03493"></a>03493                 <span class="comment">// else (it&#39;s already &quot;&quot;)</span>
<a name="l03494"></a>03494 
<a name="l03495"></a>03495                 pVar = <span class="keyword">new</span> <a class="code" href="class_o_t_variable.html">OTVariable</a>(str_Name, str_Value, <a class="code" href="class_o_t_variable.html#a649f74cb58ba9ed9aeb8601750c98672a3663696326da4cd07edb796beec5c324">OTVariable::Var_Constant</a>);
<a name="l03496"></a>03496                 <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != pVar);
<a name="l03497"></a>03497                 theVarAngel.<a class="code" href="class_o_t_cleanup.html#a00a399db45f730439d2263d4429d00c1">SetCleanupTarget</a>(*pVar);
<a name="l03498"></a>03498                 <span class="comment">// -------------------------------------</span>
<a name="l03499"></a>03499                 pVar-&gt;<a class="code" href="class_o_t_variable.html#a89944d26c87080bbc6aab0ff3fe26de5">RegisterForExecution</a>(*pScript); <span class="comment">// This causes pVar to keep a pointer to the script so it can remove itself from the script upon destruction.</span>
<a name="l03500"></a>03500 <span class="comment">//              pScript-&gt;AddVariable(str_Name, *pVar);</span>
<a name="l03501"></a>03501             }
<a name="l03502"></a>03502             <span class="comment">// ****************************************</span>
<a name="l03503"></a>03503             <span class="comment">// TEMP FOR TESTING (HARDCODED CLAUSE NAME HERE...)</span>
<a name="l03504"></a>03504 <span class="comment">//          OTVariable theReturnVal(&quot;return_val&quot;, false); // initial value is: false.</span>
<a name="l03505"></a>03505 
<a name="l03506"></a>03506             this-&gt;<a class="code" href="class_o_t_smart_contract.html#a0724be6ceeab338be3d9ea1469e82114">SetDisplayLabel</a>(&amp;str_clause_name);
<a name="l03507"></a>03507 
<a name="l03508"></a>03508             pScript-&gt;SetDisplayFilename(<a class="code" href="class_o_t_scriptable.html#a9e1d9c7e46bab582ea1922026a21b357">m_strLabel</a>.<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>());
<a name="l03509"></a>03509 
<a name="l03510"></a>03510             <span class="keywordflow">if</span> (<span class="keyword">false</span> == pScript-&gt;ExecuteScript())  <span class="comment">// If I passed theReturnVal in here, then it&#39;d be assumed a bool is expected to be returned inside it.</span>
<a name="l03511"></a>03511 <span class="comment">//          if (false == pScript-&gt;ExecuteScript((str_clause_name.compare(&quot;process_clause&quot;) == 0) ? &amp;theReturnVal : NULL))</span>
<a name="l03512"></a>03512             {
<a name="l03513"></a>03513                 <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;OTSmartContract::ExecuteClauses: Error while running smartcontract trans# %lld, clause: %s \n\n&quot;</span>,
<a name="l03514"></a>03514                              <a class="code" href="class_o_t_trackable.html#a2594d320e3b24f3210bd38a08de66a70">GetTransactionNum</a>(), str_clause_name.c_str());
<a name="l03515"></a>03515             }
<a name="l03516"></a>03516             <span class="keywordflow">else</span>
<a name="l03517"></a>03517                 <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(0, <span class="stringliteral">&quot;OTSmartContract::ExecuteClauses: Success executing smartcontract trans# %lld, clause: %s \n\n&quot;</span>,
<a name="l03518"></a>03518                                <a class="code" href="class_o_t_trackable.html#a2594d320e3b24f3210bd38a08de66a70">GetTransactionNum</a>(), str_clause_name.c_str());
<a name="l03519"></a>03519             <span class="comment">// ****************************************</span>
<a name="l03520"></a>03520 <span class="comment">//          For now, I&#39;ve decided to allow ALL clauses to trigger on the hook. The flag only matters after</span>
<a name="l03521"></a>03521 <span class="comment">//          they are done, and not between scripts. Otherwise problems could arise, such as order of execution.</span>
<a name="l03522"></a>03522 <span class="comment">//          Remember, there is nothing stopping people from using their own variables and ending all behavior</span>
<a name="l03523"></a>03523 <span class="comment">//          after that flag is set.  Todo security: revisit this just in case.</span>
<a name="l03524"></a>03524 <span class="comment">//</span>
<a name="l03525"></a>03525 <span class="comment">//          // Check this after each script.</span>
<a name="l03526"></a>03526 <span class="comment">//          //</span>
<a name="l03527"></a>03527 <span class="comment">//          if (IsFlaggedForRemoval())</span>
<a name="l03528"></a>03528 <span class="comment">//          {</span>
<a name="l03529"></a>03529 <span class="comment">//              OTLog::Output(3, &quot;OTSmartContract::ExecuteClauses: Flagged for removal by script.\n&quot;);</span>
<a name="l03530"></a>03530 <span class="comment">//          }</span>
<a name="l03531"></a>03531         }
<a name="l03532"></a>03532         <span class="comment">// ---------------------------------------------------------------</span>
<a name="l03533"></a>03533         <span class="keywordflow">else</span>
<a name="l03534"></a>03534         {
<a name="l03535"></a>03535             <a class="code" href="class_o_t_log.html#a5acd90ac91c2618f395b0ff37ad4f8ee">OTLog::Error</a>(<span class="stringliteral">&quot;OTSmartContract::ExecuteClauses: Error instantiating script!\n&quot;</span>);
<a name="l03536"></a>03536         }
<a name="l03537"></a>03537     } <span class="comment">// FOR_EACH clauses...</span>
<a name="l03538"></a>03538 
<a name="l03539"></a>03539     <span class="comment">// ***************************************************************</span>
<a name="l03540"></a>03540 
<a name="l03541"></a>03541     <span class="comment">// &quot;Important&quot; variables.</span>
<a name="l03542"></a>03542     <span class="comment">// (If any of them have changed, then I need to notice the parties.)</span>
<a name="l03543"></a>03543     <span class="comment">//</span>
<a name="l03544"></a>03544     <span class="comment">// TODO: Fix IsDirtyImportant() so that it checks for changed STASHES</span>
<a name="l03545"></a>03545     <span class="comment">// as well. (Or have another function to do it, which is also called here.)</span>
<a name="l03546"></a>03546     <span class="comment">//</span>
<a name="l03547"></a>03547     <span class="comment">// I&#39;d like to get to where I can just call IsDirty() here, and then SAVE CRON HERE,</span>
<a name="l03548"></a>03548     <span class="comment">// so I&#39;m not having to save it after EACH change, which is currently occuring in the</span>
<a name="l03549"></a>03549     <span class="comment">// StashAcctFunds / MoveAcctFunds functions. Todo.</span>
<a name="l03550"></a>03550     <span class="comment">//</span>
<a name="l03551"></a>03551     <span class="keywordflow">if</span> (this-&gt;<a class="code" href="class_o_t_scriptable.html#a9f08ba14dc0e384301b8b69947243581">IsDirtyImportant</a>()) <span class="comment">// This tells us if any &quot;Important&quot; variables have changed since executing the scripts.</span>
<a name="l03552"></a>03552     {
<a name="l03553"></a>03553         <a class="code" href="class_o_t_cron.html">OTCron</a> * pCron  = <a class="code" href="class_o_t_cron_item.html#af734ad5d309fcc9b4a60d40d6c30f55a">GetCron</a>();
<a name="l03554"></a>03554         <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != pCron);
<a name="l03555"></a>03555 
<a name="l03556"></a>03556         <a class="code" href="class_o_t_pseudonym.html">OTPseudonym</a> * pServerNym = pCron-&gt;<a class="code" href="class_o_t_cron.html#a7756d0dcc047209ca87632939dc11db3">GetServerNym</a>();
<a name="l03557"></a>03557         <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != pServerNym);
<a name="l03558"></a>03558         <span class="comment">// -----------------------------------------------------</span>
<a name="l03559"></a>03559         <span class="keyword">const</span> int64_t lNewTransactionNumber = pCron-&gt;<a class="code" href="class_o_t_cron.html#a22822e0aeced441b6404cd8a2c8e00da">GetNextTransactionNumber</a>();
<a name="l03560"></a>03560 
<a name="l03561"></a>03561 <span class="comment">//      OT_ASSERT(lNewTransactionNumber &gt; 0); // this can be my reminder.</span>
<a name="l03562"></a>03562         <span class="keywordflow">if</span> (0 == lNewTransactionNumber)
<a name="l03563"></a>03563         {
<a name="l03564"></a>03564             <a class="code" href="class_o_t_log.html#a5acd90ac91c2618f395b0ff37ad4f8ee">OTLog::Error</a>(<span class="stringliteral">&quot;OTSmartContract::ExecuteClauses: ** ERROR: Notice not sent to parties, since no &quot;</span>
<a name="l03565"></a>03565                          <span class="stringliteral">&quot;transaction numbers were available!\n&quot;</span>);
<a name="l03566"></a>03566         }
<a name="l03567"></a>03567         <span class="keywordflow">else</span>
<a name="l03568"></a>03568         {
<a name="l03569"></a>03569             this-&gt;<a class="code" href="class_o_t_contract.html#aae54340526fbd8eb8a18de27a4b97c83">ReleaseSignatures</a>();
<a name="l03570"></a>03570             this-&gt;<a class="code" href="class_o_t_contract.html#abd60037fe655ee8cae9a3ece5d1e2ea6">SignContract</a>(*pServerNym);
<a name="l03571"></a>03571             this-&gt;<a class="code" href="class_o_t_contract.html#a363ae430d4fd9256ab8364dbafb95444">SaveContract</a>();
<a name="l03572"></a>03572 
<a name="l03573"></a>03573             <span class="keyword">const</span> <a class="code" href="class_o_t_string.html">OTString</a> strReference(*<span class="keyword">this</span>);
<a name="l03574"></a>03574             <span class="keywordtype">bool</span> bDroppedNotice = this-&gt;<a class="code" href="class_o_t_scriptable.html#a03d724ec348f2dc140c9ed45d6133429">SendNoticeToAllParties</a>(<span class="keyword">true</span>, <span class="comment">// bSuccessMsg=true</span>
<a name="l03575"></a>03575                                                                *pServerNym, <a class="code" href="class_o_t_instrument.html#a878dd8998f7b131b85c082575e255375">GetServerID</a>(), lNewTransactionNumber,
<a name="l03576"></a>03576                                                                <span class="comment">// GetTransactionNum(), // each party has its own opening trans #.</span>
<a name="l03577"></a>03577                                                                strReference); <span class="comment">// pstrNote and pstrAttachment aren&#39;t used in this case.</span>
<a name="l03578"></a>03578 
<a name="l03579"></a>03579             <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(0, <span class="stringliteral">&quot;%s: FYI, &#39;Important&#39; variables were changed during the execution of this script.\n&quot;</span>
<a name="l03580"></a>03580                            <span class="stringliteral">&quot;%s dropping notifications into all parties&#39; nymboxes.\n&quot;</span>,
<a name="l03581"></a>03581                            __FUNCTION__, bDroppedNotice ? <span class="stringliteral">&quot;Success&quot;</span> : <span class="stringliteral">&quot;Failure&quot;</span>);
<a name="l03582"></a>03582         }
<a name="l03583"></a>03583     }
<a name="l03584"></a>03584 }
<a name="l03585"></a>03585 
<a name="l03586"></a>03586 
<a name="l03587"></a>03587 <span class="comment">// The server calls this when it wants to know if a certain party is allowed to cancel</span>
<a name="l03588"></a>03588 <span class="comment">// the entire contract (remove it from Cron).</span>
<a name="l03589"></a>03589 <span class="comment">// This function tries to answer that question by checking for a callback script called:</span>
<a name="l03590"></a>03590 <span class="comment">//                              callback_party_may_cancel_contract</span>
<a name="l03591"></a>03591 <span class="comment">// If the callback script exists, then it calls that for the answer. Otherwise the default</span>
<a name="l03592"></a>03592 <span class="comment">// return value is: true  (as long as he&#39;s a legitimate party.)</span>
<a name="l03593"></a>03593 <span class="comment">// Script coders may also call &quot;party_may_cancel_contract()&quot; from within a script, which</span>
<a name="l03594"></a>03594 <span class="comment">// will call this function, which will trigger the script callback_party_may_cancel_contract(),</span>
<a name="l03595"></a>03595 <span class="comment">// etc.</span>
<a name="l03596"></a>03596 <span class="comment">//</span>
<a name="l03597"></a><a class="code" href="class_o_t_smart_contract.html#a77a75cea50a6d4e8a2b199204dc8c7a6">03597</a> <span class="keywordtype">bool</span> <a class="code" href="class_o_t_smart_contract.html#a77a75cea50a6d4e8a2b199204dc8c7a6">OTSmartContract::CanCancelContract</a>(<span class="keyword">const</span> std::string str_party_name)
<a name="l03598"></a>03598 {
<a name="l03599"></a>03599     <a class="code" href="class_o_t_cron.html">OTCron</a> * pCron  = <a class="code" href="class_o_t_cron_item.html#af734ad5d309fcc9b4a60d40d6c30f55a">GetCron</a>();
<a name="l03600"></a>03600     <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != pCron);
<a name="l03601"></a>03601     <span class="comment">// ----------------------------------</span>
<a name="l03602"></a>03602     <a class="code" href="class_o_t_pseudonym.html">OTPseudonym</a> * pServerNym = pCron-&gt;<a class="code" href="class_o_t_cron.html#a7756d0dcc047209ca87632939dc11db3">GetServerNym</a>();
<a name="l03603"></a>03603     <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != pServerNym);
<a name="l03604"></a>03604     <span class="comment">// -------------------------------------------------</span>
<a name="l03605"></a>03605 
<a name="l03606"></a>03606     <a class="code" href="class_o_t_party.html">OTParty</a> * pParty = this-&gt;<a class="code" href="class_o_t_scriptable.html#acd0f8e884ed00f1d082fa498323d8894">GetParty</a>(str_party_name);
<a name="l03607"></a>03607 
<a name="l03608"></a>03608     <span class="keywordflow">if</span> (NULL == pParty)
<a name="l03609"></a>03609     {
<a name="l03610"></a>03610         <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(0, <span class="stringliteral">&quot;OTSmartContract::CanCancelContract: Unable to find this party: %s\n&quot;</span>,
<a name="l03611"></a>03611                        str_party_name.c_str());
<a name="l03612"></a>03612         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l03613"></a>03613     }
<a name="l03614"></a>03614     <span class="comment">// Below this point, pParty is good.</span>
<a name="l03615"></a>03615     <span class="comment">// ------------------------------------------------</span>
<a name="l03616"></a>03616 
<a name="l03617"></a>03617     <span class="comment">// ...This WILL check to see if pParty has its Opening number verified as issued.</span>
<a name="l03618"></a>03618     <span class="comment">// (If the opening number is &gt; 0 then VerifyPartyAuthorization() is smart enough to verify it.)</span>
<a name="l03619"></a>03619     <span class="comment">//</span>
<a name="l03620"></a>03620     <span class="comment">// To KNOW that a party has the right to even ASK the script to cancel a contract, MEANS that</span>
<a name="l03621"></a>03621     <span class="comment">// (1) The party is listed as a party on the contract. (2) The party&#39;s copy of that contract</span>
<a name="l03622"></a>03622     <span class="comment">// is signed by the authorizing agent for that party. and (3) The opening transaction number for</span>
<a name="l03623"></a>03623     <span class="comment">// that party is verified as issued for authorizing agent. (2 and 3 are both performed at the same</span>
<a name="l03624"></a>03624     <span class="comment">// time, in VerifyPartyAuthorization(), since the agent may need to be loaded in order to verify</span>
<a name="l03625"></a>03625     <span class="comment">// them.) 1 is already done by this point, as it&#39;s performed above.</span>
<a name="l03626"></a>03626     <span class="comment">//</span>
<a name="l03627"></a>03627     <span class="comment">// Done: notice this code appears in CanCancelContract() (this function) as well as</span>
<a name="l03628"></a>03628     <span class="comment">// OTScriptable::CanExecuteClause.</span>
<a name="l03629"></a>03629     <span class="comment">// Therefore I can see that THIS VERIFICATION CODE WILL GET CALLED EVERY SINGLE TIME THE SCRIPT</span>
<a name="l03630"></a>03630     <span class="comment">// CALLS ANY CLAUSE OR OT NATIVE FUNCTION.  Since technically this only needs to be verified before the</span>
<a name="l03631"></a>03631     <span class="comment">// first call, and not for EVERY call during any of a script&#39;s runs, I should probably move this verification</span>
<a name="l03632"></a>03632     <span class="comment">// higher, such as each time the OTCronItem triggers, plus each time a party triggers a clause directly</span>
<a name="l03633"></a>03633     <span class="comment">// through the API (server message). As long as those are covered, I will be able to remove it from here</span>
<a name="l03634"></a>03634     <span class="comment">// which should be a significant improvement for performance.</span>
<a name="l03635"></a>03635     <span class="comment">// It will be at the bottom of those same functions that &quot;ClearTemporaryPointers()&quot; should finally be called.</span>
<a name="l03636"></a>03636     <span class="comment">//</span>
<a name="l03637"></a>03637     <span class="comment">// Also todo:  Need to implement MOVE CONSTRUCTORS and MOVE COPY CONSTRUCTORS all over the place,</span>
<a name="l03638"></a>03638     <span class="comment">// once I&#39;m sure C++0x build environments are available for all of the various OT platforms. That should</span>
<a name="l03639"></a>03639     <span class="comment">// be another great performance boost!</span>
<a name="l03640"></a>03640     <span class="comment">//</span>
<a name="l03641"></a>03641     <span class="comment">//  FINAL DECISION: Redundant. See comment in OTSmartContract::StashAcctFunds()</span>
<a name="l03642"></a>03642     <span class="comment">//</span>
<a name="l03643"></a>03643 <span class="comment">//  const OTString strServerID(GetServerID());</span>
<a name="l03644"></a>03644 <span class="comment">//</span>
<a name="l03645"></a>03645 <span class="comment">//  mapOfNyms   map_Nyms_Already_Loaded;</span>
<a name="l03646"></a>03646 <span class="comment">//  this-&gt;RetrieveNymPointers(map_Nyms_Already_Loaded);</span>
<a name="l03647"></a>03647 <span class="comment">//</span>
<a name="l03648"></a>03648 <span class="comment">//  bool bVerifiedAuthorization =</span>
<a name="l03649"></a>03649 <span class="comment">//      this-&gt;VerifyPartyAuthorization(*pParty, *pServerNym, strServerID, &amp;map_Nyms_Already_Loaded);</span>
<a name="l03650"></a>03650 <span class="comment">//</span>
<a name="l03651"></a>03651 <span class="comment">//  if (!bVerifiedAuthorization)</span>
<a name="l03652"></a>03652 <span class="comment">//  {</span>
<a name="l03653"></a>03653 <span class="comment">//      OTLog::vOutput(0, &quot;OTSmartContract::CanCancelContract: Unable to verify this party: %s\n&quot;,</span>
<a name="l03654"></a>03654 <span class="comment">//                     str_party_name.c_str());</span>
<a name="l03655"></a>03655 <span class="comment">//      return false;</span>
<a name="l03656"></a>03656 <span class="comment">//  }</span>
<a name="l03657"></a>03657 <span class="comment">//</span>
<a name="l03658"></a>03658     <span class="comment">// *****************************************************************************</span>
<a name="l03659"></a>03659 
<a name="l03660"></a>03660     <span class="comment">// IF NO CALLBACK IS PROVIDED, The default answer to this function is:</span>
<a name="l03661"></a>03661     <span class="comment">//     YES, this party MAY cancel this contract! (Assuming he&#39;s a real party,</span>
<a name="l03662"></a>03662     <span class="comment">//     which we have verified by this point.)</span>
<a name="l03663"></a>03663     <span class="comment">//</span>
<a name="l03664"></a>03664     <span class="comment">// But... first we check to see if this OTScriptable has a clause named:</span>
<a name="l03665"></a>03665     <span class="comment">//          &quot;callback_party_may_cancel_contract&quot;</span>
<a name="l03666"></a>03666     <span class="comment">// ...and if so, we ask the CALLBACK to make the decision instead. This way, people can define</span>
<a name="l03667"></a>03667     <span class="comment">// in their own scripts any rules they want about which parties may cancel the contract.</span>
<a name="l03668"></a>03668 
<a name="l03669"></a>03669     <span class="comment">//</span>
<a name="l03670"></a>03670     <span class="keyword">const</span> std::string str_CallbackName(<a class="code" href="_o_t_smart_contract_8cpp.html#a868cf7423bbb3819f0c7af0ff701907f">SMARTCONTRACT_CALLBACK_PARTY_MAY_CANCEL</a>);
<a name="l03671"></a>03671 
<a name="l03672"></a>03672     <a class="code" href="class_o_t_clause.html">OTClause</a> * pCallbackClause = this-&gt;<a class="code" href="class_o_t_scriptable.html#a390511c5b2f419453b1cc169ec576972">GetCallback</a>(str_CallbackName); <span class="comment">// See if there is a script clause registered for this callback.</span>
<a name="l03673"></a>03673 
<a name="l03674"></a>03674     <span class="keywordflow">if</span> (NULL != pCallbackClause) <span class="comment">// Found it! There&#39;s a clause registered for this callback. Let&#39;s call it...</span>
<a name="l03675"></a>03675     {
<a name="l03676"></a>03676         <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(0, <span class="stringliteral">&quot;OTSmartContract::CanCancelContract: Found script for: %s. Asking...\n&quot;</span>,
<a name="l03677"></a>03677                        <a class="code" href="_o_t_smart_contract_8cpp.html#a868cf7423bbb3819f0c7af0ff701907f">SMARTCONTRACT_CALLBACK_PARTY_MAY_CANCEL</a>);
<a name="l03678"></a>03678 
<a name="l03679"></a>03679         <span class="comment">// The function we&#39;re IN defaults to TRUE, if there&#39;s no script available.</span>
<a name="l03680"></a>03680         <span class="comment">// However, if the script IS available, then our default return value starts as FALSE.</span>
<a name="l03681"></a>03681         <span class="comment">// (The script itself will then have to set it to true, if that&#39;s what it wants.)</span>
<a name="l03682"></a>03682         <span class="comment">//</span>
<a name="l03683"></a>03683         <a class="code" href="class_o_t_variable.html">OTVariable</a> theReturnVal (<span class="stringliteral">&quot;return_val&quot;</span>,        <span class="keyword">false</span>);
<a name="l03684"></a>03684         <span class="comment">// -------------------------------------------------------------</span>
<a name="l03685"></a>03685         <a class="code" href="class_o_t_variable.html">OTVariable</a> param1       (<span class="stringliteral">&quot;param_party_name&quot;</span>,  str_party_name,   <a class="code" href="class_o_t_variable.html#a649f74cb58ba9ed9aeb8601750c98672a3663696326da4cd07edb796beec5c324">OTVariable::Var_Constant</a>); <span class="comment">// script can reference param_party_name</span>
<a name="l03686"></a>03686         <span class="comment">// -------------------------------------------------------------</span>
<a name="l03687"></a>03687         <a class="code" href="_o_t_variable_8hpp.html#aa7620bdfc9f969dd2802c11c3260eb37">mapOfVariables</a> theParameters;
<a name="l03688"></a>03688         theParameters.insert(std::pair&lt;std::string, OTVariable *&gt;(<span class="stringliteral">&quot;param_party_name&quot;</span>,  &amp;param1));
<a name="l03689"></a>03689 
<a name="l03690"></a>03690         <span class="comment">// ****************************************</span>
<a name="l03691"></a>03691 
<a name="l03692"></a>03692         <span class="keywordflow">if</span> (<span class="keyword">false</span> == this-&gt;<a class="code" href="class_o_t_scriptable.html#a4a95506db44acbdd3b125f54cac3595a">ExecuteCallback</a>(*pCallbackClause, theParameters, theReturnVal)) <span class="comment">// &lt;============================================</span>
<a name="l03693"></a>03693         {
<a name="l03694"></a>03694             <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;OTSmartContract::CanCancelContract: Error while running callback script %s, clause %s \n&quot;</span>,
<a name="l03695"></a>03695                           <a class="code" href="_o_t_smart_contract_8cpp.html#a868cf7423bbb3819f0c7af0ff701907f">SMARTCONTRACT_CALLBACK_PARTY_MAY_CANCEL</a>, pCallbackClause-&gt;<a class="code" href="class_o_t_clause.html#a325b3cfeedbfc1c699de3d0f787e5120">GetName</a>().<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>());
<a name="l03696"></a>03696             <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l03697"></a>03697         }
<a name="l03698"></a>03698         <span class="keywordflow">else</span>
<a name="l03699"></a>03699         {
<a name="l03700"></a>03700             <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(0, <span class="stringliteral">&quot;OTSmartContract::CanCancelContract: Success executing callback script %s, clause: %s.\n\n&quot;</span>,
<a name="l03701"></a>03701                            <a class="code" href="_o_t_smart_contract_8cpp.html#a868cf7423bbb3819f0c7af0ff701907f">SMARTCONTRACT_CALLBACK_PARTY_MAY_CANCEL</a>, pCallbackClause-&gt;<a class="code" href="class_o_t_clause.html#a325b3cfeedbfc1c699de3d0f787e5120">GetName</a>().<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>());
<a name="l03702"></a>03702 
<a name="l03703"></a>03703             <span class="keywordflow">return</span> theReturnVal.<a class="code" href="class_o_t_variable.html#a0959b001470125f22842d05a278ce0b7">CopyValueBool</a>();
<a name="l03704"></a>03704         }
<a name="l03705"></a>03705         <span class="comment">// ****************************************</span>
<a name="l03706"></a>03706     }
<a name="l03707"></a>03707     <span class="keywordflow">else</span>
<a name="l03708"></a>03708     {
<a name="l03709"></a>03709         <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(0, <span class="stringliteral">&quot;OTSmartContract::CanCancelContract: Unable to find script for: %s. Therefore, default return value is: TRUE.\n&quot;</span>,
<a name="l03710"></a>03710                        <a class="code" href="_o_t_smart_contract_8cpp.html#a868cf7423bbb3819f0c7af0ff701907f">SMARTCONTRACT_CALLBACK_PARTY_MAY_CANCEL</a>);
<a name="l03711"></a>03711     }
<a name="l03712"></a>03712     <span class="comment">// *****************************************************************************</span>
<a name="l03713"></a>03713 
<a name="l03714"></a>03714     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l03715"></a>03715 }
<a name="l03716"></a>03716 
<a name="l03717"></a>03717 
<a name="l03720"></a><a class="code" href="class_o_t_smart_contract.html#a894df89d05a2ce8a3effec71abb23f7d">03720</a> <span class="keywordtype">bool</span> <a class="code" href="class_o_t_smart_contract.html#a894df89d05a2ce8a3effec71abb23f7d">OTSmartContract::CanRemoveItemFromCron</a>(<a class="code" href="class_o_t_pseudonym.html">OTPseudonym</a> &amp; theNym)
<a name="l03721"></a>03721 {
<a name="l03722"></a>03722     <span class="comment">// You don&#39;t just go willy-nilly and remove a cron item from a market unless you check first</span>
<a name="l03723"></a>03723     <span class="comment">// and make sure the Nym who requested it actually has said number (or a related closing number)</span>
<a name="l03724"></a>03724     <span class="comment">// signed out to him on his last receipt...</span>
<a name="l03725"></a>03725     <span class="comment">//</span>
<a name="l03726"></a>03726     <span class="comment">// Note: overrode parent method and NOT calling it.</span>
<a name="l03727"></a>03727     <span class="comment">// We do it our own way here, and call a script if it&#39;s available.</span>
<a name="l03728"></a>03728     <span class="comment">//</span>
<a name="l03729"></a>03729     <span class="comment">// ------------------------------------------------------------------</span>
<a name="l03730"></a>03730 
<a name="l03731"></a>03731     <span class="comment">// IT&#39;S ASSUMED that the opening and closing numbers WILL be verified in order to</span>
<a name="l03732"></a>03732     <span class="comment">// insure they are CURRENTLY ISSUED.</span>
<a name="l03733"></a>03733     <span class="comment">//</span>
<a name="l03734"></a>03734     <span class="comment">// theNym.VerifyIssuedNum(strServerID, this-&gt;GetOpeningNum();</span>
<a name="l03735"></a>03735     <span class="comment">// theNym.VerifyIssuedNum(strServerID, this-&gt;GetClosingNum();</span>
<a name="l03736"></a>03736     <span class="comment">//</span>
<a name="l03737"></a>03737     <span class="comment">// The default version OTCronItem does this for theNym, and the PaymentPlan version</span>
<a name="l03738"></a>03738     <span class="comment">// has to be a little smarter: it has to figure out whether theNym is the Sender or Recipient,</span>
<a name="l03739"></a>03739     <span class="comment">// so that it knows where to verify the numbers from, before allowing theNym to do the removal.</span>
<a name="l03740"></a>03740     <span class="comment">//</span>
<a name="l03741"></a>03741     <span class="comment">//</span>
<a name="l03742"></a>03742     <span class="comment">// ===&gt; THIS version (OTSmartContract) will look up pParty using theNym via:</span>
<a name="l03743"></a>03743     <span class="comment">// OTParty * OTScriptable::FindPartyBasedOnNymAsAgent(const OTPseudonym &amp; theNym, OTAgent ** ppAgent=NULL);</span>
<a name="l03744"></a>03744     <span class="comment">//</span>
<a name="l03745"></a>03745     <span class="comment">// ...Then it WILL check to see if pParty has its Opening number verified as issued.</span>
<a name="l03746"></a>03746     <span class="comment">// ...It COULD ALSO loop the partyaccounts and see if pAgent is authorized agent for any of them.</span>
<a name="l03747"></a>03747     <span class="comment">//    (If so, pAcct-&gt;VerifyClosingNumber() or pAgent-&gt;VerifyClosingNumber() as well.)</span>
<a name="l03748"></a>03748     <span class="comment">//</span>
<a name="l03749"></a>03749     <span class="comment">//</span>
<a name="l03750"></a>03750     <a class="code" href="class_o_t_agent.html">OTAgent</a> * pAgent = NULL;
<a name="l03751"></a>03751     <a class="code" href="class_o_t_party.html">OTParty</a> * pParty = this-&gt;<a class="code" href="class_o_t_scriptable.html#aa89029542587094cd2844cb8bf7a9a16">FindPartyBasedOnNymAsAgent</a>(theNym, &amp;pAgent); <span class="comment">// This sets a pointer to theNym inside pAgent, so pParty can use it later.</span>
<a name="l03752"></a>03752 
<a name="l03753"></a>03753     <span class="keywordflow">if</span> (NULL == pParty)
<a name="l03754"></a>03754     {
<a name="l03755"></a>03755         <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(0, <span class="stringliteral">&quot;OTSmartContract::CanRemoveItemFromCron: Warning: theNym is not an agent &quot;</span>
<a name="l03756"></a>03756                        <span class="stringliteral">&quot;for any party to this contract, yet tried to remove it.\n&quot;</span>);
<a name="l03757"></a>03757         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l03758"></a>03758     }
<a name="l03759"></a>03759     <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != pAgent); <span class="comment">// With one comes the other.</span>
<a name="l03760"></a>03760 
<a name="l03761"></a>03761     <span class="comment">// Below this point, pAgent is not only good, but it contains a secret hidden pointer now to theNym.</span>
<a name="l03762"></a>03762     <span class="comment">// That way, when the SCRIPT asks the party to verify issued number, without even having a reference to theNym,</span>
<a name="l03763"></a>03763     <span class="comment">// the party will internally still be able to handle it. This always works in cases where it&#39;s needed because</span>
<a name="l03764"></a>03764     <span class="comment">// we used theNym to look up pParty, and the lookup function is what sets that pointer. That&#39;s why I clean</span>
<a name="l03765"></a>03765     <span class="comment">// the pointer again after I&#39;m done. (AT THE BOTTOM OF THIS FUNCTION.)</span>
<a name="l03766"></a>03766     <span class="comment">//</span>
<a name="l03767"></a>03767     <span class="comment">// ----------------------------------------------------</span>
<a name="l03768"></a>03768     <span class="comment">// NOTE: You can see OTCronItem looks up the relevant numbers by trying to figure out if theNym</span>
<a name="l03769"></a>03769     <span class="comment">// is sender or receiver, and then calling these methods:</span>
<a name="l03770"></a>03770     <span class="comment">// if (this-&gt;GetCountClosingNumbers() &lt; 1)</span>
<a name="l03771"></a>03771     <span class="comment">// if (this-&gt;GetRecipientCountClosingNumbers() &lt; 2)</span>
<a name="l03772"></a>03772     <span class="comment">// Etc.</span>
<a name="l03773"></a>03773     <span class="comment">//</span>
<a name="l03774"></a>03774     <span class="comment">// But OTSmartContract doesn&#39;t use those functions, except where it has to in order to</span>
<a name="l03775"></a>03775     <span class="comment">// work within the existing OTCronItem system. (That is, the ORIGINATOR who actually activates</span>
<a name="l03776"></a>03776     <span class="comment">// a smart contract must still provide at least an opening number, which is stored in the old</span>
<a name="l03777"></a>03777     <span class="comment">// system and used by it.)</span>
<a name="l03778"></a>03778     <span class="comment">// Instead, OTSmartContract keeps its own records (via its parent class OTScriptable) of all the</span>
<a name="l03779"></a>03779     <span class="comment">// parties to the contract, and all of their opening transaction #s, as well as the accounts that</span>
<a name="l03780"></a>03780     <span class="comment">// are party to the contract, and the closing transaction #s for each of those.</span>
<a name="l03781"></a>03781     <span class="comment">//</span>
<a name="l03782"></a>03782     <span class="comment">// ===&gt; Therefore, when it comes to verifying whether the Nym has CERTAIN RIGHTS regarding the</span>
<a name="l03783"></a>03783     <span class="comment">// contract, OTSmartContract doesn&#39;t actually use the old system for that, but instead queries its</span>
<a name="l03784"></a>03784     <span class="comment">// own, superior system.</span>
<a name="l03785"></a>03785     <span class="comment">//</span>
<a name="l03786"></a>03786     <span class="comment">// In order to prevent infinite recursion I think I will be adding THAT code into:</span>
<a name="l03787"></a>03787     <span class="comment">//      OTSmartContract::CanCancelContract(party_name)</span>
<a name="l03788"></a>03788     <span class="comment">//</span>
<a name="l03789"></a>03789     <span class="comment">// ----------------------------------------------------------------</span>
<a name="l03790"></a>03790 
<a name="l03791"></a>03791             <span class="keywordtype">bool</span>        bReturnValue    = <span class="keyword">false</span>;
<a name="l03792"></a>03792             <span class="keywordtype">bool</span>        bPartyHasName   = <span class="keyword">false</span>;
<a name="l03793"></a>03793     <span class="keyword">const</span>   std::string str_party_name  = pParty-&gt;<a class="code" href="class_o_t_party.html#ad823a9d89b3d8d0d87bc85114eefcead">GetPartyName</a>(&amp;bPartyHasName);
<a name="l03794"></a>03794 
<a name="l03795"></a>03795     <span class="keywordflow">if</span> (bPartyHasName &amp;&amp; this-&gt;<a class="code" href="class_o_t_smart_contract.html#a77a75cea50a6d4e8a2b199204dc8c7a6">CanCancelContract</a>(str_party_name)) <span class="comment">// Here is where it calls the script, inside this call.</span>
<a name="l03796"></a>03796     {
<a name="l03797"></a>03797         <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(0, <span class="stringliteral">&quot;OTSmartContract::CanRemoveItemFromCron: Looks like theNym represents a party (%s) and &quot;</span>
<a name="l03798"></a>03798                        <span class="stringliteral">&quot;IS allowed by this contract to cancel it whenever he chooses.\n&quot;</span>);
<a name="l03799"></a>03799         bReturnValue = <span class="keyword">true</span>;
<a name="l03800"></a>03800     }
<a name="l03801"></a>03801     <span class="comment">// -----------------</span>
<a name="l03802"></a>03802 
<a name="l03803"></a>03803     pParty-&gt;<a class="code" href="class_o_t_party.html#a41a428ded2f0477cf8752648cbe51e4e">ClearTemporaryPointers</a>(); <span class="comment">// FindPartyBasedOnNymAsAgent() set the party&#39;s agent&#39;s nym pointer to theNym. This clears it.</span>
<a name="l03804"></a>03804 
<a name="l03805"></a>03805     <span class="keywordflow">return</span> bReturnValue;
<a name="l03806"></a>03806 }
<a name="l03807"></a>03807 
<a name="l03808"></a>03808 
<a name="l03809"></a>03809 <span class="comment">// TODO:</span>
<a name="l03810"></a>03810 
<a name="l03811"></a>03811 <span class="comment">// OTContract::VerifySignature(OTPseudonym &amp; theNym)    &lt;=====  already exists.</span>
<a name="l03812"></a>03812 <span class="comment">//</span>
<a name="l03813"></a>03813 <span class="comment">// Next:</span>
<a name="l03814"></a>03814 <span class="comment">//</span>
<a name="l03815"></a>03815 <span class="comment">// Verify ALL parties signatures, using the map of signers passed in.</span>
<a name="l03816"></a>03816 <span class="comment">// Client-side could technically do this, as long as he had all the public keys</span>
<a name="l03817"></a>03817 <span class="comment">// available for the various parties. For now, I need this on server side.</span>
<a name="l03818"></a>03818 <span class="comment">//</span>
<a name="l03819"></a>03819 <span class="comment">//bool OTSmartContract::VerifyAllPartiesSignatures(std::map&lt;std::string, OTPseudonym *&gt; &amp; map_SignersByNymID)</span>
<a name="l03820"></a>03820 <span class="comment">//{</span>
<a name="l03821"></a>03821 <span class="comment">//  /*</span>
<a name="l03822"></a>03822 <span class="comment">//    // Verify sender&#39;s signature on this.</span>
<a name="l03823"></a>03823 <span class="comment">//    if (!this-&gt;VerifySignature(SENDER_NYM))</span>
<a name="l03824"></a>03824 <span class="comment">//    {</span>
<a name="l03825"></a>03825 <span class="comment">//        OTLog::Output(0, &quot;OTSmartContract::VerifyAgreement: Sender&#39;s signature failed to verify.\n&quot;);</span>
<a name="l03826"></a>03826 <span class="comment">//        return false;</span>
<a name="l03827"></a>03827 <span class="comment">//    }</span>
<a name="l03828"></a>03828 <span class="comment">//</span>
<a name="l03829"></a>03829 <span class="comment">//    // Verify recipient&#39;s signature on merchant&#39;s copy.</span>
<a name="l03830"></a>03830 <span class="comment">//</span>
<a name="l03831"></a>03831 <span class="comment">//    if (!theMerchantCopy.VerifySignature(RECIPIENT_NYM))</span>
<a name="l03832"></a>03832 <span class="comment">//    {</span>
<a name="l03833"></a>03833 <span class="comment">//        OTLog::Output(0, &quot;OTSmartContract::VerifyAgreement: Recipient&#39;s signature failed to verify on internal merchant copy of agreement.\n&quot;);</span>
<a name="l03834"></a>03834 <span class="comment">//        return false;</span>
<a name="l03835"></a>03835 <span class="comment">//    }</span>
<a name="l03836"></a>03836 <span class="comment">//</span>
<a name="l03837"></a>03837 <span class="comment">//  */</span>
<a name="l03838"></a>03838 <span class="comment">//</span>
<a name="l03839"></a>03839 <span class="comment">//</span>
<a name="l03840"></a>03840 <span class="comment">//  return false;</span>
<a name="l03841"></a>03841 <span class="comment">//}</span>
<a name="l03842"></a>03842 
<a name="l03843"></a>03843 <span class="comment">// Server side. Make sure that ALL parties have valid opening transaction #s.</span>
<a name="l03844"></a>03844 <span class="comment">//</span>
<a name="l03845"></a>03845 <span class="comment">//bool OTSmartContract::VerifyAllPartiesOpeningTransNos()</span>
<a name="l03846"></a>03846 <span class="comment">//{</span>
<a name="l03847"></a>03847 <span class="comment">//  // Loop through all parties.</span>
<a name="l03848"></a>03848 <span class="comment">//  // For each, load the appropriate Nym and verify opening number on appropriate Nym for each party.</span>
<a name="l03849"></a>03849 <span class="comment">//</span>
<a name="l03850"></a>03850 <span class="comment">//  /*</span>
<a name="l03851"></a>03851 <span class="comment">//</span>
<a name="l03852"></a>03852 <span class="comment">//  const OTString strServerID(GetServerID());</span>
<a name="l03853"></a>03853 <span class="comment">//</span>
<a name="l03854"></a>03854 <span class="comment">//    // Verify Transaction Num and Closing Nums against SENDER&#39;s issued list</span>
<a name="l03855"></a>03855 <span class="comment">//    if ((GetCountClosingNumbers() &lt; 1) || !SENDER_NYM.VerifyIssuedNum(strServerID, GetTransactionNum()))</span>
<a name="l03856"></a>03856 <span class="comment">//    {</span>
<a name="l03857"></a>03857 <span class="comment">//        OTLog::Error(&quot;OTSmartContract::VerifyAgreement: Transaction number isn&#39;t on sender&#39;s issued list, &quot;</span>
<a name="l03858"></a>03858 <span class="comment">//                     &quot;or there weren&#39;t enough closing numbers.\n&quot;);</span>
<a name="l03859"></a>03859 <span class="comment">//        return false;</span>
<a name="l03860"></a>03860 <span class="comment">//    }</span>
<a name="l03861"></a>03861 <span class="comment">//    for (int32_t i = 0; i &lt; GetCountClosingNumbers(); i++)</span>
<a name="l03862"></a>03862 <span class="comment">//        if (!SENDER_NYM.VerifyIssuedNum(strServerID, GetClosingTransactionNoAt(i)))</span>
<a name="l03863"></a>03863 <span class="comment">//        {</span>
<a name="l03864"></a>03864 <span class="comment">//            OTLog::Error(&quot;OTSmartContract::VerifyAgreement: Closing transaction number isn&#39;t on sender&#39;s issued list.\n&quot;);</span>
<a name="l03865"></a>03865 <span class="comment">//            return false;</span>
<a name="l03866"></a>03866 <span class="comment">//        }</span>
<a name="l03867"></a>03867 <span class="comment">//</span>
<a name="l03868"></a>03868 <span class="comment">//   */</span>
<a name="l03869"></a>03869 <span class="comment">//</span>
<a name="l03870"></a>03870 <span class="comment">//  return false;</span>
<a name="l03871"></a>03871 <span class="comment">//}</span>
<a name="l03872"></a>03872 <span class="comment">//</span>
<a name="l03873"></a>03873 
<a name="l03874"></a>03874 <span class="comment">// Server side. Make sure that ALL parties have valid closing transaction #s for each of their asset accounts.</span>
<a name="l03875"></a>03875 <span class="comment">//</span>
<a name="l03876"></a>03876 <span class="comment">//bool OTSmartContract::VerifyAllPartiesClosingTransNos()</span>
<a name="l03877"></a>03877 <span class="comment">//{</span>
<a name="l03878"></a>03878 <span class="comment">//  // Loop through all parties.</span>
<a name="l03879"></a>03879 <span class="comment">//  // For each, loop through their accounts.</span>
<a name="l03880"></a>03880 <span class="comment">//  //</span>
<a name="l03881"></a>03881 <span class="comment">//  // Load the appropriate Nym and verify closing numbers on appropriate Nym for each Account.</span>
<a name="l03882"></a>03882 <span class="comment">//  //</span>
<a name="l03883"></a>03883 <span class="comment">//  /*</span>
<a name="l03884"></a>03884 <span class="comment">//  const OTString strServerID(GetServerID());</span>
<a name="l03885"></a>03885 <span class="comment">//</span>
<a name="l03886"></a>03886 <span class="comment">//    // Verify Transaction Num and Closing Nums against SENDER&#39;s issued list</span>
<a name="l03887"></a>03887 <span class="comment">//    if ((GetCountClosingNumbers() &lt; 1) || !SENDER_NYM.VerifyIssuedNum(strServerID, GetTransactionNum()))</span>
<a name="l03888"></a>03888 <span class="comment">//    {</span>
<a name="l03889"></a>03889 <span class="comment">//        OTLog::Error(&quot;OTSmartContract::VerifyAgreement: Transaction number isn&#39;t on sender&#39;s issued list, &quot;</span>
<a name="l03890"></a>03890 <span class="comment">//                     &quot;or there weren&#39;t enough closing numbers.\n&quot;);</span>
<a name="l03891"></a>03891 <span class="comment">//        return false;</span>
<a name="l03892"></a>03892 <span class="comment">//    }</span>
<a name="l03893"></a>03893 <span class="comment">//    for (int32_t i = 0; i &lt; GetCountClosingNumbers(); i++)</span>
<a name="l03894"></a>03894 <span class="comment">//        if (!SENDER_NYM.VerifyIssuedNum(strServerID, GetClosingTransactionNoAt(i)))</span>
<a name="l03895"></a>03895 <span class="comment">//        {</span>
<a name="l03896"></a>03896 <span class="comment">//            OTLog::Error(&quot;OTSmartContract::VerifyAgreement: Closing transaction number isn&#39;t on sender&#39;s issued list.\n&quot;);</span>
<a name="l03897"></a>03897 <span class="comment">//            return false;</span>
<a name="l03898"></a>03898 <span class="comment">//        }</span>
<a name="l03899"></a>03899 <span class="comment">//   */</span>
<a name="l03900"></a>03900 <span class="comment">//</span>
<a name="l03901"></a>03901 <span class="comment">//</span>
<a name="l03902"></a>03902 <span class="comment">//</span>
<a name="l03903"></a>03903 <span class="comment">//</span>
<a name="l03904"></a>03904 <span class="comment">//</span>
<a name="l03905"></a>03905 <span class="comment">//</span>
<a name="l03906"></a>03906 <span class="comment">//  return false;</span>
<a name="l03907"></a>03907 <span class="comment">//}</span>
<a name="l03908"></a>03908 
<a name="l03909"></a>03909 <span class="comment">// Server-side, need to verify ALL parties upon activation.</span>
<a name="l03910"></a>03910 <span class="comment">// Client-side, need to verify CURRENT list of parties before &quot;the next party&quot; signs on.</span>
<a name="l03911"></a>03911 <span class="comment">// May not be able to tell the difference, in code. I can verify that the present ones are good,</span>
<a name="l03912"></a>03912 <span class="comment">// but I can&#39;t guarantee that others aren&#39;t referenced in the script code, without some kind of</span>
<a name="l03913"></a>03913 <span class="comment">// &quot;trial run&quot; of the script, or parsing of it.</span>
<a name="l03914"></a>03914 <span class="comment">//</span>
<a name="l03915"></a>03915 <span class="comment">// Therefore no point verifying originator here -- let&#39;s verify it here for ANY of the parties, and</span>
<a name="l03916"></a>03916 <span class="comment">// let the server explicitly verify the trans#s instead of relying on this function to do it. That way</span>
<a name="l03917"></a>03917 <span class="comment">// I can use this function even in cases where I&#39;m not able to verify the trans#s (such as on the</span>
<a name="l03918"></a>03918 <span class="comment">// client side.) SERVER WILL STILL NEED TO VERIFY those numbers....</span>
<a name="l03919"></a>03919 <span class="comment">//</span>
<a name="l03920"></a>03920 <span class="comment">// Server will also want to verify that originator IS a party (this function won&#39;t do it.)</span>
<a name="l03921"></a>03921 <span class="comment">//</span>
<a name="l03922"></a>03922 <span class="comment">//bool OTSmartContract::VerifySmartContract(OTPseudonym &amp; theNym)</span>
<a name="l03923"></a>03923 <span class="comment">//{</span>
<a name="l03924"></a>03924     <span class="comment">// Need to verify:</span>
<a name="l03925"></a>03925     <span class="comment">//</span>
<a name="l03926"></a>03926     <span class="comment">// 1) That the opening/closing trans# on this CronItem match ONE of the parties. (Maybe not verifier.)</span>
<a name="l03927"></a>03927     <span class="comment">//    (Parties to trades and payments each have their own opening numbers. Therefore you can with scripts. But only one can activate.)</span>
<a name="l03928"></a>03928     <span class="comment">//    With trades, each Nym has their own cron item and #. With payment plans, there is only one cron item, and the sender is the</span>
<a name="l03929"></a>03929     <span class="comment">//    activator. Since he is the one paying, the number used is his. The other guy still gets receipts, but the code is smart</span>
<a name="l03930"></a>03930     <span class="comment">//    enough to create his receipts using HIS opening number, which he still has to provide up front. (Hmm.. in implementation that&#39;s not true...)</span>
<a name="l03931"></a>03931     <span class="comment">// Anyway, continuing: But those receipts contain</span>
<a name="l03932"></a>03932     <span class="comment">//    COPIES of the original cron item that was ACTIVATED by the sender, and has his trans# on it.</span>
<a name="l03933"></a>03933     <span class="comment">//    Still: the cron item is saved to storage under a specific number, right? Scripts must be smart enough to drop a receipt for</span>
<a name="l03934"></a>03934     <span class="comment">//    each party where the Opening Number comes from THAT PARTY, and where a closing number comes from one of his accts.</span>
<a name="l03935"></a>03935     <span class="comment">//</span>
<a name="l03936"></a>03936     <span class="comment">// 2) Verify this details against ALL parties copies.</span>
<a name="l03937"></a>03937     <span class="comment">//</span>
<a name="l03938"></a>03938     <span class="comment">// 3) If an optional list of Nyms is passed in, then verify all their signatures as well. hmm.</span>
<a name="l03939"></a>03939     <span class="comment">//</span>
<a name="l03940"></a>03940     <span class="comment">// May not even need this function. Could be the new ones above are enough to cover it all.</span>
<a name="l03941"></a>03941     <span class="comment">//</span>
<a name="l03942"></a>03942 
<a name="l03943"></a>03943     <span class="comment">// ABOVE Makes sure that all parties&#39; signed copies are equivalent to my own (*this)</span>
<a name="l03944"></a>03944     <span class="comment">//</span>
<a name="l03945"></a>03945     <span class="comment">// Once this is established, then BELOW verifies all the data on (*this) against the actual Nyms passed in.</span>
<a name="l03946"></a>03946     <span class="comment">//</span>
<a name="l03947"></a>03947     <span class="comment">// Finally, the signature for each is verified against his own copy.</span>
<a name="l03948"></a>03948     <span class="comment">//</span>
<a name="l03949"></a>03949 
<a name="l03950"></a>03950     <span class="comment">// For smart contract:</span>
<a name="l03951"></a>03951     <span class="comment">//</span>
<a name="l03952"></a>03952     <span class="comment">// 1) Assume verifier could be any one of the parties, not necessarily the originator</span>
<a name="l03953"></a>03953 
<a name="l03954"></a>03954     <span class="comment">// TO WORK WITHIN THE EXISTING CRON SYSTEM, the originator&#39;s Opening and Closing #s must be set</span>
<a name="l03955"></a>03955     <span class="comment">// and available onto THIS CRON ITEM, so that GetTransactionNum() is the opening and GetCountClosingNUmbers()</span>
<a name="l03956"></a>03956     <span class="comment">// contains at least 1 number. Thus: if originator does not have an asset account in his party, we fail to activate!!</span>
<a name="l03957"></a>03957     <span class="comment">// Originator MUST have an asset account...</span>
<a name="l03958"></a>03958     <span class="comment">// Why? Who cares about the closing numbers except for custom code for specific things like trades? We only REALLY</span>
<a name="l03959"></a>03959     <span class="comment">// care about the closing number when we need to put it into an asset account&#39;s inbox as a finalReceipt. AHHH But</span>
<a name="l03960"></a>03960     <span class="comment">// the server DOES drop copies of all finalReceipts into your NYMBOX as well, as a NOTICE, so you can get the news faster.</span>
<a name="l03961"></a>03961     <span class="comment">// And the SAME NUMBER is put onto that receipt, which you receive in your Nymbox even if you HAVE NO asset account.</span>
<a name="l03962"></a>03962     <span class="comment">// Perhaps you should provide one for your Nym AND for all your accounts.  That way your Nym can get a copy of all those</span>
<a name="l03963"></a>03963     <span class="comment">// notices, but even without any asset accounts, he STILL gets a notice onFinalReceipt with his own special number on it.</span>
<a name="l03964"></a>03964     <span class="comment">//</span>
<a name="l03965"></a>03965     <span class="comment">// THE ONLY DIFFERENCE IS:  With inbox finalReceipts, the closing number stays open until you process your inbox to accept it.</span>
<a name="l03966"></a>03966     <span class="comment">// You receive a notice of that same receipt in your Nymbox already, so that you know to stop using your OPENING number. This is</span>
<a name="l03967"></a>03967     <span class="comment">// because it&#39;s possible for it to appear out of the blue, and your transactions for all accts would stop working unless you knew</span>
<a name="l03968"></a>03968     <span class="comment">// which inbox to examine for the finalReceipt that must have appeared. So it goes into Nymbox so you only have to check one place.</span>
<a name="l03969"></a>03969     <span class="comment">// WHEREAS WITH SMART CONTRACT NYMBOX NOTICES, the Nymbox notice can also contain a CLOSING # for that NYM ITSELF. So it sees</span>
<a name="l03970"></a>03970     <span class="comment">// when the script has ended. HMM.  Why not have the Nym&#39;s Opening # be verified to start, and then that SAME # go into the Nym&#39;s</span>
<a name="l03971"></a>03971     <span class="comment">// Nymbox on the finalReceipt? The Nym can then close it out on his side (thanks to that notice) the same as it does now with other cron items.</span>
<a name="l03972"></a>03972     <span class="comment">// The &quot;closing #&quot; that would also be on the nymbox notice is unneeded in this case, since there are no asset accounts, and the Nym just needed</span>
<a name="l03973"></a>03973     <span class="comment">// notice that his opening number was free again.</span>
<a name="l03974"></a>03974     <span class="comment">//</span>
<a name="l03975"></a>03975     <span class="comment">// Therefore, to work within existing cron system, it should be easy to simply add the Opening Number for originator, AND</span>
<a name="l03976"></a>03976     <span class="comment">// to set the Closing Number on the Cron Item to be the originator&#39;s opening number, in cases where he has no asset accounts.</span>
<a name="l03977"></a>03977     <span class="comment">// I&#39;m curious where that may ever even be needed -- I bet it&#39;s only there to provide a common location, since the other cron item</span>
<a name="l03978"></a>03978     <span class="comment">// types all happen to use it. I will endeavor to work within a paradigm where closing numbers are only needed for asset accounts</span>
<a name="l03979"></a>03979     <span class="comment">// and where Cron Items are still functional without them, for Nyms using contracts without asset accounts.</span>
<a name="l03980"></a>03980     <span class="comment">//</span>
<a name="l03981"></a>03981     <span class="comment">// UPDATE: in actual implementation, I resolved this with the simple requirement that the Nym who ACTIVATES a</span>
<a name="l03982"></a>03982     <span class="comment">// smart contract, must be the authorized agent for at least ONE account for his party, in that contract!  This</span>
<a name="l03983"></a>03983     <span class="comment">// simple requirement, which would probably be true anyway, in practice, insures that there are legitimate opening</span>
<a name="l03984"></a>03984     <span class="comment">// and closing transaction numbers available from the Nym who actually activates the contract.</span>
<a name="l03985"></a>03985     <span class="comment">// (That Nym, however, is still subject to the rules of the contract.)</span>
<a name="l03986"></a>03986     <span class="comment">// ----------------------------------------------</span>
<a name="l03987"></a>03987     <span class="comment">// Here are my notes of what is needed here:</span>
<a name="l03988"></a>03988 <span class="comment">//</span>
<a name="l03989"></a>03989 <span class="comment">//    return true; // Success!</span>
<a name="l03990"></a>03990 <span class="comment">//}</span>
<a name="l03991"></a>03991 <span class="comment">//</span>
<a name="l03992"></a>03992 
<a name="l03993"></a>03993 <span class="comment">//Old thoughts</span>
<a name="l03994"></a>03994 <span class="comment">// Note: agents will have restrictable permissions. Should be overridable in the role,</span>
<a name="l03995"></a>03995 <span class="comment">// in the agent itself (in the party), etc. Like a registered agent -- he can ONLY activate</span>
<a name="l03996"></a>03996 <span class="comment">// things (and sign for them...) After that, the passive mechanism of the group voting takes</span>
<a name="l03997"></a>03997 <span class="comment">// over for all future meetings/decisions.</span>
<a name="l03998"></a>03998 <span class="comment">// But someone must sign at first.  This can be a &quot;registered agent&quot; if you want, with limited</span>
<a name="l03999"></a>03999 <span class="comment">// authority, only allowed to activate.</span>
<a name="l04000"></a>04000 
<a name="l04001"></a>04001 <span class="comment">// theNym is trying to activate the smart contract, and has</span>
<a name="l04002"></a>04002 <span class="comment">// supplied transaction numbers and a user/acct ID. ==&gt; theNym definitely IS the owner of the account... that is</span>
<a name="l04003"></a>04003 <span class="comment">// verified in OTServer::NotarizeTransaction(), before it even knows what KIND of transaction it is processing!</span>
<a name="l04004"></a>04004 <span class="comment">// (For all transactions.) So by the time OTServer::NotarizeSmartContract() is called, we know that much.</span>
<a name="l04005"></a>04005 <span class="comment">//</span>
<a name="l04006"></a>04006 <span class="comment">// But for all other parties, we do not know this, so we still need to loop them all, etc to verify this crap,</span>
<a name="l04007"></a>04007 <span class="comment">// at least once. (And then maybe I can lessen some of the double-checking, for optimization purposes, once</span>
<a name="l04008"></a>04008 <span class="comment">// we&#39;ve run this gamut.)</span>
<a name="l04009"></a>04009 <span class="comment">//</span>
<a name="l04010"></a>04010 <span class="comment">// One thing we still do not know, until VerifySmartContract is called, is whether theNym really IS a valid</span>
<a name="l04011"></a>04011 <span class="comment">// agent for this contract, and whether all the other agents are valid, and whether the accounts are validly</span>
<a name="l04012"></a>04012 <span class="comment">// owned by the agents they list, and whether the authorizing agent for each party has signed their own copy,</span>
<a name="l04013"></a>04013 <span class="comment">// and whether the authorizing agent for each party provided a valid opening number--which must be recorded</span>
<a name="l04014"></a>04014 <span class="comment">// as consumed--and whether the authorized agent for each account provided a valid closing number, which likewise</span>
<a name="l04015"></a>04015 <span class="comment">// must be recorded. (Set bBurnTransNo to true if you want to enforce the stuff about the opening and closing #s)</span>
<a name="l04016"></a>04016 <span class="comment">//</span>
<a name="l04017"></a><a class="code" href="class_o_t_smart_contract.html#a3b15d58a7c49d3ba2fc8a153bca6af0f">04017</a> <span class="keywordtype">bool</span> <a class="code" href="class_o_t_smart_contract.html#a3b15d58a7c49d3ba2fc8a153bca6af0f">OTSmartContract::VerifySmartContract</a>(<a class="code" href="class_o_t_pseudonym.html">OTPseudonym</a> &amp; theNym, <a class="code" href="class_o_t_account.html">OTAccount</a> &amp; theAcct, <a class="code" href="class_o_t_pseudonym.html">OTPseudonym</a> &amp; theServerNym,
<a name="l04018"></a>04018                                           <span class="keyword">const</span> <span class="keywordtype">bool</span> bBurnTransNo<span class="comment">/*=false*/</span>)
<a name="l04019"></a>04019 {
<a name="l04020"></a>04020     <a class="code" href="class_o_t_agent.html">OTAgent</a> * pAuthAgent = NULL;
<a name="l04021"></a>04021     <a class="code" href="class_o_t_party.html">OTParty</a> * pAuthParty = <a class="code" href="class_o_t_scriptable.html#a08ff87b0f54ed3139bfcfb362a757778">FindPartyBasedOnNymAsAuthAgent</a>(theNym, &amp;pAuthAgent);
<a name="l04022"></a>04022 
<a name="l04023"></a>04023     <span class="keywordflow">if</span> (NULL == pAuthParty)
<a name="l04024"></a>04024     {
<a name="l04025"></a>04025         <a class="code" href="class_o_t_string.html">OTString</a> strNymID; theNym.<a class="code" href="class_o_t_pseudonym.html#a1775c7aedd0dd25b2faf3f78dcccabe7">GetIdentifier</a>(strNymID);
<a name="l04026"></a>04026         <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(0, <span class="stringliteral">&quot;%s: Unable to find a party in this smart contract, based &quot;</span>
<a name="l04027"></a>04027                        <span class="stringliteral">&quot;on theNym (%s) as authorizing agent.\n&quot;</span>, __FUNCTION__, strNymID.<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>());
<a name="l04028"></a>04028         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l04029"></a>04029     }
<a name="l04030"></a>04030     <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != pAuthAgent); <span class="comment">// If it found the party, then it DEFINITELY should have set the agent pointer.</span>
<a name="l04031"></a>04031     <span class="comment">// BELOW THIS POINT, pAuthAgent and pAuthParty and both good pointers. Furthermore, we know that theNym</span>
<a name="l04032"></a>04032     <span class="comment">// really is the authorizing agent for one of the parties to the contract.</span>
<a name="l04033"></a>04033     <span class="comment">// ------------------------------------</span>
<a name="l04034"></a>04034     <span class="keyword">const</span> <a class="code" href="class_o_t_string.html">OTString</a>  strServerID(<a class="code" href="class_o_t_instrument.html#a878dd8998f7b131b85c082575e255375">GetServerID</a>()); <span class="comment">// the serverID has already been verified by this time, in OTServer::NotarizeSmartContract()</span>
<a name="l04035"></a>04035     <span class="comment">// -------------------------------</span>
<a name="l04036"></a>04036     <a class="code" href="_o_t_agent_8hpp.html#ac89892658f6bc83e354078647b704e8f">mapOfNyms</a> map_Nyms_Already_Loaded;          <span class="comment">// The list of Nyms that were already instantiated before this function was called.</span>
<a name="l04037"></a>04037     this-&gt;<a class="code" href="class_o_t_scriptable.html#a9e41bb939fd5dbfe1f2442e5919a5079">RetrieveNymPointers</a>(map_Nyms_Already_Loaded); <span class="comment">// now theNym is on this map. (His party already has a pointer to him since he is the activator.)</span>
<a name="l04038"></a>04038     <span class="comment">// -------------------------------</span>
<a name="l04039"></a>04039     <a class="code" href="_o_t_agent_8hpp.html#ac89892658f6bc83e354078647b704e8f">mapOfNyms</a> map_Nyms_Loaded_In_This_Function; <span class="comment">// The total list of Nyms that were instantiated inside this function (and must be deleted.)</span>
<a name="l04040"></a>04040     <span class="comment">// -------------------------------</span>
<a name="l04041"></a>04041     <a class="code" href="_o_t_agent_8hpp.html#abd4942716d546c8d42670619a03ef99e">mapOfAccounts</a> map_Accts_Already_Loaded;     <span class="comment">// The list of Accounts that were already instantiated before this function was called.</span>
<a name="l04042"></a>04042     <span class="keyword">const</span> <a class="code" href="class_o_t_string.html">OTString</a> strAcctID(theAcct.<a class="code" href="class_o_t_transaction_type.html#ac9b118b7db7ea538d6931dee6c2f34e2">GetRealAccountID</a>());
<a name="l04043"></a>04043     map_Accts_Already_Loaded.insert(std::pair&lt;std::string, OTAccount *&gt;(strAcctID.Get(), &amp;theAcct)); <span class="comment">// now theAcct is on this map.</span>
<a name="l04044"></a>04044     <span class="comment">// -------------------------------</span>
<a name="l04045"></a>04045     <a class="code" href="_o_t_agent_8hpp.html#abd4942716d546c8d42670619a03ef99e">mapOfAccounts</a> map_Accts_Loaded_In_This_Function;     <span class="comment">// The total list of Accts that were instantiated inside this function (and must be deleted.)</span>
<a name="l04046"></a>04046     <span class="comment">// -------------------------------</span>
<a name="l04047"></a>04047     <span class="keywordtype">bool</span>                bAreAnyInvalidParties = <span class="keyword">false</span>;
<a name="l04048"></a>04048     std::set&lt;OTParty *&gt; theFailedParties; <span class="comment">// A set of pointers to parties who failed verification.</span>
<a name="l04049"></a>04049 
<a name="l04050"></a>04050     <span class="comment">// LOOP THROUGH ALL PARTIES AND VERIFY THEM.</span>
<a name="l04051"></a>04051     <span class="comment">//</span>
<a name="l04052"></a>04052     <a class="code" href="_o_t_storage_8hpp.html#a4a94c3435a932ed34e5755f3f472547c">FOR_EACH_IT</a>(<a class="code" href="_o_t_party_8hpp.html#a029bc6921acd4516530e26201cf595f2">mapOfParties</a>, <a class="code" href="class_o_t_scriptable.html#a6a7e4ef3e0ed95f90d950b1718f815ab">m_mapParties</a>, it_party)
<a name="l04053"></a>04053     {
<a name="l04054"></a>04054         <span class="keyword">const</span> std::string str_party_name    = (*it_party).first;
<a name="l04055"></a>04055         <a class="code" href="class_o_t_party.html">OTParty</a> * pParty                    = (*it_party).second;
<a name="l04056"></a>04056         <a class="code" href="_o_t_assert_8hpp.html#a033b133f48e61f2b227c52ad2be0c882">OT_ASSERT_MSG</a>(NULL != pParty, <span class="stringliteral">&quot;OTSmartContract::VerifySmartContract: Unexpected NULL pointer in party map.\n&quot;</span>);
<a name="l04057"></a>04057         <span class="comment">// --------------------------------------------</span>
<a name="l04058"></a>04058 
<a name="l04059"></a>04059         <span class="comment">/*</span>
<a name="l04060"></a>04060 <span class="comment">         -- Load up the authorizing agent&#39;s Nym, if not already loaded. (Why? To verifySignature. Also, just to have</span>
<a name="l04061"></a>04061 <span class="comment">            it loaded so I don&#39;t have to load it twice in case it&#39;s needed for verifying one/some of the accts.) So really:</span>
<a name="l04062"></a>04062 <span class="comment">         -- Verify each party, that the authorizing agent and signature are all good. (I think I have this already...)</span>
<a name="l04063"></a>04063 <span class="comment">         -- Definitely during this, need to make sure that the contents of the signed version match the contents of the main version, for each signer.</span>
<a name="l04064"></a>04064 <span class="comment">         -- Verify that the authorizing agent actually has the opening transaction # for the party issued to him. (Do I have this?....)</span>
<a name="l04065"></a>04065 <span class="comment"></span>
<a name="l04066"></a>04066 <span class="comment">         -- REMOVE the Opening transaction # for each agent.</span>
<a name="l04067"></a>04067 <span class="comment">         (leaving it as issued, but no longer as &quot;available to be used on another transaction&quot;.)</span>
<a name="l04068"></a>04068 <span class="comment"></span>
<a name="l04069"></a>04069 <span class="comment">         THE ABOVE is all accomplished via VerifyPartyAuthorization()..</span>
<a name="l04070"></a>04070 <span class="comment"></span>
<a name="l04071"></a>04071 <span class="comment">         Next:</span>
<a name="l04072"></a>04072 <span class="comment"></span>
<a name="l04073"></a>04073 <span class="comment">         -- Loop through all the asset accounts</span>
<a name="l04074"></a>04074 <span class="comment">         -- For each, get a pointer to the authorized agent and verify the CLOSING number for that asset acct. (I have something like this?...)</span>
<a name="l04075"></a>04075 <span class="comment"></span>
<a name="l04076"></a>04076 <span class="comment">         -- Since we&#39;re looping through all the agents, and looping through all the asset accounts, and checking the agent for each asset account,</span>
<a name="l04077"></a>04077 <span class="comment">         then we might as well make sure that each agent is a legit agent for the party, and that each account has a legit agent lording over it.</span>
<a name="l04078"></a>04078 <span class="comment">         (Don&#39;t I do something like that already?)</span>
<a name="l04079"></a>04079 <span class="comment">         */</span>
<a name="l04080"></a>04080 
<a name="l04081"></a>04081         <span class="keywordtype">bool</span> bToBurnOrNotToBurn = bBurnTransNo;
<a name="l04082"></a>04082         <span class="comment">// ------------------------------------------------</span>
<a name="l04083"></a>04083         <span class="comment">// If we&#39;re burning a number, but THIS party has the same opening # as</span>
<a name="l04084"></a>04084         <span class="comment">// the smart contract itself, then don&#39;t bother verifying / burning this</span>
<a name="l04085"></a>04085         <span class="comment">// specific number (since it&#39;s been done already, higher-up.)</span>
<a name="l04086"></a>04086         <span class="comment">//</span>
<a name="l04087"></a>04087         <span class="keywordflow">if</span> (bBurnTransNo &amp;&amp;                                             <span class="comment">// If this party&#39;s opening number is the SMART CONTRACT&#39;s opening number, then this party</span>
<a name="l04088"></a>04088             (this-&gt;<a class="code" href="class_o_t_trackable.html#a2594d320e3b24f3210bd38a08de66a70">GetTransactionNum</a>() == pParty-&gt;<a class="code" href="class_o_t_party.html#aa11f990dfe9743dd1d8e34af8bfd693a">GetOpeningTransNo</a>())) <span class="comment">// MUST be the ACTIVATOR. (No need to mark his trans# as IN USE since already done earlier.)</span>
<a name="l04089"></a>04089         {
<a name="l04090"></a>04090             <span class="comment">// In cases where we&#39;re supposed to burn the transaction number, we do that</span>
<a name="l04091"></a>04091             <span class="comment">// for ALL parties EXCEPT the one who has the same Opening# as the SmartContract</span>
<a name="l04092"></a>04092             <span class="comment">// has for its GetTransactionNum().  Why? Because that one was already burned, when</span>
<a name="l04093"></a>04093             <span class="comment">// the activating party (pParty) activated the smart contract. At that time, the normal</span>
<a name="l04094"></a>04094             <span class="comment">// transaction system inside OTServer burned the # as part of its process before even</span>
<a name="l04095"></a>04095             <span class="comment">// calling NotarizeSmartContract().  Therefore, by this point, we ASSUME that party&#39;s</span>
<a name="l04096"></a>04096             <span class="comment">// opening num has already JUST been verified, and we skip it, (continuing to verify</span>
<a name="l04097"></a>04097             <span class="comment">// all the others.)</span>
<a name="l04098"></a>04098 
<a name="l04099"></a>04099             bToBurnOrNotToBurn = <span class="keyword">false</span>;
<a name="l04100"></a>04100         }
<a name="l04101"></a>04101         <span class="comment">// ------------------------------------------------------------------</span>
<a name="l04102"></a>04102         <a class="code" href="_o_t_agent_8hpp.html#ac89892658f6bc83e354078647b704e8f">mapOfNyms</a>   map_Nyms_NewlyLoaded,
<a name="l04103"></a>04103                     map_Nyms_Already_Loaded_AS_OF_NOW;
<a name="l04104"></a>04104 
<a name="l04105"></a>04105         map_Nyms_Already_Loaded_AS_OF_NOW.insert(map_Nyms_Already_Loaded.begin(),
<a name="l04106"></a>04106                                                  map_Nyms_Already_Loaded.end());
<a name="l04107"></a>04107         map_Nyms_Already_Loaded_AS_OF_NOW.insert(map_Nyms_Loaded_In_This_Function.begin(),
<a name="l04108"></a>04108                                                  map_Nyms_Loaded_In_This_Function.end());
<a name="l04109"></a>04109         <span class="comment">// ------------------------------------------------------------------</span>
<a name="l04110"></a>04110         <span class="keyword">const</span>
<a name="l04111"></a>04111         <span class="keywordtype">bool</span> bIsPartyAuthorized = this-&gt;<a class="code" href="class_o_t_scriptable.html#a5b20bcf70883ffe7e02f10343b88affc">VerifyPartyAuthorization</a>(*pParty,       <span class="comment">// The party that supposedly is authorized for this supposedly executed agreement.</span>
<a name="l04112"></a>04112                                                                  theServerNym,  <span class="comment">// For verifying signature on the authorizing Nym, when loading it</span>
<a name="l04113"></a>04113                                                                  strServerID,   <span class="comment">// For verifying issued num, need the serverID the # goes with.</span>
<a name="l04114"></a>04114                                                                  &amp;map_Nyms_Already_Loaded_AS_OF_NOW,
<a name="l04115"></a>04115                                                                  &amp;map_Nyms_NewlyLoaded,
<a name="l04116"></a>04116                                                                  bToBurnOrNotToBurn); <span class="comment">// bBurnTransNo = true  (default is false)</span>
<a name="l04117"></a>04117 
<a name="l04118"></a>04118         map_Nyms_Loaded_In_This_Function.insert(map_Nyms_NewlyLoaded.begin(),
<a name="l04119"></a>04119                                                 map_Nyms_NewlyLoaded.end());
<a name="l04120"></a>04120         <span class="comment">// ------------------------------------------------------------------</span>
<a name="l04121"></a>04121         <span class="comment">// By this point, we&#39;ve verified that pParty-&gt;GetOpeningTransNo() really is ISSUED to pParty.</span>
<a name="l04122"></a>04122         <span class="comment">// After all, you can Verify a Party&#39;s Authorization even after the smart contract has been activated.</span>
<a name="l04123"></a>04123         <span class="comment">// But in THIS function we also want to verify TRANSACTION num (not just VerifyIssuedNum()) because</span>
<a name="l04124"></a>04124         <span class="comment">// this is where that number is actually being BURNED for each one.</span>
<a name="l04125"></a>04125         <span class="comment">// Since VerifyPartyAuthorization() ALREADY has the Nym loaded up for verification, I&#39;m going</span>
<a name="l04126"></a>04126         <span class="comment">// to pass in a boolean arg to verify the Transaction Num as well, and burn it. (for this very purpose.)</span>
<a name="l04127"></a>04127         <span class="comment">//</span>
<a name="l04128"></a>04128         <span class="comment">// Due to this, We don&#39;t want to stop this loop just because one of the parties failed. We want to go ahead</span>
<a name="l04129"></a>04129         <span class="comment">// and burn ALL the opening numbers for the remainder of the parties, so that they have a consistent rule (the</span>
<a name="l04130"></a>04130         <span class="comment">// opening number is considered burned and gone after a failed activation attempt, though the closing numbers</span>
<a name="l04131"></a>04131         <span class="comment">// are salvageable.)  Otherwise they would never know, upon receiving a server failure reply, whether their</span>
<a name="l04132"></a>04132         <span class="comment">// opening number was to still be considered valid -- or not.</span>
<a name="l04133"></a>04133         <span class="comment">//</span>
<a name="l04134"></a>04134         <span class="keywordflow">if</span> (<span class="keyword">false</span> == bIsPartyAuthorized)
<a name="l04135"></a>04135         {
<a name="l04136"></a>04136             <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(0, <span class="stringliteral">&quot;%s: Party %s does NOT verify as authorized! \n&quot;</span>,
<a name="l04137"></a>04137                            __FUNCTION__, str_party_name.c_str());
<a name="l04138"></a>04138             bAreAnyInvalidParties = <span class="keyword">true</span>; <span class="comment">// We let them all go through, but we still take notice that at least one failed.</span>
<a name="l04139"></a>04139             <span class="comment">// ------------------------------------------------</span>
<a name="l04140"></a>04140             theFailedParties.insert(pParty); <span class="comment">// (So we can skip them in the loop below. Meaning THEIR closing #s also don&#39;t get marked as &quot;used&quot;, which is another reason for clients to just harvest the number in that case and consider it as clean, since the server is.)</span>
<a name="l04141"></a>04141 <span class="comment">//          return false; // see above comment. We still allow all parties to burn their opening #s, to keep things consistent for the client GUI code.</span>
<a name="l04142"></a>04142         }
<a name="l04143"></a>04143     } <span class="comment">// FOR_EACH (mapOfParties...)</span>
<a name="l04144"></a>04144     <span class="comment">// ------------------------------------------------------------------</span>
<a name="l04145"></a>04145 
<a name="l04146"></a>04146     <span class="comment">// (MOVED TO FARTHER BELOW.)</span>
<a name="l04147"></a>04147     <span class="comment">//</span>
<a name="l04148"></a>04148 <span class="comment">//  if (bAreAnyInvalidParties)</span>
<a name="l04149"></a>04149 <span class="comment">//  {</span>
<a name="l04150"></a>04150 <span class="comment">//      OTLog::Output(0, &quot;OTSmartContract::VerifySmartContract: Failure. There are invalid parties on this contract.\n&quot;);</span>
<a name="l04151"></a>04151 <span class="comment">//      return false;</span>
<a name="l04152"></a>04152 <span class="comment">//  }</span>
<a name="l04153"></a>04153 <span class="comment">//  // ------------------------------------------------------------------</span>
<a name="l04154"></a>04154     <span class="comment">// NEXT: THE ACCOUNTS</span>
<a name="l04155"></a>04155     <span class="comment">//</span>
<a name="l04156"></a>04156     <span class="comment">// We loop through the parties again, now knowing they are all authorized.</span>
<a name="l04157"></a>04157     <span class="comment">// For each party, we call pParty-&gt;LoadAndVerifyAgentNyms(). This way, they will</span>
<a name="l04158"></a>04158     <span class="comment">// all be loaded up already for when we verify the accounts. Similarly we call</span>
<a name="l04159"></a>04159     <span class="comment">// pParty-&gt;LoadAndVerifyAssetAccounts(), so that all the accounts are loaded up</span>
<a name="l04160"></a>04160     <span class="comment">// as well. (We at least need to check their signatures...) At that point, all</span>
<a name="l04161"></a>04161     <span class="comment">// of the agent nyms AND accounts have been loaded! (And verified internally against</span>
<a name="l04162"></a>04162     <span class="comment">// themselves, such as their signature, etc.)</span>
<a name="l04163"></a>04163     <span class="comment">//</span>
<a name="l04164"></a>04164     <span class="comment">// From there, I need to verify the Party&#39;s Ownership over the account, as well as</span>
<a name="l04165"></a>04165     <span class="comment">// verify that the authorized agent listed for each account actually has signer rights</span>
<a name="l04166"></a>04166     <span class="comment">// over that account, and verify the closing transaction #s for each account against its</span>
<a name="l04167"></a>04167     <span class="comment">// authorized agent.</span>
<a name="l04168"></a>04168     <span class="comment">//</span>
<a name="l04169"></a>04169     <span class="keywordtype">bool</span> bAreAnyInvalidAccounts = <span class="keyword">false</span>;
<a name="l04170"></a>04170 
<a name="l04171"></a>04171     <span class="comment">/*</span>
<a name="l04172"></a>04172 <span class="comment">     NOTE on syncronicity...</span>
<a name="l04173"></a>04173 <span class="comment"></span>
<a name="l04174"></a>04174 <span class="comment">     Above, we burned all the opening numbers for ALL the various nyms, even if there was some failure halfway through</span>
<a name="l04175"></a>04175 <span class="comment">     the verification process. This in order to make it easy to tell whether, for you, that number is still good or not.</span>
<a name="l04176"></a>04176 <span class="comment"></span>
<a name="l04177"></a>04177 <span class="comment">     Similarly, what about the closing numbers (below) ? They are not instantly BURNED just for the ATTEMPT (as the</span>
<a name="l04178"></a>04178 <span class="comment">     opening numbers were) but they are still marked below as &quot;USED BUT STILL ISSUED.&quot;</span>
<a name="l04179"></a>04179 <span class="comment"></span>
<a name="l04180"></a>04180 <span class="comment">     if (bAreAnyInvalidParties) just above insures that the below code will not run if there are any invalid parties.</span>
<a name="l04181"></a>04181 <span class="comment">     That means that if &quot;the message succeeded but transaction failed&quot; due to invalid parties, then the closing numbers</span>
<a name="l04182"></a>04182 <span class="comment">     will never be seen by the server and thus never marked as &quot;USED BUT STILL ISSUED.&quot; Instead, they would still be</span>
<a name="l04183"></a>04183 <span class="comment">     considered &quot;ISSUED AND AVAILABLE.&quot;</span>
<a name="l04184"></a>04184 <span class="comment"></span>
<a name="l04185"></a>04185 <span class="comment">     Based on that:</span>
<a name="l04186"></a>04186 <span class="comment">     If some FAILURE occurs below, as above, it still completes the loop in order to have consistent results for the</span>
<a name="l04187"></a>04187 <span class="comment">     closing transaction numbers, for all parties. So we know that success or fail, if the below code runs, the closing</span>
<a name="l04188"></a>04188 <span class="comment">     number is DEFINITELY marked as &quot;USED BUT STILL ISSUED&quot; for ALL parties, whereas if the below code does not run, the</span>
<a name="l04189"></a>04189 <span class="comment">     closing number for all parties is definitely still marked as &quot;ISSUED AND AVAILABLE&quot; (as far as this message is</span>
<a name="l04190"></a>04190 <span class="comment">     concerned.)</span>
<a name="l04191"></a>04191 <span class="comment"></span>
<a name="l04192"></a>04192 <span class="comment">     Thus, there is still an inconsistency. When a client is later trying to interpret which transaction numbers to &quot;claw</span>
<a name="l04193"></a>04193 <span class="comment">     back&quot;, he will have to harvest back the closing numbers SOMETIMES, based on WHY the transaction failed verification,</span>
<a name="l04194"></a>04194 <span class="comment">     and thus he cannot rely on a &quot;transaction failed&quot; state to give him a reliable answer to that question.</span>
<a name="l04195"></a>04195 <span class="comment"></span>
<a name="l04196"></a>04196 <span class="comment">     However, we must keep in mind that these CLOSING numbers have NOT been burned -- they ARE still on the client&#39;s local</span>
<a name="l04197"></a>04197 <span class="comment">     list for his nym as &quot;USED BUT STILL ISSUED.&quot; If the client harvests them back each time consistently, what will happen?</span>
<a name="l04198"></a>04198 <span class="comment">     The client will look at each closing number, see if it&#39;s on his local &quot;issued&quot; list (which it is) and then will re-add</span>
<a name="l04199"></a>04199 <span class="comment">     it to his &quot;available&quot; list as well. So is it really available on the server side? The answer is: sometimes.</span>
<a name="l04200"></a>04200 <span class="comment"></span>
<a name="l04201"></a>04201 <span class="comment">     SOLUTION?</span>
<a name="l04202"></a>04202 <span class="comment">     1. Above, cache a list of all the parties who failed verification.</span>
<a name="l04203"></a>04203 <span class="comment">     2. Allow the code below to run, even if some parties have failed.</span>
<a name="l04204"></a>04204 <span class="comment">     3. Change the code below to skip failed parties while verifying accounts. (Using afore-mentioned list to make this possible.)</span>
<a name="l04205"></a>04205 <span class="comment">     4. Move the &quot;if failed parties, return false&quot; block BELOW this loop, in conjunction with the invalid accounts block.</span>
<a name="l04206"></a>04206 <span class="comment"></span>
<a name="l04207"></a>04207 <span class="comment">     This will guarantee that closing numbers are consistently marked as &quot;USED BUT STILL ISSUED&quot; on the server side, no matter</span>
<a name="l04208"></a>04208 <span class="comment">     HOW the transaction has failed. (At least it will then be consistent.)</span>
<a name="l04209"></a>04209 <span class="comment"></span>
<a name="l04210"></a>04210 <span class="comment">     However, if the transaction HAS failed, then all those closing numbers, if the clients are to claw them back, must be</span>
<a name="l04211"></a>04211 <span class="comment">     marked as available once again on the server side, as well! And if the clients are NOT to claw them back for future use,</span>
<a name="l04212"></a>04212 <span class="comment">     then how will they ever close them out? The server already won&#39;t allow the numbers to be used again, since they were</span>
<a name="l04213"></a>04213 <span class="comment">     marked as &quot;used but still issued&quot;. But the transaction is ALREADY closed (it failed.)</span>
<a name="l04214"></a>04214 <span class="comment"></span>
<a name="l04215"></a>04215 <span class="comment">     SOLUTIONS?</span>
<a name="l04216"></a>04216 <span class="comment">     -- Server could burn the closing numbers for failed transactions, vs marking them as &quot;used but issued&quot; when the transaction</span>
<a name="l04217"></a>04217 <span class="comment">        is successful. That way any client getting notice of the failure would DEFINITELY know that those numbers were burned, and</span>
<a name="l04218"></a>04218 <span class="comment">        could sync himself accordingly. (We definitely need to notice all parties as well, in this case, since they will need</span>
<a name="l04219"></a>04219 <span class="comment">        to discard the burned numbers after that point, in order to avoid going out-of-sync.)</span>
<a name="l04220"></a>04220 <span class="comment"></span>
<a name="l04221"></a>04221 <span class="comment">     -- Server could also, in the event of transaction failure, mark the closing numbers as &quot;available again, like new!&quot;</span>
<a name="l04222"></a>04222 <span class="comment">        This way clients could clearly determine whether to burn their numbers or mark them as available again, purely based</span>
<a name="l04223"></a>04223 <span class="comment">        on the transaction&#39;s failure state. (State meaning the message itself is successful, and transaction could be success or fail.)</span>
<a name="l04224"></a>04224 <span class="comment">        Clients will not go out of sync in this case, if they fail to adjust to match the server. Well, they would be out of</span>
<a name="l04225"></a>04225 <span class="comment">        sync, but not the kind that prevents you from doing new transactions. (Rather, it&#39;s the kind where you have certain numbers</span>
<a name="l04226"></a>04226 <span class="comment">        signed out forever and you can never get rid of them.) Therefore, a notice is ALSO needed for this case.</span>
<a name="l04227"></a>04227 <span class="comment"></span>
<a name="l04228"></a>04228 <span class="comment">     -- I know notices are already being sent upon activation, but I need to research that more closely now and determine the</span>
<a name="l04229"></a>04229 <span class="comment">        exact circumstances of these notices. Clearly a notice is REQUIRED, no matter which above option I choose!</span>
<a name="l04230"></a>04230 <span class="comment"></span>
<a name="l04231"></a>04231 <span class="comment">     Thought: If notice is REQUIRED either way, perhaps the clients can just assume X unless a notice is received? For example,</span>
<a name="l04232"></a>04232 <span class="comment">     a client could just ASSUME the closing number is &quot;used but still issued&quot; unless notice is received to the contrary. This IS</span>
<a name="l04233"></a>04233 <span class="comment">     how the state would be if the transaction were successful, yet if it had failed, or hadn&#39;t been activated yet, the client</span>
<a name="l04234"></a>04234 <span class="comment">     also wouldn&#39;t experience any syncing issues by making this assumption.</span>
<a name="l04235"></a>04235 <span class="comment"></span>
<a name="l04236"></a>04236 <span class="comment">     Clearly the server HAS to, in the event of transaction failure, mark the closing numbers either as &quot;available again, like new!&quot;</span>
<a name="l04237"></a>04237 <span class="comment">     or it has to mark them as BURNED, but either way, it&#39;s an additional piece the server has to do (up until now it has only</span>
<a name="l04238"></a>04238 <span class="comment">     marked them as &quot;used but still issued.&quot;) What I can see is the server HAS to do something about those numbers, and it HAS</span>
<a name="l04239"></a>04239 <span class="comment">     to notify all the parties whether that transaction succeeded or failed, and then those parties HAVE to fix their client-side</span>
<a name="l04240"></a>04240 <span class="comment">     transaction count BASED on whether that transaciton succeeded or failed.</span>
<a name="l04241"></a>04241 <span class="comment"></span>
<a name="l04242"></a>04242 <span class="comment">     Therefore:</span>
<a name="l04243"></a>04243 <span class="comment"></span>
<a name="l04244"></a>04244 <span class="comment">     1. Implement the above 4-step solution.</span>
<a name="l04245"></a>04245 <span class="comment">     2. Do something about all the closing numbers, if activation fails.</span>
<a name="l04246"></a>04246 <span class="comment">        (Keep the nyms loaded until that is done, so as not to have to load them twice.)</span>
<a name="l04247"></a>04247 <span class="comment">     3. Make sure the parties are consistently noticed either way.</span>
<a name="l04248"></a>04248 <span class="comment">     4. Make sure the parties are syncing their numbers properly based on these notices.</span>
<a name="l04249"></a>04249 <span class="comment"></span>
<a name="l04250"></a>04250 <span class="comment"></span>
<a name="l04251"></a>04251 <span class="comment">     WOW, eh?  But I believe that smart contracts are the most complicated case, so this has got to be the worst of it, now handled :-)</span>
<a name="l04252"></a>04252 <span class="comment"></span>
<a name="l04253"></a>04253 <span class="comment">     Another note: If we assume the server burns the closing numbers, then the clients will suddenly be out-of-sync and unable</span>
<a name="l04254"></a>04254 <span class="comment">     to process transactions until they receive and process the notice of this failure. But if we instead assume that the server</span>
<a name="l04255"></a>04255 <span class="comment">     &quot;makes new&quot; those closing numbers, then the clients will remain in sync regardless of notice, and they only need to harvest</span>
<a name="l04256"></a>04256 <span class="comment">     the numbers upon notice, just so they can use them again, and they will not experience any &quot;out of sync failures&quot; along the</span>
<a name="l04257"></a>04257 <span class="comment">     way. Thus, it is preferable for the server to &quot;make those numbers new again!&quot; in the event of activation failure, AND to notice</span>
<a name="l04258"></a>04258 <span class="comment">     the parties of this so that they can do likewise.</span>
<a name="l04259"></a>04259 <span class="comment">     One way to notice them is to drop the &quot;message succeeded but transaction failed&quot; server reply into ALL of their Nymboxes,</span>
<a name="l04260"></a>04260 <span class="comment">     and not just the activator&#39;s. But not sure if that&#39;s safe... hm.</span>
<a name="l04261"></a>04261 <span class="comment"></span>
<a name="l04262"></a>04262 <span class="comment">     */</span>
<a name="l04263"></a>04263 
<a name="l04264"></a>04264     <a class="code" href="_o_t_storage_8hpp.html#a4a94c3435a932ed34e5755f3f472547c">FOR_EACH_IT</a>(<a class="code" href="_o_t_party_8hpp.html#a029bc6921acd4516530e26201cf595f2">mapOfParties</a>, <a class="code" href="class_o_t_scriptable.html#a6a7e4ef3e0ed95f90d950b1718f815ab">m_mapParties</a>, it_party)
<a name="l04265"></a>04265     {
<a name="l04266"></a>04266         <span class="keyword">const</span> std::string str_party_name    = (*it_party).first;
<a name="l04267"></a>04267         <a class="code" href="class_o_t_party.html">OTParty</a> * pParty                    = (*it_party).second;
<a name="l04268"></a>04268         <a class="code" href="_o_t_assert_8hpp.html#a033b133f48e61f2b227c52ad2be0c882">OT_ASSERT_MSG</a>(NULL != pParty, <span class="stringliteral">&quot;Unexpected NULL pointer in party map.&quot;</span>);
<a name="l04269"></a>04269         <span class="comment">// --------------------------------------------</span>
<a name="l04270"></a>04270         <span class="comment">//</span>
<a name="l04271"></a>04271         <span class="comment">// SKIP FAILED PARTIES...</span>
<a name="l04272"></a>04272         <span class="comment">//</span>
<a name="l04273"></a>04273         std::set&lt;OTParty *&gt;::iterator it_failed = theFailedParties.find(pParty);
<a name="l04274"></a>04274 
<a name="l04275"></a>04275         <span class="keywordflow">if</span> (theFailedParties.end() != it_failed) <span class="comment">// this means pParty was found on the FAILED list. (So we can skip it here.)</span>
<a name="l04276"></a>04276         {
<a name="l04277"></a>04277             <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(0, <span class="stringliteral">&quot;%s: FYI, at least one party (%s) has failed, and right now I&#39;m skipping verification of his &quot;</span>
<a name="l04278"></a>04278                            <span class="stringliteral">&quot;asset accounts.\n&quot;</span>, __FUNCTION__, str_party_name.c_str());
<a name="l04279"></a>04279             <span class="keywordflow">continue</span>;
<a name="l04280"></a>04280         }
<a name="l04281"></a>04281         <span class="comment">// ------------------------------------------------------------------</span>
<a name="l04282"></a>04282         <a class="code" href="_o_t_agent_8hpp.html#ac89892658f6bc83e354078647b704e8f">mapOfNyms</a>   map_Nyms_NewlyLoaded,
<a name="l04283"></a>04283                     map_Nyms_Already_Loaded_AS_OF_NOW;
<a name="l04284"></a>04284 
<a name="l04285"></a>04285         map_Nyms_Already_Loaded_AS_OF_NOW.insert(map_Nyms_Already_Loaded.begin(),
<a name="l04286"></a>04286                                                  map_Nyms_Already_Loaded.end());
<a name="l04287"></a>04287         map_Nyms_Already_Loaded_AS_OF_NOW.insert(map_Nyms_Loaded_In_This_Function.begin(),
<a name="l04288"></a>04288                                                  map_Nyms_Loaded_In_This_Function.end());
<a name="l04289"></a>04289 
<a name="l04290"></a>04290         <span class="comment">// After calling this, map_Nyms_NewlyLoaded will contain pointers to Nyms that MUST BE CLEANED UP.</span>
<a name="l04291"></a>04291         <span class="comment">// LoadAndVerifyAgentNyms will not bother loading any Nyms which appear on map_Nyms_Already_Loaded.</span>
<a name="l04292"></a>04292         <span class="comment">//</span>
<a name="l04293"></a>04293         <span class="keyword">const</span> <span class="keywordtype">bool</span> bAgentsLoaded = pParty-&gt;<a class="code" href="class_o_t_party.html#a2f9d6c69f58bb85a524f897a70a1dae6">LoadAndVerifyAgentNyms</a>(theServerNym,
<a name="l04294"></a>04294                                                                   map_Nyms_Already_Loaded_AS_OF_NOW, <span class="comment">// Nyms it won&#39;t bother loading &#39;cause they are loaded already.</span>
<a name="l04295"></a>04295                                                                   map_Nyms_NewlyLoaded);             <span class="comment">// Nyms it had to load itself, and thus that YOU must clean up afterwards.</span>
<a name="l04296"></a>04296         map_Nyms_Loaded_In_This_Function.insert(map_Nyms_NewlyLoaded.begin(),
<a name="l04297"></a>04297                                                 map_Nyms_NewlyLoaded.end());
<a name="l04298"></a>04298         <span class="keywordflow">if</span> (<span class="keyword">false</span> == bAgentsLoaded)
<a name="l04299"></a>04299         {
<a name="l04300"></a>04300             <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(0, <span class="stringliteral">&quot;%s: Failed trying to Load and Verify Agent Nyms for party: %s\n&quot;</span>,
<a name="l04301"></a>04301                            __FUNCTION__, str_party_name.c_str());
<a name="l04302"></a>04302             bAreAnyInvalidAccounts = <span class="keyword">true</span>; <span class="comment">// We let them all go through, so there is consistent output, but we still take notice that at least one failed.</span>
<a name="l04303"></a>04303         }
<a name="l04304"></a>04304         <span class="comment">// ------------------------------------------------------------------</span>
<a name="l04305"></a>04305         <a class="code" href="_o_t_agent_8hpp.html#abd4942716d546c8d42670619a03ef99e">mapOfAccounts</a>   map_Accts_NewlyLoaded,
<a name="l04306"></a>04306                         map_Accts_Already_Loaded_AS_OF_NOW;
<a name="l04307"></a>04307 
<a name="l04308"></a>04308         map_Accts_Already_Loaded_AS_OF_NOW.insert(map_Accts_Already_Loaded.begin(),
<a name="l04309"></a>04309                                                   map_Accts_Already_Loaded.end());
<a name="l04310"></a>04310         map_Accts_Already_Loaded_AS_OF_NOW.insert(map_Accts_Loaded_In_This_Function.begin(),
<a name="l04311"></a>04311                                                   map_Accts_Loaded_In_This_Function.end());
<a name="l04312"></a>04312 
<a name="l04313"></a>04313         <span class="comment">// After calling this, map_Accts_NewlyLoaded will contain pointers to Accts that MUST BE CLEANED UP.</span>
<a name="l04314"></a>04314         <span class="comment">// LoadAndVerifyAssetAccounts will not bother loading any Accts which appear on map_Accts_Already_Loaded.</span>
<a name="l04315"></a>04315         <span class="comment">//</span>
<a name="l04316"></a>04316         <span class="keyword">const</span> <span class="keywordtype">bool</span> bAcctsLoaded = pParty-&gt;<a class="code" href="class_o_t_party.html#a29151e24141937447c2be93a237e0613">LoadAndVerifyAssetAccounts</a>(theServerNym, strServerID,
<a name="l04317"></a>04317                                                                      map_Accts_Already_Loaded_AS_OF_NOW,  <span class="comment">// Accts it won&#39;t bother loading &#39;cause they are loaded already.</span>
<a name="l04318"></a>04318                                                                      map_Accts_NewlyLoaded);              <span class="comment">// Accts it had to load itself, and thus that YOU must clean up afterwards.</span>
<a name="l04319"></a>04319 
<a name="l04320"></a>04320         map_Accts_Loaded_In_This_Function.insert(map_Accts_NewlyLoaded.begin(),
<a name="l04321"></a>04321                                                  map_Accts_NewlyLoaded.end());
<a name="l04322"></a>04322         <span class="keywordflow">if</span> (<span class="keyword">false</span> == bAcctsLoaded)
<a name="l04323"></a>04323         {
<a name="l04324"></a>04324             <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(0, <span class="stringliteral">&quot;%s: Failed trying to Load and Verify Asset Accts for party: %s\n&quot;</span>,
<a name="l04325"></a>04325                            __FUNCTION__, str_party_name.c_str());
<a name="l04326"></a>04326             bAreAnyInvalidAccounts = <span class="keyword">true</span>; <span class="comment">// We let them all go through, so there is consistent output, but we still take notice that at least one failed.</span>
<a name="l04327"></a>04327         }
<a name="l04328"></a>04328         <span class="comment">// ------------------------------------------------------------------</span>
<a name="l04329"></a>04329         <span class="comment">// BY THIS POINT, FOR THIS PARTY, we have successfully loaded and verified ALL of the Nyms,</span>
<a name="l04330"></a>04330         <span class="comment">// for ALL of the party&#39;s agents, and ALL of the asset accounts, for this party. We know the</span>
<a name="l04331"></a>04331         <span class="comment">// Party has pointers internally to all of those objects as well. Therefore if we erase any of those objects, we must also clear the pointers!</span>
<a name="l04332"></a>04332         <span class="comment">//</span>
<a name="l04333"></a>04333         <span class="keyword">const</span> <span class="keywordtype">bool</span> bAreAcctsVerified = pParty-&gt;<a class="code" href="class_o_t_party.html#aa047a5d694ee951edf7bc7fc8a686d82">VerifyAccountsWithTheirAgents</a>(theServerNym, strServerID,
<a name="l04334"></a>04334                                                                              bBurnTransNo); <span class="comment">// bBurnTransNo=false by default.</span>
<a name="l04335"></a>04335         <span class="keywordflow">if</span> (<span class="keyword">false</span> == bAreAcctsVerified)
<a name="l04336"></a>04336         {
<a name="l04337"></a>04337             <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(0, <span class="stringliteral">&quot;%s: Failed trying to Verify Asset Accts with their Agents, for party: %s\n&quot;</span>,
<a name="l04338"></a>04338                            __FUNCTION__, str_party_name.c_str());
<a name="l04339"></a>04339             bAreAnyInvalidAccounts = <span class="keyword">true</span>; <span class="comment">// We let them all go through, so there is consistent output, but we still take notice that at least one failed.</span>
<a name="l04340"></a>04340         }
<a name="l04341"></a>04341         <span class="comment">// **************************************************************</span>
<a name="l04342"></a>04342 
<a name="l04343"></a>04343         <span class="comment">// Now we don&#39;t delete these until AFTER the loop, until after we know if it was a success.</span>
<a name="l04344"></a>04344         <span class="comment">// If it failed, then we can fix their closing transaction numbers from &quot;used but still issued&quot; back to</span>
<a name="l04345"></a>04345         <span class="comment">// &quot;issued and available for use.&quot; (If it was a success, then we don&#39;t do anything, since the numbers are</span>
<a name="l04346"></a>04346         <span class="comment">// already marked appropriately. And we still clean up all the nyms / accounts--just AFTER this loop.)</span>
<a name="l04347"></a>04347         <span class="comment">//</span>
<a name="l04348"></a>04348 <span class="comment">//      pParty-&gt;ClearTemporaryPointers(); // Don&#39;t want any bad pointers floating around after cleanup. (Pointers must be cleared in same scope as whatever they point to...)</span>
<a name="l04349"></a>04349 <span class="comment">//      OTSmartContract::CleanupNyms (map_Nyms_NewlyLoaded);  // HAVE to do this, or we&#39;ll leak. Even if something returned</span>
<a name="l04350"></a>04350 <span class="comment">//      OTSmartContract::CleanupAccts(map_Accts_NewlyLoaded); // false, some objects may have been loaded before it failed.</span>
<a name="l04351"></a>04351         <span class="comment">// ----------------</span>
<a name="l04352"></a>04352     } <span class="comment">// FOR_EACH_IT(mapOfParties, m_mapParties, it_party)</span>
<a name="l04353"></a>04353     <span class="comment">// ********************************************************************************</span>
<a name="l04354"></a>04354 
<a name="l04355"></a>04355     <span class="keyword">const</span> <span class="keywordtype">bool</span> bSuccess = (!bAreAnyInvalidParties &amp;&amp; !bAreAnyInvalidAccounts);  <span class="comment">// &lt;=== THE RETURN VALUE</span>
<a name="l04356"></a>04356 
<a name="l04357"></a>04357     <span class="comment">// --------------------------------------------------------------------------------</span>
<a name="l04358"></a>04358     <span class="keywordflow">if</span> (bAreAnyInvalidParties)
<a name="l04359"></a>04359         <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(0, <span class="stringliteral">&quot;%s: Failure: There are invalid party(s) on this smart contract.\n&quot;</span>, __FUNCTION__);
<a name="l04360"></a>04360     <span class="comment">// --------------------------------------------------------------------------------</span>
<a name="l04361"></a>04361     <span class="keywordflow">if</span> (bAreAnyInvalidAccounts)
<a name="l04362"></a>04362         <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(0, <span class="stringliteral">&quot;%s: Failure: there are invalid account(s) or authorized agent(s) on this smart contract.\n&quot;</span>, __FUNCTION__);
<a name="l04363"></a>04363     <span class="comment">// --------------------------------------------------------------------------------</span>
<a name="l04364"></a>04364     <span class="comment">// IF we marked the numbers as IN USE (bBurnTransNo) but then FAILURE occurred,</span>
<a name="l04365"></a>04365     <span class="comment">// then we need to CLOSE the opening numbers (RemoveIssuedNum) meaning they are done</span>
<a name="l04366"></a>04366     <span class="comment">// and over, and can never be used again, and we also need to HARVEST the CLOSING</span>
<a name="l04367"></a>04367     <span class="comment">// numbers, meaning they are available again for use in the future.</span>
<a name="l04368"></a>04368     <span class="comment">// (If failure occurred in a case where we did NOT burn the numbers, then we wouldn&#39;t</span>
<a name="l04369"></a>04369     <span class="comment">// be worried about putting them back, now would we?)</span>
<a name="l04370"></a>04370     <span class="comment">//</span>
<a name="l04371"></a>04371     <span class="comment">//</span>
<a name="l04372"></a>04372     <span class="keywordflow">if</span> (!bSuccess &amp;&amp;    <span class="comment">// If this function was not a success, overall, and</span>
<a name="l04373"></a>04373         bBurnTransNo)   <span class="comment">// if we DID burn (mark as &#39;in use&#39;) the numbers during this function...</span>
<a name="l04374"></a>04374     {
<a name="l04375"></a>04375         <span class="comment">// CloseoutOpeningNumbers...</span>
<a name="l04376"></a>04376         <span class="comment">// This closes the opening numbers for all parties except the activator Nym.</span>
<a name="l04377"></a>04377         <span class="comment">// Why not him? Because his is already closed out in NotarizeTransaction, if</span>
<a name="l04378"></a>04378         <span class="comment">// the transaction has failed.</span>
<a name="l04379"></a>04379         <span class="comment">//</span>
<a name="l04380"></a>04380         <span class="comment">// Also, where that happens, his set of open cron items is also updated to</span>
<a name="l04381"></a>04381         <span class="comment">// remove the number from that list. (As the below function also does for the rest</span>
<a name="l04382"></a>04382         <span class="comment">// of the nyms involved.)</span>
<a name="l04383"></a>04383         <span class="comment">//</span>
<a name="l04384"></a>04384         this-&gt;<a class="code" href="class_o_t_smart_contract.html#ac49c69ff88ceac23756933c4a915fd60">CloseoutOpeningNumbers</a>(&amp;theServerNym);
<a name="l04385"></a>04385 
<a name="l04386"></a>04386         <span class="comment">// Then harvest those closing numbers back again (for ALL Nyms.)</span>
<a name="l04387"></a>04387         <span class="comment">// (Not the opening numbers, which are already burned for good by this point.)</span>
<a name="l04388"></a>04388         <span class="comment">//</span>
<a name="l04389"></a>04389         this-&gt;<a class="code" href="class_o_t_smart_contract.html#a40befd7381c6c5e68e7d1042c9a7f2d3">HarvestClosingNumbers</a>(&amp;theServerNym,      <span class="comment">// theServerNym is the signer, here on the server side.</span>
<a name="l04390"></a>04390                                     &amp;theFailedParties); <span class="comment">// Since we skipped marking the closing numbers for these failed parties, then we skip adding those same numbers back again, too.</span>
<a name="l04391"></a>04391     }
<a name="l04392"></a>04392     <span class="comment">// --------------------------------------------------------------------------------</span>
<a name="l04393"></a>04393     <span class="comment">// Now that all potentially-needed harvesting is done, we can clean up.</span>
<a name="l04394"></a>04394     <span class="comment">//</span>
<a name="l04395"></a>04395     this-&gt;<a class="code" href="class_o_t_scriptable.html#ab9a6cff853b9c71456eaf427caa3ab8b">ClearTemporaryPointers</a>(); <span class="comment">// Don&#39;t want any bad pointers floating around after cleanup.</span>
<a name="l04396"></a>04396 
<a name="l04397"></a>04397     <a class="code" href="class_o_t_smart_contract.html#a16209b074a580bc416cf848025e0647e">OTSmartContract::CleanupNyms</a> (map_Nyms_Loaded_In_This_Function);  <span class="comment">// HAVE to do this, or we&#39;ll leak. Even if something returned</span>
<a name="l04398"></a>04398     <a class="code" href="class_o_t_smart_contract.html#a11408d45bd120d44b704637ebbc0c971">OTSmartContract::CleanupAccts</a>(map_Accts_Loaded_In_This_Function); <span class="comment">// false, some objects may have been loaded before it failed.</span>
<a name="l04399"></a>04399 
<a name="l04400"></a>04400     <span class="comment">// ********************************************************************************</span>
<a name="l04401"></a>04401 
<a name="l04402"></a>04402     <span class="comment">// DONE: if the above loop fails halfway through, then we should really PUT BACK the closing</span>
<a name="l04403"></a>04403     <span class="comment">// transaction #s that we removed. After all, we have a list of them. Otherwise the only way</span>
<a name="l04404"></a>04404     <span class="comment">// to know which parties have their numbers still, and which ones don&#39;t, would be to stick a notice</span>
<a name="l04405"></a>04405     <span class="comment">// in their nymbox, like we do for finalReceipt.  Perhaps such a notice should ALWAYS go into the</span>
<a name="l04406"></a>04406     <span class="comment">// Nymbox in these cases... *shrug*</span>
<a name="l04407"></a>04407 
<a name="l04408"></a>04408     <span class="keywordflow">return</span> bSuccess;
<a name="l04409"></a>04409 }
<a name="l04410"></a>04410 
<a name="l04411"></a>04411 
<a name="l04412"></a>04412 <span class="comment">// Used for closing-out the opening transaction numbers (RemoveIssuedNum(lNymOpeningNumber)), for</span>
<a name="l04413"></a>04413 <span class="comment">// all the Nyms, after the smart contract, for whatever reason, has failed to activate. ASSUMES</span>
<a name="l04414"></a>04414 <span class="comment">// the Nyms are already loaded, since this is used in a place where they are already still loaded.</span>
<a name="l04415"></a>04415 <span class="comment">// (Used above, in VerifySmartContract.)</span>
<a name="l04416"></a>04416 <span class="comment">//</span>
<a name="l04417"></a>04417 <span class="comment">// Also: Saves any Nyms that it does this for.</span>
<a name="l04418"></a>04418 <span class="comment">// NOTE: Skips the activating Nym, since his opening number is ALREADY closed out on failure,</span>
<a name="l04419"></a>04419 <span class="comment">// in NotarizeTransaction.</span>
<a name="l04420"></a>04420 <span class="comment">//</span>
<a name="l04421"></a>04421 <span class="comment">// (Server-side.)</span>
<a name="l04422"></a>04422 <span class="comment">//</span>
<a name="l04423"></a><a class="code" href="class_o_t_smart_contract.html#ac49c69ff88ceac23756933c4a915fd60">04423</a> <span class="keywordtype">void</span> <a class="code" href="class_o_t_smart_contract.html#ac49c69ff88ceac23756933c4a915fd60">OTSmartContract::CloseoutOpeningNumbers</a>(<a class="code" href="class_o_t_pseudonym.html">OTPseudonym</a> * pSignerNym<span class="comment">/*=NULL*/</span>)
<a name="l04424"></a>04424 {
<a name="l04425"></a>04425     <span class="keyword">const</span> <a class="code" href="class_o_t_string.html">OTString</a> strServerID(<a class="code" href="class_o_t_instrument.html#a878dd8998f7b131b85c082575e255375">GetServerID</a>());
<a name="l04426"></a>04426     <span class="comment">// -------------------------------------------------------</span>
<a name="l04427"></a>04427     <a class="code" href="_o_t_storage_8hpp.html#aa135ed03585fa4b246d7907afbd5873d">FOR_EACH</a>(<a class="code" href="_o_t_party_8hpp.html#a029bc6921acd4516530e26201cf595f2">mapOfParties</a>, <a class="code" href="class_o_t_scriptable.html#a6a7e4ef3e0ed95f90d950b1718f815ab">m_mapParties</a>)
<a name="l04428"></a>04428     {
<a name="l04429"></a>04429         <span class="keyword">const</span> std::string str_party_name = it-&gt;first;
<a name="l04430"></a>04430         <a class="code" href="class_o_t_party.html">OTParty</a> * pParty = (*it).second;
<a name="l04431"></a>04431         <a class="code" href="_o_t_assert_8hpp.html#a033b133f48e61f2b227c52ad2be0c882">OT_ASSERT_MSG</a>(NULL != pParty, <span class="stringliteral">&quot;OTSmartContract::CloseoutOpeningNumbers: Unexpected NULL pointer in party map.&quot;</span>);
<a name="l04432"></a>04432         <span class="comment">// --------------------------------------------</span>
<a name="l04433"></a>04433         <span class="comment">// Closeout the opening transaction numbers:</span>
<a name="l04434"></a>04434         <span class="comment">//</span>
<a name="l04435"></a>04435         <span class="keywordflow">if</span> (this-&gt;<a class="code" href="class_o_t_trackable.html#a2594d320e3b24f3210bd38a08de66a70">GetTransactionNum</a>() != pParty-&gt;<a class="code" href="class_o_t_party.html#aa11f990dfe9743dd1d8e34af8bfd693a">GetOpeningTransNo</a>()) <span class="comment">// We skip the activating Nym. (His is already closed-out in NotarizeTransaction.)</span>
<a name="l04436"></a>04436             pParty-&gt;<a class="code" href="class_o_t_party.html#ab400cfbda3311a3ae37a0b394cd4bfa5">CloseoutOpeningNumber</a>(strServerID,
<a name="l04437"></a>04437                                           <span class="keyword">true</span>,         <span class="comment">// bSave=true</span>
<a name="l04438"></a>04438                                           pSignerNym);
<a name="l04439"></a>04439     } <span class="comment">// FOR_EACH ---------------------------------------------</span>
<a name="l04440"></a>04440 }
<a name="l04441"></a>04441 
<a name="l04442"></a>04442 
<a name="l04443"></a>04443 <span class="comment">// Used for adding the closing transaction numbers BACK to all the Nyms, after the smart contract,</span>
<a name="l04444"></a>04444 <span class="comment">// for whatever reason, has failed to activate. ASSUMES the Nyms are already loaded, since this is</span>
<a name="l04445"></a>04445 <span class="comment">// used in a place where they are already still loaded.  (Used above, in VerifySmartContract.)</span>
<a name="l04446"></a>04446 <span class="comment">//</span>
<a name="l04447"></a>04447 <span class="comment">// Also: Saves any Nyms that it harvests for.</span>
<a name="l04448"></a>04448 <span class="comment">//</span>
<a name="l04449"></a>04449 <span class="comment">// (Server-side.)</span>
<a name="l04450"></a>04450 <span class="comment">//</span>
<a name="l04451"></a><a class="code" href="class_o_t_smart_contract.html#a6dc75e512f2cab9acaecf39489f31e6c">04451</a> <span class="keywordtype">void</span> <a class="code" href="class_o_t_smart_contract.html#a40befd7381c6c5e68e7d1042c9a7f2d3">OTSmartContract::HarvestClosingNumbers</a>(<a class="code" href="class_o_t_pseudonym.html">OTPseudonym</a> * pSignerNym<span class="comment">/*=NULL*/</span>,
<a name="l04452"></a>04452                                             std::set&lt;OTParty *&gt; * pFailedParties<span class="comment">/*=NULL*/</span>)
<a name="l04453"></a>04453 {
<a name="l04454"></a>04454     <span class="keyword">const</span> <a class="code" href="class_o_t_string.html">OTString</a> strServerID(<a class="code" href="class_o_t_instrument.html#a878dd8998f7b131b85c082575e255375">GetServerID</a>());
<a name="l04455"></a>04455     <span class="comment">// -------------------------------------------------------</span>
<a name="l04456"></a>04456     <a class="code" href="_o_t_storage_8hpp.html#aa135ed03585fa4b246d7907afbd5873d">FOR_EACH</a>(<a class="code" href="_o_t_party_8hpp.html#a029bc6921acd4516530e26201cf595f2">mapOfParties</a>, <a class="code" href="class_o_t_scriptable.html#a6a7e4ef3e0ed95f90d950b1718f815ab">m_mapParties</a>)
<a name="l04457"></a>04457     {
<a name="l04458"></a>04458         <span class="keyword">const</span> std::string str_party_name = it-&gt;first;
<a name="l04459"></a>04459         <a class="code" href="class_o_t_party.html">OTParty</a> * pParty = (*it).second;
<a name="l04460"></a>04460         <a class="code" href="_o_t_assert_8hpp.html#a033b133f48e61f2b227c52ad2be0c882">OT_ASSERT_MSG</a>(NULL != pParty, <span class="stringliteral">&quot;OTSmartContract::HarvestClosingNumbers: Unexpected NULL pointer in party map.&quot;</span>);
<a name="l04461"></a>04461         <span class="comment">// --------------------------------------------</span>
<a name="l04462"></a>04462         <span class="comment">// If certain parties failed verification, then OTSmartContract::VerifySmartContract() is smart enough</span>
<a name="l04463"></a>04463         <span class="comment">// not to bother verifying the accounts of those parties. Thus, the closing numbers for those accounts</span>
<a name="l04464"></a>04464         <span class="comment">// could NOT have been marked as &quot;used&quot; (since they were skipped). So we passed that same set of failed</span>
<a name="l04465"></a>04465         <span class="comment">// parties into this function here, so that we can skip them here as well, when harvesting the closing</span>
<a name="l04466"></a>04466         <span class="comment">// numbers back again.</span>
<a name="l04467"></a>04467         <span class="comment">//</span>
<a name="l04468"></a>04468         <span class="keywordflow">if</span> (NULL != pFailedParties) <span class="comment">// There are failed parties.</span>
<a name="l04469"></a>04469         {
<a name="l04470"></a>04470             <span class="comment">// --------------------------------------------</span>
<a name="l04471"></a>04471             <span class="comment">// Skip failed parties...</span>
<a name="l04472"></a>04472             <span class="comment">//</span>
<a name="l04473"></a>04473             std::set&lt;OTParty *&gt;::iterator it_failed = pFailedParties-&gt;find(pParty);
<a name="l04474"></a>04474 
<a name="l04475"></a>04475             <span class="keywordflow">if</span> (pFailedParties-&gt;end() != it_failed) <span class="comment">// this means pParty was found on the FAILED list. (So we can skip it here.)</span>
<a name="l04476"></a>04476             {
<a name="l04477"></a>04477                 <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(0, <span class="stringliteral">&quot;%s: FYI, at least one party (%s) has failed verification, so right now I&#39;m skipping harvesting of his &quot;</span>
<a name="l04478"></a>04478                                <span class="stringliteral">&quot;closing transaction numbers. (Since he failed, we never verified his accounts, so we never grabbed those closing &quot;</span>
<a name="l04479"></a>04479                                <span class="stringliteral">&quot;numbers in the first place, so there&#39;s no need to grab them back now.)\n&quot;</span>, __FUNCTION__, str_party_name.c_str());
<a name="l04480"></a>04480                 <span class="keywordflow">continue</span>;
<a name="l04481"></a>04481             }
<a name="l04482"></a>04482         }
<a name="l04483"></a>04483         <span class="comment">// -----------------</span>
<a name="l04484"></a>04484         <span class="comment">// For all non-failed parties, now we harvest the closing transaction numbers:</span>
<a name="l04485"></a>04485         <span class="comment">//</span>
<a name="l04486"></a>04486         pParty-&gt;<a class="code" href="class_o_t_party.html#a35c3abd49e3b7b59606b6a8ac52dcb0b">HarvestClosingNumbers</a>(strServerID,  <span class="comment">// &lt;==============  (THE HARVEST.)</span>
<a name="l04487"></a>04487                                       <span class="keyword">true</span>,         <span class="comment">// bSave=true</span>
<a name="l04488"></a>04488                                       pSignerNym);
<a name="l04489"></a>04489     } <span class="comment">// FOR_EACH ---------------------------------------------</span>
<a name="l04490"></a>04490 }
<a name="l04491"></a>04491 
<a name="l04492"></a>04492 
<a name="l04493"></a>04493 <span class="comment">// Used for adding transaction numbers back to a Nym, after deciding not to use this</span>
<a name="l04494"></a>04494 <span class="comment">// smart contract, or failing in trying to use it.</span>
<a name="l04495"></a>04495 <span class="comment">// Client side.</span>
<a name="l04496"></a>04496 <span class="comment">//</span>
<a name="l04497"></a><a class="code" href="class_o_t_smart_contract.html#a40befd7381c6c5e68e7d1042c9a7f2d3">04497</a> <span class="keywordtype">void</span> <a class="code" href="class_o_t_smart_contract.html#a40befd7381c6c5e68e7d1042c9a7f2d3">OTSmartContract::HarvestClosingNumbers</a>(<a class="code" href="class_o_t_pseudonym.html">OTPseudonym</a> &amp; theNym)
<a name="l04498"></a>04498 {
<a name="l04499"></a>04499     <span class="comment">// We do NOT call the parent version.</span>
<a name="l04500"></a>04500 <span class="comment">//  OTCronItem::HarvestClosingNumbers(theNym);</span>
<a name="l04501"></a>04501 
<a name="l04502"></a>04502     <span class="comment">// For payment plan, the parent (OTCronItem) grabs the sender&#39;s #s, and then the subclass&#39;s</span>
<a name="l04503"></a>04503     <span class="comment">// override (OTAgreement::HarvestClosingNumbers) grabs the recipient&#39;s #s. But with SMART</span>
<a name="l04504"></a>04504     <span class="comment">// CONTRACTS, there are only &quot;the parties&quot; and they ALL burned an opening #, plus they can</span>
<a name="l04505"></a>04505     <span class="comment">// ALL harvest their closing #s if activation failed. In fact, done: might as well send them</span>
<a name="l04506"></a>04506     <span class="comment">// all a notification if it fails, so they can all AUTOMATICALLY remove said numbers from</span>
<a name="l04507"></a>04507     <span class="comment">// their future balance agreements.</span>
<a name="l04508"></a>04508     <span class="comment">//</span>
<a name="l04509"></a>04509     <span class="comment">// ----------------------------------</span>
<a name="l04510"></a>04510     <span class="keyword">const</span> <a class="code" href="class_o_t_string.html">OTString</a> strServerID(<a class="code" href="class_o_t_instrument.html#a878dd8998f7b131b85c082575e255375">GetServerID</a>());
<a name="l04511"></a>04511     <span class="keyword">const</span> int32_t nTransNumCount = theNym.<a class="code" href="class_o_t_pseudonym.html#adee7eef0a51e8e94522c43ac898c2308">GetTransactionNumCount</a>(<a class="code" href="class_o_t_instrument.html#a878dd8998f7b131b85c082575e255375">GetServerID</a>()); <span class="comment">// save this to see if it changed, later.</span>
<a name="l04512"></a>04512 
<a name="l04513"></a>04513     <a class="code" href="_o_t_storage_8hpp.html#aa135ed03585fa4b246d7907afbd5873d">FOR_EACH</a>(<a class="code" href="_o_t_party_8hpp.html#a029bc6921acd4516530e26201cf595f2">mapOfParties</a>, <a class="code" href="class_o_t_scriptable.html#a6a7e4ef3e0ed95f90d950b1718f815ab">m_mapParties</a>)
<a name="l04514"></a>04514     {
<a name="l04515"></a>04515         <a class="code" href="class_o_t_party.html">OTParty</a> * pParty = (*it).second;
<a name="l04516"></a>04516         <a class="code" href="_o_t_assert_8hpp.html#a033b133f48e61f2b227c52ad2be0c882">OT_ASSERT_MSG</a>(NULL != pParty, <span class="stringliteral">&quot;Unexpected NULL pointer in party map.&quot;</span>);
<a name="l04517"></a>04517         <span class="comment">// --------------------------------------------</span>
<a name="l04518"></a>04518         pParty-&gt;<a class="code" href="class_o_t_party.html#a35c3abd49e3b7b59606b6a8ac52dcb0b">HarvestClosingNumbers</a>(theNym, strServerID);
<a name="l04519"></a>04519     }
<a name="l04520"></a>04520     <span class="comment">// ------------------------</span>
<a name="l04521"></a>04521     <span class="comment">// It changed, so let&#39;s save it.</span>
<a name="l04522"></a>04522     <span class="keywordflow">if</span> (nTransNumCount != theNym.<a class="code" href="class_o_t_pseudonym.html#adee7eef0a51e8e94522c43ac898c2308">GetTransactionNumCount</a>(<a class="code" href="class_o_t_instrument.html#a878dd8998f7b131b85c082575e255375">GetServerID</a>()))
<a name="l04523"></a>04523         theNym.<a class="code" href="class_o_t_pseudonym.html#a5d08ef86097db038c2c4fd30034f5dc8">SaveSignedNymfile</a>(theNym);
<a name="l04524"></a>04524 }
<a name="l04525"></a>04525 
<a name="l04526"></a>04526 
<a name="l04527"></a>04527 <span class="comment">// You usually wouldn&#39;t want to use this, since if the transaction failed, the opening number</span>
<a name="l04528"></a>04528 <span class="comment">// is already burned and gone. But there might be cases where it&#39;s not, and you want to retrieve it.</span>
<a name="l04529"></a>04529 <span class="comment">// So I added this function for those cases. (In most cases, you will prefer HarvestClosingNumbers().)</span>
<a name="l04530"></a>04530 <span class="comment">//</span>
<a name="l04531"></a>04531 <span class="comment">// Client-side.</span>
<a name="l04532"></a>04532 <span class="comment">//</span>
<a name="l04533"></a><a class="code" href="class_o_t_smart_contract.html#a6eaf2a458eb665dae9e25f026db27f8f">04533</a> <span class="keywordtype">void</span> <a class="code" href="class_o_t_smart_contract.html#a6eaf2a458eb665dae9e25f026db27f8f">OTSmartContract::HarvestOpeningNumber</a>(<a class="code" href="class_o_t_pseudonym.html">OTPseudonym</a> &amp; theNym)
<a name="l04534"></a>04534 {
<a name="l04535"></a>04535     <span class="comment">// We do NOT call the parent version.</span>
<a name="l04536"></a>04536 <span class="comment">//  OTCronItem::HarvestOpeningNumber(theNym);</span>
<a name="l04537"></a>04537 
<a name="l04538"></a>04538     <span class="comment">// For payment plan, the parent (OTCronItem) grabs the sender&#39;s #s, and then the subclass&#39;s</span>
<a name="l04539"></a>04539     <span class="comment">// override (OTAgreement::HarvestClosingNumbers) grabs the recipient&#39;s #s. But with SMART</span>
<a name="l04540"></a>04540     <span class="comment">// CONTRACTS, there are only &quot;the parties&quot; and they ALL burned an opening #, plus they can</span>
<a name="l04541"></a>04541     <span class="comment">// ALL harvest their closing #s if activation failed. In fact, todo: might as well send them</span>
<a name="l04542"></a>04542     <span class="comment">// all a notification if it fails, so they can all AUTOMATICALLY remove said numbers from</span>
<a name="l04543"></a>04543     <span class="comment">// their future balance agreements.</span>
<a name="l04544"></a>04544     <span class="comment">//</span>
<a name="l04545"></a>04545     <span class="comment">// ----------------------------------</span>
<a name="l04546"></a>04546     <span class="keyword">const</span> <a class="code" href="class_o_t_string.html">OTString</a> strServerID(<a class="code" href="class_o_t_instrument.html#a878dd8998f7b131b85c082575e255375">GetServerID</a>());
<a name="l04547"></a>04547     <span class="keyword">const</span> int32_t nTransNumCount = theNym.<a class="code" href="class_o_t_pseudonym.html#adee7eef0a51e8e94522c43ac898c2308">GetTransactionNumCount</a>(<a class="code" href="class_o_t_instrument.html#a878dd8998f7b131b85c082575e255375">GetServerID</a>()); <span class="comment">// save this to see if it changed, later.</span>
<a name="l04548"></a>04548 
<a name="l04549"></a>04549     <a class="code" href="_o_t_storage_8hpp.html#aa135ed03585fa4b246d7907afbd5873d">FOR_EACH</a>(<a class="code" href="_o_t_party_8hpp.html#a029bc6921acd4516530e26201cf595f2">mapOfParties</a>, <a class="code" href="class_o_t_scriptable.html#a6a7e4ef3e0ed95f90d950b1718f815ab">m_mapParties</a>)
<a name="l04550"></a>04550     {
<a name="l04551"></a>04551         <a class="code" href="class_o_t_party.html">OTParty</a> * pParty = (*it).second;
<a name="l04552"></a>04552         <a class="code" href="_o_t_assert_8hpp.html#a033b133f48e61f2b227c52ad2be0c882">OT_ASSERT_MSG</a>(NULL != pParty, <span class="stringliteral">&quot;Unexpected NULL pointer in party map.&quot;</span>);
<a name="l04553"></a>04553         <span class="comment">// --------------------------------------------</span>
<a name="l04554"></a>04554         pParty-&gt;<a class="code" href="class_o_t_party.html#ab97bb5511eae5e5702694d2c3b61eeee">HarvestOpeningNumber</a>(theNym, strServerID);
<a name="l04555"></a>04555     }
<a name="l04556"></a>04556     <span class="comment">// ------------------------</span>
<a name="l04557"></a>04557     <span class="comment">// It changed, so let&#39;s save it.</span>
<a name="l04558"></a>04558     <span class="keywordflow">if</span> (nTransNumCount != theNym.<a class="code" href="class_o_t_pseudonym.html#adee7eef0a51e8e94522c43ac898c2308">GetTransactionNumCount</a>(<a class="code" href="class_o_t_instrument.html#a878dd8998f7b131b85c082575e255375">GetServerID</a>()))
<a name="l04559"></a>04559         theNym.<a class="code" href="class_o_t_pseudonym.html#a5d08ef86097db038c2c4fd30034f5dc8">SaveSignedNymfile</a>(theNym);
<a name="l04560"></a>04560 }
<a name="l04561"></a>04561 
<a name="l04562"></a>04562 
<a name="l04563"></a>04563 <span class="comment">//static</span>
<a name="l04564"></a><a class="code" href="class_o_t_smart_contract.html#a16209b074a580bc416cf848025e0647e">04564</a> <span class="keywordtype">void</span> <a class="code" href="class_o_t_smart_contract.html#a16209b074a580bc416cf848025e0647e">OTSmartContract::CleanupNyms</a>(<a class="code" href="_o_t_agent_8hpp.html#ac89892658f6bc83e354078647b704e8f">mapOfNyms</a> &amp; theMap)
<a name="l04565"></a>04565 {
<a name="l04566"></a>04566     <span class="comment">// -------------------------------------</span>
<a name="l04567"></a>04567     <span class="keywordflow">while</span> (!theMap.empty())
<a name="l04568"></a>04568     {
<a name="l04569"></a>04569         <a class="code" href="class_o_t_pseudonym.html">OTPseudonym</a> * pNym = theMap.begin()-&gt;second;
<a name="l04570"></a>04570         <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != pNym);
<a name="l04571"></a>04571 
<a name="l04572"></a>04572         <span class="keyword">delete</span> pNym; pNym = NULL;
<a name="l04573"></a>04573 
<a name="l04574"></a>04574         theMap.erase(theMap.begin());
<a name="l04575"></a>04575     }
<a name="l04576"></a>04576     <span class="comment">// -------------------------------------</span>
<a name="l04577"></a>04577 }
<a name="l04578"></a>04578 
<a name="l04579"></a>04579 
<a name="l04580"></a>04580 <span class="comment">//static</span>
<a name="l04581"></a><a class="code" href="class_o_t_smart_contract.html#a11408d45bd120d44b704637ebbc0c971">04581</a> <span class="keywordtype">void</span> <a class="code" href="class_o_t_smart_contract.html#a11408d45bd120d44b704637ebbc0c971">OTSmartContract::CleanupAccts</a>(<a class="code" href="_o_t_agent_8hpp.html#abd4942716d546c8d42670619a03ef99e">mapOfAccounts</a> &amp; theMap)
<a name="l04582"></a>04582 {
<a name="l04583"></a>04583     <span class="comment">// -------------------------------------</span>
<a name="l04584"></a>04584     <span class="keywordflow">while</span> (!theMap.empty())
<a name="l04585"></a>04585     {
<a name="l04586"></a>04586         <a class="code" href="class_o_t_account.html">OTAccount</a> * pAcct = theMap.begin()-&gt;second;
<a name="l04587"></a>04587         <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != pAcct);
<a name="l04588"></a>04588 
<a name="l04589"></a>04589         <span class="keyword">delete</span> pAcct; pAcct = NULL;
<a name="l04590"></a>04590 
<a name="l04591"></a>04591         theMap.erase(theMap.begin());
<a name="l04592"></a>04592     }
<a name="l04593"></a>04593     <span class="comment">// -------------------------------------</span>
<a name="l04594"></a>04594 }
<a name="l04595"></a>04595 
<a name="l04596"></a>04596 
<a name="l04597"></a>04597 <span class="comment">// AddParty()</span>
<a name="l04598"></a>04598 <span class="comment">// For adding a theoretical party to a smart contract, as part of the contract&#39;s design, so the</span>
<a name="l04599"></a>04599 <span class="comment">// contract can be circulated BLANK and many different instances of it might be used.</span>
<a name="l04600"></a>04600 <span class="comment">//</span>
<a name="l04601"></a>04601 <span class="comment">// (The party, at this stage, has a name, and accounts with asset types, but no actual Nym IDs</span>
<a name="l04602"></a>04602 <span class="comment">// or account IDs.)</span>
<a name="l04603"></a>04603 <span class="comment">// This way any Nym or Entity could later sign on as the &quot;trustee&quot; or as the &quot;employee&quot; etc. And</span>
<a name="l04604"></a>04604 <span class="comment">// until they do, the contract still shows the &quot;trustee&quot; or &quot;employee&quot;, allowing the reader to see</span>
<a name="l04605"></a>04605 <span class="comment">// how those entities are manipulated in the script code of the smartcontract.</span>
<a name="l04606"></a>04606 <span class="comment">//</span>
<a name="l04607"></a><a class="code" href="class_o_t_smart_contract.html#af2ebb9b6ca7fd398f4bbd7e6dc21df93">04607</a> <span class="keywordtype">bool</span> <a class="code" href="class_o_t_smart_contract.html#af2ebb9b6ca7fd398f4bbd7e6dc21df93">OTSmartContract::AddParty</a>(<a class="code" href="class_o_t_party.html">OTParty</a> &amp; theParty)
<a name="l04608"></a>04608 {
<a name="l04609"></a>04609     <span class="keywordflow">if</span> (<span class="keyword">false</span> == theParty.<a class="code" href="class_o_t_party.html#a477b8c4714d7ac086630c236e4be6f89">HasActiveAgent</a>())
<a name="l04610"></a>04610     {
<a name="l04611"></a>04611         <a class="code" href="class_o_t_log.html#a1f7549d776ee919dcb6517f611ded015">OTLog::Output</a>(0, <span class="stringliteral">&quot;OTSmartContract::AddParty: Party doesn&#39;t have an active agent -- who will sign for this smart contract?\n&quot;</span>);
<a name="l04612"></a>04612         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l04613"></a>04613     }
<a name="l04614"></a>04614 
<a name="l04615"></a>04615     <span class="comment">// MIGHT move this below (1).. OR this might turn out to be important going first...</span>
<a name="l04616"></a>04616     <span class="comment">//</span>
<a name="l04617"></a>04617     <span class="keywordflow">if</span> (<span class="keyword">false</span> == <a class="code" href="class_o_t_scriptable.html#accfde75655f5c49c041ef3a5fbff54e6">OTScriptable::AddParty</a>(theParty))
<a name="l04618"></a>04618     {
<a name="l04619"></a>04619         <a class="code" href="class_o_t_log.html#a1f7549d776ee919dcb6517f611ded015">OTLog::Output</a>(0, <span class="stringliteral">&quot;OTSmartContract::AddParty: Failed adding party.\n&quot;</span>);
<a name="l04620"></a>04620         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l04621"></a>04621     }
<a name="l04622"></a>04622 
<a name="l04623"></a>04623     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l04624"></a>04624 }
<a name="l04625"></a>04625 
<a name="l04626"></a>04626 
<a name="l04627"></a>04627 <span class="comment">// Done:</span>
<a name="l04628"></a>04628 <span class="comment">// Similar to AddParty(). Used afterwards.</span>
<a name="l04629"></a>04629 <span class="comment">// ConfirmParty() looks up an existing party on the smart contract, then makes sure that it matches</span>
<a name="l04630"></a>04630 <span class="comment">// the one passed in, and then REPLACES the existing one with the new one that was passed in. Unlike</span>
<a name="l04631"></a>04631 <span class="comment">// AddParty (above) this version DOES expect account IDs, NymIDs, and transaction numbers, and it DOES</span>
<a name="l04632"></a>04632 <span class="comment">// save a signed copy internally as the ultimate confirmation. This version also needs to validate</span>
<a name="l04633"></a>04633 <span class="comment">// the signatures that are already there.</span>
<a name="l04634"></a>04634 <span class="comment">// Client-side.</span>
<a name="l04635"></a>04635 <span class="comment">//</span>
<a name="l04636"></a>04636 <span class="comment">//</span>
<a name="l04637"></a>04637 <span class="comment">// Note: AFTER A SUCCESSFUL CALL, the transaction numbers HAVE been set aside, and must be retrieved</span>
<a name="l04638"></a>04638 <span class="comment">// in the event of any failure.</span>
<a name="l04639"></a>04639 <span class="comment">//</span>
<a name="l04640"></a><a class="code" href="class_o_t_smart_contract.html#a361ba96466948934e82da4b8be6bdc8a">04640</a> <span class="keywordtype">bool</span> <a class="code" href="class_o_t_smart_contract.html#a361ba96466948934e82da4b8be6bdc8a">OTSmartContract::ConfirmParty</a>(<a class="code" href="class_o_t_party.html">OTParty</a> &amp; theParty)
<a name="l04641"></a>04641 {
<a name="l04642"></a>04642     <span class="keywordflow">if</span> (<span class="keyword">false</span> == theParty.<a class="code" href="class_o_t_party.html#a477b8c4714d7ac086630c236e4be6f89">HasActiveAgent</a>())
<a name="l04643"></a>04643     {
<a name="l04644"></a>04644         <a class="code" href="class_o_t_log.html#a1f7549d776ee919dcb6517f611ded015">OTLog::Output</a>(0, <span class="stringliteral">&quot;OTSmartContract::ConfirmParty: Party doesn&#39;t have an active agent -- who will sign for this smart contract?\n&quot;</span>);
<a name="l04645"></a>04645         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l04646"></a>04646     }
<a name="l04647"></a>04647     <span class="comment">// ----------------------------------------------------------------------------</span>
<a name="l04648"></a>04648     <span class="comment">// Let&#39;s RESERVE however many transaction numbers we need to confirm this smartcontract...</span>
<a name="l04649"></a>04649     <span class="comment">//</span>
<a name="l04650"></a>04650     <span class="keyword">const</span> <a class="code" href="class_o_t_string.html">OTString</a> strServerID (<a class="code" href="class_o_t_instrument.html#a878dd8998f7b131b85c082575e255375">GetServerID</a>());
<a name="l04651"></a>04651 
<a name="l04652"></a>04652     <span class="comment">// ReserveTransNumsForConfirm() sets aside the Opening # for the party,</span>
<a name="l04653"></a>04653     <span class="comment">// as well as the Closing #s for all the asset accounts for that party.</span>
<a name="l04654"></a>04654     <span class="comment">//</span>
<a name="l04655"></a>04655     <span class="comment">// This MUST be done before calling OTScriptable::ConfirmParty, because</span>
<a name="l04656"></a>04656     <span class="comment">// *this will get SIGNED in there, and so must have its final data in</span>
<a name="l04657"></a>04657     <span class="comment">// place already. If the confirmation fails, we will harvest the numbers</span>
<a name="l04658"></a>04658     <span class="comment">// back again.</span>
<a name="l04659"></a>04659     <span class="comment">//</span>
<a name="l04660"></a>04660     <span class="keywordflow">if</span> (<span class="keyword">false</span> == theParty.<a class="code" href="class_o_t_party.html#acdd3320424cd48622f552653d79b9dc3">ReserveTransNumsForConfirm</a>(strServerID))
<a name="l04661"></a>04661     {
<a name="l04662"></a>04662         <a class="code" href="class_o_t_log.html#a1f7549d776ee919dcb6517f611ded015">OTLog::Output</a>(0, <span class="stringliteral">&quot;OTSmartContract::ConfirmParty: Failure trying to reserve transaction numbers for &quot;</span>
<a name="l04663"></a>04663                       <span class="stringliteral">&quot;the smart contract. (Nym needs more numbers than he has.)\n&quot;</span>);
<a name="l04664"></a>04664         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l04665"></a>04665     }
<a name="l04666"></a>04666     <span class="comment">// Note: BELOW THIS POINT, the transaction numbers have been set aside, and must be retrieved,</span>
<a name="l04667"></a>04667     <span class="comment">// below this point, in the event of any failure, using this call:</span>
<a name="l04668"></a>04668     <span class="comment">// theParty.HarvestAllTransactionNumbers(strServerID);</span>
<a name="l04669"></a>04669     <span class="comment">// ----------------------------------</span>
<a name="l04670"></a>04670     <span class="comment">// Since EVERY party keeps his own signed copy, then we reset the creation date</span>
<a name="l04671"></a>04671     <span class="comment">// before EACH signature. That way, we have the date of signing for EVERY signer.</span>
<a name="l04672"></a>04672     <span class="comment">// (The final date will be set upon activation.)</span>
<a name="l04673"></a>04673     <span class="comment">//</span>
<a name="l04674"></a>04674     <span class="keyword">const</span> <a class="code" href="_o_t_common_8hpp.html#ad28ff0a3eda18840f6bda5872819167f">time64_t</a> CURRENT_TIME = <a class="code" href="_o_t_common_8hpp.html#a1163606b2546b160d50c5f0a5afe479a">OTTimeGetCurrentTime</a>(),
<a name="l04675"></a>04675                  OLD_TIME     = <a class="code" href="class_o_t_cron_item.html#aec36ac68b9f13f874ce6c56940bcec24">GetCreationDate</a>();
<a name="l04676"></a>04676 
<a name="l04677"></a>04677     <span class="comment">// Set the Creation Date.</span>
<a name="l04678"></a>04678     <a class="code" href="class_o_t_cron_item.html#a7668dc44368861c09a47de0f420cf2fa">SetCreationDate</a>(CURRENT_TIME);
<a name="l04679"></a>04679 
<a name="l04680"></a>04680     <span class="comment">// *********************************************************</span>
<a name="l04681"></a>04681     <span class="comment">//</span>
<a name="l04682"></a>04682     <span class="comment">// THIS IS where the SIGNED COPY is SAVED, so all final changes must occur ABOVE this point.</span>
<a name="l04683"></a>04683     <span class="comment">//</span>
<a name="l04684"></a>04684     <span class="keywordflow">if</span> (<span class="keyword">false</span> == <a class="code" href="class_o_t_scriptable.html#a197539281206ac2e950ff0fc4842886b">OTScriptable::ConfirmParty</a>(theParty))
<a name="l04685"></a>04685     {
<a name="l04686"></a>04686         <a class="code" href="class_o_t_log.html#a1f7549d776ee919dcb6517f611ded015">OTLog::Output</a>(0, <span class="stringliteral">&quot;OTSmartContract::ConfirmParty: Failed confirming party.\n&quot;</span>);
<a name="l04687"></a>04687         <a class="code" href="class_o_t_cron_item.html#a7668dc44368861c09a47de0f420cf2fa">SetCreationDate</a>(OLD_TIME); <span class="comment">// Might as well set this back.</span>
<a name="l04688"></a>04688         theParty.<a class="code" href="class_o_t_party.html#a27f92ee64f928849bde7f31d3c2b4d0a">HarvestAllTransactionNumbers</a>(strServerID); <span class="comment">// If it failed, grab BACK the numbers that we reserved above.</span>
<a name="l04689"></a>04689         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l04690"></a>04690     }
<a name="l04691"></a>04691     <span class="comment">// *********************************************************</span>
<a name="l04692"></a>04692 
<a name="l04693"></a>04693     <span class="comment">// SUCCESS!!</span>
<a name="l04694"></a>04694     <span class="comment">//</span>
<a name="l04695"></a>04695     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l04696"></a>04696 
<a name="l04697"></a>04697     <span class="comment">// -----------------------------------------------------------</span>
<a name="l04698"></a>04698     <span class="comment">// Are we good? The contract is compared against the other parties&#39; signed contracts; my own party and</span>
<a name="l04699"></a>04699     <span class="comment">// transaction #s are added, and a signed copy of everything is saved in my party. Then the entire contract</span>
<a name="l04700"></a>04700     <span class="comment">// is re-signed (saving its updated contents) and then sent on to the next party, who is free to release that</span>
<a name="l04701"></a>04701     <span class="comment">// signature since I already have a signed copy in my party.</span>
<a name="l04702"></a>04702     <span class="comment">//</span>
<a name="l04703"></a>04703     <span class="comment">// Assuming all parties have signed AND provided valid transaction #s, then the server is free to get started</span>
<a name="l04704"></a>04704     <span class="comment">// immediately upon activation, and furthermore to cancel whenever it wants (and probably just according to</span>
<a name="l04705"></a>04705     <span class="comment">// the terms.)  There should be a standard call for seeing if a person can cancel the agreement, and if it&#39;s</span>
<a name="l04706"></a>04706     <span class="comment">// not overridden in the contract, then it defaults to return true. (Note: that is done now.)</span>
<a name="l04707"></a>04707     <span class="comment">//</span>
<a name="l04708"></a>04708     <span class="comment">// Technically ANY party&#39;s authorizing agent could become the originator by activating the contract, but</span>
<a name="l04709"></a>04709     <span class="comment">// only if all parties have validly signed.  (Server needs to verify.)</span>
<a name="l04710"></a>04710 }
<a name="l04711"></a>04711 
<a name="l04712"></a>04712 
<a name="l04713"></a>04713 <span class="comment">// ALWAYS succeeds. (It will OT_ASSERT() otherwise.)</span>
<a name="l04714"></a>04714 <span class="comment">//</span>
<a name="l04715"></a><a class="code" href="class_o_t_smart_contract.html#af7305d13e0ac4c2bef284658bdd9ec67">04715</a> <a class="code" href="class_o_t_stash.html">OTStash</a> * <a class="code" href="class_o_t_smart_contract.html#af7305d13e0ac4c2bef284658bdd9ec67">OTSmartContract::GetStash</a>(<span class="keyword">const</span> std::string str_stash_name)
<a name="l04716"></a>04716 {
<a name="l04717"></a>04717     mapOfStashes::iterator it = m_mapStashes.find(str_stash_name);
<a name="l04718"></a>04718 
<a name="l04719"></a>04719     <span class="keywordflow">if</span> (m_mapStashes.end() == it) <span class="comment">// It&#39;s not there. Create it.</span>
<a name="l04720"></a>04720     {
<a name="l04721"></a>04721         <a class="code" href="class_o_t_stash.html">OTStash</a> * pStash = <span class="keyword">new</span> <a class="code" href="class_o_t_stash.html">OTStash</a> (str_stash_name);
<a name="l04722"></a>04722         <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != pStash);
<a name="l04723"></a>04723 
<a name="l04724"></a>04724         m_mapStashes.insert(std::pair&lt;std::string, OTStash *&gt;(str_stash_name, pStash));
<a name="l04725"></a>04725         <span class="keywordflow">return</span> pStash;
<a name="l04726"></a>04726     }
<a name="l04727"></a>04727 
<a name="l04728"></a>04728     <a class="code" href="class_o_t_stash.html">OTStash</a> * pStash = (*it).second;
<a name="l04729"></a>04729     <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != pStash);
<a name="l04730"></a>04730 
<a name="l04731"></a>04731     <span class="keywordflow">return</span> pStash;
<a name="l04732"></a>04732 }
<a name="l04733"></a>04733 
<a name="l04734"></a>04734 
<a name="l04735"></a><a class="code" href="class_o_t_smart_contract.html#a9f4865bea6e0a31bfa51b1627611aeb0">04735</a> <a class="code" href="class_o_t_smart_contract.html#a9f4865bea6e0a31bfa51b1627611aeb0">OTSmartContract::OTSmartContract</a>() : <a class="code" href="class_o_t_trackable.html">ot_super</a>(), m_StashAccts(<a class="code" href="class_o_t_account.html">OTAccount</a>::stash), m_tNextProcessDate(<a class="code" href="_o_t_common_8hpp.html#af4ca9fa2c7c290d647dd18de0a9ac25f">OT_TIME_ZERO</a>)
<a name="l04736"></a>04736 {
<a name="l04737"></a>04737     <a class="code" href="class_o_t_smart_contract.html#a6ce8a031a27a75a43275dde21919d0cd">InitSmartContract</a>();
<a name="l04738"></a>04738 }
<a name="l04739"></a>04739 
<a name="l04740"></a>04740 
<a name="l04741"></a><a class="code" href="class_o_t_smart_contract.html#ad5db7263909fc4c300a612b4dc546dcf">04741</a> <a class="code" href="class_o_t_smart_contract.html#a9f4865bea6e0a31bfa51b1627611aeb0">OTSmartContract::OTSmartContract</a>(<span class="keyword">const</span> <a class="code" href="class_o_t_identifier.html">OTIdentifier</a> &amp; SERVER_ID) :
<a name="l04742"></a>04742 <a class="code" href="class_o_t_trackable.html">ot_super</a>(), m_StashAccts(<a class="code" href="class_o_t_account.html">OTAccount</a>::stash), m_tNextProcessDate(<a class="code" href="_o_t_common_8hpp.html#af4ca9fa2c7c290d647dd18de0a9ac25f">OT_TIME_ZERO</a>)
<a name="l04743"></a>04743 {
<a name="l04744"></a>04744     <a class="code" href="class_o_t_instrument.html#a80fc5560fdedf911ec0c184ab9fbb5b7">OTInstrument::SetServerID</a>(SERVER_ID);
<a name="l04745"></a>04745     <a class="code" href="class_o_t_smart_contract.html#a6ce8a031a27a75a43275dde21919d0cd">InitSmartContract</a>();
<a name="l04746"></a>04746 }
<a name="l04747"></a>04747 
<a name="l04748"></a>04748 
<a name="l04749"></a><a class="code" href="class_o_t_smart_contract.html#a0bb1574c8f345abac7b417981b8c7daa">04749</a> <a class="code" href="class_o_t_smart_contract.html#a9f4865bea6e0a31bfa51b1627611aeb0">OTSmartContract::OTSmartContract</a>(<span class="keyword">const</span> <a class="code" href="class_o_t_identifier.html">OTIdentifier</a> &amp; SERVER_ID,            <span class="keyword">const</span> <a class="code" href="class_o_t_identifier.html">OTIdentifier</a> &amp; ASSET_ID,
<a name="l04750"></a>04750                                  <span class="keyword">const</span> <a class="code" href="class_o_t_identifier.html">OTIdentifier</a> &amp; SENDER_ACCT_ID,       <span class="keyword">const</span> <a class="code" href="class_o_t_identifier.html">OTIdentifier</a> &amp; SENDER_USER_ID,
<a name="l04751"></a>04751                                  <span class="keyword">const</span> <a class="code" href="class_o_t_identifier.html">OTIdentifier</a> &amp; RECIPIENT_ACCT_ID,    <span class="keyword">const</span> <a class="code" href="class_o_t_identifier.html">OTIdentifier</a> &amp; RECIPIENT_USER_ID) :
<a name="l04752"></a>04752 <a class="code" href="class_o_t_trackable.html">ot_super</a>(SERVER_ID, ASSET_ID, SENDER_ACCT_ID, SENDER_USER_ID),
<a name="l04753"></a>04753 m_StashAccts(<a class="code" href="class_o_t_account.html">OTAccount</a>::stash), m_tNextProcessDate(<a class="code" href="_o_t_common_8hpp.html#af4ca9fa2c7c290d647dd18de0a9ac25f">OT_TIME_ZERO</a>)
<a name="l04754"></a>04754 {
<a name="l04755"></a>04755     <a class="code" href="class_o_t_smart_contract.html#a6ce8a031a27a75a43275dde21919d0cd">InitSmartContract</a>();
<a name="l04756"></a>04756 
<a name="l04757"></a>04757     <span class="comment">// More can go here.</span>
<a name="l04758"></a>04758 
<a name="l04759"></a>04759 }
<a name="l04760"></a>04760 
<a name="l04761"></a>04761 
<a name="l04762"></a><a class="code" href="class_o_t_smart_contract.html#aeed0c58a21faf119778953a041f1821b">04762</a> <a class="code" href="class_o_t_smart_contract.html#aeed0c58a21faf119778953a041f1821b">OTSmartContract::~OTSmartContract</a>()
<a name="l04763"></a>04763 {
<a name="l04764"></a>04764     <a class="code" href="class_o_t_smart_contract.html#a5673ded692d238c80fa6b854feaa68f4">Release_SmartContract</a>();
<a name="l04765"></a>04765 }
<a name="l04766"></a>04766 
<a name="l04767"></a>04767 
<a name="l04768"></a><a class="code" href="class_o_t_smart_contract.html#a6ce8a031a27a75a43275dde21919d0cd">04768</a> <span class="keywordtype">void</span> <a class="code" href="class_o_t_smart_contract.html#a6ce8a031a27a75a43275dde21919d0cd">OTSmartContract::InitSmartContract</a>()
<a name="l04769"></a>04769 {
<a name="l04770"></a>04770     <a class="code" href="class_o_t_contract.html#ac523dac7d72b72e54b1ebb5b3a3b21cc">m_strContractType</a> = <span class="stringliteral">&quot;SMARTCONTRACT&quot;</span>;
<a name="l04771"></a>04771 
<a name="l04772"></a>04772     <a class="code" href="class_o_t_cron_item.html#a7d801b85690f539433e0ccf187f57d99">SetProcessInterval</a>(<a class="code" href="_o_t_smart_contract_8cpp.html#a07c91258ac71240a2059fd34c9cf5d89">SMART_CONTRACT_PROCESS_INTERVAL</a>); <span class="comment">// Smart contracts current default is 30 seconds. Actual default will probably be configurable in config file, and most contracts will also probably override this.</span>
<a name="l04773"></a>04773 }
<a name="l04774"></a>04774 
<a name="l04775"></a>04775 
<a name="l04776"></a><a class="code" href="class_o_t_smart_contract.html#a5e2972487aa71cb86d51393ed749f341">04776</a> <span class="keywordtype">void</span> <a class="code" href="class_o_t_smart_contract.html#a5e2972487aa71cb86d51393ed749f341">OTSmartContract::ReleaseStashes</a>()
<a name="l04777"></a>04777 {
<a name="l04778"></a>04778     <span class="comment">// -------------------------------------</span>
<a name="l04779"></a>04779     <span class="keywordflow">while</span> (!m_mapStashes.empty())
<a name="l04780"></a>04780     {
<a name="l04781"></a>04781         <a class="code" href="class_o_t_stash.html">OTStash</a> * pStash = m_mapStashes.begin()-&gt;second;
<a name="l04782"></a>04782         <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != pStash);
<a name="l04783"></a>04783 
<a name="l04784"></a>04784         <span class="keyword">delete</span> pStash;
<a name="l04785"></a>04785         pStash = NULL;
<a name="l04786"></a>04786 
<a name="l04787"></a>04787         m_mapStashes.erase(m_mapStashes.begin());
<a name="l04788"></a>04788     }
<a name="l04789"></a>04789     <span class="comment">// -------------------------------------</span>
<a name="l04790"></a>04790     m_StashAccts.<a class="code" href="class_o_t_acct_list.html#ac4946577265a5a735c27814be3fdfe30">Release</a>();
<a name="l04791"></a>04791     <span class="comment">// -------------------------------------</span>
<a name="l04792"></a>04792 }
<a name="l04793"></a>04793 
<a name="l04794"></a>04794 
<a name="l04795"></a><a class="code" href="class_o_t_smart_contract.html#a5673ded692d238c80fa6b854feaa68f4">04795</a> <span class="keywordtype">void</span> <a class="code" href="class_o_t_smart_contract.html#a5673ded692d238c80fa6b854feaa68f4">OTSmartContract::Release_SmartContract</a>()
<a name="l04796"></a>04796 {
<a name="l04797"></a>04797     <span class="comment">// -------------------------------------</span>
<a name="l04798"></a>04798 
<a name="l04799"></a>04799     <a class="code" href="class_o_t_smart_contract.html#a5e2972487aa71cb86d51393ed749f341">ReleaseStashes</a>();
<a name="l04800"></a>04800 
<a name="l04801"></a>04801     <span class="comment">// -------------------------------------</span>
<a name="l04802"></a>04802 }
<a name="l04803"></a>04803 
<a name="l04804"></a>04804 
<a name="l04805"></a><a class="code" href="class_o_t_smart_contract.html#a335f903820d3128716c7f7b93200b5ac">04805</a> <span class="keywordtype">void</span> <a class="code" href="class_o_t_smart_contract.html#a335f903820d3128716c7f7b93200b5ac">OTSmartContract::Release</a>()
<a name="l04806"></a>04806 {
<a name="l04807"></a>04807     <a class="code" href="class_o_t_smart_contract.html#a5673ded692d238c80fa6b854feaa68f4">Release_SmartContract</a>();
<a name="l04808"></a>04808     <span class="comment">// -------------------------------------</span>
<a name="l04809"></a>04809     <a class="code" href="class_o_t_cron_item.html#a11e9851acefc9162bb5f107a1952ffb7">ot_super::Release</a>(); <span class="comment">// since I&#39;ve overridden the base class, I call it now...</span>
<a name="l04810"></a>04810     <span class="comment">// -------------------------------------</span>
<a name="l04811"></a>04811     <span class="comment">// Then I call this to re-initialize everything</span>
<a name="l04812"></a>04812     <a class="code" href="class_o_t_smart_contract.html#a6ce8a031a27a75a43275dde21919d0cd">InitSmartContract</a>();
<a name="l04813"></a>04813 }
<a name="l04814"></a>04814 
<a name="l04815"></a>04815 
<a name="l04816"></a><a class="code" href="class_o_t_smart_contract.html#a24f1bc0f448832aaee8f9b665f2eec1e">04816</a> int32_t <a class="code" href="class_o_t_smart_contract.html#a24f1bc0f448832aaee8f9b665f2eec1e">OTSmartContract::GetCountStashes</a>()<span class="keyword"> const</span>
<a name="l04817"></a>04817 <span class="keyword"></span>{
<a name="l04818"></a>04818     <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span>int32_t<span class="keyword">&gt;</span> (m_mapStashes.size());
<a name="l04819"></a>04819 }
<a name="l04820"></a>04820 
<a name="l04821"></a>04821 
<a name="l04822"></a><a class="code" href="class_o_t_smart_contract.html#a400c4164f6dbced28ae4155864dcf496">04822</a> int32_t <a class="code" href="class_o_t_smart_contract.html#a400c4164f6dbced28ae4155864dcf496">OTSmartContract::GetCountStashAccts</a>()<span class="keyword"> const</span>
<a name="l04823"></a>04823 <span class="keyword"></span>{
<a name="l04824"></a>04824     <span class="keywordflow">return</span> m_StashAccts.<a class="code" href="class_o_t_acct_list.html#af511014ed6540bbf9b04728d3dea211c">GetCountAccountIDs</a>();
<a name="l04825"></a>04825 }
<a name="l04826"></a>04826 
<a name="l04827"></a>04827 
<a name="l04828"></a>04828 <span class="comment">// Done.</span>
<a name="l04829"></a>04829 <span class="comment">//</span>
<a name="l04830"></a>04830 <span class="comment">// Before we can make sure that ALL parties have signed equivalent versions,</span>
<a name="l04831"></a>04831 <span class="comment">// we must be able to compare TWO versions.  The below function does that.</span>
<a name="l04832"></a>04832 <span class="comment">//</span>
<a name="l04833"></a><a class="code" href="class_o_t_smart_contract.html#a5b4a2b0e39d8aa534de380d92778bf0d">04833</a> <span class="keywordtype">bool</span> <a class="code" href="class_o_t_smart_contract.html#a5b4a2b0e39d8aa534de380d92778bf0d">OTSmartContract::Compare</a>(<a class="code" href="class_o_t_scriptable.html">OTScriptable</a> &amp; rhs)
<a name="l04834"></a>04834 {
<a name="l04835"></a>04835     <span class="keywordflow">if</span> (<span class="keyword">false</span> == <a class="code" href="class_o_t_scriptable.html#aa4735bf6c25261ea1a021fd8afb57916">OTScriptable::Compare</a>(rhs))
<a name="l04836"></a>04836         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l04837"></a>04837 
<a name="l04838"></a>04838     <span class="comment">// -------------------------------------------------</span>
<a name="l04839"></a>04839     <span class="keywordflow">if</span> (<a class="code" href="class_o_t_smart_contract.html#a24f1bc0f448832aaee8f9b665f2eec1e">GetCountStashes</a>() &gt; 0)
<a name="l04840"></a>04840     {
<a name="l04841"></a>04841         <a class="code" href="class_o_t_log.html#a5acd90ac91c2618f395b0ff37ad4f8ee">OTLog::Error</a>(<span class="stringliteral">&quot;OTSmartContract::Compare: Error: How is this function EVER being called when there are stashes present? Only the server can create stashes.\n&quot;</span>);
<a name="l04842"></a>04842         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l04843"></a>04843     }
<a name="l04844"></a>04844 
<a name="l04845"></a>04845     <span class="keywordflow">if</span> (<a class="code" href="class_o_t_smart_contract.html#a400c4164f6dbced28ae4155864dcf496">GetCountStashAccts</a>() &gt; 0)
<a name="l04846"></a>04846     {
<a name="l04847"></a>04847         <a class="code" href="class_o_t_log.html#a5acd90ac91c2618f395b0ff37ad4f8ee">OTLog::Error</a>(<span class="stringliteral">&quot;OTSmartContract::Compare: Error: How is this function EVER being called when there are &quot;</span>
<a name="l04848"></a>04848                      <span class="stringliteral">&quot;stash accounts present? Only the server can create stash accounts.\n&quot;</span>);
<a name="l04849"></a>04849         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l04850"></a>04850     }
<a name="l04851"></a>04851     <span class="comment">// -------------------------------------------------</span>
<a name="l04852"></a>04852 
<a name="l04853"></a>04853     <span class="comment">// Compare OTSmartContract specific info here.</span>
<a name="l04854"></a>04854     <span class="keyword">const</span> <a class="code" href="class_o_t_smart_contract.html">OTSmartContract</a> * pSmartContract = <span class="keyword">dynamic_cast&lt;</span><span class="keyword">const </span><a class="code" href="class_o_t_smart_contract.html">OTSmartContract</a> *<span class="keyword">&gt;</span>(&amp;rhs);
<a name="l04855"></a>04855 
<a name="l04856"></a>04856     <span class="keywordflow">if</span> (NULL != pSmartContract)
<a name="l04857"></a>04857     {
<a name="l04858"></a>04858         <span class="keywordflow">if</span> (pSmartContract-&gt;<a class="code" href="class_o_t_smart_contract.html#a24f1bc0f448832aaee8f9b665f2eec1e">GetCountStashes</a>() &gt; 0)
<a name="l04859"></a>04859         {
<a name="l04860"></a>04860             <a class="code" href="class_o_t_log.html#a5acd90ac91c2618f395b0ff37ad4f8ee">OTLog::Error</a>(<span class="stringliteral">&quot;OTSmartContract::Compare: Error: How is this function EVER being called when there are stashes present on rhs? Only the server can create stashes.\n&quot;</span>);
<a name="l04861"></a>04861             <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l04862"></a>04862         }
<a name="l04863"></a>04863 
<a name="l04864"></a>04864         <span class="keywordflow">if</span> (pSmartContract-&gt;<a class="code" href="class_o_t_smart_contract.html#a400c4164f6dbced28ae4155864dcf496">GetCountStashAccts</a>() &gt; 0)
<a name="l04865"></a>04865         {
<a name="l04866"></a>04866             <a class="code" href="class_o_t_log.html#a5acd90ac91c2618f395b0ff37ad4f8ee">OTLog::Error</a>(<span class="stringliteral">&quot;OTSmartContract::Compare: Error: How is this function EVER being called when there are stash accounts present on rhs? Only the server can create stash accounts.\n&quot;</span>);
<a name="l04867"></a>04867             <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l04868"></a>04868         }
<a name="l04869"></a>04869         <span class="comment">// ------------------------------------</span>
<a name="l04870"></a>04870         <span class="keywordflow">if</span> (
<a name="l04871"></a>04871 <span class="comment">//          (   GetTransactionNum()  == pSmartContract-&gt;GetTransactionNum()   ) &amp;&amp; // Parties wouldn&#39;t/shouldn&#39;t have to predict the transaction # used by other parties.</span>
<a name="l04872"></a>04872 <span class="comment">//          (   GetSenderUserID()    == pSmartContract-&gt;GetSenderUserID()     ) &amp;&amp; // Same here -- we should allow parties to leave these blank. (THIS IS ACTIVATOR USER ID.)</span>
<a name="l04873"></a>04873 
<a name="l04874"></a>04874             (   <a class="code" href="class_o_t_instrument.html#a878dd8998f7b131b85c082575e255375">GetServerID</a>()        == pSmartContract-&gt;<a class="code" href="class_o_t_instrument.html#a878dd8998f7b131b85c082575e255375">GetServerID</a>()         ) &amp;&amp;
<a name="l04875"></a>04875 <span class="comment">//          (   GetCreationDate()    == pSmartContract-&gt;GetCreationDate()     ) &amp;&amp; // This gets reset each time a party confirms it. Thus, none of them will match.</span>
<a name="l04876"></a>04876             (   <a class="code" href="class_o_t_instrument.html#a08eb5f25566832e1a67b3e33c0dcc13f">GetValidFrom</a>()       == pSmartContract-&gt;<a class="code" href="class_o_t_instrument.html#a08eb5f25566832e1a67b3e33c0dcc13f">GetValidFrom</a>()        ) &amp;&amp;
<a name="l04877"></a>04877             (   <a class="code" href="class_o_t_instrument.html#ab83a62f51692c946ff394408026b0c18">GetValidTo</a>()         == pSmartContract-&gt;<a class="code" href="class_o_t_instrument.html#ab83a62f51692c946ff394408026b0c18">GetValidTo</a>()          )     <span class="comment">// These definitely need to match.</span>
<a name="l04878"></a>04878            )
<a name="l04879"></a>04879             <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l04880"></a>04880     }
<a name="l04881"></a>04881 
<a name="l04882"></a>04882     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l04883"></a>04883 }
<a name="l04884"></a>04884 
<a name="l04885"></a>04885 
<a name="l04886"></a>04886 <span class="comment">// from OTScriptable:</span>
<a name="l04887"></a>04887 <span class="comment">//</span>
<a name="l04888"></a>04888 <span class="comment">//bool  m_bCalculatingID; // NOT serialized. Used during ID calculation.</span>
<a name="l04889"></a>04889 <span class="comment">//</span>
<a name="l04890"></a>04890 <span class="comment">//bool  m_bSpecifyAssetID;  // Serialized.</span>
<a name="l04891"></a>04891 <span class="comment">//bool  m_bSpecifyParties;  // Serialized.</span>
<a name="l04892"></a>04892 
<a name="l04893"></a><a class="code" href="class_o_t_smart_contract.html#a4804dc10ab81b2bde13fce0a3afb0765">04893</a> <span class="keywordtype">void</span> <a class="code" href="class_o_t_smart_contract.html#a4804dc10ab81b2bde13fce0a3afb0765">OTSmartContract::UpdateContents</a>()
<a name="l04894"></a>04894 {
<a name="l04895"></a>04895     <span class="comment">// I release this because I&#39;m about to repopulate it.</span>
<a name="l04896"></a>04896     <a class="code" href="class_o_t_contract.html#a087fc09cfa4b2fd9076088360a5e5039">m_xmlUnsigned</a>.<a class="code" href="class_o_t_string.html#abef4b21b2170468705c58d64212d7257">Release</a>();
<a name="l04897"></a>04897     <span class="comment">// -------------------------------------------------------------</span>
<a name="l04898"></a>04898     <span class="keyword">const</span> <a class="code" href="class_o_t_string.html">OTString</a>  SERVER_ID           (<a class="code" href="class_o_t_instrument.html#a878dd8998f7b131b85c082575e255375">GetServerID</a>()),
<a name="l04899"></a>04899                     ACTIVATOR_USER_ID   (<a class="code" href="class_o_t_trackable.html#aaf5d36407abeeb35eea54f7acb0c3148">GetSenderUserID</a>()),
<a name="l04900"></a>04900                     ACTIVATOR_ACCT_ID   (<a class="code" href="class_o_t_trackable.html#a3149b0da54958e8da4cf15d26f47711f">GetSenderAcctID</a>());
<a name="l04901"></a>04901 
<a name="l04902"></a>04902     <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != <a class="code" href="class_o_t_cron_item.html#af7bb48c16e16f664b938a7f235d2872d">m_pCancelerNymID</a>);
<a name="l04903"></a>04903     <span class="comment">// -------------------------------------------------------------</span>
<a name="l04904"></a>04904     <a class="code" href="class_o_t_string.html">OTString</a> strCanceler;
<a name="l04905"></a>04905 
<a name="l04906"></a>04906     <span class="keywordflow">if</span> (<a class="code" href="class_o_t_cron_item.html#abe9ce5c7b4d2fe652908e1f81f2f3b67">m_bCanceled</a>)
<a name="l04907"></a>04907         <a class="code" href="class_o_t_cron_item.html#af7bb48c16e16f664b938a7f235d2872d">m_pCancelerNymID</a>-&gt;<a class="code" href="class_o_t_identifier.html#a4bccb30446b4b515d9d6016b86b260bb">GetString</a>(strCanceler);
<a name="l04908"></a>04908 
<a name="l04909"></a>04909     int64_t tCreation = <a class="code" href="_o_t_common_8hpp.html#a4c31551b478d298d694f7df4915b4302">OTTimeGetSecondsFromTime</a>(<a class="code" href="class_o_t_scriptable.html#a217fc906e2d6475e22913bd8653ffaa2">m_bCalculatingID</a> ? <a class="code" href="_o_t_common_8hpp.html#af4ca9fa2c7c290d647dd18de0a9ac25f">OT_TIME_ZERO</a> : <a class="code" href="class_o_t_cron_item.html#aec36ac68b9f13f874ce6c56940bcec24">GetCreationDate</a>());
<a name="l04910"></a>04910     int64_t tValidFrom = <a class="code" href="_o_t_common_8hpp.html#a4c31551b478d298d694f7df4915b4302">OTTimeGetSecondsFromTime</a>(<a class="code" href="class_o_t_scriptable.html#a217fc906e2d6475e22913bd8653ffaa2">m_bCalculatingID</a> ? <a class="code" href="_o_t_common_8hpp.html#af4ca9fa2c7c290d647dd18de0a9ac25f">OT_TIME_ZERO</a> : <a class="code" href="class_o_t_instrument.html#a08eb5f25566832e1a67b3e33c0dcc13f">GetValidFrom</a>());
<a name="l04911"></a>04911     int64_t tValidTo = <a class="code" href="_o_t_common_8hpp.html#a4c31551b478d298d694f7df4915b4302">OTTimeGetSecondsFromTime</a>(<a class="code" href="class_o_t_scriptable.html#a217fc906e2d6475e22913bd8653ffaa2">m_bCalculatingID</a> ? <a class="code" href="_o_t_common_8hpp.html#af4ca9fa2c7c290d647dd18de0a9ac25f">OT_TIME_ZERO</a> : <a class="code" href="class_o_t_instrument.html#ab83a62f51692c946ff394408026b0c18">GetValidTo</a>());
<a name="l04912"></a>04912     int64_t tNextProcess = <a class="code" href="_o_t_common_8hpp.html#a4c31551b478d298d694f7df4915b4302">OTTimeGetSecondsFromTime</a>(<a class="code" href="class_o_t_scriptable.html#a217fc906e2d6475e22913bd8653ffaa2">m_bCalculatingID</a> ? <a class="code" href="_o_t_common_8hpp.html#af4ca9fa2c7c290d647dd18de0a9ac25f">OT_TIME_ZERO</a> : <a class="code" href="class_o_t_smart_contract.html#a16737b147030f0aaaedc53f798c35a50">GetNextProcessDate</a>());
<a name="l04913"></a>04913 
<a name="l04914"></a>04914     <span class="comment">// OTSmartContract</span>
<a name="l04915"></a>04915     <a class="code" href="class_o_t_contract.html#a087fc09cfa4b2fd9076088360a5e5039">m_xmlUnsigned</a>.<a class="code" href="class_o_t_string.html#a86e54de385040ff6769d7f2149ce176b">Concatenate</a>(<span class="stringliteral">&quot;&lt;smartContract\n version=\&quot;%s\&quot;\n&quot;</span>
<a name="l04916"></a>04916                               <span class="stringliteral">&quot; serverID=\&quot;%s\&quot;\n&quot;</span>
<a name="l04917"></a>04917                               <span class="stringliteral">&quot; activatorUserID=\&quot;%s\&quot;\n&quot;</span>
<a name="l04918"></a>04918                               <span class="stringliteral">&quot; activatorAcctID=\&quot;%s\&quot;\n&quot;</span>
<a name="l04919"></a>04919                               <span class="stringliteral">&quot; lastSenderUserID=\&quot;%s\&quot;\n&quot;</span>
<a name="l04920"></a>04920                               <span class="stringliteral">&quot; lastSenderAcctID=\&quot;%s\&quot;\n&quot;</span>
<a name="l04921"></a>04921                               <span class="stringliteral">&quot; lastRecipientUserID=\&quot;%s\&quot;\n&quot;</span>
<a name="l04922"></a>04922                               <span class="stringliteral">&quot; lastRecipientAcctID=\&quot;%s\&quot;\n&quot;</span>
<a name="l04923"></a>04923                               <span class="stringliteral">&quot; canceled=\&quot;%s\&quot;\n&quot;</span>
<a name="l04924"></a>04924                               <span class="stringliteral">&quot; cancelerUserID=\&quot;%s\&quot;\n&quot;</span>
<a name="l04925"></a>04925                               <span class="stringliteral">&quot; transactionNum=\&quot;%lld\&quot;\n&quot;</span>
<a name="l04926"></a>04926                               <span class="stringliteral">&quot; creationDate=\&quot;%&quot;</span> PRId64<span class="stringliteral">&quot;\&quot;\n&quot;</span>
<a name="l04927"></a>04927                               <span class="stringliteral">&quot; validFrom=\&quot;%&quot;</span> PRId64<span class="stringliteral">&quot;\&quot;\n&quot;</span>
<a name="l04928"></a>04928                               <span class="stringliteral">&quot; validTo=\&quot;%&quot;</span> PRId64<span class="stringliteral">&quot;\&quot;\n&quot;</span>
<a name="l04929"></a>04929                               <span class="stringliteral">&quot; nextProcessDate=\&quot;%&quot;</span> PRId64<span class="stringliteral">&quot;\&quot;&quot;</span>
<a name="l04930"></a>04930                               <span class="stringliteral">&quot; &gt;\n\n&quot;</span>,
<a name="l04931"></a>04931                               <a class="code" href="class_o_t_contract.html#aa0d889e0e1670b56fedca245041a5ed3">m_strVersion</a>.<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>(),
<a name="l04932"></a>04932                               <a class="code" href="class_o_t_scriptable.html#a217fc906e2d6475e22913bd8653ffaa2">m_bCalculatingID</a> ? <span class="stringliteral">&quot;&quot;</span> : SERVER_ID.Get(),
<a name="l04933"></a>04933                               <a class="code" href="class_o_t_scriptable.html#a217fc906e2d6475e22913bd8653ffaa2">m_bCalculatingID</a> ? <span class="stringliteral">&quot;&quot;</span> : ACTIVATOR_USER_ID.Get(),
<a name="l04934"></a>04934                               <a class="code" href="class_o_t_scriptable.html#a217fc906e2d6475e22913bd8653ffaa2">m_bCalculatingID</a> ? <span class="stringliteral">&quot;&quot;</span> : ACTIVATOR_ACCT_ID.<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>(),
<a name="l04935"></a>04935                               <a class="code" href="class_o_t_scriptable.html#a217fc906e2d6475e22913bd8653ffaa2">m_bCalculatingID</a> ? <span class="stringliteral">&quot;&quot;</span> : m_strLastSenderUser.<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>(),
<a name="l04936"></a>04936                               <a class="code" href="class_o_t_scriptable.html#a217fc906e2d6475e22913bd8653ffaa2">m_bCalculatingID</a> ? <span class="stringliteral">&quot;&quot;</span> : m_strLastSenderAcct.<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>(),
<a name="l04937"></a>04937                               <a class="code" href="class_o_t_scriptable.html#a217fc906e2d6475e22913bd8653ffaa2">m_bCalculatingID</a> ? <span class="stringliteral">&quot;&quot;</span> : m_strLastRecipientUser.<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>(),
<a name="l04938"></a>04938                               <a class="code" href="class_o_t_scriptable.html#a217fc906e2d6475e22913bd8653ffaa2">m_bCalculatingID</a> ? <span class="stringliteral">&quot;&quot;</span> : m_strLastRecipientAcct.<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>(),
<a name="l04939"></a>04939                               <a class="code" href="class_o_t_cron_item.html#abe9ce5c7b4d2fe652908e1f81f2f3b67">m_bCanceled</a> ? <span class="stringliteral">&quot;true&quot;</span> : <span class="stringliteral">&quot;false&quot;</span>,
<a name="l04940"></a>04940                               <a class="code" href="class_o_t_cron_item.html#abe9ce5c7b4d2fe652908e1f81f2f3b67">m_bCanceled</a> ? strCanceler.<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>() : <span class="stringliteral">&quot;&quot;</span>,
<a name="l04941"></a>04941                               <a class="code" href="class_o_t_scriptable.html#a217fc906e2d6475e22913bd8653ffaa2">m_bCalculatingID</a> ? 0 : <a class="code" href="class_o_t_trackable.html#a90bc18f9b5d6b3c8059a83685b86674e">m_lTransactionNum</a>,
<a name="l04942"></a>04942                               tCreation,
<a name="l04943"></a>04943                               tValidFrom,
<a name="l04944"></a>04944                               tValidTo,
<a name="l04945"></a>04945                               tNextProcess );
<a name="l04946"></a>04946     <span class="comment">// -------------------------------------------------------------</span>
<a name="l04947"></a>04947     <span class="comment">// OTCronItem</span>
<a name="l04948"></a>04948     <span class="keywordflow">if</span> (!<a class="code" href="class_o_t_scriptable.html#a217fc906e2d6475e22913bd8653ffaa2">m_bCalculatingID</a>)
<a name="l04949"></a>04949     {
<a name="l04950"></a>04950         <span class="keywordflow">for</span> (int32_t i = 0; i &lt; <a class="code" href="class_o_t_cron_item.html#a96d3ae7898526a317dd503daecbf10af">GetCountClosingNumbers</a>(); i++)
<a name="l04951"></a>04951         {
<a name="l04952"></a>04952             int64_t lClosingNumber = <a class="code" href="class_o_t_cron_item.html#ab4bd4e606ddbb49d3f36248f18391ec1">GetClosingTransactionNoAt</a>(i);
<a name="l04953"></a>04953             <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(lClosingNumber &gt; 0);
<a name="l04954"></a>04954 
<a name="l04955"></a>04955             <a class="code" href="class_o_t_contract.html#a087fc09cfa4b2fd9076088360a5e5039">m_xmlUnsigned</a>.<a class="code" href="class_o_t_string.html#a86e54de385040ff6769d7f2149ce176b">Concatenate</a>(<span class="stringliteral">&quot;&lt;closingTransactionNumber value=\&quot;%lld\&quot;/&gt;\n\n&quot;</span>,
<a name="l04956"></a>04956                                       lClosingNumber);
<a name="l04957"></a>04957 
<a name="l04958"></a>04958             <span class="comment">// For OTSmartContract, this should only contain a single number, from the activator Nym.</span>
<a name="l04959"></a>04959             <span class="comment">// I preserved the loop anyway. Call me crazy. But I&#39;m still displaying an error if there&#39;s</span>
<a name="l04960"></a>04960             <span class="comment">// more than one.</span>
<a name="l04961"></a>04961             <span class="keywordflow">if</span> (i &gt; 0)
<a name="l04962"></a>04962                 <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;OTSmartContract::%s: ERROR: There&#39;s only ever &quot;</span>
<a name="l04963"></a>04963                              <span class="stringliteral">&quot;supposed to be a single closing number here (for smart contracts.)\n&quot;</span>,
<a name="l04964"></a>04964                               __FUNCTION__);
<a name="l04965"></a>04965         }
<a name="l04966"></a>04966     }
<a name="l04967"></a>04967     <span class="comment">// -------------------------------------------------------------</span>
<a name="l04968"></a>04968     <span class="comment">//</span>
<a name="l04969"></a>04969     <span class="comment">// *** OT SCRIPTABLE ***</span>
<a name="l04970"></a>04970     <span class="comment">//</span>
<a name="l04971"></a>04971     <a class="code" href="class_o_t_scriptable.html#a65ed14652345ef231ad4a3d347d89c3a">UpdateContentsToString</a>(<a class="code" href="class_o_t_contract.html#a087fc09cfa4b2fd9076088360a5e5039">m_xmlUnsigned</a>); <span class="comment">// FYI: this is: void OTScriptable::UpdateContentsToString(OTString &amp;)</span>
<a name="l04972"></a>04972     <span class="comment">// -------------------------------------------------------------</span>
<a name="l04973"></a>04973     <span class="keywordflow">if</span> (!<a class="code" href="class_o_t_scriptable.html#a217fc906e2d6475e22913bd8653ffaa2">m_bCalculatingID</a>)
<a name="l04974"></a>04974     {
<a name="l04975"></a>04975         <span class="comment">// -----------------</span>
<a name="l04976"></a>04976         <span class="comment">// Save m_StashAccts.</span>
<a name="l04977"></a>04977         <span class="comment">//</span>
<a name="l04978"></a>04978         <span class="comment">// (This is an object that contains a map of OTAccountIDs, by asset_type_id)</span>
<a name="l04979"></a>04979         <span class="comment">//</span>
<a name="l04980"></a>04980         m_StashAccts.<a class="code" href="class_o_t_acct_list.html#a3e8b8cf7b31d9f4affb3be6dba3852a8">Serialize</a>(<a class="code" href="class_o_t_contract.html#a087fc09cfa4b2fd9076088360a5e5039">m_xmlUnsigned</a>);
<a name="l04981"></a>04981 
<a name="l04982"></a>04982         <span class="comment">// -----------------</span>
<a name="l04983"></a>04983         <span class="comment">// This is a map of OTStash&#39;s, by stash_name.</span>
<a name="l04984"></a>04984         <span class="comment">// EACH ONE contains a map of OTStashItems, by asset_type_id</span>
<a name="l04985"></a>04985         <span class="comment">// -----------------</span>
<a name="l04986"></a>04986 
<a name="l04987"></a>04987         <a class="code" href="_o_t_storage_8hpp.html#aa135ed03585fa4b246d7907afbd5873d">FOR_EACH</a>(<a class="code" href="_o_t_stash_8hpp.html#a97aeca3992247240bcbef033b8c0813b">mapOfStashes</a>, m_mapStashes)    <span class="comment">// These stashes are what the scripts interact with. They have names.</span>
<a name="l04988"></a>04988         {                                       <span class="comment">// Whereas the stash accts (above) are the actual accountIDs</span>
<a name="l04989"></a>04989             <a class="code" href="class_o_t_stash.html">OTStash</a> * pStash = (*it).second;    <span class="comment">// where the actual funds are stored for each asset type.</span>
<a name="l04990"></a>04990             <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != pStash);
<a name="l04991"></a>04991             <span class="comment">// -------------------------</span>
<a name="l04992"></a>04992             pStash-&gt;<a class="code" href="class_o_t_stash.html#a3dc00bfe2c0414b42fe1065a7a28be41">Serialize</a>(<a class="code" href="class_o_t_contract.html#a087fc09cfa4b2fd9076088360a5e5039">m_xmlUnsigned</a>);
<a name="l04993"></a>04993         }
<a name="l04994"></a>04994     }
<a name="l04995"></a>04995     <span class="comment">// -------------------------------------------------------------</span>
<a name="l04996"></a>04996     <a class="code" href="class_o_t_contract.html#a087fc09cfa4b2fd9076088360a5e5039">m_xmlUnsigned</a>.<a class="code" href="class_o_t_string.html#a86e54de385040ff6769d7f2149ce176b">Concatenate</a>(<span class="stringliteral">&quot;&lt;/smartContract&gt;\n\n&quot;</span>);
<a name="l04997"></a>04997 }
<a name="l04998"></a>04998 
<a name="l04999"></a>04999 
<a name="l05000"></a>05000 <span class="comment">// Add &quot;send Instrument&quot; function for sending instruments instead of messages.</span>
<a name="l05001"></a>05001 
<a name="l05002"></a>05002 <span class="comment">// Then add API functions for loading/save editable and template smart contracts to/from local storage.</span>
<a name="l05003"></a>05003 
<a name="l05004"></a>05004 <span class="comment">// Then add API functions for issuing and downloading the smart contracts to/from server.</span>
<a name="l05005"></a>05005 
<a name="l05006"></a>05006 <span class="comment">// Then add API functions for downloading and loading up the list of INSTANCES (contracts activated on server.)</span>
<a name="l05007"></a>05007 
<a name="l05008"></a>05008 <span class="comment">// The &quot;INSTANCES&quot; tab will show contracts not only that are activated, but also that are confirmed and pending activation.</span>
<a name="l05009"></a>05009 <span class="comment">// Therefore should be a stringmap style thing again, where instances</span>
<a name="l05010"></a>05010 <span class="comment">//</span>
<a name="l05011"></a><a class="code" href="class_o_t_smart_contract.html#abd37d88f1828402ae7313aa130ccbe9f">05011</a> <span class="keywordtype">bool</span> <a class="code" href="class_o_t_smart_contract.html#abd37d88f1828402ae7313aa130ccbe9f">OTSmartContract::LoadEditable</a>(<span class="keyword">const</span> <a class="code" href="class_o_t_string.html">OTString</a> &amp; strName)
<a name="l05012"></a>05012 {
<a name="l05013"></a>05013     <span class="keywordflow">if</span> (!strName.<a class="code" href="class_o_t_string.html#adf7489cd917d4ae5bf30853a3ad78daf">Exists</a>())
<a name="l05014"></a>05014     {
<a name="l05015"></a>05015         <a class="code" href="class_o_t_log.html#a5acd90ac91c2618f395b0ff37ad4f8ee">OTLog::Error</a>(<span class="stringliteral">&quot;OTSmartContract::LoadEditable: Empty name passed in. (Returning false.)\n&quot;</span>);
<a name="l05016"></a>05016         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l05017"></a>05017     }
<a name="l05018"></a>05018 
<a name="l05019"></a>05019     <span class="keyword">const</span> <a class="code" href="class_o_t_string.html">OTString</a> strServerID(<a class="code" href="class_o_t_instrument.html#a878dd8998f7b131b85c082575e255375">GetServerID</a>());
<a name="l05020"></a>05020     <span class="comment">// --------------------------------------</span>
<a name="l05021"></a>05021     <span class="keyword">const</span> <a class="code" href="class_o_t_a_s_c_i_i_armor.html">OTASCIIArmor</a> ascName(strName); <span class="comment">// Filename (base64-encoded)</span>
<a name="l05022"></a>05022     std::string str_contract;
<a name="l05023"></a>05023 
<a name="l05024"></a>05024     <span class="keywordflow">if</span> (!<a class="code" href="namespace_o_t_d_b.html#a73e39a590dfb64f63065821c6bbcd4c6">OTDB::Exists</a>(<a class="code" href="class_o_t_folders.html#a698b8fd86486783a1b21ec54e1d0867e">OTFolders::SmartContracts</a>().Get(),
<a name="l05025"></a>05025                      strServerID.<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>(),
<a name="l05026"></a>05026                      <span class="stringliteral">&quot;editing&quot;</span>,     <span class="comment">// todo hardcoding. The folder where smart contracts are edited.</span>
<a name="l05027"></a>05027                      ascName.<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>()))
<a name="l05028"></a>05028     {
<a name="l05029"></a>05029         <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(2, <span class="stringliteral">&quot;OTSmartContract::LoadEditable: File doesn&#39;t exist: %s%s%s%s%s%s%s\n&quot;</span>,
<a name="l05030"></a>05030                        <a class="code" href="class_o_t_folders.html#a698b8fd86486783a1b21ec54e1d0867e">OTFolders::SmartContracts</a>().Get(), <a class="code" href="class_o_t_log.html#a42d3c91ff84ecae0690e34efb4619a77">OTLog::PathSeparator</a>(),
<a name="l05031"></a>05031                        strServerID.<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>(), <a class="code" href="class_o_t_log.html#a42d3c91ff84ecae0690e34efb4619a77">OTLog::PathSeparator</a>(), <span class="stringliteral">&quot;editing&quot;</span>,
<a name="l05032"></a>05032                        <a class="code" href="class_o_t_log.html#a42d3c91ff84ecae0690e34efb4619a77">OTLog::PathSeparator</a>(), ascName.<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>());
<a name="l05033"></a>05033         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l05034"></a>05034     }
<a name="l05035"></a>05035     <span class="keywordflow">else</span>
<a name="l05036"></a>05036         str_contract = <a class="code" href="namespace_o_t_d_b.html#a921d6f538de00f4e4297c25cf679f00a">OTDB::QueryPlainString</a>(<a class="code" href="class_o_t_folders.html#a698b8fd86486783a1b21ec54e1d0867e">OTFolders::SmartContracts</a>().Get(),
<a name="l05037"></a>05037                                               strServerID.<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>(),
<a name="l05038"></a>05038                                               <span class="stringliteral">&quot;editing&quot;</span>, <span class="comment">// todo stop hardcoding.</span>
<a name="l05039"></a>05039                                               ascName.<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>());
<a name="l05040"></a>05040     <span class="keywordflow">if</span> (str_contract.size() &lt; 1)
<a name="l05041"></a>05041     {
<a name="l05042"></a>05042         <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;OTSmartContract::LoadEditable: Failed loading: %s%s%s%s%s%s%s\n&quot;</span>,
<a name="l05043"></a>05043                       <a class="code" href="class_o_t_folders.html#a698b8fd86486783a1b21ec54e1d0867e">OTFolders::SmartContracts</a>().Get(), <a class="code" href="class_o_t_log.html#a42d3c91ff84ecae0690e34efb4619a77">OTLog::PathSeparator</a>(),
<a name="l05044"></a>05044                       strServerID.<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>(), <a class="code" href="class_o_t_log.html#a42d3c91ff84ecae0690e34efb4619a77">OTLog::PathSeparator</a>(), <span class="stringliteral">&quot;editing&quot;</span>,
<a name="l05045"></a>05045                       <a class="code" href="class_o_t_log.html#a42d3c91ff84ecae0690e34efb4619a77">OTLog::PathSeparator</a>(), ascName.<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>());
<a name="l05046"></a>05046     }
<a name="l05047"></a>05047     <span class="keywordflow">else</span>
<a name="l05048"></a>05048     {
<a name="l05049"></a>05049         <span class="keyword">const</span> <a class="code" href="class_o_t_string.html">OTString</a> strSmartContract(str_contract.c_str());
<a name="l05050"></a>05050 
<a name="l05051"></a>05051         <span class="keywordflow">if</span> (<span class="keyword">false</span> == this-&gt;<a class="code" href="class_o_t_contract.html#a36300e34dcd94ed7006d98b392d46815">LoadContractFromString</a>(strSmartContract)) <span class="comment">// Handles OT ARMORED file formats.</span>
<a name="l05052"></a>05052         {
<a name="l05053"></a>05053             <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;OTSmartContract::LoadEditable: Failed attempt to load (editable), smart contract from storage: %s \n&quot;</span>,
<a name="l05054"></a>05054                           strName.<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>());
<a name="l05055"></a>05055         }
<a name="l05056"></a>05056         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l05057"></a>05057     }
<a name="l05058"></a>05058 
<a name="l05059"></a>05059     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l05060"></a>05060 }
<a name="l05061"></a>05061 
<a name="l05062"></a>05062 
<a name="l05063"></a><a class="code" href="class_o_t_smart_contract.html#acaa73a3c0357768583a129612d8ebb91">05063</a> <span class="keywordtype">bool</span> <a class="code" href="class_o_t_smart_contract.html#acaa73a3c0357768583a129612d8ebb91">OTSmartContract::SaveEditable</a>(<span class="keyword">const</span> <a class="code" href="class_o_t_string.html">OTString</a> &amp; strName)
<a name="l05064"></a>05064 {
<a name="l05065"></a>05065     <a class="code" href="class_o_t_d_b_1_1_string_map.html">OTDB::StringMap</a> * pList = NULL;
<a name="l05066"></a>05066 
<a name="l05067"></a>05067     <span class="keywordflow">if</span> (!strName.<a class="code" href="class_o_t_string.html#adf7489cd917d4ae5bf30853a3ad78daf">Exists</a>())
<a name="l05068"></a>05068     {
<a name="l05069"></a>05069         <a class="code" href="class_o_t_log.html#a5acd90ac91c2618f395b0ff37ad4f8ee">OTLog::Error</a>(<span class="stringliteral">&quot;OTSmartContract::SaveEditable: Empty name passed in. (Returning false.)\n&quot;</span>);
<a name="l05070"></a>05070         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l05071"></a>05071     }
<a name="l05072"></a>05072 
<a name="l05073"></a>05073     <span class="keyword">const</span> <a class="code" href="class_o_t_string.html">OTString</a> strServerID(<a class="code" href="class_o_t_instrument.html#a878dd8998f7b131b85c082575e255375">GetServerID</a>());
<a name="l05074"></a>05074     <span class="comment">// --------------------------------------</span>
<a name="l05075"></a>05075     <span class="keyword">const</span> <a class="code" href="class_o_t_a_s_c_i_i_armor.html">OTASCIIArmor</a> ascName(strName); <span class="comment">// Filename (base64-encoded)</span>
<a name="l05076"></a>05076 
<a name="l05077"></a>05077     <span class="keywordflow">if</span> (<a class="code" href="namespace_o_t_d_b.html#a73e39a590dfb64f63065821c6bbcd4c6">OTDB::Exists</a>(<a class="code" href="class_o_t_folders.html#a698b8fd86486783a1b21ec54e1d0867e">OTFolders::SmartContracts</a>().Get(),
<a name="l05078"></a>05078                      strServerID.<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>(),
<a name="l05079"></a>05079                      <span class="stringliteral">&quot;editing&quot;</span>,     <span class="comment">// todo hardcoding. The folder where smart contracts are edited.</span>
<a name="l05080"></a>05080                      <span class="stringliteral">&quot;list.dat&quot;</span>))
<a name="l05081"></a>05081         pList = <span class="keyword">dynamic_cast&lt;</span><a class="code" href="class_o_t_d_b_1_1_string_map.html">OTDB::StringMap</a> *<span class="keyword">&gt;</span>(<a class="code" href="namespace_o_t_d_b.html#aaf0caee055f843a828e3bac094321886">OTDB::QueryObject</a>(<a class="code" href="namespace_o_t_d_b.html#abce432e500285dde333e6f76f6fbde82acc03e85e0f615881a2abe9ca12628330">OTDB::STORED_OBJ_STRING_MAP</a>,
<a name="l05082"></a>05082                                                                   <a class="code" href="class_o_t_folders.html#a698b8fd86486783a1b21ec54e1d0867e">OTFolders::SmartContracts</a>().Get(),
<a name="l05083"></a>05083                                                                   strServerID.<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>(),
<a name="l05084"></a>05084                                                                   <span class="stringliteral">&quot;editing&quot;</span>, <span class="comment">// todo stop hardcoding.</span>
<a name="l05085"></a>05085                                                                   <span class="stringliteral">&quot;list.dat&quot;</span>));
<a name="l05086"></a>05086     <span class="keywordflow">if</span> (NULL == pList)
<a name="l05087"></a>05087     {
<a name="l05088"></a>05088         <a class="code" href="class_o_t_log.html#a1f7549d776ee919dcb6517f611ded015">OTLog::Output</a>(2, <span class="stringliteral">&quot;OTSmartContract::SaveEditable: Creating storage list of editable smart contracts.\n&quot;</span>);
<a name="l05089"></a>05089         pList = <span class="keyword">dynamic_cast&lt;</span><a class="code" href="class_o_t_d_b_1_1_string_map.html">OTDB::StringMap</a> *<span class="keyword">&gt;</span>(<a class="code" href="namespace_o_t_d_b.html#a67b35ca5812604fb3e1eae2b659f66ee">OTDB::CreateObject</a>(<a class="code" href="namespace_o_t_d_b.html#abce432e500285dde333e6f76f6fbde82acc03e85e0f615881a2abe9ca12628330">OTDB::STORED_OBJ_STRING_MAP</a>));
<a name="l05090"></a>05090     }
<a name="l05091"></a>05091     <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != pList);
<a name="l05092"></a>05092     <a class="code" href="class_o_t_cleanup.html">OTCleanup&lt;OTDB::StringMap&gt;</a> theListAngel(*pList);
<a name="l05093"></a>05093 
<a name="l05094"></a>05094     <span class="keyword">const</span> std::string str_asc_name(ascName.<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>()), str_name(strName.<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>()); <span class="comment">// encoded name and normal name.</span>
<a name="l05095"></a>05095 
<a name="l05096"></a>05096     pList-&gt;<a class="code" href="class_o_t_d_b_1_1_string_map.html#a62d93725398feb9c58fe618b8798485a">SetValue</a>(str_asc_name, str_name); <span class="comment">// Add the filename to the map of filenames.</span>
<a name="l05097"></a>05097 
<a name="l05098"></a>05098     <span class="keywordflow">if</span> (<span class="keyword">false</span> == <a class="code" href="namespace_o_t_d_b.html#a394420b02f48d3ebdfebb75d92a4d6dd">OTDB::StoreObject</a>(*pList,
<a name="l05099"></a>05099                                     <a class="code" href="class_o_t_folders.html#a698b8fd86486783a1b21ec54e1d0867e">OTFolders::SmartContracts</a>().Get(),
<a name="l05100"></a>05100                                     strServerID.<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>(),
<a name="l05101"></a>05101                                     <span class="stringliteral">&quot;editing&quot;</span>, <span class="comment">// todo stop hardcoding.</span>
<a name="l05102"></a>05102                                     <span class="stringliteral">&quot;list.dat&quot;</span>))
<a name="l05103"></a>05103     {
<a name="l05104"></a>05104         <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;OTSmartContract::SaveEditable: Failed saving %s%s%s%s%s%s%s\n&quot;</span>,
<a name="l05105"></a>05105                       <a class="code" href="class_o_t_folders.html#a698b8fd86486783a1b21ec54e1d0867e">OTFolders::SmartContracts</a>().Get(), <a class="code" href="class_o_t_log.html#a42d3c91ff84ecae0690e34efb4619a77">OTLog::PathSeparator</a>(),
<a name="l05106"></a>05106                       strServerID.<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>(), <a class="code" href="class_o_t_log.html#a42d3c91ff84ecae0690e34efb4619a77">OTLog::PathSeparator</a>(), <span class="stringliteral">&quot;editing&quot;</span>,
<a name="l05107"></a>05107                       <a class="code" href="class_o_t_log.html#a42d3c91ff84ecae0690e34efb4619a77">OTLog::PathSeparator</a>(), <span class="stringliteral">&quot;list.dat&quot;</span>);
<a name="l05108"></a>05108     }
<a name="l05109"></a>05109     <span class="keywordflow">else</span>    <span class="comment">// We saved the list of filenames -- now save the contract itself.</span>
<a name="l05110"></a>05110     {
<a name="l05111"></a>05111         <span class="keywordflow">if</span> (<a class="code" href="class_o_t_contract.html#a90c53743214bc0f0025ad63c3ace7bf2">m_strRawFile</a>.<a class="code" href="class_o_t_string.html#adf7489cd917d4ae5bf30853a3ad78daf">Exists</a>())
<a name="l05112"></a>05112         {
<a name="l05113"></a>05113             <a class="code" href="class_o_t_string.html">OTString</a> strFinal;
<a name="l05114"></a>05114             <a class="code" href="class_o_t_a_s_c_i_i_armor.html">OTASCIIArmor</a> ascTemp(<a class="code" href="class_o_t_contract.html#a90c53743214bc0f0025ad63c3ace7bf2">m_strRawFile</a>);
<a name="l05115"></a>05115 
<a name="l05116"></a>05116             <span class="keywordflow">if</span> (<span class="keyword">false</span> == ascTemp.<a class="code" href="class_o_t_a_s_c_i_i_armor.html#a754effb29fd0192ba0a7535846e52890">WriteArmoredString</a>(strFinal, <a class="code" href="class_o_t_contract.html#ac523dac7d72b72e54b1ebb5b3a3b21cc">m_strContractType</a>.<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>()))
<a name="l05117"></a>05117             {
<a name="l05118"></a>05118                 <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;OTSmartContract::SaveEditable: Error saving editable smart contract (failed writing armored string):\n%s%s%s%s%s%s%s\n&quot;</span>,
<a name="l05119"></a>05119                               <a class="code" href="class_o_t_folders.html#a698b8fd86486783a1b21ec54e1d0867e">OTFolders::SmartContracts</a>().Get(), <a class="code" href="class_o_t_log.html#a42d3c91ff84ecae0690e34efb4619a77">OTLog::PathSeparator</a>(),
<a name="l05120"></a>05120                               strServerID.<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>(), <a class="code" href="class_o_t_log.html#a42d3c91ff84ecae0690e34efb4619a77">OTLog::PathSeparator</a>(), <span class="stringliteral">&quot;editing&quot;</span>,
<a name="l05121"></a>05121                               <a class="code" href="class_o_t_log.html#a42d3c91ff84ecae0690e34efb4619a77">OTLog::PathSeparator</a>(), str_asc_name.c_str());
<a name="l05122"></a>05122                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l05123"></a>05123             }
<a name="l05124"></a>05124             <span class="comment">// ----------------------------------------------------</span>
<a name="l05125"></a>05125             <span class="keywordflow">if</span>  (<span class="keyword">false</span> == <a class="code" href="namespace_o_t_d_b.html#a7ec0a905bba2c1c8ba5b1e873e12eab4">OTDB::StorePlainString</a>(strFinal.<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>(),
<a name="l05126"></a>05126                                                  <a class="code" href="class_o_t_folders.html#a698b8fd86486783a1b21ec54e1d0867e">OTFolders::SmartContracts</a>().<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>(),
<a name="l05127"></a>05127                                                  strServerID.<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>(),
<a name="l05128"></a>05128                                                  <span class="stringliteral">&quot;editing&quot;</span>, <span class="comment">// todo stop hardcoding.</span>
<a name="l05129"></a>05129                                                  str_asc_name)) <span class="comment">// encoded version of name.</span>
<a name="l05130"></a>05130             {
<a name="l05131"></a>05131                 <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;OTSmartContract::SaveEditable: Failed saving (editable) smart contract: %s \n to path: %s%s%s%s%s%s%s&quot;</span>,
<a name="l05132"></a>05132                               str_name.c_str(), <a class="code" href="class_o_t_folders.html#a698b8fd86486783a1b21ec54e1d0867e">OTFolders::SmartContracts</a>().<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>(), <a class="code" href="class_o_t_log.html#a42d3c91ff84ecae0690e34efb4619a77">OTLog::PathSeparator</a>(),
<a name="l05133"></a>05133                               strServerID.<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>(), <a class="code" href="class_o_t_log.html#a42d3c91ff84ecae0690e34efb4619a77">OTLog::PathSeparator</a>(), <span class="stringliteral">&quot;editing&quot;</span>,
<a name="l05134"></a>05134                               <a class="code" href="class_o_t_log.html#a42d3c91ff84ecae0690e34efb4619a77">OTLog::PathSeparator</a>(), str_asc_name.c_str());
<a name="l05135"></a>05135             }
<a name="l05136"></a>05136             <span class="keywordflow">else</span>
<a name="l05137"></a>05137             {
<a name="l05138"></a>05138                 <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l05139"></a>05139             }
<a name="l05140"></a>05140         }
<a name="l05141"></a>05141         <span class="keywordflow">else</span>
<a name="l05142"></a>05142         {
<a name="l05143"></a>05143             <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;OTSmartContract::SaveEditable: Failed attempt to save empty (unsigned?), editable, smart contract: %s \n&quot;</span>,
<a name="l05144"></a>05144                           str_name.c_str());
<a name="l05145"></a>05145         }
<a name="l05146"></a>05146     }
<a name="l05147"></a>05147 
<a name="l05148"></a>05148     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l05149"></a>05149 }
<a name="l05150"></a>05150 
<a name="l05151"></a>05151 
<a name="l05152"></a>05152 <span class="comment">/*</span>
<a name="l05153"></a>05153 <span class="comment"> Authorized User</span>
<a name="l05154"></a>05154 <span class="comment"> isn&#39;t dropdown filtered by servers Nym is registered at?</span>
<a name="l05155"></a>05155 <span class="comment"></span>
<a name="l05156"></a>05156 <span class="comment"> 11:06</span>
<a name="l05157"></a>05157 <span class="comment"> vickyc@jabber.rayservers.com</span>
<a name="l05158"></a>05158 <span class="comment"> yes</span>
<a name="l05159"></a>05159 <span class="comment"></span>
<a name="l05160"></a>05160 <span class="comment"> 11:06</span>
<a name="l05161"></a>05161 <span class="comment"> Authorized User</span>
<a name="l05162"></a>05162 <span class="comment"> if only 1, then drop-down contains only 1</span>
<a name="l05163"></a>05163 <span class="comment"> then you can see it</span>
<a name="l05164"></a>05164 <span class="comment"></span>
<a name="l05165"></a>05165 <span class="comment"> 11:06</span>
<a name="l05166"></a>05166 <span class="comment"> vickyc@jabber.rayservers.com</span>
<a name="l05167"></a>05167 <span class="comment"> filtered</span>
<a name="l05168"></a>05168 <span class="comment"></span>
<a name="l05169"></a>05169 <span class="comment"> 11:06</span>
<a name="l05170"></a>05170 <span class="comment"> Authorized User</span>
<a name="l05171"></a>05171 <span class="comment"> then you don&#39;t need it in a column, if already in dropdown</span>
<a name="l05172"></a>05172 <span class="comment"></span>
<a name="l05173"></a>05173 <span class="comment"> 11:06</span>
<a name="l05174"></a>05174 <span class="comment"> vickyc@jabber.rayservers.com</span>
<a name="l05175"></a>05175 <span class="comment"> ok np.. wll keep tht screen everytime</span>
<a name="l05176"></a>05176 <span class="comment"> ok.. will remove frm column</span>
<a name="l05177"></a>05177 <span class="comment"> and type?</span>
<a name="l05178"></a>05178 <span class="comment"></span>
<a name="l05179"></a>05179 <span class="comment"> 11:07</span>
<a name="l05180"></a>05180 <span class="comment"> Authorized User</span>
<a name="l05181"></a>05181 <span class="comment"> Maybe I will have to give you API function to get that</span>
<a name="l05182"></a>05182 <span class="comment"> I will check</span>
<a name="l05183"></a>05183 <span class="comment"> add one if not already there</span>
<a name="l05184"></a>05184 <span class="comment"> */</span>
<a name="l05185"></a>05185 
<a name="l05186"></a>05186 
<a name="l05187"></a>05187 <span class="comment">// Once a smart contract is issued onto a server, then it&#39;s available there as a template.</span>
<a name="l05188"></a>05188 <span class="comment">// Users can download a list of templates, and create an instance of a smart contract. From</span>
<a name="l05189"></a>05189 <span class="comment">// there they can confirm and activate it along with the other parties.</span>
<a name="l05190"></a>05190 <span class="comment">// (You have have multiple instances of a single template. For example, two escrow contracts</span>
<a name="l05191"></a>05191 <span class="comment">// might be otherwise identical, except for gold in one instance, and silver in another.)</span>
<a name="l05192"></a>05192 <span class="comment">//</span>
<a name="l05193"></a>05193 <span class="comment">// Whether the template is on the server side or client side, this function behaves identically.</span>
<a name="l05194"></a>05194 <span class="comment">//</span>
<a name="l05195"></a><a class="code" href="class_o_t_smart_contract.html#a180d318d02a58976aaf8e8dc1ee729ab">05195</a> <span class="keywordtype">bool</span> <a class="code" href="class_o_t_smart_contract.html#a180d318d02a58976aaf8e8dc1ee729ab">OTSmartContract::LoadTemplate</a>(<span class="keyword">const</span> <a class="code" href="class_o_t_identifier.html">OTIdentifier</a> &amp; SERVER_ID, <span class="keyword">const</span> <a class="code" href="class_o_t_identifier.html">OTIdentifier</a> &amp; CONTRACT_ID)
<a name="l05196"></a>05196 {
<a name="l05197"></a>05197     <span class="keywordflow">if</span> (!<a class="code" href="class_o_t_contract.html#ab1e11693a38a1673037b1f29c9d84010">m_strFoldername</a>.<a class="code" href="class_o_t_string.html#adf7489cd917d4ae5bf30853a3ad78daf">Exists</a>())
<a name="l05198"></a>05198         <a class="code" href="class_o_t_contract.html#ab1e11693a38a1673037b1f29c9d84010">m_strFoldername</a>.<a class="code" href="class_o_t_string.html#aa5db620fe8e60c849585d741975db991">Set</a>(<a class="code" href="class_o_t_folders.html#a698b8fd86486783a1b21ec54e1d0867e">OTFolders::SmartContracts</a>().<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>());
<a name="l05199"></a>05199 
<a name="l05200"></a>05200     <span class="keyword">const</span> <a class="code" href="class_o_t_string.html">OTString</a> strServerID(SERVER_ID), strContractID(CONTRACT_ID);
<a name="l05201"></a>05201 
<a name="l05202"></a>05202     <span class="keywordflow">if</span> (!<a class="code" href="class_o_t_contract.html#ab7ab1f1fe7ff7e52f2c126404a8f4f92">m_strFilename</a>.<a class="code" href="class_o_t_string.html#adf7489cd917d4ae5bf30853a3ad78daf">Exists</a>())
<a name="l05203"></a>05203     {
<a name="l05204"></a>05204         <a class="code" href="class_o_t_contract.html#ab7ab1f1fe7ff7e52f2c126404a8f4f92">m_strFilename</a>.<a class="code" href="class_o_t_string.html#af1c861f21033a1d583b3cb12f952422e">Format</a>(<span class="stringliteral">&quot;%s%s%s&quot;</span>, strServerID.Get(), <a class="code" href="class_o_t_log.html#a42d3c91ff84ecae0690e34efb4619a77">OTLog::PathSeparator</a>(), strContractID.<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>());
<a name="l05205"></a>05205     }
<a name="l05206"></a>05206     <span class="comment">// --------------------------------------------------------------------</span>
<a name="l05207"></a>05207 
<a name="l05208"></a>05208     <span class="keyword">const</span> <span class="keywordtype">char</span> * szFolder1name  = <a class="code" href="class_o_t_folders.html#a698b8fd86486783a1b21ec54e1d0867e">OTFolders::SmartContracts</a>().<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>();    <span class="comment">// &quot;smartcontracts&quot;</span>
<a name="l05209"></a>05209     <span class="keyword">const</span> <span class="keywordtype">char</span> * szFolder2name  = strServerID.Get();                <span class="comment">// &quot;smartcontracts/SERVER_ID&quot;</span>
<a name="l05210"></a>05210     <span class="keyword">const</span> <span class="keywordtype">char</span> * szFilename     = strContractID.<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>();              <span class="comment">// &quot;smartcontracts/SERVER_ID/CONTRACT_ID&quot;</span>
<a name="l05211"></a>05211 
<a name="l05212"></a>05212     <span class="comment">// --------------------------------------------------------------------</span>
<a name="l05213"></a>05213 
<a name="l05214"></a>05214     <span class="keywordflow">if</span> (<span class="keyword">false</span> == <a class="code" href="namespace_o_t_d_b.html#a73e39a590dfb64f63065821c6bbcd4c6">OTDB::Exists</a>(szFolder1name, szFolder2name, szFilename))
<a name="l05215"></a>05215     {
<a name="l05216"></a>05216         <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(0, <span class="stringliteral">&quot;OTSmartContract::LoadTemplate: File does not exist: %s%s%s%s%s\n&quot;</span>,
<a name="l05217"></a>05217                        szFolder1name, <a class="code" href="class_o_t_log.html#a42d3c91ff84ecae0690e34efb4619a77">OTLog::PathSeparator</a>(), szFolder2name, <a class="code" href="class_o_t_log.html#a42d3c91ff84ecae0690e34efb4619a77">OTLog::PathSeparator</a>(), szFilename);
<a name="l05218"></a>05218         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l05219"></a>05219     }
<a name="l05220"></a>05220     <span class="comment">// --------------------------------------------------------------------</span>
<a name="l05221"></a>05221     <span class="comment">//</span>
<a name="l05222"></a>05222     std::string strFileContents(<a class="code" href="namespace_o_t_d_b.html#a921d6f538de00f4e4297c25cf679f00a">OTDB::QueryPlainString</a>(szFolder1name, szFolder2name, szFilename)); <span class="comment">// &lt;=== LOADING FROM DATA STORE.</span>
<a name="l05223"></a>05223 
<a name="l05224"></a>05224     <span class="keywordflow">if</span> (strFileContents.length() &lt; 2)
<a name="l05225"></a>05225     {
<a name="l05226"></a>05226         <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;OTSmartContract::LoadTemplate: Error reading file: %s%s%s%s%s\n&quot;</span>,
<a name="l05227"></a>05227                       szFolder1name, <a class="code" href="class_o_t_log.html#a42d3c91ff84ecae0690e34efb4619a77">OTLog::PathSeparator</a>(), szFolder2name, <a class="code" href="class_o_t_log.html#a42d3c91ff84ecae0690e34efb4619a77">OTLog::PathSeparator</a>(), szFilename);
<a name="l05228"></a>05228         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l05229"></a>05229     }
<a name="l05230"></a>05230     <span class="comment">// --------------------------------------------------------------------</span>
<a name="l05231"></a>05231 
<a name="l05232"></a>05232     <a class="code" href="class_o_t_string.html">OTString</a> strRawFile(strFileContents.c_str());
<a name="l05233"></a>05233 
<a name="l05234"></a>05234     <span class="keywordtype">bool</span> bSuccess = <a class="code" href="class_o_t_contract.html#a36300e34dcd94ed7006d98b392d46815">LoadContractFromString</a>(strRawFile); <span class="comment">// Handles OT ARMORED file formats...</span>
<a name="l05235"></a>05235 
<a name="l05236"></a>05236     <span class="keywordflow">return</span> bSuccess;
<a name="l05237"></a>05237 }
<a name="l05238"></a>05238 
<a name="l05239"></a>05239 
<a name="l05240"></a><a class="code" href="class_o_t_smart_contract.html#a61617c4df9db720a7b7167f9b92bd750">05240</a> <span class="keywordtype">bool</span> <a class="code" href="class_o_t_smart_contract.html#a61617c4df9db720a7b7167f9b92bd750">OTSmartContract::SaveTemplate</a>(<span class="keyword">const</span> <a class="code" href="class_o_t_identifier.html">OTIdentifier</a> &amp; SERVER_ID)
<a name="l05241"></a>05241 {
<a name="l05242"></a>05242     <span class="keywordflow">if</span> (!<a class="code" href="class_o_t_contract.html#ab1e11693a38a1673037b1f29c9d84010">m_strFoldername</a>.<a class="code" href="class_o_t_string.html#adf7489cd917d4ae5bf30853a3ad78daf">Exists</a>())
<a name="l05243"></a>05243         <a class="code" href="class_o_t_contract.html#ab1e11693a38a1673037b1f29c9d84010">m_strFoldername</a>.<a class="code" href="class_o_t_string.html#aa5db620fe8e60c849585d741975db991">Set</a>(<a class="code" href="class_o_t_folders.html#a698b8fd86486783a1b21ec54e1d0867e">OTFolders::SmartContracts</a>().<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>());
<a name="l05244"></a>05244 
<a name="l05245"></a>05245     <a class="code" href="class_o_t_identifier.html">OTIdentifier</a> theContractID;
<a name="l05246"></a>05246     <a class="code" href="class_o_t_scriptable.html#ac1c6d838f350141b461420004bb8834b">CalculateContractID</a>(theContractID);
<a name="l05247"></a>05247 
<a name="l05248"></a>05248     <span class="keyword">const</span> <a class="code" href="class_o_t_string.html">OTString</a> strServerID(SERVER_ID), strContractID(theContractID);
<a name="l05249"></a>05249 
<a name="l05250"></a>05250     <span class="keywordflow">if</span> (!<a class="code" href="class_o_t_contract.html#ab7ab1f1fe7ff7e52f2c126404a8f4f92">m_strFilename</a>.<a class="code" href="class_o_t_string.html#adf7489cd917d4ae5bf30853a3ad78daf">Exists</a>())
<a name="l05251"></a>05251     {
<a name="l05252"></a>05252         <a class="code" href="class_o_t_contract.html#ab7ab1f1fe7ff7e52f2c126404a8f4f92">m_strFilename</a>.<a class="code" href="class_o_t_string.html#af1c861f21033a1d583b3cb12f952422e">Format</a>(<span class="stringliteral">&quot;%s%s%s&quot;</span>, strServerID.Get(), <a class="code" href="class_o_t_log.html#a42d3c91ff84ecae0690e34efb4619a77">OTLog::PathSeparator</a>(), strContractID.<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>());
<a name="l05253"></a>05253     }
<a name="l05254"></a>05254 
<a name="l05255"></a>05255     <span class="keyword">const</span> <span class="keywordtype">char</span> * szFolder1name  = <a class="code" href="class_o_t_folders.html#a698b8fd86486783a1b21ec54e1d0867e">OTFolders::SmartContracts</a>().<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>();
<a name="l05256"></a>05256     <span class="keyword">const</span> <span class="keywordtype">char</span> * szFolder2name  = strServerID.Get();
<a name="l05257"></a>05257     <span class="keyword">const</span> <span class="keywordtype">char</span> * szFilename     = strContractID.<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>();
<a name="l05258"></a>05258 
<a name="l05259"></a>05259     <span class="comment">// --------------------------------------------------------------------</span>
<a name="l05260"></a>05260 
<a name="l05261"></a>05261     <a class="code" href="class_o_t_string.html">OTString</a> strRawFile;
<a name="l05262"></a>05262 
<a name="l05263"></a>05263     <span class="keywordflow">if</span> (!<a class="code" href="class_o_t_contract.html#a5fd00cded794a6f96ba80d8d4081d591">SaveContractRaw</a>(strRawFile))
<a name="l05264"></a>05264     {
<a name="l05265"></a>05265         <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;OTSmartContract::SaveTemplate: Error saving smart contract template (to string):\n%s%s%s%s%s\n&quot;</span>,
<a name="l05266"></a>05266                       szFolder1name, <a class="code" href="class_o_t_log.html#a42d3c91ff84ecae0690e34efb4619a77">OTLog::PathSeparator</a>(), szFolder2name, <a class="code" href="class_o_t_log.html#a42d3c91ff84ecae0690e34efb4619a77">OTLog::PathSeparator</a>(), szFilename);
<a name="l05267"></a>05267         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l05268"></a>05268     }
<a name="l05269"></a>05269     <span class="comment">// --------------------------------------------------------------------</span>
<a name="l05270"></a>05270     <span class="comment">//</span>
<a name="l05271"></a>05271     <a class="code" href="class_o_t_string.html">OTString</a> strFinal;
<a name="l05272"></a>05272     <a class="code" href="class_o_t_a_s_c_i_i_armor.html">OTASCIIArmor</a> ascTemp(strRawFile);
<a name="l05273"></a>05273 
<a name="l05274"></a>05274     <span class="keywordflow">if</span> (<span class="keyword">false</span> == ascTemp.<a class="code" href="class_o_t_a_s_c_i_i_armor.html#a754effb29fd0192ba0a7535846e52890">WriteArmoredString</a>(strFinal, <a class="code" href="class_o_t_contract.html#ac523dac7d72b72e54b1ebb5b3a3b21cc">m_strContractType</a>.<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>()))
<a name="l05275"></a>05275     {
<a name="l05276"></a>05276         <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;OTSmartContract::SaveTemplate: Error saving smart contract template (failed writing armored string):\n%s%s%s%s%s\n&quot;</span>,
<a name="l05277"></a>05277                       szFolder1name, <a class="code" href="class_o_t_log.html#a42d3c91ff84ecae0690e34efb4619a77">OTLog::PathSeparator</a>(), szFolder2name, <a class="code" href="class_o_t_log.html#a42d3c91ff84ecae0690e34efb4619a77">OTLog::PathSeparator</a>(), szFilename);
<a name="l05278"></a>05278         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l05279"></a>05279     }
<a name="l05280"></a>05280     <span class="comment">// --------------------------------------------------------------------</span>
<a name="l05281"></a>05281     <span class="comment">//</span>
<a name="l05282"></a>05282     <span class="keywordtype">bool</span> bSaved = <a class="code" href="namespace_o_t_d_b.html#a7ec0a905bba2c1c8ba5b1e873e12eab4">OTDB::StorePlainString</a>(strFinal.<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>(), szFolder1name,
<a name="l05283"></a>05283                                          szFolder2name, szFilename); <span class="comment">// &lt;=== SAVING TO DATA STORE.</span>
<a name="l05284"></a>05284 
<a name="l05285"></a>05285     <span class="keywordflow">if</span> (!bSaved)
<a name="l05286"></a>05286     {
<a name="l05287"></a>05287         <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;OTSmartContract::SaveTemplate: Error writing to file: %s%s%s%s%s\n&quot;</span>, szFolder1name,
<a name="l05288"></a>05288                       <a class="code" href="class_o_t_log.html#a42d3c91ff84ecae0690e34efb4619a77">OTLog::PathSeparator</a>(), szFolder2name, <a class="code" href="class_o_t_log.html#a42d3c91ff84ecae0690e34efb4619a77">OTLog::PathSeparator</a>(), szFilename);
<a name="l05289"></a>05289 
<a name="l05290"></a>05290         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l05291"></a>05291     }
<a name="l05292"></a>05292     <span class="comment">// --------------------------------------------------------------------</span>
<a name="l05293"></a>05293 
<a name="l05294"></a>05294     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l05295"></a>05295 }
<a name="l05296"></a>05296 
<a name="l05297"></a>05297 
<a name="l05298"></a>05298 <span class="comment">// Used internally here.</span>
<a name="l05299"></a><a class="code" href="class_o_t_smart_contract.html#a09de789ac2e616e2119feb9ddf416c9d">05299</a> <span class="keywordtype">void</span> <a class="code" href="class_o_t_smart_contract.html#a09de789ac2e616e2119feb9ddf416c9d">OTSmartContract::ReleaseLastSenderRecipientIDs</a>()
<a name="l05300"></a>05300 {
<a name="l05301"></a>05301     m_strLastSenderUser.<a class="code" href="class_o_t_string.html#abef4b21b2170468705c58d64212d7257">Release</a>();      <span class="comment">// This is the last User ID of a party who SENT money.</span>
<a name="l05302"></a>05302     m_strLastSenderAcct.<a class="code" href="class_o_t_string.html#abef4b21b2170468705c58d64212d7257">Release</a>();      <span class="comment">// This is the last Acct ID of a party who SENT money.</span>
<a name="l05303"></a>05303     m_strLastRecipientUser.<a class="code" href="class_o_t_string.html#abef4b21b2170468705c58d64212d7257">Release</a>();   <span class="comment">// This is the last User ID of a party who RECEIVED money.</span>
<a name="l05304"></a>05304     m_strLastRecipientAcct.<a class="code" href="class_o_t_string.html#abef4b21b2170468705c58d64212d7257">Release</a>();   <span class="comment">// This is the last Acct ID of a party who RECEIVED money.</span>
<a name="l05305"></a>05305 }
<a name="l05306"></a>05306 
<a name="l05307"></a>05307 
<a name="l05308"></a>05308 <span class="comment">// We call this just before activation (in OT_API::activateSmartContract) in order</span>
<a name="l05309"></a>05309 <span class="comment">// to make sure that certain IDs and transaction #s are set, so the smart contract</span>
<a name="l05310"></a>05310 <span class="comment">// will interoperate with the old Cron Item system of doing things.</span>
<a name="l05311"></a>05311 <span class="comment">//</span>
<a name="l05312"></a><a class="code" href="class_o_t_smart_contract.html#afd41dba13f15554183828bd79f0cbb3f">05312</a> <span class="keywordtype">void</span> <a class="code" href="class_o_t_smart_contract.html#afd41dba13f15554183828bd79f0cbb3f">OTSmartContract::PrepareToActivate</a>(<span class="keyword">const</span> int64_t &amp; lOpeningTransNo,    <span class="keyword">const</span> int64_t &amp; lClosingTransNo,
<a name="l05313"></a>05313                                         <span class="keyword">const</span> <a class="code" href="class_o_t_identifier.html">OTIdentifier</a> &amp; theUserID, <span class="keyword">const</span> <a class="code" href="class_o_t_identifier.html">OTIdentifier</a> &amp; theAcctID)
<a name="l05314"></a>05314 {
<a name="l05315"></a>05315     <a class="code" href="class_o_t_trackable.html#a6ef06e21f2ad3616ab6b3a303662846d">SetTransactionNum</a>(lOpeningTransNo);
<a name="l05316"></a>05316 
<a name="l05317"></a>05317     <a class="code" href="class_o_t_cron_item.html#a3941f19ac62239dbeee9a300d9f8c2b1">ClearClosingNumbers</a>(); <span class="comment">// Just in case. Should be unnecessary, but you never know how people might screw around.</span>
<a name="l05318"></a>05318     <a class="code" href="class_o_t_cron_item.html#a310153e4e82ec7fbc887e93c4d12220d">AddClosingTransactionNo</a>(lClosingTransNo);
<a name="l05319"></a>05319 
<a name="l05320"></a>05320     <span class="comment">// -------------------------------------</span>
<a name="l05321"></a>05321 
<a name="l05322"></a>05322     <a class="code" href="class_o_t_trackable.html#a689cca3d471d7e85bec084d302f3cd83">SetSenderUserID</a>(theUserID); <span class="comment">// This is the activator of the contract. (NOT the actual &quot;sender&quot; of any single payment, in the case of smart contracts anyway.)</span>
<a name="l05323"></a>05323     <a class="code" href="class_o_t_trackable.html#a75814babcec8eb5cfed15047d4dfb4f6">SetSenderAcctID</a>(theAcctID); <span class="comment">// This is an account provided by the activator so a closing number and final receipt are guaranteed for this smart contract.</span>
<a name="l05324"></a>05324 
<a name="l05325"></a>05325     <span class="comment">// -------------------------------------</span>
<a name="l05326"></a>05326 
<a name="l05327"></a>05327     <a class="code" href="class_o_t_smart_contract.html#a09de789ac2e616e2119feb9ddf416c9d">ReleaseLastSenderRecipientIDs</a>(); <span class="comment">// These should be blank starting out anyway.</span>
<a name="l05328"></a>05328 
<a name="l05329"></a>05329     <span class="comment">// -------------------------------------</span>
<a name="l05330"></a>05330     <span class="comment">// You shouldn&#39;t have any of these anyway; the server only creates</span>
<a name="l05331"></a>05331     <span class="comment">// them after a smart contract is activated.</span>
<a name="l05332"></a>05332     <span class="comment">//</span>
<a name="l05333"></a>05333     <a class="code" href="class_o_t_smart_contract.html#a5e2972487aa71cb86d51393ed749f341">ReleaseStashes</a>();
<a name="l05334"></a>05334 }
<a name="l05335"></a>05335 
<a name="l05336"></a>05336 
<a name="l05337"></a>05337 <span class="comment">// return -1 if error, 0 if nothing, and 1 if the node was processed.</span>
<a name="l05338"></a><a class="code" href="class_o_t_smart_contract.html#a8524c56a7469d39a895bed4b18671972">05338</a> int32_t <a class="code" href="class_o_t_smart_contract.html#a8524c56a7469d39a895bed4b18671972">OTSmartContract::ProcessXMLNode</a>(<a class="code" href="namespaceirr_1_1io.html#a1628edbb9d5d53f18c82d2a92b0ad27e">irr::io::IrrXMLReader</a>*&amp; xml)
<a name="l05339"></a>05339 {
<a name="l05340"></a>05340     <span class="keyword">const</span> <a class="code" href="class_o_t_string.html">OTString</a> strNodeName(xml-&gt;getNodeName());
<a name="l05341"></a>05341 
<a name="l05342"></a>05342 
<a name="l05343"></a>05343 <span class="comment">//    OTLog::vError(&quot;-- CALLING SUPER CLASS -- OTSmartContract::ProcessXMLNode. strNodeName: %s \n&quot;,</span>
<a name="l05344"></a>05344 <span class="comment">//                  strNodeName.Get());</span>
<a name="l05345"></a>05345 
<a name="l05346"></a>05346     int32_t nReturnVal = 0;
<a name="l05347"></a>05347 
<a name="l05348"></a>05348     <span class="comment">// Here we call the parent class first.</span>
<a name="l05349"></a>05349     <span class="comment">// If the node is found there, or there is some error,</span>
<a name="l05350"></a>05350     <span class="comment">// then we just return either way.  But if it comes back</span>
<a name="l05351"></a>05351     <span class="comment">// as &#39;0&#39;, then nothing happened, and we&#39;ll continue executing.</span>
<a name="l05352"></a>05352     <span class="comment">//</span>
<a name="l05353"></a>05353     <span class="comment">// OTSmartContract::ProcessXMLNode calls OTCronItem::ProcessXMLNode,</span>
<a name="l05354"></a>05354     <span class="comment">// which calls OTScriptable... Meaning:</span>
<a name="l05355"></a>05355     <span class="comment">//</span>
<a name="l05356"></a>05356     <span class="comment">// NO NEED to explicitly load OTScriptable stuff here!</span>
<a name="l05357"></a>05357     <span class="comment">//</span>
<a name="l05358"></a>05358     nReturnVal = <a class="code" href="class_o_t_cron_item.html#a6b7eec23353a8ed49ee40a742c391aa3">ot_super::ProcessXMLNode</a>(xml);
<a name="l05359"></a>05359 
<a name="l05360"></a>05360     <span class="keywordflow">if</span> (0 != (nReturnVal))
<a name="l05361"></a>05361     {
<a name="l05362"></a>05362 <span class="comment">//        if ((-1) == nReturnVal)</span>
<a name="l05363"></a>05363 <span class="comment">//            OTLog::vError(&quot;**** ERROR**** in superclass...\n &quot;);</span>
<a name="l05364"></a>05364 
<a name="l05365"></a>05365         <span class="keywordflow">return</span> nReturnVal;
<a name="l05366"></a>05366     }
<a name="l05367"></a>05367     <span class="comment">// -------------------------------------------------</span>
<a name="l05368"></a>05368 
<a name="l05369"></a>05369 
<a name="l05370"></a>05370 
<a name="l05371"></a>05371 <span class="comment">//    OTLog::vError(&quot;-- FINISHED CALLING SUPER CLASS -- OTSmartContract::ProcessXMLNode:  strNodeName: %s \n&quot;, strNodeName.Get());</span>
<a name="l05372"></a>05372 
<a name="l05373"></a>05373 
<a name="l05374"></a>05374 
<a name="l05375"></a>05375     <span class="keywordflow">if</span> (strNodeName.Compare(<span class="stringliteral">&quot;smartContract&quot;</span>))
<a name="l05376"></a>05376     {
<a name="l05377"></a>05377         <a class="code" href="class_o_t_contract.html#aa0d889e0e1670b56fedca245041a5ed3">m_strVersion</a>    = xml-&gt;getAttributeValue(<span class="stringliteral">&quot;version&quot;</span>);
<a name="l05378"></a>05378 
<a name="l05379"></a>05379         <span class="keyword">const</span> <a class="code" href="class_o_t_string.html">OTString</a>  strServerID       (xml-&gt;getAttributeValue(<span class="stringliteral">&quot;serverID&quot;</span>));
<a name="l05380"></a>05380         <span class="keyword">const</span> <a class="code" href="class_o_t_string.html">OTString</a>  strActivatorUserID(xml-&gt;getAttributeValue(<span class="stringliteral">&quot;activatorUserID&quot;</span>));
<a name="l05381"></a>05381         <span class="keyword">const</span> <a class="code" href="class_o_t_string.html">OTString</a>  strActivatorAcctID(xml-&gt;getAttributeValue(<span class="stringliteral">&quot;activatorAcctID&quot;</span>));
<a name="l05382"></a>05382         <span class="keyword">const</span> <a class="code" href="class_o_t_string.html">OTString</a>  strCanceled       (xml-&gt;getAttributeValue(<span class="stringliteral">&quot;canceled&quot;</span>));
<a name="l05383"></a>05383         <span class="keyword">const</span> <a class="code" href="class_o_t_string.html">OTString</a>  strCancelerUserID (xml-&gt;getAttributeValue(<span class="stringliteral">&quot;cancelerUserID&quot;</span>));
<a name="l05384"></a>05384 
<a name="l05385"></a>05385         <span class="keywordflow">if</span> (strServerID.Exists())
<a name="l05386"></a>05386         {
<a name="l05387"></a>05387             <span class="keyword">const</span> <a class="code" href="class_o_t_identifier.html">OTIdentifier</a>  SERVER_ID(strServerID);
<a name="l05388"></a>05388             <a class="code" href="class_o_t_instrument.html#a80fc5560fdedf911ec0c184ab9fbb5b7">SetServerID</a>(SERVER_ID);
<a name="l05389"></a>05389         }
<a name="l05390"></a>05390         <span class="keywordflow">if</span> (strActivatorUserID.Exists())
<a name="l05391"></a>05391         {
<a name="l05392"></a>05392             <span class="keyword">const</span> <a class="code" href="class_o_t_identifier.html">OTIdentifier</a>  ACTIVATOR_USER_ID(strActivatorUserID);
<a name="l05393"></a>05393             <a class="code" href="class_o_t_trackable.html#a689cca3d471d7e85bec084d302f3cd83">SetSenderUserID</a>(ACTIVATOR_USER_ID);
<a name="l05394"></a>05394         }
<a name="l05395"></a>05395         <span class="keywordflow">if</span> (strActivatorAcctID.Exists())
<a name="l05396"></a>05396         {
<a name="l05397"></a>05397             <span class="keyword">const</span> <a class="code" href="class_o_t_identifier.html">OTIdentifier</a>  ACTIVATOR_ACCT_ID(strActivatorAcctID);
<a name="l05398"></a>05398             <a class="code" href="class_o_t_trackable.html#a75814babcec8eb5cfed15047d4dfb4f6">SetSenderAcctID</a>(ACTIVATOR_ACCT_ID);
<a name="l05399"></a>05399         }
<a name="l05400"></a>05400 
<a name="l05401"></a>05401         <span class="comment">// ----------------------</span>
<a name="l05402"></a>05402         <span class="keywordflow">if</span> (strCanceled.Exists() &amp;&amp; strCanceled.Compare(<span class="stringliteral">&quot;true&quot;</span>))
<a name="l05403"></a>05403         {
<a name="l05404"></a>05404             <a class="code" href="class_o_t_cron_item.html#abe9ce5c7b4d2fe652908e1f81f2f3b67">m_bCanceled</a> = <span class="keyword">true</span>;
<a name="l05405"></a>05405 
<a name="l05406"></a>05406             <span class="keywordflow">if</span> (strCancelerUserID.Exists())
<a name="l05407"></a>05407                 <a class="code" href="class_o_t_cron_item.html#af7bb48c16e16f664b938a7f235d2872d">m_pCancelerNymID</a>-&gt;<a class="code" href="class_o_t_identifier.html#ae29aa1245d3831a207aabc9b8a493bfc">SetString</a>(strCancelerUserID);
<a name="l05408"></a>05408             <span class="comment">// else log</span>
<a name="l05409"></a>05409         }
<a name="l05410"></a>05410         <span class="keywordflow">else</span>
<a name="l05411"></a>05411         {
<a name="l05412"></a>05412             <a class="code" href="class_o_t_cron_item.html#abe9ce5c7b4d2fe652908e1f81f2f3b67">m_bCanceled</a> = <span class="keyword">false</span>;
<a name="l05413"></a>05413             <a class="code" href="class_o_t_cron_item.html#af7bb48c16e16f664b938a7f235d2872d">m_pCancelerNymID</a>-&gt;<a class="code" href="class_o_t_data.html#aab9a5758e85597ef1d7250bcf2cc56a6">Release</a>();
<a name="l05414"></a>05414         }
<a name="l05415"></a>05415         <span class="comment">// ----------------------------------------------------------------------------</span>
<a name="l05416"></a>05416         <span class="keyword">const</span> <a class="code" href="class_o_t_string.html">OTString</a> strTransNum = xml-&gt;getAttributeValue(<span class="stringliteral">&quot;transactionNum&quot;</span>);
<a name="l05417"></a>05417 
<a name="l05418"></a>05418         <a class="code" href="class_o_t_trackable.html#a6ef06e21f2ad3616ab6b3a303662846d">SetTransactionNum</a>( strTransNum.<a class="code" href="class_o_t_string.html#adf7489cd917d4ae5bf30853a3ad78daf">Exists</a>() ? atol(strTransNum.<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>()) : 0 );
<a name="l05419"></a>05419         <span class="comment">// ----------------------------------------------------------------------------</span>
<a name="l05420"></a>05420         <span class="keyword">const</span> <a class="code" href="class_o_t_string.html">OTString</a> str_valid_from   = xml-&gt;getAttributeValue(<span class="stringliteral">&quot;validFrom&quot;</span>);
<a name="l05421"></a>05421         <span class="keyword">const</span> <a class="code" href="class_o_t_string.html">OTString</a> str_valid_to     = xml-&gt;getAttributeValue(<span class="stringliteral">&quot;validTo&quot;</span>);
<a name="l05422"></a>05422         <span class="keyword">const</span> <a class="code" href="class_o_t_string.html">OTString</a> str_creation     = xml-&gt;getAttributeValue(<span class="stringliteral">&quot;creationDate&quot;</span>);
<a name="l05423"></a>05423         <span class="keyword">const</span> <a class="code" href="class_o_t_string.html">OTString</a> str_next_process = xml-&gt;getAttributeValue(<span class="stringliteral">&quot;nextProcessDate&quot;</span>);
<a name="l05424"></a>05424         <span class="comment">// ----------------------------------------------------------------------------</span>
<a name="l05425"></a>05425         int64_t tValidFrom   = str_valid_from.<a class="code" href="class_o_t_string.html#a18ca8f42f6e90ab7801c019611d9dca8">ToLong</a>();
<a name="l05426"></a>05426         int64_t tValidTo     = str_valid_to.<a class="code" href="class_o_t_string.html#a18ca8f42f6e90ab7801c019611d9dca8">ToLong</a>();
<a name="l05427"></a>05427         int64_t tCreation    = str_creation.<a class="code" href="class_o_t_string.html#a18ca8f42f6e90ab7801c019611d9dca8">ToLong</a>();
<a name="l05428"></a>05428         int64_t tNextProcess = str_next_process.<a class="code" href="class_o_t_string.html#a18ca8f42f6e90ab7801c019611d9dca8">ToLong</a>();
<a name="l05429"></a>05429         <span class="comment">// ----------------------------------------------------------------------------</span>
<a name="l05430"></a>05430         <a class="code" href="class_o_t_instrument.html#af8e356f6956ad222a1766435edca8374">SetValidFrom</a>(<a class="code" href="_o_t_common_8hpp.html#a5c0893ffd83818f1c3c6b3b7ae92da13">OTTimeGetTimeFromSeconds</a>(tValidFrom));
<a name="l05431"></a>05431         <a class="code" href="class_o_t_instrument.html#a5baef9beffaf6627cd9d5277fdbb14c3">SetValidTo</a>(<a class="code" href="_o_t_common_8hpp.html#a5c0893ffd83818f1c3c6b3b7ae92da13">OTTimeGetTimeFromSeconds</a>(tValidTo));
<a name="l05432"></a>05432         <a class="code" href="class_o_t_cron_item.html#a7668dc44368861c09a47de0f420cf2fa">SetCreationDate</a>(<a class="code" href="_o_t_common_8hpp.html#a5c0893ffd83818f1c3c6b3b7ae92da13">OTTimeGetTimeFromSeconds</a>(tCreation));
<a name="l05433"></a>05433         <a class="code" href="class_o_t_smart_contract.html#a0c0ffa47dacaa8fa79304317f8e04544">SetNextProcessDate</a>(<a class="code" href="_o_t_common_8hpp.html#a5c0893ffd83818f1c3c6b3b7ae92da13">OTTimeGetTimeFromSeconds</a>(tNextProcess));
<a name="l05434"></a>05434         <span class="comment">// ----------------------------------------------------------------------------</span>
<a name="l05435"></a>05435         <span class="comment">// These are stored for RECEIPTS, so if there is an inbox receipt with an amount,</span>
<a name="l05436"></a>05436         <span class="comment">// we will know who was sending and receiving.  If sender or receiver is blank, that</span>
<a name="l05437"></a>05437         <span class="comment">// means the source/destination was a STASH instead of an account. FYI.</span>
<a name="l05438"></a>05438         <span class="comment">//</span>
<a name="l05439"></a>05439         m_strLastSenderUser     = xml-&gt;getAttributeValue(<span class="stringliteral">&quot;lastSenderUserID&quot;</span>);    <span class="comment">// Last User ID of a party who SENT money.</span>
<a name="l05440"></a>05440         m_strLastSenderAcct     = xml-&gt;getAttributeValue(<span class="stringliteral">&quot;lastSenderAcctID&quot;</span>);    <span class="comment">// Last Acct ID of a party who SENT money.</span>
<a name="l05441"></a>05441         m_strLastRecipientUser  = xml-&gt;getAttributeValue(<span class="stringliteral">&quot;lastRecipientUserID&quot;</span>); <span class="comment">// Last User ID of a party who RECEIVED money.</span>
<a name="l05442"></a>05442         m_strLastRecipientAcct  = xml-&gt;getAttributeValue(<span class="stringliteral">&quot;lastRecipientAcctID&quot;</span>); <span class="comment">// Last Acct ID of a party who RECEIVED money.</span>
<a name="l05443"></a>05443         <span class="comment">// ----------------------------------------------------------------------------</span>
<a name="l05444"></a>05444         <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(1, <span class="stringliteral">&quot;\n\n Smartcontract. Transaction Number: %lld\n&quot;</span>, <a class="code" href="class_o_t_trackable.html#a90bc18f9b5d6b3c8059a83685b86674e">m_lTransactionNum</a>);
<a name="l05445"></a>05445 
<a name="l05446"></a>05446         <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(2,
<a name="l05447"></a>05447                        <span class="stringliteral">&quot; Creation Date: %&quot;</span> PRId64<span class="stringliteral">&quot;   Valid From: %&quot;</span> PRId64<span class="stringliteral">&quot;\n Valid To: %&quot;</span> PRId64<span class="stringliteral">&quot;\n&quot;</span>
<a name="l05448"></a>05448                        <span class="stringliteral">&quot; ServerID: %s\n&quot;</span>
<a name="l05449"></a>05449                        <span class="stringliteral">&quot; activatorUserID: %s\n &quot;</span>,
<a name="l05450"></a>05450                        tCreation, tValidFrom, tValidTo,
<a name="l05451"></a>05451                        strServerID.Get(),
<a name="l05452"></a>05452                        strActivatorUserID.Get());
<a name="l05453"></a>05453 
<a name="l05454"></a>05454         nReturnVal = 1;
<a name="l05455"></a>05455     }
<a name="l05456"></a>05456 
<a name="l05457"></a>05457     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strNodeName.Compare(<span class="stringliteral">&quot;accountList&quot;</span>)) <span class="comment">// the stash reserve account IDs.</span>
<a name="l05458"></a>05458     {
<a name="l05459"></a>05459         <span class="keyword">const</span> <a class="code" href="class_o_t_string.html">OTString</a> strAcctType  = xml-&gt;getAttributeValue(<span class="stringliteral">&quot;type&quot;</span>);
<a name="l05460"></a>05460         <span class="keyword">const</span> <a class="code" href="class_o_t_string.html">OTString</a> strAcctCount = xml-&gt;getAttributeValue(<span class="stringliteral">&quot;count&quot;</span>);
<a name="l05461"></a>05461 
<a name="l05462"></a>05462         <span class="keywordflow">if</span> ((-1) == m_StashAccts.<a class="code" href="class_o_t_acct_list.html#ab821444a5a7e7cc453182e755d5a00dc">ReadFromXMLNode</a>(xml, strAcctType, strAcctCount))
<a name="l05463"></a>05463         {
<a name="l05464"></a>05464             <a class="code" href="class_o_t_log.html#a5acd90ac91c2618f395b0ff37ad4f8ee">OTLog::Error</a>(<span class="stringliteral">&quot;OTSmartContract::ProcessXMLNode: Error loading stash accountList.\n&quot;</span>);
<a name="l05465"></a>05465             nReturnVal = (-1);
<a name="l05466"></a>05466         }
<a name="l05467"></a>05467         <span class="keywordflow">else</span>
<a name="l05468"></a>05468             nReturnVal = 1;
<a name="l05469"></a>05469     }
<a name="l05470"></a>05470 
<a name="l05471"></a>05471     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strNodeName.Compare(<span class="stringliteral">&quot;stash&quot;</span>)) <span class="comment">// the actual stashes.</span>
<a name="l05472"></a>05472     {
<a name="l05473"></a>05473         <span class="keyword">const</span> <a class="code" href="class_o_t_string.html">OTString</a> strStashName = xml-&gt;getAttributeValue(<span class="stringliteral">&quot;name&quot;</span>);
<a name="l05474"></a>05474         <span class="keyword">const</span> <a class="code" href="class_o_t_string.html">OTString</a> strItemCount = xml-&gt;getAttributeValue(<span class="stringliteral">&quot;count&quot;</span>);
<a name="l05475"></a>05475 
<a name="l05476"></a>05476         <span class="keyword">const</span> std::string str_stash_name = strStashName.<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>();
<a name="l05477"></a>05477         <a class="code" href="class_o_t_stash.html">OTStash</a> * pStash = <span class="keyword">new</span> <a class="code" href="class_o_t_stash.html">OTStash</a>(str_stash_name);
<a name="l05478"></a>05478         <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != pStash);
<a name="l05479"></a>05479 
<a name="l05480"></a>05480         <span class="keywordflow">if</span> ((-1) == pStash-&gt;<a class="code" href="class_o_t_stash.html#a71923cb44bd1c4273b77ba760ebd4067">ReadFromXMLNode</a>(xml, strStashName, strItemCount))
<a name="l05481"></a>05481         {
<a name="l05482"></a>05482             <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;OTSmartContract::ProcessXMLNode: Error loading stash: %s\n&quot;</span>,
<a name="l05483"></a>05483                           strStashName.<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>());
<a name="l05484"></a>05484             <span class="keyword">delete</span> pStash;
<a name="l05485"></a>05485             nReturnVal = (-1);
<a name="l05486"></a>05486         }
<a name="l05487"></a>05487         <span class="keywordflow">else</span>
<a name="l05488"></a>05488         {
<a name="l05489"></a>05489             <span class="comment">// Success</span>
<a name="l05490"></a>05490             <span class="comment">//</span>
<a name="l05491"></a>05491             m_mapStashes.insert(std::pair&lt;std::string, OTStash *&gt;(strStashName.<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>(), pStash));
<a name="l05492"></a>05492 
<a name="l05493"></a>05493             nReturnVal = 1;
<a name="l05494"></a>05494         }
<a name="l05495"></a>05495     }
<a name="l05496"></a>05496 
<a name="l05497"></a>05497 <span class="comment">//    OTLog::vError(&quot;-- FINALLY -- OTSmartContract::ProcessXMLNode:  nReturnVal: %d  strNodeName: %s \n&quot;,</span>
<a name="l05498"></a>05498 <span class="comment">//                  nReturnVal, strNodeName.Get());</span>
<a name="l05499"></a>05499 
<a name="l05500"></a>05500     <span class="keywordflow">return</span> nReturnVal;
<a name="l05501"></a>05501 }
<a name="l05502"></a>05502 
<a name="l05503"></a>05503 
<a name="l05504"></a><a class="code" href="class_o_t_smart_contract.html#aa39d672a40e0778c205ed308b86c6927">05504</a> <span class="keywordtype">bool</span> <a class="code" href="class_o_t_smart_contract.html#aa39d672a40e0778c205ed308b86c6927">OTSmartContract::SaveContractWallet</a>(std::ofstream &amp; ofs)
<a name="l05505"></a>05505 {
<a name="l05506"></a>05506     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l05507"></a>05507 }
</pre></div></div><!-- contents -->
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="_o_t_smart_contract_8cpp.html">OTSmartContract.cpp</a>      </li>

    <li class="footer">Generated on Wed May 21 2014 11:26:04 for Open-Transactions by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1 </li>
   </ul>
 </div>


</body>
</html>
