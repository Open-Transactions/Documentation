<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Open-Transactions: OTCachedKey Class Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Open-Transactions
   &#160;<span id="projectnumber">master/1066fb4910a63ee3f7de8e0807fee3eb663b66c7</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('class_o_t_cached_key.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">OTCachedKey Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<!-- doxytag: class="OTCachedKey" -->
<p><code>#include &lt;<a class="el" href="_o_t_cached_key_8hpp_source.html">OTCachedKey.hpp</a>&gt;</code></p>

<p><a href="class_o_t_cached_key-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">tthread::mutex *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_t_cached_key.html#a0b51adc5e45ea1e377febeaad27dbb60">GetMutex</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">EXPORT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_t_cached_key.html#af19207ce069d02be362773cfb02424d6">OTCachedKey</a> (const <a class="el" href="class_o_t_a_s_c_i_i_armor.html">OTASCIIArmor</a> &amp;ascCachedKey)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">EXPORT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_t_cached_key.html#aad66d1eeb1f84fbcd82fe796bdb393bd">~OTCachedKey</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_t_cached_key.html#acec139cffbbad3a4bc3e45e69748f43a">GetIdentifier</a> (<a class="el" href="class_o_t_identifier.html">OTIdentifier</a> &amp;theIdentifier) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_t_cached_key.html#a2914f95a9df7bc9265b50571624ec375">GetIdentifier</a> (<a class="el" href="class_o_t_string.html">OTString</a> &amp;strIdentifier) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_t_cached_key.html#a841c81a6323383f9762f21cc820bbdab">IsGenerated</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_t_cached_key.html#a1b868584e683faa9cd4cc63bcd5bc3f4">HasHashCheck</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_t_cached_key.html#a95adb6583e128ed03719dc365e14005e">IsUsingSystemKeyring</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_t_cached_key.html#a6dd72d33332ed12525d15f0861960c5f">UseSystemKeyring</a> (bool bUsing=true)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_t_cached_key.html#af778e40cf52dedde7c1896b3fbb2e02b">Pause</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_t_cached_key.html#a0fa693b734082f41578b9984d242dd79">Unpause</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_t_cached_key.html#aef5e98808a18741cb9c8c240f702e996">isPaused</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_t_cached_key.html#a5f7a335ec7dc9ac8fd2b1ebf2ef26dd8">SerializeTo</a> (<a class="el" href="class_o_t_a_s_c_i_i_armor.html">OTASCIIArmor</a> &amp;ascOutput)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_t_cached_key.html#a4544aaabde49afd185df0fa05b775679">SerializeFrom</a> (const <a class="el" href="class_o_t_a_s_c_i_i_armor.html">OTASCIIArmor</a> &amp;ascInput)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_t_cached_key.html#aa23079dbadddf2d7f2a2f205e3c05738">SetCachedKey</a> (const <a class="el" href="class_o_t_a_s_c_i_i_armor.html">OTASCIIArmor</a> &amp;ascCachedKey)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">EXPORT int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_t_cached_key.html#ac0de8ead34b8bff4913844507987e61a">GetTimeoutSeconds</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_t_cached_key.html#a7b0822845b243c8f739f021d0f96bcd7">SetTimeoutSeconds</a> (int32_t nTimeoutSeconds)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">EXPORT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_t_cached_key.html#ab5afd7677fed682812ac40de76f5f5db">GetMasterPassword</a> (<a class="el" href="_t_r1___wrapper_8hpp.html#a4081b6aa22d0f454ce7498756ea212ff">_SharedPtr</a>&lt; <a class="el" href="class_o_t_cached_key.html">OTCachedKey</a> &gt; &amp;mySharedPtr, <a class="el" href="class_o_t_password.html">OTPassword</a> &amp;theOutput, const char *szDisplay=NULL, bool bVerifyTwice=false)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_t_cached_key.html#a6bf2bbe368339460eb08cf9dc42eeced">DestroyMasterPassword</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_t_cached_key.html#a3ed776977711a2d217fff380dd6cd3c5">ResetMasterPassword</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_t_cached_key.html#a6933e0f88aae70fe30b925f150e8cc20">LowLevelReleaseThread</a> ()</td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static EXPORT <a class="el" href="_t_r1___wrapper_8hpp.html#a4081b6aa22d0f454ce7498756ea212ff">_SharedPtr</a><br class="typebreak"/>
&lt; <a class="el" href="class_o_t_cached_key.html">OTCachedKey</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_t_cached_key.html#a8780b8a3f392b0bc4c11253a797d8b5a">It</a> (<a class="el" href="class_o_t_identifier.html">OTIdentifier</a> *pIdentifier=NULL)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static EXPORT <a class="el" href="_t_r1___wrapper_8hpp.html#a4081b6aa22d0f454ce7498756ea212ff">_SharedPtr</a><br class="typebreak"/>
&lt; <a class="el" href="class_o_t_cached_key.html">OTCachedKey</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_t_cached_key.html#a47cf6d6425469515db0e21ec4e4b4833">It</a> (<a class="el" href="class_o_t_cached_key.html">OTCachedKey</a> &amp;theSourceKey)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_t_cached_key.html#a60f1041be525c88bde575ac183e64435">Cleanup</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static EXPORT <a class="el" href="_t_r1___wrapper_8hpp.html#a4081b6aa22d0f454ce7498756ea212ff">_SharedPtr</a><br class="typebreak"/>
&lt; <a class="el" href="class_o_t_cached_key.html">OTCachedKey</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_t_cached_key.html#a97bb15bbe2b2a100a5379b835c4b539d">CreateMasterPassword</a> (<a class="el" href="class_o_t_password.html">OTPassword</a> &amp;theOutput, const char *szDisplay=NULL, int32_t nTimeoutSeconds=<a class="el" href="_o_t_cached_key_8hpp.html#a359f8993fefe08ca989f8715ec6f0a43">OT_MASTER_KEY_TIMEOUT</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static EXPORT void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_t_cached_key.html#a7ac7c4130bd8d8cb9a443be54ae5e004">ThreadTimeout</a> (void *pArg)</td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock">
<p>Definition at line <a class="el" href="_o_t_cached_key_8hpp_source.html#l00252">252</a> of file <a class="el" href="_o_t_cached_key_8hpp_source.html">OTCachedKey.hpp</a>.</p>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="af19207ce069d02be362773cfb02424d6"></a><!-- doxytag: member="OTCachedKey::OTCachedKey" ref="af19207ce069d02be362773cfb02424d6" args="(const OTASCIIArmor &amp;ascCachedKey)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OTCachedKey::OTCachedKey </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_t_a_s_c_i_i_armor.html">OTASCIIArmor</a> &amp;&#160;</td>
          <td class="paramname"><em>ascCachedKey</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_o_t_cached_key_8cpp_source.html#l00349">349</a> of file <a class="el" href="_o_t_cached_key_8cpp_source.html">OTCachedKey.cpp</a>.</p>
<div class="fragment"><pre class="fragment">                                                          :
    m_pThread(NULL),
    m_nTimeoutSeconds(<a class="code" href="class_o_t_cached_key.html#a8780b8a3f392b0bc4c11253a797d8b5a">OTCachedKey::It</a>()-&gt;<a class="code" href="class_o_t_cached_key.html#ac0de8ead34b8bff4913844507987e61a">GetTimeoutSeconds</a>()),
    m_pMasterPassword(NULL), <span class="comment">// This is created in GetMasterPassword, and destroyed by a timer thread sometime soon after.</span>
    m_bUse_System_Keyring(<a class="code" href="class_o_t_cached_key.html#a8780b8a3f392b0bc4c11253a797d8b5a">OTCachedKey::It</a>()-&gt;<a class="code" href="class_o_t_cached_key.html#a95adb6583e128ed03719dc365e14005e">IsUsingSystemKeyring</a>()), <span class="comment">// this master key instance will decide to use the system keyring based on what the global master key instance is set to do. (So we get the same settings from config file, etc.)</span>
    m_pSymmetricKey(NULL),   <span class="comment">// OTServer OR OTWallet owns this key, and sets this pointer. It&#39;s the encrypted form of s_pMasterPassword.</span>
    m_bPaused(<span class="keyword">false</span>)
{
    <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(ascCachedKey.<a class="code" href="class_o_t_string.html#adf7489cd917d4ae5bf30853a3ad78daf">Exists</a>());
    this-&gt;<a class="code" href="class_o_t_cached_key.html#aa23079dbadddf2d7f2a2f205e3c05738">SetCachedKey</a>(ascCachedKey);
}
</pre></div>
</div>
</div>
<a class="anchor" id="aad66d1eeb1f84fbcd82fe796bdb393bd"></a><!-- doxytag: member="OTCachedKey::~OTCachedKey" ref="aad66d1eeb1f84fbcd82fe796bdb393bd" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_t_cached_key.html#aad66d1eeb1f84fbcd82fe796bdb393bd">OTCachedKey::~OTCachedKey</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_o_t_cached_key_8cpp_source.html#l00429">429</a> of file <a class="el" href="_o_t_cached_key_8cpp_source.html">OTCachedKey.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
    tthread::lock_guard&lt;tthread::mutex&gt; lock(m_Mutex);  <span class="comment">// I figured this would cause some kind of problem but how else can I mess with the members unless I lock this?</span>
    <span class="comment">// --------------------</span>
    <a class="code" href="class_o_t_cached_key.html#a6933e0f88aae70fe30b925f150e8cc20">LowLevelReleaseThread</a>();
    <span class="comment">// -----</span>
    <span class="keywordflow">if</span> (NULL != m_pMasterPassword)  <span class="comment">// Only stored temporarily, the purpose of this class is to destoy it after a timer.</span>
    {
        <a class="code" href="class_o_t_password.html">OTPassword</a> * pPassword = m_pMasterPassword;

        m_pMasterPassword = NULL;

        <span class="keyword">delete</span> pPassword; pPassword = NULL;
    }
    <span class="comment">// -----</span>
    <span class="keywordflow">if</span> (NULL != m_pSymmetricKey)       <span class="comment">// Owned / based on a string passed in. Stored somewhere else (OTServer, OTWallet...)</span>
    {
        <a class="code" href="class_o_t_symmetric_key.html">OTSymmetricKey</a> * pSymmetricKey = m_pSymmetricKey;

        m_pSymmetricKey = NULL;

        <span class="keyword">delete</span> pSymmetricKey; pSymmetricKey = NULL;
    }
    <span class="comment">// -----</span>
}
</pre></div>
</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a60f1041be525c88bde575ac183e64435"></a><!-- doxytag: member="OTCachedKey::Cleanup" ref="a60f1041be525c88bde575ac183e64435" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_o_t_cached_key.html#a60f1041be525c88bde575ac183e64435">OTCachedKey::Cleanup</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_o_t_cached_key_8cpp_source.html#l00320">320</a> of file <a class="el" href="_o_t_cached_key_8cpp_source.html">OTCachedKey.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
    tthread::lock_guard&lt;tthread::mutex&gt; lock(OTCachedKey::s_mutexCachedKeys);
    <span class="comment">// ----------------------------------</span>
    s_mapCachedKeys.clear();

<span class="comment">//  while (!s_mapCachedKeys.empty())</span>
<span class="comment">//  {</span>
<span class="comment">//      OTCachedKey * pTemp = s_mapCachedKeys.begin()-&gt;second;</span>
<span class="comment">//      OT_ASSERT(NULL != pTemp);</span>
<span class="comment">//      s_mapCachedKeys.erase(s_mapCachedKeys.begin());</span>
<span class="comment">//      delete pTemp; pTemp = NULL;</span>
<span class="comment">//  }</span>
    <span class="comment">// ------------------------</span>
}
</pre></div>
</div>
</div>
<a class="anchor" id="a97bb15bbe2b2a100a5379b835c4b539d"></a><!-- doxytag: member="OTCachedKey::CreateMasterPassword" ref="a97bb15bbe2b2a100a5379b835c4b539d" args="(OTPassword &amp;theOutput, const char *szDisplay=NULL, int32_t nTimeoutSeconds=OT_MASTER_KEY_TIMEOUT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_t_r1___wrapper_8hpp.html#a4081b6aa22d0f454ce7498756ea212ff">_SharedPtr</a>&lt; <a class="el" href="class_o_t_cached_key.html">OTCachedKey</a> &gt; <a class="el" href="class_o_t_cached_key.html#a97bb15bbe2b2a100a5379b835c4b539d">OTCachedKey::CreateMasterPassword</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_t_password.html">OTPassword</a> &amp;&#160;</td>
          <td class="paramname"><em>theOutput</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>szDisplay</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>nTimeoutSeconds</em> = <code><a class="el" href="_o_t_cached_key_8hpp.html#a359f8993fefe08ca989f8715ec6f0a43">OT_MASTER_KEY_TIMEOUT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_o_t_cached_key_8cpp_source.html#l00577">577</a> of file <a class="el" href="_o_t_cached_key_8cpp_source.html">OTCachedKey.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
    _SharedPtr&lt;OTCachedKey&gt; pMaster(<span class="keyword">new</span> <a class="code" href="class_o_t_cached_key.html">OTCachedKey</a>(nTimeoutSeconds));
    <span class="comment">// -------------------</span>
    <span class="keyword">const</span> <a class="code" href="class_o_t_string.html">OTString</a> strDisplay((NULL == szDisplay) ? <span class="stringliteral">&quot;Creating a passphrase...&quot;</span> : szDisplay); <span class="comment">// todo internationalization / hardcoding.</span>

    <span class="keyword">const</span> <span class="keywordtype">bool</span> bGotPassphrase = pMaster-&gt;GetMasterPassword(pMaster, theOutput, strDisplay.Get(), <span class="keyword">true</span>); <span class="comment">//bool bVerifyTwice=false by default. Really we didn&#39;t have to pass true here, since it asks twice anyway, when first generating the key.</span>

    <span class="keywordflow">if</span> (bGotPassphrase) <span class="comment">// success!</span>
        <span class="keywordflow">return</span> pMaster;
    <span class="comment">// ----------------------------</span>
    <span class="comment">// If we&#39;re still here, that means bGotPassphrase failed.</span>
    <span class="comment">//</span>
<span class="comment">//    delete pMaster; pMaster = NULL;</span>
    <span class="keywordflow">return</span> _SharedPtr&lt;OTCachedKey&gt;();
}
</pre></div>
</div>
</div>
<a class="anchor" id="a6bf2bbe368339460eb08cf9dc42eeced"></a><!-- doxytag: member="OTCachedKey::DestroyMasterPassword" ref="a6bf2bbe368339460eb08cf9dc42eeced" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_o_t_cached_key.html#a6bf2bbe368339460eb08cf9dc42eeced">OTCachedKey::DestroyMasterPassword</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_o_t_cached_key_8cpp_source.html#l01086">1086</a> of file <a class="el" href="_o_t_cached_key_8cpp_source.html">OTCachedKey.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
    tthread::lock_guard&lt;tthread::mutex&gt; lock(m_Mutex); <span class="comment">// Multiple threads can&#39;t get inside here at the same time.</span>
    <span class="comment">//</span>
    <span class="keywordflow">if</span> (m_nTimeoutSeconds != (-1))
    {
        <span class="comment">// (m_pSymmetricKey stays.</span>
        <span class="comment">//  m_pMasterPassword only is destroyed.)</span>
        <span class="comment">//</span>
        <span class="keywordflow">if</span> (NULL != m_pMasterPassword)
        {
            <a class="code" href="class_o_t_password.html">OTPassword</a> * pPassword = m_pMasterPassword;

            m_pMasterPassword = NULL;

            <span class="keyword">delete</span> pPassword; pPassword = NULL;
        }
    }
    <span class="comment">// (We do NOT call LowLevelReleaseThread(); here, since the thread is</span>
    <span class="comment">// what CALLED this function. Instead, we destroy / NULL the master password,</span>
    <span class="comment">// so that next time around we will see it is NULL and THEN we will know to</span>
    <span class="comment">// call LowLevelReleaseThread(); before instantiating a new one.)</span>

    <span class="comment">// ---------------------------------------</span>

    <span class="comment">// New: When the master password is destroyed here, we also remove it from</span>
    <span class="comment">// the system keychain:</span>
    <span class="comment">//</span>
    <span class="keywordflow">if</span> (NULL != m_pSymmetricKey)
    {
        <span class="keyword">const</span> std::string str_display;
        <span class="comment">// -----------------------------------------------------</span>
        <span class="keyword">const</span> <a class="code" href="class_o_t_identifier.html">OTIdentifier</a> idCachedKey(*m_pSymmetricKey);
        <span class="keyword">const</span> <a class="code" href="class_o_t_string.html">OTString</a>     strCachedKeyHash(idCachedKey); <span class="comment">// Same thing, in string form.</span>
        <span class="comment">// -----------------------------------------------------</span>
        <span class="keyword">const</span> <span class="keywordtype">bool</span> bDeletedSecret = this-&gt;<a class="code" href="class_o_t_cached_key.html#a95adb6583e128ed03719dc365e14005e">IsUsingSystemKeyring</a>() &amp;&amp;
                            <a class="code" href="class_o_t_keyring.html#a129634f61201323134ce7bde1acdc612">OTKeyring::DeleteSecret</a>(
                                  strCachedKeyHash, <span class="comment">// HASH OF ENCRYPTED MASTER KEY</span>
                                  str_display);     <span class="comment">// &quot;optional&quot; display string.</span>
        <span class="keywordflow">if</span> (bDeletedSecret)
        {
            <a class="code" href="class_o_t_log.html#a1f7549d776ee919dcb6517f611ded015">OTLog::Output</a>(0, <span class="stringliteral">&quot;OTCachedKey::DestroyMasterPassword: FYI, deleted &quot;</span>
                          <span class="stringliteral">&quot;the derived key (used for unlocking the master key password) &quot;</span>
                          <span class="stringliteral">&quot;from system keychain at the same time as we deleted the master key &quot;</span>
                          <span class="stringliteral">&quot;password from OT internally, due to password timeout.\n&quot;</span>);
        }
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="acec139cffbbad3a4bc3e45e69748f43a"></a><!-- doxytag: member="OTCachedKey::GetIdentifier" ref="acec139cffbbad3a4bc3e45e69748f43a" args="(OTIdentifier &amp;theIdentifier) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_o_t_cached_key.html#acec139cffbbad3a4bc3e45e69748f43a">OTCachedKey::GetIdentifier</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_t_identifier.html">OTIdentifier</a> &amp;&#160;</td>
          <td class="paramname"><em>theIdentifier</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_o_t_cached_key_8cpp_source.html#l00540">540</a> of file <a class="el" href="_o_t_cached_key_8cpp_source.html">OTCachedKey.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
    tthread::lock_guard&lt;tthread::mutex&gt; lock((const_cast&lt;OTCachedKey *&gt;(<span class="keyword">this</span>))-&gt;m_Mutex);

    <span class="keywordflow">if</span> ((NULL == m_pSymmetricKey) || !m_pSymmetricKey-&gt;<a class="code" href="class_o_t_symmetric_key.html#a9e2eced2ded569ff96ddace6488a7968">IsGenerated</a>())
        <span class="keywordflow">return</span> <span class="keyword">false</span>;

    m_pSymmetricKey-&gt;<a class="code" href="class_o_t_symmetric_key.html#a70cc2a2c32250ae5c005df3fac0497ba">GetIdentifier</a>(theIdentifier);
    <span class="keywordflow">return</span> <span class="keyword">true</span>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a2914f95a9df7bc9265b50571624ec375"></a><!-- doxytag: member="OTCachedKey::GetIdentifier" ref="a2914f95a9df7bc9265b50571624ec375" args="(OTString &amp;strIdentifier) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_o_t_cached_key.html#acec139cffbbad3a4bc3e45e69748f43a">OTCachedKey::GetIdentifier</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_t_string.html">OTString</a> &amp;&#160;</td>
          <td class="paramname"><em>strIdentifier</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_o_t_cached_key_8cpp_source.html#l00552">552</a> of file <a class="el" href="_o_t_cached_key_8cpp_source.html">OTCachedKey.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
    tthread::lock_guard&lt;tthread::mutex&gt; lock((const_cast&lt;OTCachedKey *&gt;(<span class="keyword">this</span>))-&gt;m_Mutex);

    <span class="keywordflow">if</span> ((NULL == m_pSymmetricKey) || !m_pSymmetricKey-&gt;<a class="code" href="class_o_t_symmetric_key.html#a9e2eced2ded569ff96ddace6488a7968">IsGenerated</a>())
        <span class="keywordflow">return</span> <span class="keyword">false</span>;

    m_pSymmetricKey-&gt;<a class="code" href="class_o_t_symmetric_key.html#a70cc2a2c32250ae5c005df3fac0497ba">GetIdentifier</a>(strIdentifier);
    <span class="keywordflow">return</span> <span class="keyword">true</span>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ab5afd7677fed682812ac40de76f5f5db"></a><!-- doxytag: member="OTCachedKey::GetMasterPassword" ref="ab5afd7677fed682812ac40de76f5f5db" args="(_SharedPtr&lt; OTCachedKey &gt; &amp;mySharedPtr, OTPassword &amp;theOutput, const char *szDisplay=NULL, bool bVerifyTwice=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_o_t_cached_key.html#ab5afd7677fed682812ac40de76f5f5db">OTCachedKey::GetMasterPassword</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_t_r1___wrapper_8hpp.html#a4081b6aa22d0f454ce7498756ea212ff">_SharedPtr</a>&lt; <a class="el" href="class_o_t_cached_key.html">OTCachedKey</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mySharedPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_t_password.html">OTPassword</a> &amp;&#160;</td>
          <td class="paramname"><em>theOutput</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>szDisplay</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bVerifyTwice</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_o_t_cached_key_8cpp_source.html#l00601">601</a> of file <a class="el" href="_o_t_cached_key_8cpp_source.html">OTCachedKey.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
    tthread::lock_guard&lt;tthread::mutex&gt; lock(m_Mutex); <span class="comment">// Multiple threads can&#39;t get inside here at the same time.</span>

    std::string str_display(NULL != szDisplay ? szDisplay : <span class="stringliteral">&quot;(Display string was blank.)&quot;</span>);

    <span class="keyword">const</span> <span class="keywordtype">char</span> * szFunc = <span class="stringliteral">&quot;OTCachedKey::GetMasterPassword&quot;</span>;

    <span class="comment">//  OT_ASSERT(NULL != m_pSymmetricKey); // (This had better be set already.) // Took this out because calling Generate inside here now.</span>
    <span class="comment">// ----------------------------------------</span>
    <span class="comment">//</span>
    <span class="keywordflow">if</span> (NULL != m_pMasterPassword)
    {
        <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(2, <span class="stringliteral">&quot;%s: Master password was available. (Returning it now.)\n&quot;</span>, szFunc);

        theOutput = *m_pMasterPassword;
        <span class="keywordflow">return</span> <span class="keyword">true</span>;
    }
    <span class="comment">// --------------------------------------------</span>
    <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(2, <span class="stringliteral">&quot;%s: Master password wasn&#39;t loaded. Instantiating...\n&quot;</span>, szFunc);

    <span class="comment">// If m_pMasterPassword is NULL, (which below this point it is) then...</span>
    <span class="comment">//</span>
    <span class="comment">// Either it hasn&#39;t been created yet, in which case we need to instantiate it,</span>
    <span class="comment">// OR it expired, in which case m_pMasterPassword is NULL,</span>
    <span class="comment">// but m_pThread isn&#39;t, and still needs cleaning up before we instantiate another one!</span>
    <span class="comment">//</span>
    <a class="code" href="class_o_t_cached_key.html#a6933e0f88aae70fe30b925f150e8cc20">LowLevelReleaseThread</a>();
    <span class="comment">// --------------------------------------------</span>
    m_pMasterPassword = <a class="code" href="class_o_t_cached_key.html#a8780b8a3f392b0bc4c11253a797d8b5a">OTCrypto::It</a>()-&gt;InstantiateBinarySecret(); <span class="comment">// already asserts.</span>
    <span class="comment">// --------------------------------------------</span>
    <span class="comment">/*</span>
<span class="comment">    How does this work?</span>
<span class="comment"></span>
<span class="comment">    When trying to open a normal nym, the password callback realizes we are calling it</span>
<span class="comment">    in &quot;NOT master mode&quot;, so instead of just collecting the passphrase and giving it</span>
<span class="comment">    back to OpenSSL, it calls this function first, which returns the master password</span>
<span class="comment">    (so that IT can be given to OpenSSL instead.)</span>
<span class="comment"></span>
<span class="comment">    If the master wasn&#39;t already loaded (common) then we call the callback in here ourselves.</span>
<span class="comment">    Notice it&#39;s recursive! But this time, the callback sees we ARE in master mode, so it doesn&#39;t</span>
<span class="comment">    call this function again (which would be an infinite loop.) Instead, it collects the password</span>
<span class="comment">    as normal, only instead of passing it back to the caller via the buffer, it uses the</span>
<span class="comment">    passUserInput by attaching it to thePWData before the call. That way the callback function</span>
<span class="comment">    can set passUserInput with whatever it retrieved from the user, and then back in this function</span>
<span class="comment">    again we can get the passUserInput and use it to unlock the MASTER passphrase, which we set</span>
<span class="comment">    onto theOutput.</span>
<span class="comment"></span>
<span class="comment">    When this function returns true, the callback (0th level of recursion) uses theOutput</span>
<span class="comment">    as the &quot;passphrase&quot; for all Nyms, passing it to OpenSSL.</span>
<span class="comment"></span>
<span class="comment">    This way, OpenSSL gets a random key instead of a passphrase, and the passphrase is just used</span>
<span class="comment">    for encrypting that random key whenever its timer has run out.</span>
<span class="comment"></span>
<span class="comment">    */</span>

    <span class="keywordtype">bool</span> bReturnVal = <span class="keyword">false</span>;

    <span class="comment">// CALL the callback directly. (To retrieve a passphrase so I can use it in GenerateKey</span>
    <span class="comment">// and GetRawKey.)</span>
    <span class="comment">//</span>
    <span class="comment">//int32_t OT_OPENSSL_CALLBACK (char *buf, int32_t size, int32_t rwflag, void *userdata);</span>
    <span class="comment">//</span>
    <span class="comment">// For us, it will set passUserInput to the password from the user, and return</span>
    <span class="comment">// a simple 1 or 0 (instead of the length.) buf and size can be NULL / 0, and</span>
    <span class="comment">// rwflag should be passed in from somewhere.</span>
    <span class="comment">//</span>
    <span class="comment">// m_pSymmetricKey is the encrypted form of the master key. Therefore we want to hash</span>
    <span class="comment">// it, in order to get the ID for lookups on the keychain.</span>
    <span class="comment">//</span>
    <a class="code" href="class_o_t_password.html">OTPassword</a> * pDerivedKey = NULL;
    <a class="code" href="class_o_t_cleanup.html">OTCleanup&lt;OTPassword&gt;</a> theDerivedAngel;
    <span class="comment">// ---------------------------------</span>
    <span class="keywordflow">if</span> (NULL == m_pSymmetricKey)
    {
        m_pSymmetricKey = <span class="keyword">new</span> <a class="code" href="class_o_t_symmetric_key.html">OTSymmetricKey</a>;
        <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != m_pSymmetricKey);
    }
    <span class="comment">// --------------------------------------------------</span>
    <span class="keywordflow">if</span> (<span class="keyword">false</span> == m_pSymmetricKey-&gt;<a class="code" href="class_o_t_symmetric_key.html#a9e2eced2ded569ff96ddace6488a7968">IsGenerated</a>()) <span class="comment">// doesn&#39;t already exist.</span>
    {
        <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(1, <span class="stringliteral">&quot;%s: Master key didn&#39;t exist. Need to collect a passphrase from the user, &quot;</span>
            <span class="stringliteral">&quot;so we can generate a master key...\n &quot;</span>, szFunc);

        bVerifyTwice = <span class="keyword">true</span>; <span class="comment">// we force it, in this case.</span>
    }

    <span class="comment">// --------------------------------------------------</span>
    <span class="keywordflow">else</span> <span class="comment">// If the symmetric key itself ALREADY exists (which it usually will...)</span>
    {    <span class="comment">// then we might have also already stashed the derived key on the system</span>
        <span class="comment">// keychain. Let&#39;s check there first before asking the user to enter his</span>
        <span class="comment">// passphrase...</span>
        <span class="comment">//</span>

        <span class="comment">// -----------------------------------------------------</span>
        <span class="keyword">const</span> <a class="code" href="class_o_t_identifier.html">OTIdentifier</a> idCachedKey(*m_pSymmetricKey); <span class="comment">// Grab the ID of this symmetric key.</span>
        <span class="keyword">const</span> <a class="code" href="class_o_t_string.html">OTString</a>     strCachedKeyHash(idCachedKey); <span class="comment">// Same thing, in string form.</span>
        <span class="comment">//</span>
        <span class="comment">// This only happens in here where we KNOW m_pSymmetricKey was already generated.</span>
        <span class="comment">//</span>
        <span class="comment">//      OTString strCachedKeyHash;</span>
        <span class="comment">//      m_pSymmetricKey-&gt;GetIdentifier(strCachedKeyHash);</span>
        <span class="comment">// -----------------------------------------------------</span>
        pDerivedKey = <a class="code" href="class_o_t_cached_key.html#a8780b8a3f392b0bc4c11253a797d8b5a">OTCrypto::It</a>()-&gt;InstantiateBinarySecret(); <span class="comment">// pDerivedKey is instantiated here to use as output argument below.</span>
        <span class="comment">// -----------------------------------------------------</span>
        <span class="comment">//</span>
        <span class="comment">// *** ATTEMPT to RETRIEVE the *Derived Key* from THE SYSTEM KEYCHAIN ***</span>
        <span class="comment">//</span>
        <span class="keyword">const</span> <span class="keywordtype">bool</span> bFoundOnKeyring = this-&gt;<a class="code" href="class_o_t_cached_key.html#a95adb6583e128ed03719dc365e14005e">IsUsingSystemKeyring</a>() &amp;&amp;
            <a class="code" href="class_o_t_keyring.html#afa0c2601a6d15a14743ac16fe214ad8f">OTKeyring::RetrieveSecret</a>(
            strCachedKeyHash, <span class="comment">// HASH OF ENCRYPTED MASTER KEY</span>
            *pDerivedKey,     <span class="comment">// (Output) RETRIEVED PASSWORD.</span>
            str_display);     <span class="comment">// optional display string.</span>
        <span class="comment">// -----------------------------------------------------</span>
        <span class="keywordflow">if</span> (bFoundOnKeyring) <span class="comment">// We found it -- but does it WORK?</span>
        {
            <span class="keyword">const</span> <span class="keywordtype">bool</span> bCachedKey = m_pSymmetricKey-&gt;<a class="code" href="class_o_t_symmetric_key.html#a99470a8be3349bb0d0336802aeff60fb">GetRawKeyFromDerivedKey</a>(*pDerivedKey, *m_pMasterPassword);

            <span class="comment">//</span>
            <span class="comment">// Note: What IS the secret? We don&#39;t want it to be the user&#39;s passphrase that he TYPES.</span>
            <span class="comment">// We also don&#39;t want it to be the eventual (random) key that unlocks the private keys.</span>
            <span class="comment">// Rather, we want it to be the intermediary key, generated from the user&#39;s passphrase via</span>
            <span class="comment">// a key-derivation algorithm, which is then used to unlock the (random) symmetric key that</span>
            <span class="comment">// actually unlocks the private keys.</span>
            <span class="comment">// This way the symmetric key itself can be kept locked at ALL times, and instead, we have the</span>
            <span class="comment">// derived key on the timer, use it to unlock the symmetric key EVERY TIME we use that, and</span>
            <span class="comment">// IMMEDIATELY throw it away afterwards, since we can still open it again (until the timeout) by</span>
            <span class="comment">// using the derived key.</span>
            <span class="comment">// This is slick because the user doesn&#39;t directly enter the derived key, and neither is it</span>
            <span class="comment">// directly used for unlocking private keys -- so it&#39;s preferable to store in RAM than those things.</span>
            <span class="comment">//</span>
            <span class="comment">//</span>
            <span class="comment">// 1. Make sure the above description is actually what we DO do now. (UPDATE: for keyring, yes. For OT internally, no.)</span>
            <span class="comment">// 2. Make sure the derived key, as described above, is also what is stored as the SECRET, here! (UPDATE: Yes!)</span>
            <span class="comment">//    (i.e. in other processes such as Mac Keychain or Gnome.)</span>
            <span class="comment">// 3. Done. Need to add ability for OTIdentifier to hash OTSymmetricKey, so we can use it for strUser above. DONE.</span>
            <span class="comment">//</span>
            <span class="comment">// UPDATE: the master key cached inside OT (on a timer) is not the derived key, but the master key itself</span>
            <span class="comment">// that&#39;s used on the private keys. However, the one we&#39;re caching in the system keyring IS the derived key,</span>
            <span class="comment">// and not the master key. So for example, if an attacker obtained the derived key from the system keyring,</span>
            <span class="comment">//</span>

            <span class="keywordflow">if</span> (bCachedKey) <span class="comment">// It works!</span>
            {
                <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(1, <span class="stringliteral">&quot;%s: Finished calling m_pSymmetricKey-&gt;GetRawKeyFromDerivedKey (Success.)\n&quot;</span>, szFunc);
                theOutput  = *m_pMasterPassword; <span class="comment">// Return it to the caller.</span>
                theDerivedAngel.<a class="code" href="class_o_t_cleanup.html#a00a399db45f730439d2263d4429d00c1">SetCleanupTarget</a>(*pDerivedKey); <span class="comment">// Set our own copy to be destroyed later. It continues below as &quot;NOT NULL&quot;.</span>
                bReturnVal = <span class="keyword">true</span>; <span class="comment">// Success.</span>
            }
            <span class="keywordflow">else</span> <span class="comment">// It didn&#39;t unlock with the one we found.</span>
            {
                <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(0, <span class="stringliteral">&quot;%s: Unable to unlock master key using derived key found on system keyring.\n&quot;</span>, szFunc);
                <span class="keyword">delete</span> pDerivedKey;
                pDerivedKey = NULL;  <span class="comment">// Below, this function checks pDerivedKey for NULL.</span>
            }
        }
        <span class="keywordflow">else</span>    <span class="comment">// NOT found on keyring.</span>
        {
            <span class="keywordflow">if</span> (this-&gt;<a class="code" href="class_o_t_cached_key.html#a95adb6583e128ed03719dc365e14005e">IsUsingSystemKeyring</a>()) <span class="comment">// We WERE using the keying, but we DIDN&#39;T find the derived key.</span>
                <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(1, <span class="stringliteral">&quot;%s: Unable to find derived key on system keyring.\n&quot;</span>, szFunc);
            <span class="comment">// (Otherwise if we WEREN&#39;T using the system keyring, then of course we didn&#39;t find any derived key cached there.)</span>
            <span class="keyword">delete</span> pDerivedKey;
            pDerivedKey = NULL; <span class="comment">// Below, this function checks pDerivedKey for NULL.</span>

        }
    }
    <span class="comment">// --------------------------------------------------</span>
    <span class="comment">// NOT found on Keyring...</span>
    <span class="comment">//</span>
    <span class="keywordflow">if</span> (NULL == pDerivedKey) <span class="comment">// Master key was not cached in OT, nor was it found in the system keychain.</span>
    {                        <span class="comment">// Therefore we HAVE to ask the user for a passphrase and decrypt it ourselves,</span>
        <span class="comment">// since we DO have an encrypted version of the key...</span>

        <span class="comment">// This time we DEFINITELY force the user input, since we already played our hand.</span>
        <span class="comment">// If the master key was still in memory we would have returned already, above.</span>
        <span class="comment">// Then we tried to find it on the keyring and we couldn&#39;t find it, so now we have</span>
        <span class="comment">// to actually ask the user to enter it.</span>
        <span class="comment">//</span>

        std::string default_password(<a class="code" href="_o_t_cached_key_8cpp.html#aa00325ea7c8ea1e1406bb2d019d7e6fe">OT_DEFAULT_PASSWORD</a>); <span class="comment">// default password</span>
        <a class="code" href="class_o_t_password.html">OTPassword</a> passwordDefault; passwordDefault.<a class="code" href="class_o_t_password.html#a3a971b06f42d1c89802167a0ab5330a5">zeroMemory</a>();
        passwordDefault.<a class="code" href="class_o_t_password.html#a251ed5100b869ae4b80166453e75e964">setPassword</a>(default_password.c_str(), <span class="keyword">static_cast&lt;</span>int32_t<span class="keyword">&gt;</span>(default_password.length()));

        <a class="code" href="class_o_t_password.html">OTPassword</a> passUserInput;  passUserInput.<a class="code" href="class_o_t_password.html#a3a971b06f42d1c89802167a0ab5330a5">zeroMemory</a>(); <span class="comment">// text mode.</span>
        <a class="code" href="class_o_t_password_data.html">OTPasswordData</a>  thePWData(str_display.c_str(), &amp;passUserInput, mySharedPtr); <span class="comment">// these pointers are only passed in the case where it&#39;s for a master key.</span>
<span class="comment">//      OTLog::vOutput(2, &quot;*********Begin OTCachedKey::GetMasterPassword: Calling souped-up password cb...\n * *  * *  * *  * *  * &quot;);</span>
        <span class="comment">// -----------------------------------------------------------------------</span>


        <span class="comment">// It&#39;s possible this is the first time this is happening, and the master key</span>
        <span class="comment">// hasn&#39;t even been generated yet. In which case, we generate it here...</span>
        <span class="comment">//</span>
        <span class="keywordtype">bool</span> bGenerated = m_pSymmetricKey-&gt;<a class="code" href="class_o_t_symmetric_key.html#a9e2eced2ded569ff96ddace6488a7968">IsGenerated</a>();

        <span class="keywordflow">if</span> (!bGenerated) <span class="comment">// This Symmetric Key hasn&#39;t been generated before....</span>
        {

            <span class="keywordflow">if</span> (!<a class="code" href="class_o_t_asymmetric_key.html#a7515df1669bf358ddfc7ea477aedafdf">OTAsymmetricKey::GetPasswordCallback</a>()(NULL, 0, bVerifyTwice ? 1 : 0, static_cast&lt;void *&gt;(&amp;thePWData)))
            {
                <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;%s: Failed to get password from user!&quot;</span>, __FUNCTION__);
                <span class="keywordflow">return</span> <span class="keyword">false</span>;
            }


            <span class="comment">// If the length of the user supplied password is less than 4 characters int64_t, we are going to use the default password!</span>
            <span class="keywordtype">bool</span> bUsingDefaultPassword = <span class="keyword">false</span>;
            {
                <span class="keywordflow">if</span> (4 &gt; std::string(passUserInput.<a class="code" href="class_o_t_password.html#a2b3bc99637b0b01f9b4ffcae78abc5b4">getPassword</a>()).length())
                {
                    <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(0, <span class="stringliteral">&quot;\n Password entered was less than 4 characters int64_t! This is NOT secure!!\n&quot;</span>
                        <span class="stringliteral">&quot;... Assuming password is for testing only... setting to default password: %s \n&quot;</span>,
                        <a class="code" href="_o_t_cached_key_8cpp.html#aa00325ea7c8ea1e1406bb2d019d7e6fe">OT_DEFAULT_PASSWORD</a>);
                    bUsingDefaultPassword = <span class="keyword">true</span>;
                }
            }

<span class="comment">//          OTLog::vOutput(0, &quot;%s: Calling m_pSymmetricKey-&gt;GenerateKey()...\n&quot;, szFunc);</span>

            bGenerated = m_pSymmetricKey-&gt;<a class="code" href="class_o_t_symmetric_key.html#a2ef54d17c58afc9edea214ea0a2dcf13">GenerateKey</a>(bUsingDefaultPassword ? passwordDefault : passUserInput, &amp;pDerivedKey); <span class="comment">// derived key is optional here.</span>
            <span class="comment">//</span>
            <span class="comment">// Note: since I passed &amp;pDerivedKey in the above call, then **I** am responsible to</span>
            <span class="comment">// check it for NULL, and delete it if there&#39;s something there!</span>
            <span class="comment">//</span>
            <span class="keywordflow">if</span> (NULL != pDerivedKey)
                theDerivedAngel.<a class="code" href="class_o_t_cleanup.html#a00a399db45f730439d2263d4429d00c1">SetCleanupTarget</a>(*pDerivedKey);
            <span class="keywordflow">else</span>
                <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;%s: FYI: Derived key is still NULL after calling OTSymmetricKey::GenerateKey.\n&quot;</span>);

<span class="comment">//          OTLog::vOutput(0, &quot;%s: Finished calling m_pSymmetricKey-&gt;GenerateKey()...\n&quot;, szFunc);</span>
        }
        <span class="keywordflow">else</span> <span class="comment">// m_pSymmetricKey-&gt;IsGenerated() == true. (Symmetric Key is already generated.)</span>
        {
            <span class="comment">// -------------------------------------------------------------------------------------------------</span>
            <span class="comment">// Generate derived key from passphrase.</span>
            <span class="comment">//</span>
            <span class="comment">// We generate the derived key here so that GetRawKeyFromPassphrase() call (below)</span>
            <span class="comment">// works with it being passed in. (Because the above call to GenerateKey also grabs</span>
            <span class="comment">// a copy of the derived key and passes it in below to the same GetRawKeyFromPassphrase.)</span>
            <span class="comment">//</span>
            <span class="comment">// So WHY are we keeping a copy of the derived key through these calls? Otherwise they</span>
            <span class="comment">// would all individually generate it, which is a waste of resources. Also, we want to have</span>
            <span class="comment">// our grubby hands on the derived key at the end so we can add it to the system keyring</span>
            <span class="comment">// (below), and we&#39;d just end up having to derive it AGAIN in order to do so.</span>
            <span class="comment">//</span>
            <span class="keywordflow">if</span> (m_pSymmetricKey-&gt;<a class="code" href="class_o_t_symmetric_key.html#a213fa5c52407fa234f8396c4f795f783">HasHashCheck</a>())
            {
                pDerivedKey = m_pSymmetricKey-&gt;<a class="code" href="class_o_t_symmetric_key.html#ad91f8bb8c8384b0719204df381fa693f">CalculateDerivedKeyFromPassphrase</a>(passwordDefault); <span class="comment">// asserts already.</span>

                <span class="keywordflow">if</span> (NULL == pDerivedKey)
                {
                    <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(0, <span class="stringliteral">&quot;\n\n%s: Please enter your password.\n\n&quot;</span>, __FUNCTION__);

                    <span class="keywordflow">for</span> ( ;; )  <span class="comment">// bad passphase (as the calculate key returned NULL)</span>
                    {
                        <span class="keywordflow">if</span> (!<a class="code" href="class_o_t_asymmetric_key.html#a7515df1669bf358ddfc7ea477aedafdf">OTAsymmetricKey::GetPasswordCallback</a>()(NULL, 0, <span class="keyword">false</span>, static_cast&lt;void *&gt;(&amp;thePWData)))
                        {
                            <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;\n\n%s: Failed to get password from user!\n\n&quot;</span>, __FUNCTION__);
                            <span class="keywordflow">return</span> <span class="keyword">false</span>;
                        }
                        pDerivedKey = m_pSymmetricKey-&gt;<a class="code" href="class_o_t_symmetric_key.html#ad91f8bb8c8384b0719204df381fa693f">CalculateDerivedKeyFromPassphrase</a>(passUserInput); <span class="comment">// asserts already.</span>
                        <span class="keywordflow">if</span> (NULL != pDerivedKey) <span class="keywordflow">break</span>; <span class="comment">// success</span>

                        <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(0, <span class="stringliteral">&quot;\n\n%s: Wrong Password, Please Try Again.\n\n&quot;</span>, __FUNCTION__);
                    }
                }
            }
            <span class="keywordflow">else</span>
            {
                <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(0,<span class="stringliteral">&quot;\n Please enter your current password twice, (not a new password!!) \n&quot;</span>);

                <span class="keywordflow">if</span> (!<a class="code" href="class_o_t_asymmetric_key.html#a7515df1669bf358ddfc7ea477aedafdf">OTAsymmetricKey::GetPasswordCallback</a>()(NULL, 0, <span class="keyword">true</span>, static_cast&lt;void *&gt;(&amp;thePWData)))
                {
                    <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;%s: Failed to get password from user!&quot;</span>, __FUNCTION__);
                    <span class="keywordflow">return</span> <span class="keyword">false</span>;
                }

                pDerivedKey = m_pSymmetricKey-&gt;<a class="code" href="class_o_t_symmetric_key.html#a7784859786cd0bfb61def268a6dbb9a7">CalculateNewDerivedKeyFromPassphrase</a>(passUserInput); <span class="comment">// asserts already.</span>
                <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != pDerivedKey);
            }
            theDerivedAngel.<a class="code" href="class_o_t_cleanup.html#a00a399db45f730439d2263d4429d00c1">SetCleanupTarget</a>(*pDerivedKey);

            <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(1, <span class="stringliteral">&quot;%s: FYI, symmetric key was already generated. &quot;</span>
                <span class="stringliteral">&quot;Proceeding to try and use it...\n&quot;</span>, szFunc);

            <span class="comment">// bGenerated is true, if we&#39;re even in this block in the first place.</span>
            <span class="comment">// (No need to set it twice.)</span>
        }

        <span class="comment">// -------------------------------------------------------------------------------------------------</span>
        <span class="comment">// Below this point, pDerivedKey could still be null.</span>
        <span class="comment">// (And we only clean it up later if we created it.)</span>
        <span class="comment">// Also, bGenerated could still be false. (Like if it wasn&#39;t</span>
        <span class="comment">// generated, then generation itself failed, then it&#39;s still false.)</span>
        <span class="comment">//</span>
        <span class="comment">// Also, even if it was already generated, or if it wasn&#39;t but then successfully did,</span>
        <span class="comment">//</span>
        <span class="comment">// -----------------------------------------------------</span>

        <span class="keywordflow">if</span> (bGenerated) <span class="comment">// If SymmetricKey (*this) is already generated.</span>
        {
            <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(2, <span class="stringliteral">&quot;%s: Calling m_pSymmetricKey-&gt;GetRawKeyFromPassphrase()...\n&quot;</span>, szFunc);

            <span class="comment">// Once we have the user&#39;s password, then we use it to GetKey from the OTSymmetricKey (which</span>
            <span class="comment">// is encrypted) and that retrieves the cleartext master password which we set here and also</span>
            <span class="comment">// return a copy of.</span>
            <span class="comment">//</span>
            <span class="comment">// Note: if pDerivedKey was derived above already, which it should have been, then it will</span>
            <span class="comment">// be not-NULL, and will be used here, and will be used subsequently for adding to the system</span>
            <span class="comment">// keychain. Otherwise, it will be NULL, and GetRawKeyFromPassphrase will thus just derive its</span>
            <span class="comment">// own copy of the derived key internally. It will still work, but then back up here, it will</span>
            <span class="comment">// NOT be added to the system keyring, since it&#39;s still NULL back up here.</span>
            <span class="comment">// (FYI.)</span>
            <span class="comment">//</span>
            <span class="keyword">const</span> <span class="keywordtype">bool</span> bCachedKey = m_pSymmetricKey-&gt;<a class="code" href="class_o_t_symmetric_key.html#a6930ce6ccea45d4259a8e44171d27763">GetRawKeyFromPassphrase</a>(passUserInput,
                *m_pMasterPassword,
                pDerivedKey);
            <span class="keywordflow">if</span> (bCachedKey)
            {
                <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(2, <span class="stringliteral">&quot;%s: Finished calling m_pSymmetricKey-&gt;GetRawKeyFromPassphrase (Success.)\n&quot;</span>, szFunc);
                theOutput  = *m_pMasterPassword; <span class="comment">// Success!</span>
                <span class="comment">// ------------------------------</span>
                <span class="comment">// Store the derived key to the system keyring.</span>
                <span class="comment">//</span>
                <span class="keywordflow">if</span> (this-&gt;<a class="code" href="class_o_t_cached_key.html#a95adb6583e128ed03719dc365e14005e">IsUsingSystemKeyring</a>() &amp;&amp; (NULL != pDerivedKey))
                {
                    <span class="keyword">const</span> std::string str_display(NULL != szDisplay ? szDisplay : <span class="stringliteral">&quot;(Display string was blank.)&quot;</span>);
                    <span class="comment">// -----------------------------------------------------</span>
                    <span class="keyword">const</span> <a class="code" href="class_o_t_identifier.html">OTIdentifier</a> idCachedKey(*m_pSymmetricKey);
                    <span class="keyword">const</span> <a class="code" href="class_o_t_string.html">OTString</a>     strCachedKeyHash(idCachedKey); <span class="comment">// Same thing, in string form.</span>
                    <span class="comment">// -----------------------------------------------------</span>
                    <span class="comment">//                      const bool bStored =</span>
                    <a class="code" href="class_o_t_keyring.html#ab8689b4baa6c7db88827558c466808cf">OTKeyring::StoreSecret</a>(strCachedKeyHash, <span class="comment">// HASH OF ENCRYPTED MASTER KEY</span>
                        *pDerivedKey,     <span class="comment">// (Input) Derived Key BEING STORED.</span>
                        str_display);     <span class="comment">// optional display string.</span>
                }
                <span class="keywordflow">else</span>
                    <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(1, <span class="stringliteral">&quot;%s: Strange: Problem with either: this-&gt;IsUsingSystemKeyring (%s) &quot;</span>
                    <span class="stringliteral">&quot;or: (NULL != pDerivedKey) (%s)\n&quot;</span>, szFunc, this-&gt;<a class="code" href="class_o_t_cached_key.html#a95adb6583e128ed03719dc365e14005e">IsUsingSystemKeyring</a>() ? <span class="stringliteral">&quot;true&quot;</span> : <span class="stringliteral">&quot;false&quot;</span>,
                    (NULL != pDerivedKey) ? <span class="stringliteral">&quot;true&quot;</span> : <span class="stringliteral">&quot;false&quot;</span>);

                bReturnVal = <span class="keyword">true</span>;
            }
            <span class="keywordflow">else</span>
                <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(0, <span class="stringliteral">&quot;%s: m_pSymmetricKey-&gt;GetRawKeyFromPassphrase() failed.\n&quot;</span>, szFunc);
        } <span class="comment">// bGenerated</span>
        <span class="keywordflow">else</span>
            <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;%s: bGenerated is still false, even after trying to generate it, yadda yadda yadda.\n&quot;</span>, szFunc);

    } <span class="comment">// NULL == pDerivedKey</span>
    <span class="comment">// -------------------------------------------</span>

    <span class="keywordflow">if</span> (bReturnVal) <span class="comment">// Start the thread!</span>
    {
<span class="comment">//      OTLog::vOutput(4, &quot;%s: starting up new thread, so we can expire the master key from RAM.\n&quot;, szFunc);</span>


<span class="comment">// ************************************************************************</span>
<span class="preprocessor">#if defined(OT_CRYPTO_USING_OPENSSL)</span>
<span class="preprocessor"></span>
<span class="comment">// -------------------------------------------------</span>
<span class="preprocessor">#if defined(OPENSSL_THREADS)</span>
<span class="preprocessor"></span>        <span class="comment">// thread support enabled</span>

        <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(2, <span class="stringliteral">&quot;%s: Starting thread for Master Key...\n&quot;</span>, szFunc);

        _SharedPtr&lt;OTCachedKey&gt; * pthreadSharedPtr = <span class="keyword">new</span> _SharedPtr&lt;OTCachedKey&gt;(mySharedPtr); <span class="comment">// TODO: memory leak.</span>

        m_pThread = <span class="keyword">new</span> tthread::thread(<a class="code" href="class_o_t_cached_key.html#a7ac7c4130bd8d8cb9a443be54ae5e004">OTCachedKey::ThreadTimeout</a>, static_cast&lt;void *&gt;(pthreadSharedPtr));

<span class="preprocessor">#else</span>
<span class="preprocessor"></span>        <span class="comment">// no thread support</span>

        <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;%s: WARNING: OpenSSL was NOT compiled with thread support. &quot;</span>
            <span class="stringliteral">&quot;(Master Key will not expire.)\n&quot;</span>, szFunc);

<span class="preprocessor">#endif</span>
<span class="preprocessor"></span><span class="comment">// -------------------------------------------------</span>

<span class="comment">// ************************************************************************</span>
<span class="preprocessor">#elif defined(OT_CRYPTO_USING_GPG)</span>
<span class="preprocessor"></span>
        <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;%s: WARNING: OT was compiled for GPG, which is not yet supported. &quot;</span>
                      <span class="stringliteral">&quot;(Master Key will not expire.)\n&quot;</span>, szFunc);

<span class="comment">// ************************************************************************</span>
<span class="preprocessor">#else  // OT_CRYPTO_USING_ ... nothing?</span>
<span class="preprocessor"></span>
        <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;%s: WARNING: OT wasn&#39;t compiled for any crypto library &quot;</span>
                      <span class="stringliteral">&quot;(such as OpenSSL or GPG). Which is very strange, and I doubt &quot;</span>
                      <span class="stringliteral">&quot;things will even work, with it in this condition. (Plus, Master &quot;</span>
                      <span class="stringliteral">&quot;Key will not expire.)\n&quot;</span>, szFunc);

<span class="comment">// -------------------------------------------------</span>
<span class="preprocessor">#endif     //if defined(OT_CRYPTO_USING_OPENSSL),  elif defined(OT_CRYPTO_USING_GPG),  else,  endif.</span>
<span class="preprocessor"></span><span class="comment">// ************************************************************************</span>


        <span class="comment">// -------------------------------------------------</span>

    }
    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (m_nTimeoutSeconds != (-1))
    {
        <span class="keywordflow">if</span> (NULL != m_pMasterPassword)
        {
            <a class="code" href="class_o_t_password.html">OTPassword</a> * pMasterPassword = m_pMasterPassword;

            m_pMasterPassword = NULL;

            <span class="keyword">delete</span> pMasterPassword; pMasterPassword = NULL;
        }
    }
    <span class="comment">// Since we have set the cleartext master password, We also have to fire up the thread</span>
    <span class="comment">// so it can timeout and be destroyed. In the meantime, it&#39;ll be stored in an OTPassword</span>
    <span class="comment">// which has these security precautions:</span>
    <span class="comment">/*</span>
<span class="comment">    1. Zeros memory in a secure and cross-platform way, in its destructor.</span>
<span class="comment">    2. OT_Init() uses setrlimit to prevent core dumps.</span>
<span class="comment">    3. Uses VirtualLock and mlock to reduce/prevent swapping RAM to hard drive.</span>
<span class="comment">    4. (SOON) will use VirtualProtect on Windows (standard API for protected memory)</span>
<span class="comment">    5. (SOON) and similarly have option in config file for ssh-agent, gpg-agent, etc.</span>
<span class="comment">    6. Even without those things,the master password is stored in an encrypted form after it times out.</span>
<span class="comment">    7. While decrypted (while timer is going) it&#39;s still got the above security mechanisms,</span>
<span class="comment">    plus options for standard protected-memory APIs are made available wherever possible.</span>
<span class="comment">    8. The actual passphrase the user types is not stored in memory, except just int64_t enough to</span>
<span class="comment">    use it to derive another key, used to unlock the actual key (for a temporary period of time.)</span>
<span class="comment">    9. Meanwhile the actual key is stored in encrypted form on disk, and the derived key isn&#39;t stored anywhere.</span>
<span class="comment">    10. Ultimately external hardware, and smart cards, are the way to go. But OT should still do the best possible.</span>
<span class="comment">    */</span>

    <span class="keywordflow">return</span> bReturnVal;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a0b51adc5e45ea1e377febeaad27dbb60"></a><!-- doxytag: member="OTCachedKey::GetMutex" ref="a0b51adc5e45ea1e377febeaad27dbb60" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tthread::mutex* <a class="el" href="class_o_t_cached_key.html#a0b51adc5e45ea1e377febeaad27dbb60">OTCachedKey::GetMutex</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_o_t_cached_key_8hpp_source.html#l00272">272</a> of file <a class="el" href="_o_t_cached_key_8hpp_source.html">OTCachedKey.hpp</a>.</p>
<div class="fragment"><pre class="fragment">{ <span class="keywordflow">return</span> &amp;m_Mutex; } <span class="comment">// So static functions using this CachedKey can also lock its mutex.</span>
</pre></div>
</div>
</div>
<a class="anchor" id="ac0de8ead34b8bff4913844507987e61a"></a><!-- doxytag: member="OTCachedKey::GetTimeoutSeconds" ref="ac0de8ead34b8bff4913844507987e61a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t <a class="el" href="class_o_t_cached_key.html#ac0de8ead34b8bff4913844507987e61a">OTCachedKey::GetTimeoutSeconds</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_o_t_cached_key_8cpp_source.html#l00456">456</a> of file <a class="el" href="_o_t_cached_key_8cpp_source.html">OTCachedKey.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
    tthread::lock_guard&lt;tthread::mutex&gt; lock(m_Mutex); <span class="comment">// Multiple threads can&#39;t get inside here at the same time.</span>

    <span class="keyword">const</span> int32_t nTimeout = m_nTimeoutSeconds;

    <span class="keywordflow">return</span> nTimeout;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a1b868584e683faa9cd4cc63bcd5bc3f4"></a><!-- doxytag: member="OTCachedKey::HasHashCheck" ref="a1b868584e683faa9cd4cc63bcd5bc3f4" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_o_t_cached_key.html#a1b868584e683faa9cd4cc63bcd5bc3f4">OTCachedKey::HasHashCheck</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_o_t_cached_key_8cpp_source.html#l00185">185</a> of file <a class="el" href="_o_t_cached_key_8cpp_source.html">OTCachedKey.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
    tthread::lock_guard&lt;tthread::mutex&gt; lock(m_Mutex);
    <span class="comment">// ----------------------------</span>
    <span class="keywordtype">bool</span> bReturnVal = <span class="keyword">false</span>;

    <span class="keywordflow">if</span> (NULL != m_pSymmetricKey)
    {
        bReturnVal = m_pSymmetricKey-&gt;<a class="code" href="class_o_t_symmetric_key.html#a213fa5c52407fa234f8396c4f795f783">HasHashCheck</a>();
    }

    <span class="keywordflow">return</span> bReturnVal;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a841c81a6323383f9762f21cc820bbdab"></a><!-- doxytag: member="OTCachedKey::IsGenerated" ref="a841c81a6323383f9762f21cc820bbdab" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_o_t_cached_key.html#a841c81a6323383f9762f21cc820bbdab">OTCachedKey::IsGenerated</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_o_t_cached_key_8cpp_source.html#l00170">170</a> of file <a class="el" href="_o_t_cached_key_8cpp_source.html">OTCachedKey.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
    tthread::lock_guard&lt;tthread::mutex&gt; lock(m_Mutex);
    <span class="comment">// ----------------------------</span>
    <span class="keywordtype">bool</span> bReturnVal = <span class="keyword">false</span>;

    <span class="keywordflow">if</span> (NULL != m_pSymmetricKey)
    {
        bReturnVal = m_pSymmetricKey-&gt;<a class="code" href="class_o_t_symmetric_key.html#a9e2eced2ded569ff96ddace6488a7968">IsGenerated</a>();
    }

    <span class="keywordflow">return</span> bReturnVal;
}
</pre></div>
</div>
</div>
<a class="anchor" id="aef5e98808a18741cb9c8c240f702e996"></a><!-- doxytag: member="OTCachedKey::isPaused" ref="aef5e98808a18741cb9c8c240f702e996" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_o_t_cached_key.html#aef5e98808a18741cb9c8c240f702e996">OTCachedKey::isPaused</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_o_t_cached_key_8cpp_source.html#l00367">367</a> of file <a class="el" href="_o_t_cached_key_8cpp_source.html">OTCachedKey.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
<span class="comment">//  tthread::lock_guard&lt;tthread::mutex&gt; lock(m_Mutex);</span>

    <span class="keywordflow">return</span> m_bPaused;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a95adb6583e128ed03719dc365e14005e"></a><!-- doxytag: member="OTCachedKey::IsUsingSystemKeyring" ref="a95adb6583e128ed03719dc365e14005e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EXPORT bool <a class="el" href="class_o_t_cached_key.html#a95adb6583e128ed03719dc365e14005e">OTCachedKey::IsUsingSystemKeyring</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_o_t_cached_key_8hpp_source.html#l00289">289</a> of file <a class="el" href="_o_t_cached_key_8hpp_source.html">OTCachedKey.hpp</a>.</p>
<div class="fragment"><pre class="fragment">{ <span class="keywordflow">return</span> m_bUse_System_Keyring; }
</pre></div>
</div>
</div>
<a class="anchor" id="a8780b8a3f392b0bc4c11253a797d8b5a"></a><!-- doxytag: member="OTCachedKey::It" ref="a8780b8a3f392b0bc4c11253a797d8b5a" args="(OTIdentifier *pIdentifier=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_t_r1___wrapper_8hpp.html#a4081b6aa22d0f454ce7498756ea212ff">_SharedPtr</a>&lt; <a class="el" href="class_o_t_cached_key.html">OTCachedKey</a> &gt; <a class="el" href="class_o_t_cached_key.html#a8780b8a3f392b0bc4c11253a797d8b5a">OTCachedKey::It</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_t_identifier.html">OTIdentifier</a> *&#160;</td>
          <td class="paramname"><em>pIdentifier</em> = <code>NULL</code></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_o_t_cached_key_8cpp_source.html#l00204">204</a> of file <a class="el" href="_o_t_cached_key_8cpp_source.html">OTCachedKey.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">// For now we&#39;re only allowing a single global instance, unless you pass in an ID, in which case we keep a map.</span>
    <span class="comment">//</span>
    <span class="keyword">static</span> _SharedPtr&lt;OTCachedKey&gt; s_theSingleton(<span class="keyword">new</span> <a class="code" href="class_o_t_cached_key.html">OTCachedKey</a>);  <span class="comment">// Default is 0 (&quot;you have to type your PW a million times&quot;), but it&#39;s overridden in config file.</span>

    <span class="keywordflow">if</span> (NULL == pIdentifier)
        <span class="keywordflow">return</span> s_theSingleton; <span class="comment">// Notice if you pass NULL (no args) then it ALWAYS returns a good pointer here.</span>
    <span class="comment">// ----------------------------------------------------------------</span>
    <span class="comment">// There is a chance of failure if you pass an ID, since maybe it&#39;s not already on the map.</span>
    <span class="comment">// But at least by this point we know FOR SURE that pIdentifier is NOT NULL.</span>
    <span class="comment">//</span>
    tthread::lock_guard&lt;tthread::mutex&gt; lock(OTCachedKey::s_mutexCachedKeys);
    <span class="comment">// ----------------------------</span>
    <span class="keyword">const</span> <a class="code" href="class_o_t_string.html">OTString</a>    strIdentifier (*pIdentifier);
    <span class="keyword">const</span> std::string str_identifier(strIdentifier.Get());

    mapOfCachedKeys::iterator it_keys = s_mapCachedKeys.find(str_identifier);

    <span class="keywordflow">if</span> (s_mapCachedKeys.end() != it_keys) <span class="comment">// found it!</span>
    {
        _SharedPtr&lt;OTCachedKey&gt; pShared(it_keys-&gt;second);

        <span class="keywordflow">if</span> (pShared)
        {
            <span class="keywordflow">return</span> pShared;
        }
        <span class="keywordflow">else</span>
            s_mapCachedKeys.erase(it_keys);
    }
    <span class="comment">// ----------------------------------------------------------------------</span>
    <span class="comment">// else: We can&#39;t instantiate it, since we don&#39;t have the corresponding CachedKey, just its</span>
    <span class="comment">// Identifier. We&#39;re forced simply to return NULL in this case.</span>
    <span class="comment">//</span>
    <span class="comment">// Therefore you should normally pass in the master key (the same one that you want to cache a copy</span>
    <span class="comment">// of) using the below version of It(). That version creates the copy, if it&#39;s not already there.</span>
    <span class="comment">//</span>
    <span class="keywordflow">return</span> _SharedPtr&lt;OTCachedKey&gt;();
}
</pre></div>
</div>
</div>
<a class="anchor" id="a47cf6d6425469515db0e21ec4e4b4833"></a><!-- doxytag: member="OTCachedKey::It" ref="a47cf6d6425469515db0e21ec4e4b4833" args="(OTCachedKey &amp;theSourceKey)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_t_r1___wrapper_8hpp.html#a4081b6aa22d0f454ce7498756ea212ff">_SharedPtr</a>&lt; <a class="el" href="class_o_t_cached_key.html">OTCachedKey</a> &gt; <a class="el" href="class_o_t_cached_key.html#a8780b8a3f392b0bc4c11253a797d8b5a">OTCachedKey::It</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_t_cached_key.html">OTCachedKey</a> &amp;&#160;</td>
          <td class="paramname"><em>theSourceKey</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_o_t_cached_key_8cpp_source.html#l00256">256</a> of file <a class="el" href="_o_t_cached_key_8cpp_source.html">OTCachedKey.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
<span class="comment">//    tthread::lock_guard&lt;tthread::mutex&gt; lock(*(theSourceKey.GetMutex()));</span>
    <span class="comment">// ----------------------------------------------------------------</span>
    <span class="comment">// There is no chance of failure since he passed the master key itself,</span>
    <span class="comment">// since even if it&#39;s not already on the map, we&#39;ll just create a copy and put</span>
    <span class="comment">// it there ourselves, returning a pointer either way.</span>
    <span class="comment">//</span>
    <span class="comment">// Except... if theSourceKey isn&#39;t generated...</span>
    <span class="comment">//</span>
    <span class="keywordflow">if</span> (!(const_cast&lt;OTCachedKey &amp;&gt;(theSourceKey)).<a class="code" href="class_o_t_cached_key.html#a841c81a6323383f9762f21cc820bbdab">IsGenerated</a>()) <span class="comment">//it&#39;s only not const due to the mutex inside</span>
    {
        <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;OTCachedKey::%s: theSourceKey.IsGenerated() returned false. &quot;</span>
                      <span class="stringliteral">&quot;(Returning NULL.)\n&quot;</span>, __FUNCTION__);
        <span class="keywordflow">return</span> _SharedPtr&lt;OTCachedKey&gt;();
    }
    <span class="comment">// ----------------------------------</span>
    tthread::lock_guard&lt;tthread::mutex&gt; lock_keys(OTCachedKey::s_mutexCachedKeys);
    <span class="comment">// ----------------------------------</span>
    <span class="keyword">const</span> <a class="code" href="class_o_t_identifier.html">OTIdentifier</a> theSourceID(theSourceKey);
    <span class="comment">// ----------------------------------</span>
    <span class="keyword">const</span> <a class="code" href="class_o_t_string.html">OTString</a>     strIdentifier (theSourceID);
    <span class="keyword">const</span> std::string  str_identifier(strIdentifier.Get());

    <span class="comment">// Let&#39;s see if it&#39;s already there on the map...</span>
    <span class="comment">//</span>
    mapOfCachedKeys::iterator it_keys = s_mapCachedKeys.find(str_identifier);

    <span class="keywordflow">if</span> (s_mapCachedKeys.end() != it_keys) <span class="comment">// found it!</span>
    {
        _SharedPtr&lt;OTCachedKey&gt; pMaster(it_keys-&gt;second);

        <span class="keywordflow">if</span> (pMaster)
            <span class="keywordflow">return</span> pMaster;
        <span class="keywordflow">else</span>
            s_mapCachedKeys.erase(it_keys);
    }
    <span class="comment">// ----------------------------------</span>
    <span class="comment">// By this point, pMaster is definitely NULL. (Not found on the map, needs to be added.)</span>
    <span class="comment">//</span>
    <span class="comment">// ----------------------------------</span>
    <span class="comment">// Here we make a copy of the master key and insert it into the map.</span>
    <span class="comment">// Then we return a pointer to it.</span>
    <span class="comment">//</span>
    <a class="code" href="class_o_t_a_s_c_i_i_armor.html">OTASCIIArmor</a> ascCachedKey;
    <span class="keywordflow">if</span> ((const_cast&lt;OTCachedKey &amp;&gt;(theSourceKey)).<a class="code" href="class_o_t_cached_key.html#a5f7a335ec7dc9ac8fd2b1ebf2ef26dd8">SerializeTo</a>(ascCachedKey)) <span class="comment">//it&#39;s only not const due to the mutex inside</span>
    {
        _SharedPtr&lt;OTCachedKey&gt; pMaster(<span class="keyword">new</span> <a class="code" href="class_o_t_cached_key.html">OTCachedKey</a>); <span class="comment">//int32_t nTimeoutSeconds=OT_MASTER_KEY_TIMEOUT;</span>
        <span class="comment">// ----------------------------------</span>
        pMaster-&gt;SetCachedKey(ascCachedKey);
        <span class="comment">// ----------------------------------</span>
        s_mapCachedKeys.insert(std::pair&lt;std::string, _SharedPtr&lt;OTCachedKey&gt; &gt;(str_identifier, pMaster)); <span class="comment">// takes ownership here.</span>
        <span class="keywordflow">return</span> pMaster;
    }
    <span class="comment">// theSourceKey WAS generated, but SerializeTo FAILED? Very strange...</span>
    <span class="keywordflow">else</span>
        <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;%s: theSourceKey.SerializeTo(ascCachedKey) failed. &quot;</span>
                      <span class="stringliteral">&quot;Returning NULL.\n&quot;</span>, __FUNCTION__);
    <span class="comment">// ----------------------------------</span>
    <span class="keywordflow">return</span> _SharedPtr&lt;OTCachedKey&gt;();
}
</pre></div>
</div>
</div>
<a class="anchor" id="a6933e0f88aae70fe30b925f150e8cc20"></a><!-- doxytag: member="OTCachedKey::LowLevelReleaseThread" ref="a6933e0f88aae70fe30b925f150e8cc20" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_o_t_cached_key.html#a6933e0f88aae70fe30b925f150e8cc20">OTCachedKey::LowLevelReleaseThread</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_o_t_cached_key_8cpp_source.html#l00412">412</a> of file <a class="el" href="_o_t_cached_key_8cpp_source.html">OTCachedKey.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">// NO NEED TO LOCK THIS ONE -- BUT ONLY CALL IT FROM A LOCKED FUNCTION.</span>
    <span class="keywordflow">if</span> (NULL != m_pThread)
    {
        tthread::thread * pThread = m_pThread;
        m_pThread = NULL;

        <span class="keywordflow">if</span> (pThread-&gt;joinable())
        {
            pThread-&gt;detach();
        }
        <span class="keyword">delete</span> pThread; pThread = NULL;
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="af778e40cf52dedde7c1896b3fbb2e02b"></a><!-- doxytag: member="OTCachedKey::Pause" ref="af778e40cf52dedde7c1896b3fbb2e02b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_o_t_cached_key.html#af778e40cf52dedde7c1896b3fbb2e02b">OTCachedKey::Pause</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_o_t_cached_key_8cpp_source.html#l00380">380</a> of file <a class="el" href="_o_t_cached_key_8cpp_source.html">OTCachedKey.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
    tthread::lock_guard&lt;tthread::mutex&gt; lock(m_Mutex);
    <span class="comment">// ----------------------------</span>
    <span class="keywordflow">if</span> (!m_bPaused)
    {
        m_bPaused = <span class="keyword">true</span>;
        <span class="keywordflow">return</span> <span class="keyword">true</span>;
    }
    <span class="keywordflow">return</span> <span class="keyword">false</span>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a3ed776977711a2d217fff380dd6cd3c5"></a><!-- doxytag: member="OTCachedKey::ResetMasterPassword" ref="a3ed776977711a2d217fff380dd6cd3c5" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_o_t_cached_key.html#a3ed776977711a2d217fff380dd6cd3c5">OTCachedKey::ResetMasterPassword</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_o_t_cached_key_8cpp_source.html#l01138">1138</a> of file <a class="el" href="_o_t_cached_key_8cpp_source.html">OTCachedKey.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
    tthread::lock_guard&lt;tthread::mutex&gt; lock(m_Mutex); <span class="comment">// Multiple threads can&#39;t get inside here at the same time.</span>
    <span class="comment">// -----------------------------</span>
    <a class="code" href="class_o_t_cached_key.html#a6933e0f88aae70fe30b925f150e8cc20">LowLevelReleaseThread</a>();
    <span class="comment">// -----------------------------</span>
    <span class="keywordflow">if</span> (NULL != m_pMasterPassword)
    {
        <a class="code" href="class_o_t_password.html">OTPassword</a> * pPassword = m_pMasterPassword;

        m_pMasterPassword = NULL;

        <span class="keyword">delete</span> pPassword; pPassword = NULL;
    }
    <span class="comment">// -----------------------------</span>
    <span class="comment">//</span>
    <span class="keywordflow">if</span> (NULL != m_pSymmetricKey)
    {
        <span class="comment">// We also remove it from the system keychain:</span>
        <span class="comment">//</span>
        <span class="keyword">const</span> std::string str_display;
        <span class="comment">// -----------------------------------------------------</span>
        <span class="keyword">const</span> <a class="code" href="class_o_t_identifier.html">OTIdentifier</a> idCachedKey(*m_pSymmetricKey); <span class="comment">// Symmetric Key ID of the Master key.</span>
        <span class="keyword">const</span> <a class="code" href="class_o_t_string.html">OTString</a>     strCachedKeyHash(idCachedKey); <span class="comment">// Same thing, in string form.</span>
        <span class="comment">// -----------------------------------------------------</span>
        <span class="keyword">const</span> <span class="keywordtype">bool</span> bDeletedSecret = this-&gt;<a class="code" href="class_o_t_cached_key.html#a95adb6583e128ed03719dc365e14005e">IsUsingSystemKeyring</a>() &amp;&amp;
                            <a class="code" href="class_o_t_keyring.html#a129634f61201323134ce7bde1acdc612">OTKeyring::DeleteSecret</a>(
                                strCachedKeyHash, <span class="comment">// HASH OF ENCRYPTED MASTER KEY</span>
                                str_display);     <span class="comment">// &quot;optional&quot; display string.</span>
        <span class="keywordflow">if</span> (bDeletedSecret)
        {
            <a class="code" href="class_o_t_log.html#a1f7549d776ee919dcb6517f611ded015">OTLog::Output</a>(0, <span class="stringliteral">&quot;OTCachedKey::ResetMasterPassword: FYI, deleted &quot;</span>
                          <span class="stringliteral">&quot;the derived key (used for unlocking the master key password) &quot;</span>
                          <span class="stringliteral">&quot;from system keychain at the same time as we deleted the master key &quot;</span>
                          <span class="stringliteral">&quot;itself, presumably due to the passphrase being reset.\n&quot;</span>);
        }
        <span class="comment">// -----------------------------------------------------</span>
        <span class="comment">// Now wipe the symmetric key itself (so it can later be</span>
        <span class="comment">// re-created as a new key.)</span>
        <span class="comment">//</span>
        <span class="keywordflow">if</span> (NULL != m_pSymmetricKey)
        {
            <a class="code" href="class_o_t_symmetric_key.html">OTSymmetricKey</a> * pSymmetricKey = m_pSymmetricKey;

            m_pSymmetricKey = NULL;

            <span class="keyword">delete</span> pSymmetricKey; pSymmetricKey = NULL;
        }
        <span class="comment">// -----------------------------------------------------</span>
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a4544aaabde49afd185df0fa05b775679"></a><!-- doxytag: member="OTCachedKey::SerializeFrom" ref="a4544aaabde49afd185df0fa05b775679" args="(const OTASCIIArmor &amp;ascInput)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_o_t_cached_key.html#a4544aaabde49afd185df0fa05b775679">OTCachedKey::SerializeFrom</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_t_a_s_c_i_i_armor.html">OTASCIIArmor</a> &amp;&#160;</td>
          <td class="paramname"><em>ascInput</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_o_t_cached_key_8cpp_source.html#l00514">514</a> of file <a class="el" href="_o_t_cached_key_8cpp_source.html">OTCachedKey.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
    tthread::lock_guard&lt;tthread::mutex&gt; lock(m_Mutex);

    <span class="keywordflow">if</span> (NULL == m_pSymmetricKey)
        <span class="keywordflow">return</span> <span class="keyword">false</span>;

    <span class="keywordflow">return</span> m_pSymmetricKey-&gt;<a class="code" href="class_o_t_symmetric_key.html#ac1a0a93da93305492ecebca03110a954">SerializeFrom</a>(ascInput);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a5f7a335ec7dc9ac8fd2b1ebf2ef26dd8"></a><!-- doxytag: member="OTCachedKey::SerializeTo" ref="a5f7a335ec7dc9ac8fd2b1ebf2ef26dd8" args="(OTASCIIArmor &amp;ascOutput)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_o_t_cached_key.html#a5f7a335ec7dc9ac8fd2b1ebf2ef26dd8">OTCachedKey::SerializeTo</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_t_a_s_c_i_i_armor.html">OTASCIIArmor</a> &amp;&#160;</td>
          <td class="paramname"><em>ascOutput</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_o_t_cached_key_8cpp_source.html#l00525">525</a> of file <a class="el" href="_o_t_cached_key_8cpp_source.html">OTCachedKey.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
    tthread::lock_guard&lt;tthread::mutex&gt; lock(m_Mutex);

    <span class="keywordflow">if</span> (NULL == m_pSymmetricKey)
        <span class="keywordflow">return</span> <span class="keyword">false</span>;

    <span class="keywordflow">return</span> m_pSymmetricKey-&gt;<a class="code" href="class_o_t_symmetric_key.html#a9d5d084b9986a338d28d171b8721ac2a">SerializeTo</a>(ascOutput);
}
</pre></div>
</div>
</div>
<a class="anchor" id="aa23079dbadddf2d7f2a2f205e3c05738"></a><!-- doxytag: member="OTCachedKey::SetCachedKey" ref="aa23079dbadddf2d7f2a2f205e3c05738" args="(const OTASCIIArmor &amp;ascCachedKey)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_o_t_cached_key.html#aa23079dbadddf2d7f2a2f205e3c05738">OTCachedKey::SetCachedKey</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_t_a_s_c_i_i_armor.html">OTASCIIArmor</a> &amp;&#160;</td>
          <td class="paramname"><em>ascCachedKey</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_o_t_cached_key_8cpp_source.html#l00478">478</a> of file <a class="el" href="_o_t_cached_key_8cpp_source.html">OTCachedKey.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
    tthread::lock_guard&lt;tthread::mutex&gt; lock(m_Mutex); <span class="comment">// Multiple threads can&#39;t get inside here at the same time.</span>

    <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(ascCachedKey.<a class="code" href="class_o_t_string.html#adf7489cd917d4ae5bf30853a3ad78daf">Exists</a>());
    <span class="comment">// ----------------------------------------</span>
    <span class="keywordflow">if</span> (NULL != m_pSymmetricKey)
    {
        <a class="code" href="class_o_t_log.html#a5acd90ac91c2618f395b0ff37ad4f8ee">OTLog::Error</a>(<span class="stringliteral">&quot;OTCachedKey::SetCachedKey: Warning: This was already set. (Re-setting.)\n&quot;</span>);

        <a class="code" href="class_o_t_symmetric_key.html">OTSymmetricKey</a> * pSymmetricKey = m_pSymmetricKey;

        m_pSymmetricKey = NULL;

        <span class="keyword">delete</span> pSymmetricKey; pSymmetricKey = NULL;
    }
    <span class="comment">// -----------------------------------------</span>
    m_pSymmetricKey = <span class="keyword">new</span> <a class="code" href="class_o_t_symmetric_key.html">OTSymmetricKey</a>;
    <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != m_pSymmetricKey);
    <span class="comment">// ----------------------------------</span>

    <span class="comment">//const bool bSerialized =</span>
    m_pSymmetricKey-&gt;<a class="code" href="class_o_t_symmetric_key.html#ac1a0a93da93305492ecebca03110a954">SerializeFrom</a>(ascCachedKey);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a7b0822845b243c8f739f021d0f96bcd7"></a><!-- doxytag: member="OTCachedKey::SetTimeoutSeconds" ref="a7b0822845b243c8f739f021d0f96bcd7" args="(int32_t nTimeoutSeconds)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_o_t_cached_key.html#a7b0822845b243c8f739f021d0f96bcd7">OTCachedKey::SetTimeoutSeconds</a> </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>nTimeoutSeconds</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_o_t_cached_key_8cpp_source.html#l00466">466</a> of file <a class="el" href="_o_t_cached_key_8cpp_source.html">OTCachedKey.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
    tthread::lock_guard&lt;tthread::mutex&gt; lock(m_Mutex); <span class="comment">// Multiple threads can&#39;t get inside here at the same time.</span>

    <a class="code" href="_o_t_assert_8hpp.html#a033b133f48e61f2b227c52ad2be0c882">OT_ASSERT_MSG</a>(nTimeoutSeconds &gt;= (-1), <span class="stringliteral">&quot;OTCachedKey::SetTimeoutSeconds: ASSERT: nTimeoutSeconds must be &gt;= (-1)\n&quot;</span>);

    m_nTimeoutSeconds = nTimeoutSeconds;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a7ac7c4130bd8d8cb9a443be54ae5e004"></a><!-- doxytag: member="OTCachedKey::ThreadTimeout" ref="a7ac7c4130bd8d8cb9a443be54ae5e004" args="(void *pArg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_o_t_cached_key.html#a7ac7c4130bd8d8cb9a443be54ae5e004">OTCachedKey::ThreadTimeout</a> </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pArg</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_o_t_cached_key_8cpp_source.html#l01040">1040</a> of file <a class="el" href="_o_t_cached_key_8cpp_source.html">OTCachedKey.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">// TODO: Save a copy of pArg, in the cached key object, and delete it whenever LowLevelRemoveThread</span>
    <span class="comment">// is called. Otherwise it&#39;s a memory leak.</span>
    <span class="comment">//</span>
    _SharedPtr&lt;OTCachedKey&gt; * pthreadSharedPtr = <span class="keyword">static_cast&lt;</span>_SharedPtr&lt;OTCachedKey&gt; *<span class="keyword">&gt;</span>(pArg);
    _SharedPtr&lt;OTCachedKey&gt;   pMyself = *pthreadSharedPtr;

    <span class="keywordflow">if</span> (!pMyself) { <a class="code" href="_o_t_assert_8hpp.html#aa86aeed4e57eecded96d5955b5cc23c5">OT_FAIL_MSG</a>(<span class="stringliteral">&quot;OTCachedKey::ThreadTimeout: Need ptr to master key here, that activated this thread.\n&quot;</span>); }

    <span class="comment">// --------------------------------------</span>
<span class="comment">//    tthread::lock_guard&lt;tthread::mutex&gt; lock(*(pMyself-&gt;GetMutex())); // Multiple threads can&#39;t get inside here at the same time.</span>
    <span class="comment">// --------------------------------------</span>
    int32_t nTimeoutSeconds = 0;

    {
        tthread::lock_guard&lt;tthread::mutex&gt; lock(OTCachedKey::s_mutexThreadTimeout);

        <span class="keywordflow">if</span> (pMyself)
        {
            nTimeoutSeconds = pMyself-&gt;GetTimeoutSeconds(); <span class="comment">// locks mutex internally.</span>
        }
    }
    <span class="comment">// --------------------------------------</span>
    <span class="keywordflow">if</span> (nTimeoutSeconds &gt; 0)
    {
        <span class="keywordflow">if</span> (pMyself)
            tthread::this_thread::sleep_for(tthread::chrono::seconds(nTimeoutSeconds)); <span class="comment">// &lt;===== ASLEEP!</span>
    }
    <span class="comment">// --------------------------------------</span>
    {
        tthread::lock_guard&lt;tthread::mutex&gt; lock(OTCachedKey::s_mutexThreadTimeout);

        <span class="keywordflow">if</span> (pMyself &amp;&amp; (nTimeoutSeconds != (-1)))
        {
            pMyself-&gt;DestroyMasterPassword(); <span class="comment">// locks mutex internally.</span>
        }
    }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a0fa693b734082f41578b9984d242dd79"></a><!-- doxytag: member="OTCachedKey::Unpause" ref="a0fa693b734082f41578b9984d242dd79" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_o_t_cached_key.html#a0fa693b734082f41578b9984d242dd79">OTCachedKey::Unpause</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_o_t_cached_key_8cpp_source.html#l00393">393</a> of file <a class="el" href="_o_t_cached_key_8cpp_source.html">OTCachedKey.cpp</a>.</p>
<div class="fragment"><pre class="fragment">{
    tthread::lock_guard&lt;tthread::mutex&gt; lock(m_Mutex);
    <span class="comment">// ----------------------------</span>
    <span class="keywordflow">if</span> (m_bPaused)
    {
        m_bPaused = <span class="keyword">false</span>;
        <span class="keywordflow">return</span> <span class="keyword">true</span>;
    }
    <span class="keywordflow">return</span> <span class="keyword">false</span>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a6dd72d33332ed12525d15f0861960c5f"></a><!-- doxytag: member="OTCachedKey::UseSystemKeyring" ref="a6dd72d33332ed12525d15f0861960c5f" args="(bool bUsing=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EXPORT void <a class="el" href="class_o_t_cached_key.html#a6dd72d33332ed12525d15f0861960c5f">OTCachedKey::UseSystemKeyring</a> </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bUsing</em> = <code>true</code></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Definition at line <a class="el" href="_o_t_cached_key_8hpp_source.html#l00290">290</a> of file <a class="el" href="_o_t_cached_key_8hpp_source.html">OTCachedKey.hpp</a>.</p>
<div class="fragment"><pre class="fragment">{ m_bUse_System_Keyring = bUsing; } <span class="comment">// Start using system keyring.</span>
</pre></div>
</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/otlib/<a class="el" href="_o_t_cached_key_8hpp_source.html">OTCachedKey.hpp</a></li>
<li>src/otlib/<a class="el" href="_o_t_cached_key_8cpp_source.html">OTCachedKey.cpp</a></li>
</ul>
</div><!-- contents -->
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="class_o_t_cached_key.html">OTCachedKey</a>      </li>

    <li class="footer">Generated on Wed May 21 2014 11:26:11 for Open-Transactions by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1 </li>
   </ul>
 </div>


</body>
</html>
