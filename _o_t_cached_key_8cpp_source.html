<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Open-Transactions: src/otlib/OTCachedKey.cpp Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Open-Transactions
   &#160;<span id="projectnumber">master/1066fb4910a63ee3f7de8e0807fee3eb663b66c7</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('_o_t_cached_key_8cpp.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">src/otlib/OTCachedKey.cpp</div>  </div>
</div><!--header-->
<div class="contents">
<a href="_o_t_cached_key_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/************************************************************</span>
<a name="l00002"></a>00002 <span class="comment"> *</span>
<a name="l00003"></a>00003 <span class="comment"> *  OTCachedKey.cpp</span>
<a name="l00004"></a>00004 <span class="comment"> *</span>
<a name="l00005"></a>00005 <span class="comment"> */</span>
<a name="l00006"></a>00006 
<a name="l00007"></a>00007 <span class="comment">/************************************************************</span>
<a name="l00008"></a>00008 <span class="comment"> -----BEGIN PGP SIGNED MESSAGE-----</span>
<a name="l00009"></a>00009 <span class="comment"> Hash: SHA1</span>
<a name="l00010"></a>00010 <span class="comment"></span>
<a name="l00011"></a>00011 <span class="comment"> *                 OPEN TRANSACTIONS</span>
<a name="l00012"></a>00012 <span class="comment"> *</span>
<a name="l00013"></a>00013 <span class="comment"> *       Financial Cryptography and Digital Cash</span>
<a name="l00014"></a>00014 <span class="comment"> *       Library, Protocol, API, Server, CLI, GUI</span>
<a name="l00015"></a>00015 <span class="comment"> *</span>
<a name="l00016"></a>00016 <span class="comment"> *       -- Anonymous Numbered Accounts.</span>
<a name="l00017"></a>00017 <span class="comment"> *       -- Untraceable Digital Cash.</span>
<a name="l00018"></a>00018 <span class="comment"> *       -- Triple-Signed Receipts.</span>
<a name="l00019"></a>00019 <span class="comment"> *       -- Cheques, Vouchers, Transfers, Inboxes.</span>
<a name="l00020"></a>00020 <span class="comment"> *       -- Basket Currencies, Markets, Payment Plans.</span>
<a name="l00021"></a>00021 <span class="comment"> *       -- Signed, XML, Ricardian-style Contracts.</span>
<a name="l00022"></a>00022 <span class="comment"> *       -- Scripted smart contracts.</span>
<a name="l00023"></a>00023 <span class="comment"> *</span>
<a name="l00024"></a>00024 <span class="comment"> *  Copyright (C) 2010-2013 by &quot;Fellow Traveler&quot; (A pseudonym)</span>
<a name="l00025"></a>00025 <span class="comment"> *</span>
<a name="l00026"></a>00026 <span class="comment"> *  EMAIL:</span>
<a name="l00027"></a>00027 <span class="comment"> *  FellowTraveler@rayservers.net</span>
<a name="l00028"></a>00028 <span class="comment"> *</span>
<a name="l00029"></a>00029 <span class="comment"> *  BITCOIN:  1NtTPVVjDsUfDWybS4BwvHpG2pdS9RnYyQ</span>
<a name="l00030"></a>00030 <span class="comment"> *</span>
<a name="l00031"></a>00031 <span class="comment"> *  KEY FINGERPRINT (PGP Key in license file):</span>
<a name="l00032"></a>00032 <span class="comment"> *  9DD5 90EB 9292 4B48 0484  7910 0308 00ED F951 BB8E</span>
<a name="l00033"></a>00033 <span class="comment"> *</span>
<a name="l00034"></a>00034 <span class="comment"> *  OFFICIAL PROJECT WIKI(s):</span>
<a name="l00035"></a>00035 <span class="comment"> *  https://github.com/FellowTraveler/Moneychanger</span>
<a name="l00036"></a>00036 <span class="comment"> *  https://github.com/FellowTraveler/Open-Transactions/wiki</span>
<a name="l00037"></a>00037 <span class="comment"> *</span>
<a name="l00038"></a>00038 <span class="comment"> *  WEBSITE:</span>
<a name="l00039"></a>00039 <span class="comment"> *  http://www.OpenTransactions.org/</span>
<a name="l00040"></a>00040 <span class="comment"> *</span>
<a name="l00041"></a>00041 <span class="comment"> *  Components and licensing:</span>
<a name="l00042"></a>00042 <span class="comment"> *   -- Moneychanger..A Java client GUI.....LICENSE:.....GPLv3</span>
<a name="l00043"></a>00043 <span class="comment"> *   -- otlib.........A class library.......LICENSE:...LAGPLv3</span>
<a name="l00044"></a>00044 <span class="comment"> *   -- otapi.........A client API..........LICENSE:...LAGPLv3</span>
<a name="l00045"></a>00045 <span class="comment"> *   -- opentxs/ot....Command-line client...LICENSE:...LAGPLv3</span>
<a name="l00046"></a>00046 <span class="comment"> *   -- otserver......Server Application....LICENSE:....AGPLv3</span>
<a name="l00047"></a>00047 <span class="comment"> *  Github.com/FellowTraveler/Open-Transactions/wiki/Components</span>
<a name="l00048"></a>00048 <span class="comment"> *</span>
<a name="l00049"></a>00049 <span class="comment"> *  All of the above OT components were designed and written by</span>
<a name="l00050"></a>00050 <span class="comment"> *  Fellow Traveler, with the exception of Moneychanger, which</span>
<a name="l00051"></a>00051 <span class="comment"> *  was contracted out to Vicky C (bitcointrader4@gmail.com).</span>
<a name="l00052"></a>00052 <span class="comment"> *  The open-source community has since actively contributed.</span>
<a name="l00053"></a>00053 <span class="comment"> *</span>
<a name="l00054"></a>00054 <span class="comment"> *  -----------------------------------------------------</span>
<a name="l00055"></a>00055 <span class="comment"> *</span>
<a name="l00056"></a>00056 <span class="comment"> *   LICENSE:</span>
<a name="l00057"></a>00057 <span class="comment"> *   This program is free software: you can redistribute it</span>
<a name="l00058"></a>00058 <span class="comment"> *   and/or modify it under the terms of the GNU Affero</span>
<a name="l00059"></a>00059 <span class="comment"> *   General Public License as published by the Free Software</span>
<a name="l00060"></a>00060 <span class="comment"> *   Foundation, either version 3 of the License, or (at your</span>
<a name="l00061"></a>00061 <span class="comment"> *   option) any later version.</span>
<a name="l00062"></a>00062 <span class="comment"> *</span>
<a name="l00063"></a>00063 <span class="comment"> *   ADDITIONAL PERMISSION under the GNU Affero GPL version 3</span>
<a name="l00064"></a>00064 <span class="comment"> *   section 7: (This paragraph applies only to the LAGPLv3</span>
<a name="l00065"></a>00065 <span class="comment"> *   components listed above.) If you modify this Program, or</span>
<a name="l00066"></a>00066 <span class="comment"> *   any covered work, by linking or combining it with other</span>
<a name="l00067"></a>00067 <span class="comment"> *   code, such other code is not for that reason alone subject</span>
<a name="l00068"></a>00068 <span class="comment"> *   to any of the requirements of the GNU Affero GPL version 3.</span>
<a name="l00069"></a>00069 <span class="comment"> *   (==&gt; This means if you are only using the OT API, then you</span>
<a name="l00070"></a>00070 <span class="comment"> *   don&#39;t have to open-source your code--only your changes to</span>
<a name="l00071"></a>00071 <span class="comment"> *   Open-Transactions itself must be open source. Similar to</span>
<a name="l00072"></a>00072 <span class="comment"> *   LGPLv3, except it applies to software-as-a-service, not</span>
<a name="l00073"></a>00073 <span class="comment"> *   just to distributing binaries.)</span>
<a name="l00074"></a>00074 <span class="comment"> *</span>
<a name="l00075"></a>00075 <span class="comment"> *   Extra WAIVER for OpenSSL, Lucre, and all other libraries</span>
<a name="l00076"></a>00076 <span class="comment"> *   used by Open Transactions: This program is released under</span>
<a name="l00077"></a>00077 <span class="comment"> *   the AGPL with the additional exemption that compiling,</span>
<a name="l00078"></a>00078 <span class="comment"> *   linking, and/or using OpenSSL is allowed. The same is true</span>
<a name="l00079"></a>00079 <span class="comment"> *   for any other open source libraries included in this</span>
<a name="l00080"></a>00080 <span class="comment"> *   project: complete waiver from the AGPL is hereby granted to</span>
<a name="l00081"></a>00081 <span class="comment"> *   compile, link, and/or use them with Open-Transactions,</span>
<a name="l00082"></a>00082 <span class="comment"> *   according to their own terms, as long as the rest of the</span>
<a name="l00083"></a>00083 <span class="comment"> *   Open-Transactions terms remain respected, with regard to</span>
<a name="l00084"></a>00084 <span class="comment"> *   the Open-Transactions code itself.</span>
<a name="l00085"></a>00085 <span class="comment"> *</span>
<a name="l00086"></a>00086 <span class="comment"> *   Lucre License:</span>
<a name="l00087"></a>00087 <span class="comment"> *   This code is also &quot;dual-license&quot;, meaning that Ben Lau-</span>
<a name="l00088"></a>00088 <span class="comment"> *   rie&#39;s license must also be included and respected, since</span>
<a name="l00089"></a>00089 <span class="comment"> *   the code for Lucre is also included with Open Transactions.</span>
<a name="l00090"></a>00090 <span class="comment"> *   See Open-Transactions/src/otlib/lucre/LUCRE_LICENSE.txt</span>
<a name="l00091"></a>00091 <span class="comment"> *   The Laurie requirements are light, but if there is any</span>
<a name="l00092"></a>00092 <span class="comment"> *   problem with his license, simply remove the Lucre code.</span>
<a name="l00093"></a>00093 <span class="comment"> *   Although there are no other blind token algorithms in Open</span>
<a name="l00094"></a>00094 <span class="comment"> *   Transactions (yet. credlib is coming), the other functions</span>
<a name="l00095"></a>00095 <span class="comment"> *   will continue to operate.</span>
<a name="l00096"></a>00096 <span class="comment"> *   See Lucre on Github:  https://github.com/benlaurie/lucre</span>
<a name="l00097"></a>00097 <span class="comment"> *   -----------------------------------------------------</span>
<a name="l00098"></a>00098 <span class="comment"> *   You should have received a copy of the GNU Affero General</span>
<a name="l00099"></a>00099 <span class="comment"> *   Public License along with this program.  If not, see:</span>
<a name="l00100"></a>00100 <span class="comment"> *   http://www.gnu.org/licenses/</span>
<a name="l00101"></a>00101 <span class="comment"> *</span>
<a name="l00102"></a>00102 <span class="comment"> *   If you would like to use this software outside of the free</span>
<a name="l00103"></a>00103 <span class="comment"> *   software license, please contact FellowTraveler.</span>
<a name="l00104"></a>00104 <span class="comment"> *   (Unfortunately many will run anonymously and untraceably,</span>
<a name="l00105"></a>00105 <span class="comment"> *   so who could really stop them?)</span>
<a name="l00106"></a>00106 <span class="comment"> *</span>
<a name="l00107"></a>00107 <span class="comment"> *   DISCLAIMER:</span>
<a name="l00108"></a>00108 <span class="comment"> *   This program is distributed in the hope that it will be</span>
<a name="l00109"></a>00109 <span class="comment"> *   useful, but WITHOUT ANY WARRANTY; without even the implied</span>
<a name="l00110"></a>00110 <span class="comment"> *   warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR</span>
<a name="l00111"></a>00111 <span class="comment"> *   PURPOSE.  See the GNU Affero General Public License for</span>
<a name="l00112"></a>00112 <span class="comment"> *   more details.</span>
<a name="l00113"></a>00113 <span class="comment"></span>
<a name="l00114"></a>00114 <span class="comment"> -----BEGIN PGP SIGNATURE-----</span>
<a name="l00115"></a>00115 <span class="comment"> Version: GnuPG v1.4.9 (Darwin)</span>
<a name="l00116"></a>00116 <span class="comment"></span>
<a name="l00117"></a>00117 <span class="comment"> iQIcBAEBAgAGBQJRSsfJAAoJEAMIAO35UbuOQT8P/RJbka8etf7wbxdHQNAY+2cC</span>
<a name="l00118"></a>00118 <span class="comment"> vDf8J3X8VI+pwMqv6wgTVy17venMZJa4I4ikXD/MRyWV1XbTG0mBXk/7AZk7Rexk</span>
<a name="l00119"></a>00119 <span class="comment"> KTvL/U1kWiez6+8XXLye+k2JNM6v7eej8xMrqEcO0ZArh/DsLoIn1y8p8qjBI7+m</span>
<a name="l00120"></a>00120 <span class="comment"> aE7lhstDiD0z8mwRRLKFLN2IH5rAFaZZUvj5ERJaoYUKdn4c+RcQVei2YOl4T0FU</span>
<a name="l00121"></a>00121 <span class="comment"> LWND3YLoH8naqJXkaOKEN4UfJINCwxhe5Ke9wyfLWLUO7NamRkWD2T7CJ0xocnD1</span>
<a name="l00122"></a>00122 <span class="comment"> sjAzlVGNgaFDRflfIF4QhBx1Ddl6wwhJfw+d08bjqblSq8aXDkmFA7HeunSFKkdn</span>
<a name="l00123"></a>00123 <span class="comment"> oIEOEgyj+veuOMRJC5pnBJ9vV+7qRdDKQWaCKotynt4sWJDGQ9kWGWm74SsNaduN</span>
<a name="l00124"></a>00124 <span class="comment"> TPMyr9kNmGsfR69Q2Zq/FLcLX/j8ESxU+HYUB4vaARw2xEOu2xwDDv6jt0j3Vqsg</span>
<a name="l00125"></a>00125 <span class="comment"> x7rWv4S/Eh18FDNDkVRChiNoOIilLYLL6c38uMf1pnItBuxP3uhgY6COm59kVaRh</span>
<a name="l00126"></a>00126 <span class="comment"> nyGTYCDYD2TK+fI9o89F1297uDCwEJ62U0Q7iTDp5QuXCoxkPfv8/kX6lS6T3y9G</span>
<a name="l00127"></a>00127 <span class="comment"> M9mqIoLbIQ1EDntFv7/t6fUTS2+46uCrdZWbQ5RjYXdrzjij02nDmJAm2BngnZvd</span>
<a name="l00128"></a>00128 <span class="comment"> kamH0Y/n11lCvo1oQxM+</span>
<a name="l00129"></a>00129 <span class="comment"> =uSzz</span>
<a name="l00130"></a>00130 <span class="comment"> -----END PGP SIGNATURE-----</span>
<a name="l00131"></a>00131 <span class="comment"> **************************************************************/</span>
<a name="l00132"></a>00132 
<a name="l00133"></a>00133 <span class="preprocessor">#include &lt;<a class="code" href="stdafx_8hpp.html">stdafx.hpp</a>&gt;</span>
<a name="l00134"></a>00134 
<a name="l00135"></a>00135 <span class="preprocessor">#include &lt;<a class="code" href="_o_t_cached_key_8hpp.html">OTCachedKey.hpp</a>&gt;</span>
<a name="l00136"></a>00136 
<a name="l00137"></a>00137 <span class="preprocessor">#include &lt;<a class="code" href="_o_t_symmetric_key_8hpp.html">OTSymmetricKey.hpp</a>&gt;</span>
<a name="l00138"></a>00138 <span class="preprocessor">#include &lt;<a class="code" href="_o_t_string_8hpp.html">OTString.hpp</a>&gt;</span>
<a name="l00139"></a>00139 <span class="preprocessor">#include &lt;<a class="code" href="_o_t_log_8hpp.html">OTLog.hpp</a>&gt;</span>
<a name="l00140"></a>00140 <span class="preprocessor">#include &lt;<a class="code" href="_o_t_identifier_8hpp.html">OTIdentifier.hpp</a>&gt;</span>
<a name="l00141"></a>00141 <span class="preprocessor">#include &lt;<a class="code" href="_o_t_a_s_c_i_i_armor_8hpp.html">OTASCIIArmor.hpp</a>&gt;</span>
<a name="l00142"></a>00142 <span class="preprocessor">#include &lt;<a class="code" href="_o_t_password_8hpp.html">OTPassword.hpp</a>&gt;</span>
<a name="l00143"></a>00143 <span class="preprocessor">#include &lt;<a class="code" href="_o_t_crypto_8hpp.html">OTCrypto.hpp</a>&gt;</span>
<a name="l00144"></a>00144 <span class="preprocessor">#include &lt;<a class="code" href="_o_t_keyring_8hpp.html">OTKeyring.hpp</a>&gt;</span>
<a name="l00145"></a>00145 <span class="preprocessor">#include &lt;<a class="code" href="_o_t_asymmetric_key_8hpp.html">OTAsymmetricKey.hpp</a>&gt;</span>
<a name="l00146"></a>00146 
<a name="l00147"></a>00147 <span class="preprocessor">#include &quot;tinythread.hpp&quot;</span>   <span class="comment">// These are in the header already.</span>
<a name="l00148"></a>00148 <span class="keyword">using namespace </span>tthread;
<a name="l00149"></a>00149 
<a name="l00150"></a><a class="code" href="_o_t_cached_key_8cpp.html#aa00325ea7c8ea1e1406bb2d019d7e6fe">00150</a> <span class="preprocessor">#define OT_DEFAULT_PASSWORD &quot;test&quot;</span>
<a name="l00151"></a>00151 <span class="preprocessor"></span>
<a name="l00152"></a>00152 <span class="preprocessor">#if defined (OT_CRYPTO_USING_OPENSSL)</span>
<a name="l00153"></a>00153 <span class="preprocessor"></span>
<a name="l00154"></a>00154 <span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span>
<a name="l00155"></a>00155 {
<a name="l00156"></a>00156 <span class="preprocessor">#include &lt;openssl/opensslconf.h&gt;</span>
<a name="l00157"></a>00157 }
<a name="l00158"></a>00158 
<a name="l00159"></a>00159 <span class="preprocessor">#endif</span>
<a name="l00160"></a>00160 <span class="preprocessor"></span>
<a name="l00161"></a>00161 
<a name="l00162"></a>00162 <span class="comment">//static</span>
<a name="l00163"></a>00163 
<a name="l00164"></a>00164 tthread::mutex  OTCachedKey::s_mutexThreadTimeout;
<a name="l00165"></a>00165 
<a name="l00166"></a>00166 tthread::mutex  OTCachedKey::s_mutexCachedKeys;
<a name="l00167"></a>00167 <a class="code" href="_o_t_cached_key_8hpp.html#a32c9259e56d708a983d9fb79fee41403">mapOfCachedKeys</a> OTCachedKey::s_mapCachedKeys;
<a name="l00168"></a>00168 
<a name="l00169"></a>00169 
<a name="l00170"></a><a class="code" href="class_o_t_cached_key.html#a841c81a6323383f9762f21cc820bbdab">00170</a> <span class="keywordtype">bool</span> <a class="code" href="class_o_t_cached_key.html#a841c81a6323383f9762f21cc820bbdab">OTCachedKey::IsGenerated</a>()
<a name="l00171"></a>00171 {
<a name="l00172"></a>00172     tthread::lock_guard&lt;tthread::mutex&gt; lock(m_Mutex);
<a name="l00173"></a>00173     <span class="comment">// ----------------------------</span>
<a name="l00174"></a>00174     <span class="keywordtype">bool</span> bReturnVal = <span class="keyword">false</span>;
<a name="l00175"></a>00175 
<a name="l00176"></a>00176     <span class="keywordflow">if</span> (NULL != m_pSymmetricKey)
<a name="l00177"></a>00177     {
<a name="l00178"></a>00178         bReturnVal = m_pSymmetricKey-&gt;IsGenerated();
<a name="l00179"></a>00179     }
<a name="l00180"></a>00180 
<a name="l00181"></a>00181     <span class="keywordflow">return</span> bReturnVal;
<a name="l00182"></a>00182 }
<a name="l00183"></a>00183 
<a name="l00184"></a>00184 
<a name="l00185"></a><a class="code" href="class_o_t_cached_key.html#a1b868584e683faa9cd4cc63bcd5bc3f4">00185</a> <span class="keywordtype">bool</span> <a class="code" href="class_o_t_cached_key.html#a1b868584e683faa9cd4cc63bcd5bc3f4">OTCachedKey::HasHashCheck</a>()
<a name="l00186"></a>00186 {
<a name="l00187"></a>00187     tthread::lock_guard&lt;tthread::mutex&gt; lock(m_Mutex);
<a name="l00188"></a>00188     <span class="comment">// ----------------------------</span>
<a name="l00189"></a>00189     <span class="keywordtype">bool</span> bReturnVal = <span class="keyword">false</span>;
<a name="l00190"></a>00190 
<a name="l00191"></a>00191     <span class="keywordflow">if</span> (NULL != m_pSymmetricKey)
<a name="l00192"></a>00192     {
<a name="l00193"></a>00193         bReturnVal = m_pSymmetricKey-&gt;HasHashCheck();
<a name="l00194"></a>00194     }
<a name="l00195"></a>00195 
<a name="l00196"></a>00196     <span class="keywordflow">return</span> bReturnVal;
<a name="l00197"></a>00197 }
<a name="l00198"></a>00198 
<a name="l00199"></a>00199 
<a name="l00200"></a>00200 <span class="comment">// if you pass in a master key ID, it will look it up on an existing cached map of master keys.</span>
<a name="l00201"></a>00201 <span class="comment">// Otherwise it will use &quot;the&quot; global Master Key (the one used for the Nyms.)</span>
<a name="l00202"></a>00202 <span class="comment">//</span>
<a name="l00203"></a>00203 <span class="comment">//static</span>
<a name="l00204"></a><a class="code" href="class_o_t_cached_key.html#a8780b8a3f392b0bc4c11253a797d8b5a">00204</a> _SharedPtr&lt;OTCachedKey&gt; <a class="code" href="class_o_t_cached_key.html#a8780b8a3f392b0bc4c11253a797d8b5a">OTCachedKey::It</a>(<a class="code" href="class_o_t_identifier.html">OTIdentifier</a> * pIdentifier<span class="comment">/*=NULL*/</span>)
<a name="l00205"></a>00205 {
<a name="l00206"></a>00206     <span class="comment">// For now we&#39;re only allowing a single global instance, unless you pass in an ID, in which case we keep a map.</span>
<a name="l00207"></a>00207     <span class="comment">//</span>
<a name="l00208"></a>00208     <span class="keyword">static</span> _SharedPtr&lt;OTCachedKey&gt; s_theSingleton(<span class="keyword">new</span> <a class="code" href="class_o_t_cached_key.html">OTCachedKey</a>);  <span class="comment">// Default is 0 (&quot;you have to type your PW a million times&quot;), but it&#39;s overridden in config file.</span>
<a name="l00209"></a>00209 
<a name="l00210"></a>00210     <span class="keywordflow">if</span> (NULL == pIdentifier)
<a name="l00211"></a>00211         <span class="keywordflow">return</span> s_theSingleton; <span class="comment">// Notice if you pass NULL (no args) then it ALWAYS returns a good pointer here.</span>
<a name="l00212"></a>00212     <span class="comment">// ----------------------------------------------------------------</span>
<a name="l00213"></a>00213     <span class="comment">// There is a chance of failure if you pass an ID, since maybe it&#39;s not already on the map.</span>
<a name="l00214"></a>00214     <span class="comment">// But at least by this point we know FOR SURE that pIdentifier is NOT NULL.</span>
<a name="l00215"></a>00215     <span class="comment">//</span>
<a name="l00216"></a>00216     tthread::lock_guard&lt;tthread::mutex&gt; lock(OTCachedKey::s_mutexCachedKeys);
<a name="l00217"></a>00217     <span class="comment">// ----------------------------</span>
<a name="l00218"></a>00218     <span class="keyword">const</span> <a class="code" href="class_o_t_string.html">OTString</a>    strIdentifier (*pIdentifier);
<a name="l00219"></a>00219     <span class="keyword">const</span> std::string str_identifier(strIdentifier.<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>());
<a name="l00220"></a>00220 
<a name="l00221"></a>00221     mapOfCachedKeys::iterator it_keys = s_mapCachedKeys.find(str_identifier);
<a name="l00222"></a>00222 
<a name="l00223"></a>00223     <span class="keywordflow">if</span> (s_mapCachedKeys.end() != it_keys) <span class="comment">// found it!</span>
<a name="l00224"></a>00224     {
<a name="l00225"></a>00225         _SharedPtr&lt;OTCachedKey&gt; pShared(it_keys-&gt;second);
<a name="l00226"></a>00226 
<a name="l00227"></a>00227         <span class="keywordflow">if</span> (pShared)
<a name="l00228"></a>00228         {
<a name="l00229"></a>00229             <span class="keywordflow">return</span> pShared;
<a name="l00230"></a>00230         }
<a name="l00231"></a>00231         <span class="keywordflow">else</span>
<a name="l00232"></a>00232             s_mapCachedKeys.erase(it_keys);
<a name="l00233"></a>00233     }
<a name="l00234"></a>00234     <span class="comment">// ----------------------------------------------------------------------</span>
<a name="l00235"></a>00235     <span class="comment">// else: We can&#39;t instantiate it, since we don&#39;t have the corresponding CachedKey, just its</span>
<a name="l00236"></a>00236     <span class="comment">// Identifier. We&#39;re forced simply to return NULL in this case.</span>
<a name="l00237"></a>00237     <span class="comment">//</span>
<a name="l00238"></a>00238     <span class="comment">// Therefore you should normally pass in the master key (the same one that you want to cache a copy</span>
<a name="l00239"></a>00239     <span class="comment">// of) using the below version of It(). That version creates the copy, if it&#39;s not already there.</span>
<a name="l00240"></a>00240     <span class="comment">//</span>
<a name="l00241"></a>00241     <span class="keywordflow">return</span> _SharedPtr&lt;OTCachedKey&gt;();
<a name="l00242"></a>00242 }
<a name="l00243"></a>00243 
<a name="l00244"></a>00244 
<a name="l00245"></a>00245 <span class="comment">// if you pass in a master key, it will look it up on an existing cached map of master keys,</span>
<a name="l00246"></a>00246 <span class="comment">// based on the ID of the master key passed in. (Where it stores its own cached copy of the same</span>
<a name="l00247"></a>00247 <span class="comment">// master key.)</span>
<a name="l00248"></a>00248 <span class="comment">// NOTE: If you use it this way, then you must NEVER use the actual master key being cached (such as</span>
<a name="l00249"></a>00249 <span class="comment">// the one stored in a password-protected purse.) Instead, you must always look up the cached version,</span>
<a name="l00250"></a>00250 <span class="comment">// and use THAT master key, instead of the actual one in your  OTPurse. The only time</span>
<a name="l00251"></a>00251 <span class="comment">// you can use your master key itself is when loading it (such as when OTPurse loads</span>
<a name="l00252"></a>00252 <span class="comment">// its internal Master Key.) But thereafter, use the cached version of it for all operations</span>
<a name="l00253"></a>00253 <span class="comment">// and for saving.</span>
<a name="l00254"></a>00254 <span class="comment">//</span>
<a name="l00255"></a>00255 <span class="comment">//static</span>
<a name="l00256"></a><a class="code" href="class_o_t_cached_key.html#a47cf6d6425469515db0e21ec4e4b4833">00256</a> _SharedPtr&lt;OTCachedKey&gt; <a class="code" href="class_o_t_cached_key.html#a8780b8a3f392b0bc4c11253a797d8b5a">OTCachedKey::It</a>(<a class="code" href="class_o_t_cached_key.html">OTCachedKey</a> &amp; theSourceKey) <span class="comment">// Note: parameter no longer const due to need to lock its mutex.</span>
<a name="l00257"></a>00257 {
<a name="l00258"></a>00258 <span class="comment">//    tthread::lock_guard&lt;tthread::mutex&gt; lock(*(theSourceKey.GetMutex()));</span>
<a name="l00259"></a>00259     <span class="comment">// ----------------------------------------------------------------</span>
<a name="l00260"></a>00260     <span class="comment">// There is no chance of failure since he passed the master key itself,</span>
<a name="l00261"></a>00261     <span class="comment">// since even if it&#39;s not already on the map, we&#39;ll just create a copy and put</span>
<a name="l00262"></a>00262     <span class="comment">// it there ourselves, returning a pointer either way.</span>
<a name="l00263"></a>00263     <span class="comment">//</span>
<a name="l00264"></a>00264     <span class="comment">// Except... if theSourceKey isn&#39;t generated...</span>
<a name="l00265"></a>00265     <span class="comment">//</span>
<a name="l00266"></a>00266     <span class="keywordflow">if</span> (!(const_cast&lt;OTCachedKey &amp;&gt;(theSourceKey)).IsGenerated()) <span class="comment">//it&#39;s only not const due to the mutex inside</span>
<a name="l00267"></a>00267     {
<a name="l00268"></a>00268         <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;OTCachedKey::%s: theSourceKey.IsGenerated() returned false. &quot;</span>
<a name="l00269"></a>00269                       <span class="stringliteral">&quot;(Returning NULL.)\n&quot;</span>, __FUNCTION__);
<a name="l00270"></a>00270         <span class="keywordflow">return</span> _SharedPtr&lt;OTCachedKey&gt;();
<a name="l00271"></a>00271     }
<a name="l00272"></a>00272     <span class="comment">// ----------------------------------</span>
<a name="l00273"></a>00273     tthread::lock_guard&lt;tthread::mutex&gt; lock_keys(OTCachedKey::s_mutexCachedKeys);
<a name="l00274"></a>00274     <span class="comment">// ----------------------------------</span>
<a name="l00275"></a>00275     <span class="keyword">const</span> <a class="code" href="class_o_t_identifier.html">OTIdentifier</a> theSourceID(theSourceKey);
<a name="l00276"></a>00276     <span class="comment">// ----------------------------------</span>
<a name="l00277"></a>00277     <span class="keyword">const</span> <a class="code" href="class_o_t_string.html">OTString</a>     strIdentifier (theSourceID);
<a name="l00278"></a>00278     <span class="keyword">const</span> std::string  str_identifier(strIdentifier.<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>());
<a name="l00279"></a>00279 
<a name="l00280"></a>00280     <span class="comment">// Let&#39;s see if it&#39;s already there on the map...</span>
<a name="l00281"></a>00281     <span class="comment">//</span>
<a name="l00282"></a>00282     mapOfCachedKeys::iterator it_keys = s_mapCachedKeys.find(str_identifier);
<a name="l00283"></a>00283 
<a name="l00284"></a>00284     <span class="keywordflow">if</span> (s_mapCachedKeys.end() != it_keys) <span class="comment">// found it!</span>
<a name="l00285"></a>00285     {
<a name="l00286"></a>00286         _SharedPtr&lt;OTCachedKey&gt; pMaster(it_keys-&gt;second);
<a name="l00287"></a>00287 
<a name="l00288"></a>00288         <span class="keywordflow">if</span> (pMaster)
<a name="l00289"></a>00289             <span class="keywordflow">return</span> pMaster;
<a name="l00290"></a>00290         <span class="keywordflow">else</span>
<a name="l00291"></a>00291             s_mapCachedKeys.erase(it_keys);
<a name="l00292"></a>00292     }
<a name="l00293"></a>00293     <span class="comment">// ----------------------------------</span>
<a name="l00294"></a>00294     <span class="comment">// By this point, pMaster is definitely NULL. (Not found on the map, needs to be added.)</span>
<a name="l00295"></a>00295     <span class="comment">//</span>
<a name="l00296"></a>00296     <span class="comment">// ----------------------------------</span>
<a name="l00297"></a>00297     <span class="comment">// Here we make a copy of the master key and insert it into the map.</span>
<a name="l00298"></a>00298     <span class="comment">// Then we return a pointer to it.</span>
<a name="l00299"></a>00299     <span class="comment">//</span>
<a name="l00300"></a>00300     <a class="code" href="class_o_t_a_s_c_i_i_armor.html">OTASCIIArmor</a> ascCachedKey;
<a name="l00301"></a>00301     <span class="keywordflow">if</span> ((const_cast&lt;OTCachedKey &amp;&gt;(theSourceKey)).SerializeTo(ascCachedKey)) <span class="comment">//it&#39;s only not const due to the mutex inside</span>
<a name="l00302"></a>00302     {
<a name="l00303"></a>00303         _SharedPtr&lt;OTCachedKey&gt; pMaster(<span class="keyword">new</span> <a class="code" href="class_o_t_cached_key.html">OTCachedKey</a>); <span class="comment">//int32_t nTimeoutSeconds=OT_MASTER_KEY_TIMEOUT;</span>
<a name="l00304"></a>00304         <span class="comment">// ----------------------------------</span>
<a name="l00305"></a>00305         pMaster-&gt;SetCachedKey(ascCachedKey);
<a name="l00306"></a>00306         <span class="comment">// ----------------------------------</span>
<a name="l00307"></a>00307         s_mapCachedKeys.insert(std::pair&lt;std::string, _SharedPtr&lt;OTCachedKey&gt; &gt;(str_identifier, pMaster)); <span class="comment">// takes ownership here.</span>
<a name="l00308"></a>00308         <span class="keywordflow">return</span> pMaster;
<a name="l00309"></a>00309     }
<a name="l00310"></a>00310     <span class="comment">// theSourceKey WAS generated, but SerializeTo FAILED? Very strange...</span>
<a name="l00311"></a>00311     <span class="keywordflow">else</span>
<a name="l00312"></a>00312         <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;%s: theSourceKey.SerializeTo(ascCachedKey) failed. &quot;</span>
<a name="l00313"></a>00313                       <span class="stringliteral">&quot;Returning NULL.\n&quot;</span>, __FUNCTION__);
<a name="l00314"></a>00314     <span class="comment">// ----------------------------------</span>
<a name="l00315"></a>00315     <span class="keywordflow">return</span> _SharedPtr&lt;OTCachedKey&gt;();
<a name="l00316"></a>00316 }
<a name="l00317"></a>00317 
<a name="l00318"></a>00318 
<a name="l00319"></a>00319 <span class="comment">//static</span>
<a name="l00320"></a><a class="code" href="class_o_t_cached_key.html#a60f1041be525c88bde575ac183e64435">00320</a> <span class="keywordtype">void</span> <a class="code" href="class_o_t_cached_key.html#a60f1041be525c88bde575ac183e64435">OTCachedKey::Cleanup</a>()
<a name="l00321"></a>00321 {
<a name="l00322"></a>00322     tthread::lock_guard&lt;tthread::mutex&gt; lock(OTCachedKey::s_mutexCachedKeys);
<a name="l00323"></a>00323     <span class="comment">// ----------------------------------</span>
<a name="l00324"></a>00324     s_mapCachedKeys.clear();
<a name="l00325"></a>00325 
<a name="l00326"></a>00326 <span class="comment">//  while (!s_mapCachedKeys.empty())</span>
<a name="l00327"></a>00327 <span class="comment">//  {</span>
<a name="l00328"></a>00328 <span class="comment">//      OTCachedKey * pTemp = s_mapCachedKeys.begin()-&gt;second;</span>
<a name="l00329"></a>00329 <span class="comment">//      OT_ASSERT(NULL != pTemp);</span>
<a name="l00330"></a>00330 <span class="comment">//      s_mapCachedKeys.erase(s_mapCachedKeys.begin());</span>
<a name="l00331"></a>00331 <span class="comment">//      delete pTemp; pTemp = NULL;</span>
<a name="l00332"></a>00332 <span class="comment">//  }</span>
<a name="l00333"></a>00333     <span class="comment">// ------------------------</span>
<a name="l00334"></a>00334 }
<a name="l00335"></a>00335 
<a name="l00336"></a>00336 
<a name="l00337"></a>00337 OTCachedKey::OTCachedKey(int32_t nTimeoutSeconds<span class="comment">/*=OT_MASTER_KEY_TIMEOUT*/</span>) :
<a name="l00338"></a>00338     m_pThread(NULL),
<a name="l00339"></a>00339     m_nTimeoutSeconds(nTimeoutSeconds),
<a name="l00340"></a>00340     m_pMasterPassword(NULL), <span class="comment">// This is created in GetMasterPassword, and destroyed by a timer thread sometime soon after.</span>
<a name="l00341"></a>00341     m_bUse_System_Keyring(false), <span class="comment">// the config file might turn this on.</span>
<a name="l00342"></a>00342     m_pSymmetricKey(NULL),   <span class="comment">// OTServer OR OTWallet owns this key, and sets this pointer. It&#39;s the encrypted form of s_pMasterPassword.</span>
<a name="l00343"></a>00343     m_bPaused(false)
<a name="l00344"></a>00344 {
<a name="l00345"></a>00345 
<a name="l00346"></a>00346 }
<a name="l00347"></a>00347 
<a name="l00348"></a>00348 
<a name="l00349"></a><a class="code" href="class_o_t_cached_key.html#af19207ce069d02be362773cfb02424d6">00349</a> OTCachedKey::OTCachedKey(<span class="keyword">const</span> <a class="code" href="class_o_t_a_s_c_i_i_armor.html">OTASCIIArmor</a> &amp; ascCachedKey) :
<a name="l00350"></a>00350     m_pThread(NULL),
<a name="l00351"></a>00351     m_nTimeoutSeconds(<a class="code" href="class_o_t_cached_key.html">OTCachedKey</a>::It()-&gt;GetTimeoutSeconds()),
<a name="l00352"></a>00352     m_pMasterPassword(NULL), <span class="comment">// This is created in GetMasterPassword, and destroyed by a timer thread sometime soon after.</span>
<a name="l00353"></a>00353     m_bUse_System_Keyring(<a class="code" href="class_o_t_cached_key.html">OTCachedKey</a>::It()-&gt;IsUsingSystemKeyring()), <span class="comment">// this master key instance will decide to use the system keyring based on what the global master key instance is set to do. (So we get the same settings from config file, etc.)</span>
<a name="l00354"></a>00354     m_pSymmetricKey(NULL),   <span class="comment">// OTServer OR OTWallet owns this key, and sets this pointer. It&#39;s the encrypted form of s_pMasterPassword.</span>
<a name="l00355"></a>00355     m_bPaused(false)
<a name="l00356"></a>00356 {
<a name="l00357"></a>00357     <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(ascCachedKey.<a class="code" href="class_o_t_string.html#adf7489cd917d4ae5bf30853a3ad78daf">Exists</a>());
<a name="l00358"></a>00358     this-&gt;<a class="code" href="class_o_t_cached_key.html#aa23079dbadddf2d7f2a2f205e3c05738">SetCachedKey</a>(ascCachedKey);
<a name="l00359"></a>00359 }
<a name="l00360"></a>00360 
<a name="l00361"></a>00361 
<a name="l00362"></a>00362 <span class="comment">// We don&#39;t lock the mutex here because otherwise we&#39;ll freeze ourselves.</span>
<a name="l00363"></a>00363 <span class="comment">//</span>
<a name="l00364"></a>00364 <span class="comment">// UPDATE: Adding lock since we now use recursive mutexes. SHOULD be fine.</span>
<a name="l00365"></a>00365 <span class="comment">// HMM, weird: it&#39;s still freezing here. Commenting this one out for now.</span>
<a name="l00366"></a>00366 <span class="comment">//</span>
<a name="l00367"></a><a class="code" href="class_o_t_cached_key.html#aef5e98808a18741cb9c8c240f702e996">00367</a> <span class="keywordtype">bool</span> <a class="code" href="class_o_t_cached_key.html#aef5e98808a18741cb9c8c240f702e996">OTCachedKey::isPaused</a>()
<a name="l00368"></a>00368 {
<a name="l00369"></a>00369 <span class="comment">//  tthread::lock_guard&lt;tthread::mutex&gt; lock(m_Mutex);</span>
<a name="l00370"></a>00370 
<a name="l00371"></a>00371     <span class="keywordflow">return</span> m_bPaused;
<a name="l00372"></a>00372 }
<a name="l00373"></a>00373 
<a name="l00374"></a>00374 
<a name="l00375"></a>00375 <span class="comment">// When the master key is on pause, it won&#39;t work (Nyms will just use their</span>
<a name="l00376"></a>00376 <span class="comment">// own passwords instead of the master password.) This is important, for example,</span>
<a name="l00377"></a>00377 <span class="comment">// if you are loading up a bunch of Old Nyms. You pause before and after each one,</span>
<a name="l00378"></a>00378 <span class="comment">// and THEN convert them to the master key.</span>
<a name="l00379"></a>00379 <span class="comment">//</span>
<a name="l00380"></a><a class="code" href="class_o_t_cached_key.html#af778e40cf52dedde7c1896b3fbb2e02b">00380</a> <span class="keywordtype">bool</span> <a class="code" href="class_o_t_cached_key.html#af778e40cf52dedde7c1896b3fbb2e02b">OTCachedKey::Pause</a>()
<a name="l00381"></a>00381 {
<a name="l00382"></a>00382     tthread::lock_guard&lt;tthread::mutex&gt; lock(m_Mutex);
<a name="l00383"></a>00383     <span class="comment">// ----------------------------</span>
<a name="l00384"></a>00384     <span class="keywordflow">if</span> (!m_bPaused)
<a name="l00385"></a>00385     {
<a name="l00386"></a>00386         m_bPaused = <span class="keyword">true</span>;
<a name="l00387"></a>00387         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00388"></a>00388     }
<a name="l00389"></a>00389     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00390"></a>00390 }
<a name="l00391"></a>00391 
<a name="l00392"></a>00392 
<a name="l00393"></a><a class="code" href="class_o_t_cached_key.html#a0fa693b734082f41578b9984d242dd79">00393</a> <span class="keywordtype">bool</span> <a class="code" href="class_o_t_cached_key.html#a0fa693b734082f41578b9984d242dd79">OTCachedKey::Unpause</a>()
<a name="l00394"></a>00394 {
<a name="l00395"></a>00395     tthread::lock_guard&lt;tthread::mutex&gt; lock(m_Mutex);
<a name="l00396"></a>00396     <span class="comment">// ----------------------------</span>
<a name="l00397"></a>00397     <span class="keywordflow">if</span> (m_bPaused)
<a name="l00398"></a>00398     {
<a name="l00399"></a>00399         m_bPaused = <span class="keyword">false</span>;
<a name="l00400"></a>00400         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00401"></a>00401     }
<a name="l00402"></a>00402     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00403"></a>00403 }
<a name="l00404"></a>00404 
<a name="l00405"></a>00405 
<a name="l00406"></a>00406 <span class="comment">// This should ONLY be called from a function that locks the Mutex first!</span>
<a name="l00407"></a>00407 <span class="comment">//</span>
<a name="l00408"></a>00408 <span class="comment">// UPDATE: SHOULD be fine to lock the mutex since we now use recursive mutexes.</span>
<a name="l00409"></a>00409 <span class="comment">// However, I did verify that this function is only called in other functions that</span>
<a name="l00410"></a>00410 <span class="comment">// have already locked it, so I&#39;m leaving the call out for now.</span>
<a name="l00411"></a>00411 <span class="comment">//</span>
<a name="l00412"></a><a class="code" href="class_o_t_cached_key.html#a6933e0f88aae70fe30b925f150e8cc20">00412</a> <span class="keywordtype">void</span> <a class="code" href="class_o_t_cached_key.html#a6933e0f88aae70fe30b925f150e8cc20">OTCachedKey::LowLevelReleaseThread</a>()
<a name="l00413"></a>00413 {
<a name="l00414"></a>00414     <span class="comment">// NO NEED TO LOCK THIS ONE -- BUT ONLY CALL IT FROM A LOCKED FUNCTION.</span>
<a name="l00415"></a>00415     <span class="keywordflow">if</span> (NULL != m_pThread)
<a name="l00416"></a>00416     {
<a name="l00417"></a>00417         tthread::thread * pThread = m_pThread;
<a name="l00418"></a>00418         m_pThread = NULL;
<a name="l00419"></a>00419 
<a name="l00420"></a>00420         <span class="keywordflow">if</span> (pThread-&gt;joinable())
<a name="l00421"></a>00421         {
<a name="l00422"></a>00422             pThread-&gt;detach();
<a name="l00423"></a>00423         }
<a name="l00424"></a>00424         <span class="keyword">delete</span> pThread; pThread = NULL;
<a name="l00425"></a>00425     }
<a name="l00426"></a>00426 }
<a name="l00427"></a>00427 
<a name="l00428"></a>00428 
<a name="l00429"></a><a class="code" href="class_o_t_cached_key.html#aad66d1eeb1f84fbcd82fe796bdb393bd">00429</a> <a class="code" href="class_o_t_cached_key.html#aad66d1eeb1f84fbcd82fe796bdb393bd">OTCachedKey::~OTCachedKey</a>()
<a name="l00430"></a>00430 {
<a name="l00431"></a>00431     tthread::lock_guard&lt;tthread::mutex&gt; lock(m_Mutex);  <span class="comment">// I figured this would cause some kind of problem but how else can I mess with the members unless I lock this?</span>
<a name="l00432"></a>00432     <span class="comment">// --------------------</span>
<a name="l00433"></a>00433     <a class="code" href="class_o_t_cached_key.html#a6933e0f88aae70fe30b925f150e8cc20">LowLevelReleaseThread</a>();
<a name="l00434"></a>00434     <span class="comment">// -----</span>
<a name="l00435"></a>00435     <span class="keywordflow">if</span> (NULL != m_pMasterPassword)  <span class="comment">// Only stored temporarily, the purpose of this class is to destoy it after a timer.</span>
<a name="l00436"></a>00436     {
<a name="l00437"></a>00437         <a class="code" href="class_o_t_password.html">OTPassword</a> * pPassword = m_pMasterPassword;
<a name="l00438"></a>00438 
<a name="l00439"></a>00439         m_pMasterPassword = NULL;
<a name="l00440"></a>00440 
<a name="l00441"></a>00441         <span class="keyword">delete</span> pPassword; pPassword = NULL;
<a name="l00442"></a>00442     }
<a name="l00443"></a>00443     <span class="comment">// -----</span>
<a name="l00444"></a>00444     <span class="keywordflow">if</span> (NULL != m_pSymmetricKey)       <span class="comment">// Owned / based on a string passed in. Stored somewhere else (OTServer, OTWallet...)</span>
<a name="l00445"></a>00445     {
<a name="l00446"></a>00446         <a class="code" href="class_o_t_symmetric_key.html">OTSymmetricKey</a> * pSymmetricKey = m_pSymmetricKey;
<a name="l00447"></a>00447 
<a name="l00448"></a>00448         m_pSymmetricKey = NULL;
<a name="l00449"></a>00449 
<a name="l00450"></a>00450         <span class="keyword">delete</span> pSymmetricKey; pSymmetricKey = NULL;
<a name="l00451"></a>00451     }
<a name="l00452"></a>00452     <span class="comment">// -----</span>
<a name="l00453"></a>00453 }
<a name="l00454"></a>00454 
<a name="l00455"></a>00455 
<a name="l00456"></a><a class="code" href="class_o_t_cached_key.html#ac0de8ead34b8bff4913844507987e61a">00456</a> int32_t <a class="code" href="class_o_t_cached_key.html#ac0de8ead34b8bff4913844507987e61a">OTCachedKey::GetTimeoutSeconds</a>()
<a name="l00457"></a>00457 {
<a name="l00458"></a>00458     tthread::lock_guard&lt;tthread::mutex&gt; lock(m_Mutex); <span class="comment">// Multiple threads can&#39;t get inside here at the same time.</span>
<a name="l00459"></a>00459 
<a name="l00460"></a>00460     <span class="keyword">const</span> int32_t nTimeout = m_nTimeoutSeconds;
<a name="l00461"></a>00461 
<a name="l00462"></a>00462     <span class="keywordflow">return</span> nTimeout;
<a name="l00463"></a>00463 }
<a name="l00464"></a>00464 
<a name="l00465"></a>00465 
<a name="l00466"></a><a class="code" href="class_o_t_cached_key.html#a7b0822845b243c8f739f021d0f96bcd7">00466</a> <span class="keywordtype">void</span> <a class="code" href="class_o_t_cached_key.html#a7b0822845b243c8f739f021d0f96bcd7">OTCachedKey::SetTimeoutSeconds</a>(int32_t nTimeoutSeconds) <span class="comment">// So we can load from the config file.</span>
<a name="l00467"></a>00467 {
<a name="l00468"></a>00468     tthread::lock_guard&lt;tthread::mutex&gt; lock(m_Mutex); <span class="comment">// Multiple threads can&#39;t get inside here at the same time.</span>
<a name="l00469"></a>00469 
<a name="l00470"></a>00470     <a class="code" href="_o_t_assert_8hpp.html#a033b133f48e61f2b227c52ad2be0c882">OT_ASSERT_MSG</a>(nTimeoutSeconds &gt;= (-1), <span class="stringliteral">&quot;OTCachedKey::SetTimeoutSeconds: ASSERT: nTimeoutSeconds must be &gt;= (-1)\n&quot;</span>);
<a name="l00471"></a>00471 
<a name="l00472"></a>00472     m_nTimeoutSeconds = nTimeoutSeconds;
<a name="l00473"></a>00473 }
<a name="l00474"></a>00474 
<a name="l00475"></a>00475 
<a name="l00476"></a>00476 <span class="comment">// Called by OTServer or OTWallet, or whatever instantiates those.</span>
<a name="l00477"></a>00477 <span class="comment">//</span>
<a name="l00478"></a><a class="code" href="class_o_t_cached_key.html#aa23079dbadddf2d7f2a2f205e3c05738">00478</a> <span class="keywordtype">void</span> <a class="code" href="class_o_t_cached_key.html#aa23079dbadddf2d7f2a2f205e3c05738">OTCachedKey::SetCachedKey</a>(<span class="keyword">const</span> <a class="code" href="class_o_t_a_s_c_i_i_armor.html">OTASCIIArmor</a> &amp; ascCachedKey)
<a name="l00479"></a>00479 {
<a name="l00480"></a>00480     tthread::lock_guard&lt;tthread::mutex&gt; lock(m_Mutex); <span class="comment">// Multiple threads can&#39;t get inside here at the same time.</span>
<a name="l00481"></a>00481 
<a name="l00482"></a>00482     <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(ascCachedKey.<a class="code" href="class_o_t_string.html#adf7489cd917d4ae5bf30853a3ad78daf">Exists</a>());
<a name="l00483"></a>00483     <span class="comment">// ----------------------------------------</span>
<a name="l00484"></a>00484     <span class="keywordflow">if</span> (NULL != m_pSymmetricKey)
<a name="l00485"></a>00485     {
<a name="l00486"></a>00486         <a class="code" href="class_o_t_log.html#a5acd90ac91c2618f395b0ff37ad4f8ee">OTLog::Error</a>(<span class="stringliteral">&quot;OTCachedKey::SetCachedKey: Warning: This was already set. (Re-setting.)\n&quot;</span>);
<a name="l00487"></a>00487 
<a name="l00488"></a>00488         <a class="code" href="class_o_t_symmetric_key.html">OTSymmetricKey</a> * pSymmetricKey = m_pSymmetricKey;
<a name="l00489"></a>00489 
<a name="l00490"></a>00490         m_pSymmetricKey = NULL;
<a name="l00491"></a>00491 
<a name="l00492"></a>00492         <span class="keyword">delete</span> pSymmetricKey; pSymmetricKey = NULL;
<a name="l00493"></a>00493     }
<a name="l00494"></a>00494     <span class="comment">// -----------------------------------------</span>
<a name="l00495"></a>00495     m_pSymmetricKey = <span class="keyword">new</span> <a class="code" href="class_o_t_symmetric_key.html">OTSymmetricKey</a>;
<a name="l00496"></a>00496     <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != m_pSymmetricKey);
<a name="l00497"></a>00497     <span class="comment">// ----------------------------------</span>
<a name="l00498"></a>00498 
<a name="l00499"></a>00499     <span class="comment">//const bool bSerialized =</span>
<a name="l00500"></a>00500     m_pSymmetricKey-&gt;<a class="code" href="class_o_t_symmetric_key.html#ac1a0a93da93305492ecebca03110a954">SerializeFrom</a>(ascCachedKey);
<a name="l00501"></a>00501 }
<a name="l00502"></a>00502 
<a name="l00503"></a>00503 
<a name="l00504"></a>00504 <span class="comment">// Above version deletes the internal symmetric key if it already exists,</span>
<a name="l00505"></a>00505 <span class="comment">// and then below that, creates it again if it does not exist. Then serializes</span>
<a name="l00506"></a>00506 <span class="comment">// it up from storage via ascCachedKey (input.)</span>
<a name="l00507"></a>00507 <span class="comment">// Whereas below version, if internal symmetric key doesn&#39;t exist, simply</span>
<a name="l00508"></a>00508 <span class="comment">// returns false.  Therefore if it&#39;s &quot;not generated&quot; and you want to load it</span>
<a name="l00509"></a>00509 <span class="comment">// up from some input, call the above function, SetCachedKey().</span>
<a name="l00510"></a>00510 
<a name="l00511"></a>00511 <span class="comment">// Apparently SerializeFrom (as of this writing) is only used in OTEnvelope.cpp</span>
<a name="l00512"></a>00512 <span class="comment">// whereas SetCachedKey (above) is used in OTWallet and OTServer.</span>
<a name="l00513"></a>00513 <span class="comment">//</span>
<a name="l00514"></a><a class="code" href="class_o_t_cached_key.html#a4544aaabde49afd185df0fa05b775679">00514</a> <span class="keywordtype">bool</span> <a class="code" href="class_o_t_cached_key.html#a4544aaabde49afd185df0fa05b775679">OTCachedKey::SerializeFrom</a>(<span class="keyword">const</span> <a class="code" href="class_o_t_a_s_c_i_i_armor.html">OTASCIIArmor</a> &amp; ascInput)
<a name="l00515"></a>00515 {
<a name="l00516"></a>00516     tthread::lock_guard&lt;tthread::mutex&gt; lock(m_Mutex);
<a name="l00517"></a>00517 
<a name="l00518"></a>00518     <span class="keywordflow">if</span> (NULL == m_pSymmetricKey)
<a name="l00519"></a>00519         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00520"></a>00520 
<a name="l00521"></a>00521     <span class="keywordflow">return</span> m_pSymmetricKey-&gt;<a class="code" href="class_o_t_symmetric_key.html#ac1a0a93da93305492ecebca03110a954">SerializeFrom</a>(ascInput);
<a name="l00522"></a>00522 }
<a name="l00523"></a>00523 
<a name="l00524"></a>00524 
<a name="l00525"></a><a class="code" href="class_o_t_cached_key.html#a5f7a335ec7dc9ac8fd2b1ebf2ef26dd8">00525</a> <span class="keywordtype">bool</span> <a class="code" href="class_o_t_cached_key.html#a5f7a335ec7dc9ac8fd2b1ebf2ef26dd8">OTCachedKey::SerializeTo</a>(<a class="code" href="class_o_t_a_s_c_i_i_armor.html">OTASCIIArmor</a> &amp; ascOutput)
<a name="l00526"></a>00526 {
<a name="l00527"></a>00527     tthread::lock_guard&lt;tthread::mutex&gt; lock(m_Mutex);
<a name="l00528"></a>00528 
<a name="l00529"></a>00529     <span class="keywordflow">if</span> (NULL == m_pSymmetricKey)
<a name="l00530"></a>00530         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00531"></a>00531 
<a name="l00532"></a>00532     <span class="keywordflow">return</span> m_pSymmetricKey-&gt;<a class="code" href="class_o_t_symmetric_key.html#a9d5d084b9986a338d28d171b8721ac2a">SerializeTo</a>(ascOutput);
<a name="l00533"></a>00533 }
<a name="l00534"></a>00534 
<a name="l00535"></a>00535 
<a name="l00536"></a>00536 <span class="comment">// Note: this calculates its ID based only on m_dataEncryptedKey,</span>
<a name="l00537"></a>00537 <span class="comment">// and does NOT include salt, IV, iteration count, etc when</span>
<a name="l00538"></a>00538 <span class="comment">// generating the hash for the ID.</span>
<a name="l00539"></a>00539 <span class="comment">//</span>
<a name="l00540"></a><a class="code" href="class_o_t_cached_key.html#acec139cffbbad3a4bc3e45e69748f43a">00540</a> <span class="keywordtype">bool</span> <a class="code" href="class_o_t_cached_key.html#acec139cffbbad3a4bc3e45e69748f43a">OTCachedKey::GetIdentifier</a>(<a class="code" href="class_o_t_identifier.html">OTIdentifier</a> &amp; theIdentifier)<span class="keyword"> const</span>
<a name="l00541"></a>00541 <span class="keyword"></span>{
<a name="l00542"></a>00542     tthread::lock_guard&lt;tthread::mutex&gt; lock((const_cast&lt;OTCachedKey *&gt;(<span class="keyword">this</span>))-&gt;m_Mutex);
<a name="l00543"></a>00543 
<a name="l00544"></a>00544     <span class="keywordflow">if</span> ((NULL == m_pSymmetricKey) || !m_pSymmetricKey-&gt;<a class="code" href="class_o_t_symmetric_key.html#a9e2eced2ded569ff96ddace6488a7968">IsGenerated</a>())
<a name="l00545"></a>00545         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00546"></a>00546 
<a name="l00547"></a>00547     m_pSymmetricKey-&gt;<a class="code" href="class_o_t_symmetric_key.html#a70cc2a2c32250ae5c005df3fac0497ba">GetIdentifier</a>(theIdentifier);
<a name="l00548"></a>00548     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00549"></a>00549 }
<a name="l00550"></a>00550 
<a name="l00551"></a>00551 
<a name="l00552"></a><a class="code" href="class_o_t_cached_key.html#a2914f95a9df7bc9265b50571624ec375">00552</a> <span class="keywordtype">bool</span> <a class="code" href="class_o_t_cached_key.html#acec139cffbbad3a4bc3e45e69748f43a">OTCachedKey::GetIdentifier</a>(<a class="code" href="class_o_t_string.html">OTString</a> &amp; strIdentifier)<span class="keyword"> const</span>
<a name="l00553"></a>00553 <span class="keyword"></span>{
<a name="l00554"></a>00554     tthread::lock_guard&lt;tthread::mutex&gt; lock((const_cast&lt;OTCachedKey *&gt;(<span class="keyword">this</span>))-&gt;m_Mutex);
<a name="l00555"></a>00555 
<a name="l00556"></a>00556     <span class="keywordflow">if</span> ((NULL == m_pSymmetricKey) || !m_pSymmetricKey-&gt;<a class="code" href="class_o_t_symmetric_key.html#a9e2eced2ded569ff96ddace6488a7968">IsGenerated</a>())
<a name="l00557"></a>00557         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00558"></a>00558 
<a name="l00559"></a>00559     m_pSymmetricKey-&gt;<a class="code" href="class_o_t_symmetric_key.html#a70cc2a2c32250ae5c005df3fac0497ba">GetIdentifier</a>(strIdentifier);
<a name="l00560"></a>00560     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00561"></a>00561 }
<a name="l00562"></a>00562 
<a name="l00563"></a>00563 
<a name="l00564"></a>00564 <span class="comment">/*</span>
<a name="l00565"></a>00565 <span class="comment"> // TOdo: make this so you can pass in a password, or you can pass NULL</span>
<a name="l00566"></a>00566 <span class="comment"> // and then it will use the GetPasswordCallback() method to collect one</span>
<a name="l00567"></a>00567 <span class="comment"> // from the user.</span>
<a name="l00568"></a>00568 <span class="comment"></span>
<a name="l00569"></a>00569 <span class="comment"> OT_OPENSSL_CALLBACK * OTAsymmetricKey::GetPasswordCallback()</span>
<a name="l00570"></a>00570 <span class="comment"></span>
<a name="l00571"></a>00571 <span class="comment"> #define OPENSSL_CALLBACK_FUNC(name) extern &quot;C&quot; (name)(char *buf, int32_t size, int32_t rwflag, void *userdata)</span>
<a name="l00572"></a>00572 <span class="comment"></span>
<a name="l00573"></a>00573 <span class="comment"> */</span>
<a name="l00574"></a>00574 
<a name="l00575"></a>00575 <span class="comment">// Caller must delete!</span>
<a name="l00576"></a>00576 <span class="comment">//static</span>
<a name="l00577"></a><a class="code" href="class_o_t_cached_key.html#a97bb15bbe2b2a100a5379b835c4b539d">00577</a> _SharedPtr&lt;OTCachedKey&gt; <a class="code" href="class_o_t_cached_key.html#a97bb15bbe2b2a100a5379b835c4b539d">OTCachedKey::CreateMasterPassword</a>(<a class="code" href="class_o_t_password.html">OTPassword</a> &amp; theOutput,
<a name="l00578"></a>00578                                                         <span class="keyword">const</span> <span class="keywordtype">char</span> * szDisplay<span class="comment">/*=NULL*/</span>,
<a name="l00579"></a>00579                                                         int32_t nTimeoutSeconds<span class="comment">/*=OT_MASTER_KEY_TIMEOUT*/</span>)
<a name="l00580"></a>00580 {
<a name="l00581"></a>00581     _SharedPtr&lt;OTCachedKey&gt; pMaster(<span class="keyword">new</span> <a class="code" href="class_o_t_cached_key.html">OTCachedKey</a>(nTimeoutSeconds));
<a name="l00582"></a>00582     <span class="comment">// -------------------</span>
<a name="l00583"></a>00583     <span class="keyword">const</span> <a class="code" href="class_o_t_string.html">OTString</a> strDisplay((NULL == szDisplay) ? <span class="stringliteral">&quot;Creating a passphrase...&quot;</span> : szDisplay); <span class="comment">// todo internationalization / hardcoding.</span>
<a name="l00584"></a>00584 
<a name="l00585"></a>00585     <span class="keyword">const</span> <span class="keywordtype">bool</span> bGotPassphrase = pMaster-&gt;GetMasterPassword(pMaster, theOutput, strDisplay.<a class="code" href="class_o_t_string.html#af87b3b43148de9b1425ed8e9348241d3">Get</a>(), <span class="keyword">true</span>); <span class="comment">//bool bVerifyTwice=false by default. Really we didn&#39;t have to pass true here, since it asks twice anyway, when first generating the key.</span>
<a name="l00586"></a>00586 
<a name="l00587"></a>00587     <span class="keywordflow">if</span> (bGotPassphrase) <span class="comment">// success!</span>
<a name="l00588"></a>00588         <span class="keywordflow">return</span> pMaster;
<a name="l00589"></a>00589     <span class="comment">// ----------------------------</span>
<a name="l00590"></a>00590     <span class="comment">// If we&#39;re still here, that means bGotPassphrase failed.</span>
<a name="l00591"></a>00591     <span class="comment">//</span>
<a name="l00592"></a>00592 <span class="comment">//    delete pMaster; pMaster = NULL;</span>
<a name="l00593"></a>00593     <span class="keywordflow">return</span> _SharedPtr&lt;OTCachedKey&gt;();
<a name="l00594"></a>00594 }
<a name="l00595"></a>00595 
<a name="l00596"></a>00596 
<a name="l00597"></a>00597 <span class="comment">// Called by the password callback function.</span>
<a name="l00598"></a>00598 <span class="comment">// The password callback uses this to get the password for any individual Nym.</span>
<a name="l00599"></a>00599 <span class="comment">// This will also generate the master password, if one does not already exist.</span>
<a name="l00600"></a>00600 <span class="comment">//</span>
<a name="l00601"></a><a class="code" href="class_o_t_cached_key.html#ab5afd7677fed682812ac40de76f5f5db">00601</a> <span class="keywordtype">bool</span> <a class="code" href="class_o_t_cached_key.html#ab5afd7677fed682812ac40de76f5f5db">OTCachedKey::GetMasterPassword</a>(_SharedPtr&lt;OTCachedKey&gt; &amp; mySharedPtr,
<a name="l00602"></a>00602                                     <a class="code" href="class_o_t_password.html">OTPassword</a>            &amp; theOutput,
<a name="l00603"></a>00603                                     <span class="keyword">const</span> <span class="keywordtype">char</span>            * szDisplay,
<a name="l00604"></a>00604                                     <span class="keywordtype">bool</span> bVerifyTwice<span class="comment">/*=false*/</span>)
<a name="l00605"></a>00605 {
<a name="l00606"></a>00606     tthread::lock_guard&lt;tthread::mutex&gt; lock(m_Mutex); <span class="comment">// Multiple threads can&#39;t get inside here at the same time.</span>
<a name="l00607"></a>00607 
<a name="l00608"></a>00608     std::string str_display(NULL != szDisplay ? szDisplay : <span class="stringliteral">&quot;(Display string was blank.)&quot;</span>);
<a name="l00609"></a>00609 
<a name="l00610"></a>00610     <span class="keyword">const</span> <span class="keywordtype">char</span> * szFunc = <span class="stringliteral">&quot;OTCachedKey::GetMasterPassword&quot;</span>;
<a name="l00611"></a>00611 
<a name="l00612"></a>00612     <span class="comment">//  OT_ASSERT(NULL != m_pSymmetricKey); // (This had better be set already.) // Took this out because calling Generate inside here now.</span>
<a name="l00613"></a>00613     <span class="comment">// ----------------------------------------</span>
<a name="l00614"></a>00614     <span class="comment">//</span>
<a name="l00615"></a>00615     <span class="keywordflow">if</span> (NULL != m_pMasterPassword)
<a name="l00616"></a>00616     {
<a name="l00617"></a>00617         <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(2, <span class="stringliteral">&quot;%s: Master password was available. (Returning it now.)\n&quot;</span>, szFunc);
<a name="l00618"></a>00618 
<a name="l00619"></a>00619         theOutput = *m_pMasterPassword;
<a name="l00620"></a>00620         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00621"></a>00621     }
<a name="l00622"></a>00622     <span class="comment">// --------------------------------------------</span>
<a name="l00623"></a>00623     <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(2, <span class="stringliteral">&quot;%s: Master password wasn&#39;t loaded. Instantiating...\n&quot;</span>, szFunc);
<a name="l00624"></a>00624 
<a name="l00625"></a>00625     <span class="comment">// If m_pMasterPassword is NULL, (which below this point it is) then...</span>
<a name="l00626"></a>00626     <span class="comment">//</span>
<a name="l00627"></a>00627     <span class="comment">// Either it hasn&#39;t been created yet, in which case we need to instantiate it,</span>
<a name="l00628"></a>00628     <span class="comment">// OR it expired, in which case m_pMasterPassword is NULL,</span>
<a name="l00629"></a>00629     <span class="comment">// but m_pThread isn&#39;t, and still needs cleaning up before we instantiate another one!</span>
<a name="l00630"></a>00630     <span class="comment">//</span>
<a name="l00631"></a>00631     <a class="code" href="class_o_t_cached_key.html#a6933e0f88aae70fe30b925f150e8cc20">LowLevelReleaseThread</a>();
<a name="l00632"></a>00632     <span class="comment">// --------------------------------------------</span>
<a name="l00633"></a>00633     m_pMasterPassword = <a class="code" href="class_o_t_cached_key.html#a8780b8a3f392b0bc4c11253a797d8b5a">OTCrypto::It</a>()-&gt;InstantiateBinarySecret(); <span class="comment">// already asserts.</span>
<a name="l00634"></a>00634     <span class="comment">// --------------------------------------------</span>
<a name="l00635"></a>00635     <span class="comment">/*</span>
<a name="l00636"></a>00636 <span class="comment">    How does this work?</span>
<a name="l00637"></a>00637 <span class="comment"></span>
<a name="l00638"></a>00638 <span class="comment">    When trying to open a normal nym, the password callback realizes we are calling it</span>
<a name="l00639"></a>00639 <span class="comment">    in &quot;NOT master mode&quot;, so instead of just collecting the passphrase and giving it</span>
<a name="l00640"></a>00640 <span class="comment">    back to OpenSSL, it calls this function first, which returns the master password</span>
<a name="l00641"></a>00641 <span class="comment">    (so that IT can be given to OpenSSL instead.)</span>
<a name="l00642"></a>00642 <span class="comment"></span>
<a name="l00643"></a>00643 <span class="comment">    If the master wasn&#39;t already loaded (common) then we call the callback in here ourselves.</span>
<a name="l00644"></a>00644 <span class="comment">    Notice it&#39;s recursive! But this time, the callback sees we ARE in master mode, so it doesn&#39;t</span>
<a name="l00645"></a>00645 <span class="comment">    call this function again (which would be an infinite loop.) Instead, it collects the password</span>
<a name="l00646"></a>00646 <span class="comment">    as normal, only instead of passing it back to the caller via the buffer, it uses the</span>
<a name="l00647"></a>00647 <span class="comment">    passUserInput by attaching it to thePWData before the call. That way the callback function</span>
<a name="l00648"></a>00648 <span class="comment">    can set passUserInput with whatever it retrieved from the user, and then back in this function</span>
<a name="l00649"></a>00649 <span class="comment">    again we can get the passUserInput and use it to unlock the MASTER passphrase, which we set</span>
<a name="l00650"></a>00650 <span class="comment">    onto theOutput.</span>
<a name="l00651"></a>00651 <span class="comment"></span>
<a name="l00652"></a>00652 <span class="comment">    When this function returns true, the callback (0th level of recursion) uses theOutput</span>
<a name="l00653"></a>00653 <span class="comment">    as the &quot;passphrase&quot; for all Nyms, passing it to OpenSSL.</span>
<a name="l00654"></a>00654 <span class="comment"></span>
<a name="l00655"></a>00655 <span class="comment">    This way, OpenSSL gets a random key instead of a passphrase, and the passphrase is just used</span>
<a name="l00656"></a>00656 <span class="comment">    for encrypting that random key whenever its timer has run out.</span>
<a name="l00657"></a>00657 <span class="comment"></span>
<a name="l00658"></a>00658 <span class="comment">    */</span>
<a name="l00659"></a>00659 
<a name="l00660"></a>00660     <span class="keywordtype">bool</span> bReturnVal = <span class="keyword">false</span>;
<a name="l00661"></a>00661 
<a name="l00662"></a>00662     <span class="comment">// CALL the callback directly. (To retrieve a passphrase so I can use it in GenerateKey</span>
<a name="l00663"></a>00663     <span class="comment">// and GetRawKey.)</span>
<a name="l00664"></a>00664     <span class="comment">//</span>
<a name="l00665"></a>00665     <span class="comment">//int32_t OT_OPENSSL_CALLBACK (char *buf, int32_t size, int32_t rwflag, void *userdata);</span>
<a name="l00666"></a>00666     <span class="comment">//</span>
<a name="l00667"></a>00667     <span class="comment">// For us, it will set passUserInput to the password from the user, and return</span>
<a name="l00668"></a>00668     <span class="comment">// a simple 1 or 0 (instead of the length.) buf and size can be NULL / 0, and</span>
<a name="l00669"></a>00669     <span class="comment">// rwflag should be passed in from somewhere.</span>
<a name="l00670"></a>00670     <span class="comment">//</span>
<a name="l00671"></a>00671     <span class="comment">// m_pSymmetricKey is the encrypted form of the master key. Therefore we want to hash</span>
<a name="l00672"></a>00672     <span class="comment">// it, in order to get the ID for lookups on the keychain.</span>
<a name="l00673"></a>00673     <span class="comment">//</span>
<a name="l00674"></a>00674     <a class="code" href="class_o_t_password.html">OTPassword</a> * pDerivedKey = NULL;
<a name="l00675"></a>00675     <a class="code" href="class_o_t_cleanup.html">OTCleanup&lt;OTPassword&gt;</a> theDerivedAngel;
<a name="l00676"></a>00676     <span class="comment">// ---------------------------------</span>
<a name="l00677"></a>00677     <span class="keywordflow">if</span> (NULL == m_pSymmetricKey)
<a name="l00678"></a>00678     {
<a name="l00679"></a>00679         m_pSymmetricKey = <span class="keyword">new</span> <a class="code" href="class_o_t_symmetric_key.html">OTSymmetricKey</a>;
<a name="l00680"></a>00680         <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != m_pSymmetricKey);
<a name="l00681"></a>00681     }
<a name="l00682"></a>00682     <span class="comment">// --------------------------------------------------</span>
<a name="l00683"></a>00683     <span class="keywordflow">if</span> (<span class="keyword">false</span> == m_pSymmetricKey-&gt;<a class="code" href="class_o_t_symmetric_key.html#a9e2eced2ded569ff96ddace6488a7968">IsGenerated</a>()) <span class="comment">// doesn&#39;t already exist.</span>
<a name="l00684"></a>00684     {
<a name="l00685"></a>00685         <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(1, <span class="stringliteral">&quot;%s: Master key didn&#39;t exist. Need to collect a passphrase from the user, &quot;</span>
<a name="l00686"></a>00686             <span class="stringliteral">&quot;so we can generate a master key...\n &quot;</span>, szFunc);
<a name="l00687"></a>00687 
<a name="l00688"></a>00688         bVerifyTwice = <span class="keyword">true</span>; <span class="comment">// we force it, in this case.</span>
<a name="l00689"></a>00689     }
<a name="l00690"></a>00690 
<a name="l00691"></a>00691     <span class="comment">// --------------------------------------------------</span>
<a name="l00692"></a>00692     <span class="keywordflow">else</span> <span class="comment">// If the symmetric key itself ALREADY exists (which it usually will...)</span>
<a name="l00693"></a>00693     {    <span class="comment">// then we might have also already stashed the derived key on the system</span>
<a name="l00694"></a>00694         <span class="comment">// keychain. Let&#39;s check there first before asking the user to enter his</span>
<a name="l00695"></a>00695         <span class="comment">// passphrase...</span>
<a name="l00696"></a>00696         <span class="comment">//</span>
<a name="l00697"></a>00697 
<a name="l00698"></a>00698         <span class="comment">// -----------------------------------------------------</span>
<a name="l00699"></a>00699         <span class="keyword">const</span> <a class="code" href="class_o_t_identifier.html">OTIdentifier</a> idCachedKey(*m_pSymmetricKey); <span class="comment">// Grab the ID of this symmetric key.</span>
<a name="l00700"></a>00700         <span class="keyword">const</span> <a class="code" href="class_o_t_string.html">OTString</a>     strCachedKeyHash(idCachedKey); <span class="comment">// Same thing, in string form.</span>
<a name="l00701"></a>00701         <span class="comment">//</span>
<a name="l00702"></a>00702         <span class="comment">// This only happens in here where we KNOW m_pSymmetricKey was already generated.</span>
<a name="l00703"></a>00703         <span class="comment">//</span>
<a name="l00704"></a>00704         <span class="comment">//      OTString strCachedKeyHash;</span>
<a name="l00705"></a>00705         <span class="comment">//      m_pSymmetricKey-&gt;GetIdentifier(strCachedKeyHash);</span>
<a name="l00706"></a>00706         <span class="comment">// -----------------------------------------------------</span>
<a name="l00707"></a>00707         pDerivedKey = <a class="code" href="class_o_t_cached_key.html#a8780b8a3f392b0bc4c11253a797d8b5a">OTCrypto::It</a>()-&gt;InstantiateBinarySecret(); <span class="comment">// pDerivedKey is instantiated here to use as output argument below.</span>
<a name="l00708"></a>00708         <span class="comment">// -----------------------------------------------------</span>
<a name="l00709"></a>00709         <span class="comment">//</span>
<a name="l00710"></a>00710         <span class="comment">// *** ATTEMPT to RETRIEVE the *Derived Key* from THE SYSTEM KEYCHAIN ***</span>
<a name="l00711"></a>00711         <span class="comment">//</span>
<a name="l00712"></a>00712         <span class="keyword">const</span> <span class="keywordtype">bool</span> bFoundOnKeyring = this-&gt;<a class="code" href="class_o_t_cached_key.html#a95adb6583e128ed03719dc365e14005e">IsUsingSystemKeyring</a>() &amp;&amp;
<a name="l00713"></a>00713             <a class="code" href="class_o_t_keyring.html#afa0c2601a6d15a14743ac16fe214ad8f">OTKeyring::RetrieveSecret</a>(
<a name="l00714"></a>00714             strCachedKeyHash, <span class="comment">// HASH OF ENCRYPTED MASTER KEY</span>
<a name="l00715"></a>00715             *pDerivedKey,     <span class="comment">// (Output) RETRIEVED PASSWORD.</span>
<a name="l00716"></a>00716             str_display);     <span class="comment">// optional display string.</span>
<a name="l00717"></a>00717         <span class="comment">// -----------------------------------------------------</span>
<a name="l00718"></a>00718         <span class="keywordflow">if</span> (bFoundOnKeyring) <span class="comment">// We found it -- but does it WORK?</span>
<a name="l00719"></a>00719         {
<a name="l00720"></a>00720             <span class="keyword">const</span> <span class="keywordtype">bool</span> bCachedKey = m_pSymmetricKey-&gt;<a class="code" href="class_o_t_symmetric_key.html#a99470a8be3349bb0d0336802aeff60fb">GetRawKeyFromDerivedKey</a>(*pDerivedKey, *m_pMasterPassword);
<a name="l00721"></a>00721 
<a name="l00722"></a>00722             <span class="comment">//</span>
<a name="l00723"></a>00723             <span class="comment">// Note: What IS the secret? We don&#39;t want it to be the user&#39;s passphrase that he TYPES.</span>
<a name="l00724"></a>00724             <span class="comment">// We also don&#39;t want it to be the eventual (random) key that unlocks the private keys.</span>
<a name="l00725"></a>00725             <span class="comment">// Rather, we want it to be the intermediary key, generated from the user&#39;s passphrase via</span>
<a name="l00726"></a>00726             <span class="comment">// a key-derivation algorithm, which is then used to unlock the (random) symmetric key that</span>
<a name="l00727"></a>00727             <span class="comment">// actually unlocks the private keys.</span>
<a name="l00728"></a>00728             <span class="comment">// This way the symmetric key itself can be kept locked at ALL times, and instead, we have the</span>
<a name="l00729"></a>00729             <span class="comment">// derived key on the timer, use it to unlock the symmetric key EVERY TIME we use that, and</span>
<a name="l00730"></a>00730             <span class="comment">// IMMEDIATELY throw it away afterwards, since we can still open it again (until the timeout) by</span>
<a name="l00731"></a>00731             <span class="comment">// using the derived key.</span>
<a name="l00732"></a>00732             <span class="comment">// This is slick because the user doesn&#39;t directly enter the derived key, and neither is it</span>
<a name="l00733"></a>00733             <span class="comment">// directly used for unlocking private keys -- so it&#39;s preferable to store in RAM than those things.</span>
<a name="l00734"></a>00734             <span class="comment">//</span>
<a name="l00735"></a>00735             <span class="comment">//</span>
<a name="l00736"></a>00736             <span class="comment">// 1. Make sure the above description is actually what we DO do now. (UPDATE: for keyring, yes. For OT internally, no.)</span>
<a name="l00737"></a>00737             <span class="comment">// 2. Make sure the derived key, as described above, is also what is stored as the SECRET, here! (UPDATE: Yes!)</span>
<a name="l00738"></a>00738             <span class="comment">//    (i.e. in other processes such as Mac Keychain or Gnome.)</span>
<a name="l00739"></a>00739             <span class="comment">// 3. Done. Need to add ability for OTIdentifier to hash OTSymmetricKey, so we can use it for strUser above. DONE.</span>
<a name="l00740"></a>00740             <span class="comment">//</span>
<a name="l00741"></a>00741             <span class="comment">// UPDATE: the master key cached inside OT (on a timer) is not the derived key, but the master key itself</span>
<a name="l00742"></a>00742             <span class="comment">// that&#39;s used on the private keys. However, the one we&#39;re caching in the system keyring IS the derived key,</span>
<a name="l00743"></a>00743             <span class="comment">// and not the master key. So for example, if an attacker obtained the derived key from the system keyring,</span>
<a name="l00744"></a>00744             <span class="comment">//</span>
<a name="l00745"></a>00745 
<a name="l00746"></a>00746             <span class="keywordflow">if</span> (bCachedKey) <span class="comment">// It works!</span>
<a name="l00747"></a>00747             {
<a name="l00748"></a>00748                 <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(1, <span class="stringliteral">&quot;%s: Finished calling m_pSymmetricKey-&gt;GetRawKeyFromDerivedKey (Success.)\n&quot;</span>, szFunc);
<a name="l00749"></a>00749                 theOutput  = *m_pMasterPassword; <span class="comment">// Return it to the caller.</span>
<a name="l00750"></a>00750                 theDerivedAngel.<a class="code" href="class_o_t_cleanup.html#a00a399db45f730439d2263d4429d00c1">SetCleanupTarget</a>(*pDerivedKey); <span class="comment">// Set our own copy to be destroyed later. It continues below as &quot;NOT NULL&quot;.</span>
<a name="l00751"></a>00751                 bReturnVal = <span class="keyword">true</span>; <span class="comment">// Success.</span>
<a name="l00752"></a>00752             }
<a name="l00753"></a>00753             <span class="keywordflow">else</span> <span class="comment">// It didn&#39;t unlock with the one we found.</span>
<a name="l00754"></a>00754             {
<a name="l00755"></a>00755                 <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(0, <span class="stringliteral">&quot;%s: Unable to unlock master key using derived key found on system keyring.\n&quot;</span>, szFunc);
<a name="l00756"></a>00756                 <span class="keyword">delete</span> pDerivedKey;
<a name="l00757"></a>00757                 pDerivedKey = NULL;  <span class="comment">// Below, this function checks pDerivedKey for NULL.</span>
<a name="l00758"></a>00758             }
<a name="l00759"></a>00759         }
<a name="l00760"></a>00760         <span class="keywordflow">else</span>    <span class="comment">// NOT found on keyring.</span>
<a name="l00761"></a>00761         {
<a name="l00762"></a>00762             <span class="keywordflow">if</span> (this-&gt;<a class="code" href="class_o_t_cached_key.html#a95adb6583e128ed03719dc365e14005e">IsUsingSystemKeyring</a>()) <span class="comment">// We WERE using the keying, but we DIDN&#39;T find the derived key.</span>
<a name="l00763"></a>00763                 <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(1, <span class="stringliteral">&quot;%s: Unable to find derived key on system keyring.\n&quot;</span>, szFunc);
<a name="l00764"></a>00764             <span class="comment">// (Otherwise if we WEREN&#39;T using the system keyring, then of course we didn&#39;t find any derived key cached there.)</span>
<a name="l00765"></a>00765             <span class="keyword">delete</span> pDerivedKey;
<a name="l00766"></a>00766             pDerivedKey = NULL; <span class="comment">// Below, this function checks pDerivedKey for NULL.</span>
<a name="l00767"></a>00767 
<a name="l00768"></a>00768         }
<a name="l00769"></a>00769     }
<a name="l00770"></a>00770     <span class="comment">// --------------------------------------------------</span>
<a name="l00771"></a>00771     <span class="comment">// NOT found on Keyring...</span>
<a name="l00772"></a>00772     <span class="comment">//</span>
<a name="l00773"></a>00773     <span class="keywordflow">if</span> (NULL == pDerivedKey) <span class="comment">// Master key was not cached in OT, nor was it found in the system keychain.</span>
<a name="l00774"></a>00774     {                        <span class="comment">// Therefore we HAVE to ask the user for a passphrase and decrypt it ourselves,</span>
<a name="l00775"></a>00775         <span class="comment">// since we DO have an encrypted version of the key...</span>
<a name="l00776"></a>00776 
<a name="l00777"></a>00777         <span class="comment">// This time we DEFINITELY force the user input, since we already played our hand.</span>
<a name="l00778"></a>00778         <span class="comment">// If the master key was still in memory we would have returned already, above.</span>
<a name="l00779"></a>00779         <span class="comment">// Then we tried to find it on the keyring and we couldn&#39;t find it, so now we have</span>
<a name="l00780"></a>00780         <span class="comment">// to actually ask the user to enter it.</span>
<a name="l00781"></a>00781         <span class="comment">//</span>
<a name="l00782"></a>00782 
<a name="l00783"></a>00783         std::string default_password(<a class="code" href="_o_t_cached_key_8cpp.html#aa00325ea7c8ea1e1406bb2d019d7e6fe">OT_DEFAULT_PASSWORD</a>); <span class="comment">// default password</span>
<a name="l00784"></a>00784         <a class="code" href="class_o_t_password.html">OTPassword</a> passwordDefault; passwordDefault.<a class="code" href="class_o_t_password.html#a3a971b06f42d1c89802167a0ab5330a5">zeroMemory</a>();
<a name="l00785"></a>00785         passwordDefault.<a class="code" href="class_o_t_password.html#a251ed5100b869ae4b80166453e75e964">setPassword</a>(default_password.c_str(), <span class="keyword">static_cast&lt;</span>int32_t<span class="keyword">&gt;</span>(default_password.length()));
<a name="l00786"></a>00786 
<a name="l00787"></a>00787         <a class="code" href="class_o_t_password.html">OTPassword</a> passUserInput;  passUserInput.<a class="code" href="class_o_t_password.html#a3a971b06f42d1c89802167a0ab5330a5">zeroMemory</a>(); <span class="comment">// text mode.</span>
<a name="l00788"></a>00788         <a class="code" href="class_o_t_password_data.html">OTPasswordData</a>  thePWData(str_display.c_str(), &amp;passUserInput, mySharedPtr); <span class="comment">// these pointers are only passed in the case where it&#39;s for a master key.</span>
<a name="l00789"></a>00789 <span class="comment">//      OTLog::vOutput(2, &quot;*********Begin OTCachedKey::GetMasterPassword: Calling souped-up password cb...\n * *  * *  * *  * *  * &quot;);</span>
<a name="l00790"></a>00790         <span class="comment">// -----------------------------------------------------------------------</span>
<a name="l00791"></a>00791 
<a name="l00792"></a>00792 
<a name="l00793"></a>00793         <span class="comment">// It&#39;s possible this is the first time this is happening, and the master key</span>
<a name="l00794"></a>00794         <span class="comment">// hasn&#39;t even been generated yet. In which case, we generate it here...</span>
<a name="l00795"></a>00795         <span class="comment">//</span>
<a name="l00796"></a>00796         <span class="keywordtype">bool</span> bGenerated = m_pSymmetricKey-&gt;<a class="code" href="class_o_t_symmetric_key.html#a9e2eced2ded569ff96ddace6488a7968">IsGenerated</a>();
<a name="l00797"></a>00797 
<a name="l00798"></a>00798         <span class="keywordflow">if</span> (!bGenerated) <span class="comment">// This Symmetric Key hasn&#39;t been generated before....</span>
<a name="l00799"></a>00799         {
<a name="l00800"></a>00800 
<a name="l00801"></a>00801             <span class="keywordflow">if</span> (!<a class="code" href="class_o_t_asymmetric_key.html#a7515df1669bf358ddfc7ea477aedafdf">OTAsymmetricKey::GetPasswordCallback</a>()(NULL, 0, bVerifyTwice ? 1 : 0, static_cast&lt;void *&gt;(&amp;thePWData)))
<a name="l00802"></a>00802             {
<a name="l00803"></a>00803                 <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;%s: Failed to get password from user!&quot;</span>, __FUNCTION__);
<a name="l00804"></a>00804                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00805"></a>00805             }
<a name="l00806"></a>00806 
<a name="l00807"></a>00807 
<a name="l00808"></a>00808             <span class="comment">// If the length of the user supplied password is less than 4 characters int64_t, we are going to use the default password!</span>
<a name="l00809"></a>00809             <span class="keywordtype">bool</span> bUsingDefaultPassword = <span class="keyword">false</span>;
<a name="l00810"></a>00810             {
<a name="l00811"></a>00811                 <span class="keywordflow">if</span> (4 &gt; std::string(passUserInput.<a class="code" href="class_o_t_password.html#a2b3bc99637b0b01f9b4ffcae78abc5b4">getPassword</a>()).length())
<a name="l00812"></a>00812                 {
<a name="l00813"></a>00813                     <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(0, <span class="stringliteral">&quot;\n Password entered was less than 4 characters int64_t! This is NOT secure!!\n&quot;</span>
<a name="l00814"></a>00814                         <span class="stringliteral">&quot;... Assuming password is for testing only... setting to default password: %s \n&quot;</span>,
<a name="l00815"></a>00815                         <a class="code" href="_o_t_cached_key_8cpp.html#aa00325ea7c8ea1e1406bb2d019d7e6fe">OT_DEFAULT_PASSWORD</a>);
<a name="l00816"></a>00816                     bUsingDefaultPassword = <span class="keyword">true</span>;
<a name="l00817"></a>00817                 }
<a name="l00818"></a>00818             }
<a name="l00819"></a>00819 
<a name="l00820"></a>00820 <span class="comment">//          OTLog::vOutput(0, &quot;%s: Calling m_pSymmetricKey-&gt;GenerateKey()...\n&quot;, szFunc);</span>
<a name="l00821"></a>00821 
<a name="l00822"></a>00822             bGenerated = m_pSymmetricKey-&gt;<a class="code" href="class_o_t_symmetric_key.html#a2ef54d17c58afc9edea214ea0a2dcf13">GenerateKey</a>(bUsingDefaultPassword ? passwordDefault : passUserInput, &amp;pDerivedKey); <span class="comment">// derived key is optional here.</span>
<a name="l00823"></a>00823             <span class="comment">//</span>
<a name="l00824"></a>00824             <span class="comment">// Note: since I passed &amp;pDerivedKey in the above call, then **I** am responsible to</span>
<a name="l00825"></a>00825             <span class="comment">// check it for NULL, and delete it if there&#39;s something there!</span>
<a name="l00826"></a>00826             <span class="comment">//</span>
<a name="l00827"></a>00827             <span class="keywordflow">if</span> (NULL != pDerivedKey)
<a name="l00828"></a>00828                 theDerivedAngel.<a class="code" href="class_o_t_cleanup.html#a00a399db45f730439d2263d4429d00c1">SetCleanupTarget</a>(*pDerivedKey);
<a name="l00829"></a>00829             <span class="keywordflow">else</span>
<a name="l00830"></a>00830                 <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;%s: FYI: Derived key is still NULL after calling OTSymmetricKey::GenerateKey.\n&quot;</span>);
<a name="l00831"></a>00831 
<a name="l00832"></a>00832 <span class="comment">//          OTLog::vOutput(0, &quot;%s: Finished calling m_pSymmetricKey-&gt;GenerateKey()...\n&quot;, szFunc);</span>
<a name="l00833"></a>00833         }
<a name="l00834"></a>00834         <span class="keywordflow">else</span> <span class="comment">// m_pSymmetricKey-&gt;IsGenerated() == true. (Symmetric Key is already generated.)</span>
<a name="l00835"></a>00835         {
<a name="l00836"></a>00836             <span class="comment">// -------------------------------------------------------------------------------------------------</span>
<a name="l00837"></a>00837             <span class="comment">// Generate derived key from passphrase.</span>
<a name="l00838"></a>00838             <span class="comment">//</span>
<a name="l00839"></a>00839             <span class="comment">// We generate the derived key here so that GetRawKeyFromPassphrase() call (below)</span>
<a name="l00840"></a>00840             <span class="comment">// works with it being passed in. (Because the above call to GenerateKey also grabs</span>
<a name="l00841"></a>00841             <span class="comment">// a copy of the derived key and passes it in below to the same GetRawKeyFromPassphrase.)</span>
<a name="l00842"></a>00842             <span class="comment">//</span>
<a name="l00843"></a>00843             <span class="comment">// So WHY are we keeping a copy of the derived key through these calls? Otherwise they</span>
<a name="l00844"></a>00844             <span class="comment">// would all individually generate it, which is a waste of resources. Also, we want to have</span>
<a name="l00845"></a>00845             <span class="comment">// our grubby hands on the derived key at the end so we can add it to the system keyring</span>
<a name="l00846"></a>00846             <span class="comment">// (below), and we&#39;d just end up having to derive it AGAIN in order to do so.</span>
<a name="l00847"></a>00847             <span class="comment">//</span>
<a name="l00848"></a>00848             <span class="keywordflow">if</span> (m_pSymmetricKey-&gt;<a class="code" href="class_o_t_symmetric_key.html#a213fa5c52407fa234f8396c4f795f783">HasHashCheck</a>())
<a name="l00849"></a>00849             {
<a name="l00850"></a>00850                 pDerivedKey = m_pSymmetricKey-&gt;<a class="code" href="class_o_t_symmetric_key.html#ad91f8bb8c8384b0719204df381fa693f">CalculateDerivedKeyFromPassphrase</a>(passwordDefault); <span class="comment">// asserts already.</span>
<a name="l00851"></a>00851 
<a name="l00852"></a>00852                 <span class="keywordflow">if</span> (NULL == pDerivedKey)
<a name="l00853"></a>00853                 {
<a name="l00854"></a>00854                     <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(0, <span class="stringliteral">&quot;\n\n%s: Please enter your password.\n\n&quot;</span>, __FUNCTION__);
<a name="l00855"></a>00855 
<a name="l00856"></a>00856                     <span class="keywordflow">for</span> ( ;; )  <span class="comment">// bad passphase (as the calculate key returned NULL)</span>
<a name="l00857"></a>00857                     {
<a name="l00858"></a>00858                         <span class="keywordflow">if</span> (!<a class="code" href="class_o_t_asymmetric_key.html#a7515df1669bf358ddfc7ea477aedafdf">OTAsymmetricKey::GetPasswordCallback</a>()(NULL, 0, <span class="keyword">false</span>, static_cast&lt;void *&gt;(&amp;thePWData)))
<a name="l00859"></a>00859                         {
<a name="l00860"></a>00860                             <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;\n\n%s: Failed to get password from user!\n\n&quot;</span>, __FUNCTION__);
<a name="l00861"></a>00861                             <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00862"></a>00862                         }
<a name="l00863"></a>00863                         pDerivedKey = m_pSymmetricKey-&gt;<a class="code" href="class_o_t_symmetric_key.html#ad91f8bb8c8384b0719204df381fa693f">CalculateDerivedKeyFromPassphrase</a>(passUserInput); <span class="comment">// asserts already.</span>
<a name="l00864"></a>00864                         <span class="keywordflow">if</span> (NULL != pDerivedKey) <span class="keywordflow">break</span>; <span class="comment">// success</span>
<a name="l00865"></a>00865 
<a name="l00866"></a>00866                         <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(0, <span class="stringliteral">&quot;\n\n%s: Wrong Password, Please Try Again.\n\n&quot;</span>, __FUNCTION__);
<a name="l00867"></a>00867                     }
<a name="l00868"></a>00868                 }
<a name="l00869"></a>00869             }
<a name="l00870"></a>00870             <span class="keywordflow">else</span>
<a name="l00871"></a>00871             {
<a name="l00872"></a>00872                 <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(0,<span class="stringliteral">&quot;\n Please enter your current password twice, (not a new password!!) \n&quot;</span>);
<a name="l00873"></a>00873 
<a name="l00874"></a>00874                 <span class="keywordflow">if</span> (!<a class="code" href="class_o_t_asymmetric_key.html#a7515df1669bf358ddfc7ea477aedafdf">OTAsymmetricKey::GetPasswordCallback</a>()(NULL, 0, <span class="keyword">true</span>, static_cast&lt;void *&gt;(&amp;thePWData)))
<a name="l00875"></a>00875                 {
<a name="l00876"></a>00876                     <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;%s: Failed to get password from user!&quot;</span>, __FUNCTION__);
<a name="l00877"></a>00877                     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00878"></a>00878                 }
<a name="l00879"></a>00879 
<a name="l00880"></a>00880                 pDerivedKey = m_pSymmetricKey-&gt;<a class="code" href="class_o_t_symmetric_key.html#a7784859786cd0bfb61def268a6dbb9a7">CalculateNewDerivedKeyFromPassphrase</a>(passUserInput); <span class="comment">// asserts already.</span>
<a name="l00881"></a>00881                 <a class="code" href="_o_t_assert_8hpp.html#a74ecab0c6a7b0a9a546bb545160e23b3">OT_ASSERT</a>(NULL != pDerivedKey);
<a name="l00882"></a>00882             }
<a name="l00883"></a>00883             theDerivedAngel.<a class="code" href="class_o_t_cleanup.html#a00a399db45f730439d2263d4429d00c1">SetCleanupTarget</a>(*pDerivedKey);
<a name="l00884"></a>00884 
<a name="l00885"></a>00885             <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(1, <span class="stringliteral">&quot;%s: FYI, symmetric key was already generated. &quot;</span>
<a name="l00886"></a>00886                 <span class="stringliteral">&quot;Proceeding to try and use it...\n&quot;</span>, szFunc);
<a name="l00887"></a>00887 
<a name="l00888"></a>00888             <span class="comment">// bGenerated is true, if we&#39;re even in this block in the first place.</span>
<a name="l00889"></a>00889             <span class="comment">// (No need to set it twice.)</span>
<a name="l00890"></a>00890         }
<a name="l00891"></a>00891 
<a name="l00892"></a>00892         <span class="comment">// -------------------------------------------------------------------------------------------------</span>
<a name="l00893"></a>00893         <span class="comment">// Below this point, pDerivedKey could still be null.</span>
<a name="l00894"></a>00894         <span class="comment">// (And we only clean it up later if we created it.)</span>
<a name="l00895"></a>00895         <span class="comment">// Also, bGenerated could still be false. (Like if it wasn&#39;t</span>
<a name="l00896"></a>00896         <span class="comment">// generated, then generation itself failed, then it&#39;s still false.)</span>
<a name="l00897"></a>00897         <span class="comment">//</span>
<a name="l00898"></a>00898         <span class="comment">// Also, even if it was already generated, or if it wasn&#39;t but then successfully did,</span>
<a name="l00899"></a>00899         <span class="comment">//</span>
<a name="l00900"></a>00900         <span class="comment">// -----------------------------------------------------</span>
<a name="l00901"></a>00901 
<a name="l00902"></a>00902         <span class="keywordflow">if</span> (bGenerated) <span class="comment">// If SymmetricKey (*this) is already generated.</span>
<a name="l00903"></a>00903         {
<a name="l00904"></a>00904             <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(2, <span class="stringliteral">&quot;%s: Calling m_pSymmetricKey-&gt;GetRawKeyFromPassphrase()...\n&quot;</span>, szFunc);
<a name="l00905"></a>00905 
<a name="l00906"></a>00906             <span class="comment">// Once we have the user&#39;s password, then we use it to GetKey from the OTSymmetricKey (which</span>
<a name="l00907"></a>00907             <span class="comment">// is encrypted) and that retrieves the cleartext master password which we set here and also</span>
<a name="l00908"></a>00908             <span class="comment">// return a copy of.</span>
<a name="l00909"></a>00909             <span class="comment">//</span>
<a name="l00910"></a>00910             <span class="comment">// Note: if pDerivedKey was derived above already, which it should have been, then it will</span>
<a name="l00911"></a>00911             <span class="comment">// be not-NULL, and will be used here, and will be used subsequently for adding to the system</span>
<a name="l00912"></a>00912             <span class="comment">// keychain. Otherwise, it will be NULL, and GetRawKeyFromPassphrase will thus just derive its</span>
<a name="l00913"></a>00913             <span class="comment">// own copy of the derived key internally. It will still work, but then back up here, it will</span>
<a name="l00914"></a>00914             <span class="comment">// NOT be added to the system keyring, since it&#39;s still NULL back up here.</span>
<a name="l00915"></a>00915             <span class="comment">// (FYI.)</span>
<a name="l00916"></a>00916             <span class="comment">//</span>
<a name="l00917"></a>00917             <span class="keyword">const</span> <span class="keywordtype">bool</span> bCachedKey = m_pSymmetricKey-&gt;<a class="code" href="class_o_t_symmetric_key.html#a6930ce6ccea45d4259a8e44171d27763">GetRawKeyFromPassphrase</a>(passUserInput,
<a name="l00918"></a>00918                 *m_pMasterPassword,
<a name="l00919"></a>00919                 pDerivedKey);
<a name="l00920"></a>00920             <span class="keywordflow">if</span> (bCachedKey)
<a name="l00921"></a>00921             {
<a name="l00922"></a>00922                 <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(2, <span class="stringliteral">&quot;%s: Finished calling m_pSymmetricKey-&gt;GetRawKeyFromPassphrase (Success.)\n&quot;</span>, szFunc);
<a name="l00923"></a>00923                 theOutput  = *m_pMasterPassword; <span class="comment">// Success!</span>
<a name="l00924"></a>00924                 <span class="comment">// ------------------------------</span>
<a name="l00925"></a>00925                 <span class="comment">// Store the derived key to the system keyring.</span>
<a name="l00926"></a>00926                 <span class="comment">//</span>
<a name="l00927"></a>00927                 <span class="keywordflow">if</span> (this-&gt;<a class="code" href="class_o_t_cached_key.html#a95adb6583e128ed03719dc365e14005e">IsUsingSystemKeyring</a>() &amp;&amp; (NULL != pDerivedKey))
<a name="l00928"></a>00928                 {
<a name="l00929"></a>00929                     <span class="keyword">const</span> std::string str_display(NULL != szDisplay ? szDisplay : <span class="stringliteral">&quot;(Display string was blank.)&quot;</span>);
<a name="l00930"></a>00930                     <span class="comment">// -----------------------------------------------------</span>
<a name="l00931"></a>00931                     <span class="keyword">const</span> <a class="code" href="class_o_t_identifier.html">OTIdentifier</a> idCachedKey(*m_pSymmetricKey);
<a name="l00932"></a>00932                     <span class="keyword">const</span> <a class="code" href="class_o_t_string.html">OTString</a>     strCachedKeyHash(idCachedKey); <span class="comment">// Same thing, in string form.</span>
<a name="l00933"></a>00933                     <span class="comment">// -----------------------------------------------------</span>
<a name="l00934"></a>00934                     <span class="comment">//                      const bool bStored =</span>
<a name="l00935"></a>00935                     <a class="code" href="class_o_t_keyring.html#ab8689b4baa6c7db88827558c466808cf">OTKeyring::StoreSecret</a>(strCachedKeyHash, <span class="comment">// HASH OF ENCRYPTED MASTER KEY</span>
<a name="l00936"></a>00936                         *pDerivedKey,     <span class="comment">// (Input) Derived Key BEING STORED.</span>
<a name="l00937"></a>00937                         str_display);     <span class="comment">// optional display string.</span>
<a name="l00938"></a>00938                 }
<a name="l00939"></a>00939                 <span class="keywordflow">else</span>
<a name="l00940"></a>00940                     <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(1, <span class="stringliteral">&quot;%s: Strange: Problem with either: this-&gt;IsUsingSystemKeyring (%s) &quot;</span>
<a name="l00941"></a>00941                     <span class="stringliteral">&quot;or: (NULL != pDerivedKey) (%s)\n&quot;</span>, szFunc, this-&gt;<a class="code" href="class_o_t_cached_key.html#a95adb6583e128ed03719dc365e14005e">IsUsingSystemKeyring</a>() ? <span class="stringliteral">&quot;true&quot;</span> : <span class="stringliteral">&quot;false&quot;</span>,
<a name="l00942"></a>00942                     (NULL != pDerivedKey) ? <span class="stringliteral">&quot;true&quot;</span> : <span class="stringliteral">&quot;false&quot;</span>);
<a name="l00943"></a>00943 
<a name="l00944"></a>00944                 bReturnVal = <span class="keyword">true</span>;
<a name="l00945"></a>00945             }
<a name="l00946"></a>00946             <span class="keywordflow">else</span>
<a name="l00947"></a>00947                 <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(0, <span class="stringliteral">&quot;%s: m_pSymmetricKey-&gt;GetRawKeyFromPassphrase() failed.\n&quot;</span>, szFunc);
<a name="l00948"></a>00948         } <span class="comment">// bGenerated</span>
<a name="l00949"></a>00949         <span class="keywordflow">else</span>
<a name="l00950"></a>00950             <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;%s: bGenerated is still false, even after trying to generate it, yadda yadda yadda.\n&quot;</span>, szFunc);
<a name="l00951"></a>00951 
<a name="l00952"></a>00952     } <span class="comment">// NULL == pDerivedKey</span>
<a name="l00953"></a>00953     <span class="comment">// -------------------------------------------</span>
<a name="l00954"></a>00954 
<a name="l00955"></a>00955     <span class="keywordflow">if</span> (bReturnVal) <span class="comment">// Start the thread!</span>
<a name="l00956"></a>00956     {
<a name="l00957"></a>00957 <span class="comment">//      OTLog::vOutput(4, &quot;%s: starting up new thread, so we can expire the master key from RAM.\n&quot;, szFunc);</span>
<a name="l00958"></a>00958 
<a name="l00959"></a>00959 
<a name="l00960"></a>00960 <span class="comment">// ************************************************************************</span>
<a name="l00961"></a>00961 <span class="preprocessor">#if defined(OT_CRYPTO_USING_OPENSSL)</span>
<a name="l00962"></a>00962 <span class="preprocessor"></span>
<a name="l00963"></a>00963 <span class="comment">// -------------------------------------------------</span>
<a name="l00964"></a>00964 <span class="preprocessor">#if defined(OPENSSL_THREADS)</span>
<a name="l00965"></a>00965 <span class="preprocessor"></span>        <span class="comment">// thread support enabled</span>
<a name="l00966"></a>00966 
<a name="l00967"></a>00967         <a class="code" href="class_o_t_log.html#aa2a497c02879b811fe3134631d762f08">OTLog::vOutput</a>(2, <span class="stringliteral">&quot;%s: Starting thread for Master Key...\n&quot;</span>, szFunc);
<a name="l00968"></a>00968 
<a name="l00969"></a>00969         _SharedPtr&lt;OTCachedKey&gt; * pthreadSharedPtr = <span class="keyword">new</span> _SharedPtr&lt;OTCachedKey&gt;(mySharedPtr); <span class="comment">// TODO: memory leak.</span>
<a name="l00970"></a>00970 
<a name="l00971"></a>00971         m_pThread = <span class="keyword">new</span> tthread::thread(<a class="code" href="class_o_t_cached_key.html#a7ac7c4130bd8d8cb9a443be54ae5e004">OTCachedKey::ThreadTimeout</a>, static_cast&lt;void *&gt;(pthreadSharedPtr));
<a name="l00972"></a>00972 
<a name="l00973"></a>00973 <span class="preprocessor">#else</span>
<a name="l00974"></a>00974 <span class="preprocessor"></span>        <span class="comment">// no thread support</span>
<a name="l00975"></a>00975 
<a name="l00976"></a>00976         <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;%s: WARNING: OpenSSL was NOT compiled with thread support. &quot;</span>
<a name="l00977"></a>00977             <span class="stringliteral">&quot;(Master Key will not expire.)\n&quot;</span>, szFunc);
<a name="l00978"></a>00978 
<a name="l00979"></a>00979 <span class="preprocessor">#endif</span>
<a name="l00980"></a>00980 <span class="preprocessor"></span><span class="comment">// -------------------------------------------------</span>
<a name="l00981"></a>00981 
<a name="l00982"></a>00982 <span class="comment">// ************************************************************************</span>
<a name="l00983"></a>00983 <span class="preprocessor">#elif defined(OT_CRYPTO_USING_GPG)</span>
<a name="l00984"></a>00984 <span class="preprocessor"></span>
<a name="l00985"></a>00985         <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;%s: WARNING: OT was compiled for GPG, which is not yet supported. &quot;</span>
<a name="l00986"></a>00986                       <span class="stringliteral">&quot;(Master Key will not expire.)\n&quot;</span>, szFunc);
<a name="l00987"></a>00987 
<a name="l00988"></a>00988 <span class="comment">// ************************************************************************</span>
<a name="l00989"></a>00989 <span class="preprocessor">#else  // OT_CRYPTO_USING_ ... nothing?</span>
<a name="l00990"></a>00990 <span class="preprocessor"></span>
<a name="l00991"></a>00991         <a class="code" href="class_o_t_log.html#acd1264f26723485de0783186149b0eca">OTLog::vError</a>(<span class="stringliteral">&quot;%s: WARNING: OT wasn&#39;t compiled for any crypto library &quot;</span>
<a name="l00992"></a>00992                       <span class="stringliteral">&quot;(such as OpenSSL or GPG). Which is very strange, and I doubt &quot;</span>
<a name="l00993"></a>00993                       <span class="stringliteral">&quot;things will even work, with it in this condition. (Plus, Master &quot;</span>
<a name="l00994"></a>00994                       <span class="stringliteral">&quot;Key will not expire.)\n&quot;</span>, szFunc);
<a name="l00995"></a>00995 
<a name="l00996"></a>00996 <span class="comment">// -------------------------------------------------</span>
<a name="l00997"></a>00997 <span class="preprocessor">#endif     //if defined(OT_CRYPTO_USING_OPENSSL),  elif defined(OT_CRYPTO_USING_GPG),  else,  endif.</span>
<a name="l00998"></a>00998 <span class="preprocessor"></span><span class="comment">// ************************************************************************</span>
<a name="l00999"></a>00999 
<a name="l01000"></a>01000 
<a name="l01001"></a>01001         <span class="comment">// -------------------------------------------------</span>
<a name="l01002"></a>01002 
<a name="l01003"></a>01003     }
<a name="l01004"></a>01004     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (m_nTimeoutSeconds != (-1))
<a name="l01005"></a>01005     {
<a name="l01006"></a>01006         <span class="keywordflow">if</span> (NULL != m_pMasterPassword)
<a name="l01007"></a>01007         {
<a name="l01008"></a>01008             <a class="code" href="class_o_t_password.html">OTPassword</a> * pMasterPassword = m_pMasterPassword;
<a name="l01009"></a>01009 
<a name="l01010"></a>01010             m_pMasterPassword = NULL;
<a name="l01011"></a>01011 
<a name="l01012"></a>01012             <span class="keyword">delete</span> pMasterPassword; pMasterPassword = NULL;
<a name="l01013"></a>01013         }
<a name="l01014"></a>01014     }
<a name="l01015"></a>01015     <span class="comment">// Since we have set the cleartext master password, We also have to fire up the thread</span>
<a name="l01016"></a>01016     <span class="comment">// so it can timeout and be destroyed. In the meantime, it&#39;ll be stored in an OTPassword</span>
<a name="l01017"></a>01017     <span class="comment">// which has these security precautions:</span>
<a name="l01018"></a>01018     <span class="comment">/*</span>
<a name="l01019"></a>01019 <span class="comment">    1. Zeros memory in a secure and cross-platform way, in its destructor.</span>
<a name="l01020"></a>01020 <span class="comment">    2. OT_Init() uses setrlimit to prevent core dumps.</span>
<a name="l01021"></a>01021 <span class="comment">    3. Uses VirtualLock and mlock to reduce/prevent swapping RAM to hard drive.</span>
<a name="l01022"></a>01022 <span class="comment">    4. (SOON) will use VirtualProtect on Windows (standard API for protected memory)</span>
<a name="l01023"></a>01023 <span class="comment">    5. (SOON) and similarly have option in config file for ssh-agent, gpg-agent, etc.</span>
<a name="l01024"></a>01024 <span class="comment">    6. Even without those things,the master password is stored in an encrypted form after it times out.</span>
<a name="l01025"></a>01025 <span class="comment">    7. While decrypted (while timer is going) it&#39;s still got the above security mechanisms,</span>
<a name="l01026"></a>01026 <span class="comment">    plus options for standard protected-memory APIs are made available wherever possible.</span>
<a name="l01027"></a>01027 <span class="comment">    8. The actual passphrase the user types is not stored in memory, except just int64_t enough to</span>
<a name="l01028"></a>01028 <span class="comment">    use it to derive another key, used to unlock the actual key (for a temporary period of time.)</span>
<a name="l01029"></a>01029 <span class="comment">    9. Meanwhile the actual key is stored in encrypted form on disk, and the derived key isn&#39;t stored anywhere.</span>
<a name="l01030"></a>01030 <span class="comment">    10. Ultimately external hardware, and smart cards, are the way to go. But OT should still do the best possible.</span>
<a name="l01031"></a>01031 <span class="comment">    */</span>
<a name="l01032"></a>01032 
<a name="l01033"></a>01033     <span class="keywordflow">return</span> bReturnVal;
<a name="l01034"></a>01034 }
<a name="l01035"></a>01035 
<a name="l01036"></a>01036 
<a name="l01037"></a>01037 <span class="comment">//static</span>
<a name="l01038"></a>01038 <span class="comment">// This is the thread itself.</span>
<a name="l01039"></a>01039 <span class="comment">//</span>
<a name="l01040"></a><a class="code" href="class_o_t_cached_key.html#a7ac7c4130bd8d8cb9a443be54ae5e004">01040</a> <span class="keywordtype">void</span> <a class="code" href="class_o_t_cached_key.html#a7ac7c4130bd8d8cb9a443be54ae5e004">OTCachedKey::ThreadTimeout</a>(<span class="keywordtype">void</span> * pArg)
<a name="l01041"></a>01041 {
<a name="l01042"></a>01042     <span class="comment">// TODO: Save a copy of pArg, in the cached key object, and delete it whenever LowLevelRemoveThread</span>
<a name="l01043"></a>01043     <span class="comment">// is called. Otherwise it&#39;s a memory leak.</span>
<a name="l01044"></a>01044     <span class="comment">//</span>
<a name="l01045"></a>01045     _SharedPtr&lt;OTCachedKey&gt; * pthreadSharedPtr = <span class="keyword">static_cast&lt;</span>_SharedPtr&lt;OTCachedKey&gt; *<span class="keyword">&gt;</span>(pArg);
<a name="l01046"></a>01046     _SharedPtr&lt;OTCachedKey&gt;   pMyself = *pthreadSharedPtr;
<a name="l01047"></a>01047 
<a name="l01048"></a>01048     <span class="keywordflow">if</span> (!pMyself) { <a class="code" href="_o_t_assert_8hpp.html#aa86aeed4e57eecded96d5955b5cc23c5">OT_FAIL_MSG</a>(<span class="stringliteral">&quot;OTCachedKey::ThreadTimeout: Need ptr to master key here, that activated this thread.\n&quot;</span>); }
<a name="l01049"></a>01049 
<a name="l01050"></a>01050     <span class="comment">// --------------------------------------</span>
<a name="l01051"></a>01051 <span class="comment">//    tthread::lock_guard&lt;tthread::mutex&gt; lock(*(pMyself-&gt;GetMutex())); // Multiple threads can&#39;t get inside here at the same time.</span>
<a name="l01052"></a>01052     <span class="comment">// --------------------------------------</span>
<a name="l01053"></a>01053     int32_t nTimeoutSeconds = 0;
<a name="l01054"></a>01054 
<a name="l01055"></a>01055     {
<a name="l01056"></a>01056         tthread::lock_guard&lt;tthread::mutex&gt; lock(OTCachedKey::s_mutexThreadTimeout);
<a name="l01057"></a>01057 
<a name="l01058"></a>01058         <span class="keywordflow">if</span> (pMyself)
<a name="l01059"></a>01059         {
<a name="l01060"></a>01060             nTimeoutSeconds = pMyself-&gt;GetTimeoutSeconds(); <span class="comment">// locks mutex internally.</span>
<a name="l01061"></a>01061         }
<a name="l01062"></a>01062     }
<a name="l01063"></a>01063     <span class="comment">// --------------------------------------</span>
<a name="l01064"></a>01064     <span class="keywordflow">if</span> (nTimeoutSeconds &gt; 0)
<a name="l01065"></a>01065     {
<a name="l01066"></a>01066         <span class="keywordflow">if</span> (pMyself)
<a name="l01067"></a>01067             tthread::this_thread::sleep_for(tthread::chrono::seconds(nTimeoutSeconds)); <span class="comment">// &lt;===== ASLEEP!</span>
<a name="l01068"></a>01068     }
<a name="l01069"></a>01069     <span class="comment">// --------------------------------------</span>
<a name="l01070"></a>01070     {
<a name="l01071"></a>01071         tthread::lock_guard&lt;tthread::mutex&gt; lock(OTCachedKey::s_mutexThreadTimeout);
<a name="l01072"></a>01072 
<a name="l01073"></a>01073         <span class="keywordflow">if</span> (pMyself &amp;&amp; (nTimeoutSeconds != (-1)))
<a name="l01074"></a>01074         {
<a name="l01075"></a>01075             pMyself-&gt;DestroyMasterPassword(); <span class="comment">// locks mutex internally.</span>
<a name="l01076"></a>01076         }
<a name="l01077"></a>01077     }
<a name="l01078"></a>01078 }
<a name="l01079"></a>01079 
<a name="l01080"></a>01080 
<a name="l01081"></a>01081 <span class="comment">// Called by the thread.</span>
<a name="l01082"></a>01082 <span class="comment">// The cleartext version (m_pMasterPassword) is deleted and set NULL after a Timer of X seconds.</span>
<a name="l01083"></a>01083 <span class="comment">// (Timer thread calls this.) The instance that owns each thread will pass its instance pointer</span>
<a name="l01084"></a>01084 <span class="comment">// as pArg so we can access the timeout seconds and the mutex, and the password we&#39;re destroying.</span>
<a name="l01085"></a>01085 <span class="comment">//</span>
<a name="l01086"></a><a class="code" href="class_o_t_cached_key.html#a6bf2bbe368339460eb08cf9dc42eeced">01086</a> <span class="keywordtype">void</span> <a class="code" href="class_o_t_cached_key.html#a6bf2bbe368339460eb08cf9dc42eeced">OTCachedKey::DestroyMasterPassword</a>()
<a name="l01087"></a>01087 {
<a name="l01088"></a>01088     tthread::lock_guard&lt;tthread::mutex&gt; lock(m_Mutex); <span class="comment">// Multiple threads can&#39;t get inside here at the same time.</span>
<a name="l01089"></a>01089     <span class="comment">//</span>
<a name="l01090"></a>01090     <span class="keywordflow">if</span> (m_nTimeoutSeconds != (-1))
<a name="l01091"></a>01091     {
<a name="l01092"></a>01092         <span class="comment">// (m_pSymmetricKey stays.</span>
<a name="l01093"></a>01093         <span class="comment">//  m_pMasterPassword only is destroyed.)</span>
<a name="l01094"></a>01094         <span class="comment">//</span>
<a name="l01095"></a>01095         <span class="keywordflow">if</span> (NULL != m_pMasterPassword)
<a name="l01096"></a>01096         {
<a name="l01097"></a>01097             <a class="code" href="class_o_t_password.html">OTPassword</a> * pPassword = m_pMasterPassword;
<a name="l01098"></a>01098 
<a name="l01099"></a>01099             m_pMasterPassword = NULL;
<a name="l01100"></a>01100 
<a name="l01101"></a>01101             <span class="keyword">delete</span> pPassword; pPassword = NULL;
<a name="l01102"></a>01102         }
<a name="l01103"></a>01103     }
<a name="l01104"></a>01104     <span class="comment">// (We do NOT call LowLevelReleaseThread(); here, since the thread is</span>
<a name="l01105"></a>01105     <span class="comment">// what CALLED this function. Instead, we destroy / NULL the master password,</span>
<a name="l01106"></a>01106     <span class="comment">// so that next time around we will see it is NULL and THEN we will know to</span>
<a name="l01107"></a>01107     <span class="comment">// call LowLevelReleaseThread(); before instantiating a new one.)</span>
<a name="l01108"></a>01108 
<a name="l01109"></a>01109     <span class="comment">// ---------------------------------------</span>
<a name="l01110"></a>01110 
<a name="l01111"></a>01111     <span class="comment">// New: When the master password is destroyed here, we also remove it from</span>
<a name="l01112"></a>01112     <span class="comment">// the system keychain:</span>
<a name="l01113"></a>01113     <span class="comment">//</span>
<a name="l01114"></a>01114     <span class="keywordflow">if</span> (NULL != m_pSymmetricKey)
<a name="l01115"></a>01115     {
<a name="l01116"></a>01116         <span class="keyword">const</span> std::string str_display;
<a name="l01117"></a>01117         <span class="comment">// -----------------------------------------------------</span>
<a name="l01118"></a>01118         <span class="keyword">const</span> <a class="code" href="class_o_t_identifier.html">OTIdentifier</a> idCachedKey(*m_pSymmetricKey);
<a name="l01119"></a>01119         <span class="keyword">const</span> <a class="code" href="class_o_t_string.html">OTString</a>     strCachedKeyHash(idCachedKey); <span class="comment">// Same thing, in string form.</span>
<a name="l01120"></a>01120         <span class="comment">// -----------------------------------------------------</span>
<a name="l01121"></a>01121         <span class="keyword">const</span> <span class="keywordtype">bool</span> bDeletedSecret = this-&gt;<a class="code" href="class_o_t_cached_key.html#a95adb6583e128ed03719dc365e14005e">IsUsingSystemKeyring</a>() &amp;&amp;
<a name="l01122"></a>01122                             <a class="code" href="class_o_t_keyring.html#a129634f61201323134ce7bde1acdc612">OTKeyring::DeleteSecret</a>(
<a name="l01123"></a>01123                                   strCachedKeyHash, <span class="comment">// HASH OF ENCRYPTED MASTER KEY</span>
<a name="l01124"></a>01124                                   str_display);     <span class="comment">// &quot;optional&quot; display string.</span>
<a name="l01125"></a>01125         <span class="keywordflow">if</span> (bDeletedSecret)
<a name="l01126"></a>01126         {
<a name="l01127"></a>01127             <a class="code" href="class_o_t_log.html#a1f7549d776ee919dcb6517f611ded015">OTLog::Output</a>(0, <span class="stringliteral">&quot;OTCachedKey::DestroyMasterPassword: FYI, deleted &quot;</span>
<a name="l01128"></a>01128                           <span class="stringliteral">&quot;the derived key (used for unlocking the master key password) &quot;</span>
<a name="l01129"></a>01129                           <span class="stringliteral">&quot;from system keychain at the same time as we deleted the master key &quot;</span>
<a name="l01130"></a>01130                           <span class="stringliteral">&quot;password from OT internally, due to password timeout.\n&quot;</span>);
<a name="l01131"></a>01131         }
<a name="l01132"></a>01132     }
<a name="l01133"></a>01133 }
<a name="l01134"></a>01134 
<a name="l01135"></a>01135 
<a name="l01136"></a>01136 <span class="comment">// If you actually want to create a new key, and a new passphrase, then use this to destroy every last vestige of the old one. (Which will cause a new one to be automatically generated the next time OT requests the master key.) NOTE: Make SURE you have all your Nyms loaded up and unlocked before you call this. Then save them all again so they will be properly stored with the new master key.</span>
<a name="l01137"></a>01137 
<a name="l01138"></a><a class="code" href="class_o_t_cached_key.html#a3ed776977711a2d217fff380dd6cd3c5">01138</a> <span class="keywordtype">void</span> <a class="code" href="class_o_t_cached_key.html#a3ed776977711a2d217fff380dd6cd3c5">OTCachedKey::ResetMasterPassword</a>()
<a name="l01139"></a>01139 {
<a name="l01140"></a>01140     tthread::lock_guard&lt;tthread::mutex&gt; lock(m_Mutex); <span class="comment">// Multiple threads can&#39;t get inside here at the same time.</span>
<a name="l01141"></a>01141     <span class="comment">// -----------------------------</span>
<a name="l01142"></a>01142     <a class="code" href="class_o_t_cached_key.html#a6933e0f88aae70fe30b925f150e8cc20">LowLevelReleaseThread</a>();
<a name="l01143"></a>01143     <span class="comment">// -----------------------------</span>
<a name="l01144"></a>01144     <span class="keywordflow">if</span> (NULL != m_pMasterPassword)
<a name="l01145"></a>01145     {
<a name="l01146"></a>01146         <a class="code" href="class_o_t_password.html">OTPassword</a> * pPassword = m_pMasterPassword;
<a name="l01147"></a>01147 
<a name="l01148"></a>01148         m_pMasterPassword = NULL;
<a name="l01149"></a>01149 
<a name="l01150"></a>01150         <span class="keyword">delete</span> pPassword; pPassword = NULL;
<a name="l01151"></a>01151     }
<a name="l01152"></a>01152     <span class="comment">// -----------------------------</span>
<a name="l01153"></a>01153     <span class="comment">//</span>
<a name="l01154"></a>01154     <span class="keywordflow">if</span> (NULL != m_pSymmetricKey)
<a name="l01155"></a>01155     {
<a name="l01156"></a>01156         <span class="comment">// We also remove it from the system keychain:</span>
<a name="l01157"></a>01157         <span class="comment">//</span>
<a name="l01158"></a>01158         <span class="keyword">const</span> std::string str_display;
<a name="l01159"></a>01159         <span class="comment">// -----------------------------------------------------</span>
<a name="l01160"></a>01160         <span class="keyword">const</span> <a class="code" href="class_o_t_identifier.html">OTIdentifier</a> idCachedKey(*m_pSymmetricKey); <span class="comment">// Symmetric Key ID of the Master key.</span>
<a name="l01161"></a>01161         <span class="keyword">const</span> <a class="code" href="class_o_t_string.html">OTString</a>     strCachedKeyHash(idCachedKey); <span class="comment">// Same thing, in string form.</span>
<a name="l01162"></a>01162         <span class="comment">// -----------------------------------------------------</span>
<a name="l01163"></a>01163         <span class="keyword">const</span> <span class="keywordtype">bool</span> bDeletedSecret = this-&gt;<a class="code" href="class_o_t_cached_key.html#a95adb6583e128ed03719dc365e14005e">IsUsingSystemKeyring</a>() &amp;&amp;
<a name="l01164"></a>01164                             <a class="code" href="class_o_t_keyring.html#a129634f61201323134ce7bde1acdc612">OTKeyring::DeleteSecret</a>(
<a name="l01165"></a>01165                                 strCachedKeyHash, <span class="comment">// HASH OF ENCRYPTED MASTER KEY</span>
<a name="l01166"></a>01166                                 str_display);     <span class="comment">// &quot;optional&quot; display string.</span>
<a name="l01167"></a>01167         <span class="keywordflow">if</span> (bDeletedSecret)
<a name="l01168"></a>01168         {
<a name="l01169"></a>01169             <a class="code" href="class_o_t_log.html#a1f7549d776ee919dcb6517f611ded015">OTLog::Output</a>(0, <span class="stringliteral">&quot;OTCachedKey::ResetMasterPassword: FYI, deleted &quot;</span>
<a name="l01170"></a>01170                           <span class="stringliteral">&quot;the derived key (used for unlocking the master key password) &quot;</span>
<a name="l01171"></a>01171                           <span class="stringliteral">&quot;from system keychain at the same time as we deleted the master key &quot;</span>
<a name="l01172"></a>01172                           <span class="stringliteral">&quot;itself, presumably due to the passphrase being reset.\n&quot;</span>);
<a name="l01173"></a>01173         }
<a name="l01174"></a>01174         <span class="comment">// -----------------------------------------------------</span>
<a name="l01175"></a>01175         <span class="comment">// Now wipe the symmetric key itself (so it can later be</span>
<a name="l01176"></a>01176         <span class="comment">// re-created as a new key.)</span>
<a name="l01177"></a>01177         <span class="comment">//</span>
<a name="l01178"></a>01178         <span class="keywordflow">if</span> (NULL != m_pSymmetricKey)
<a name="l01179"></a>01179         {
<a name="l01180"></a>01180             <a class="code" href="class_o_t_symmetric_key.html">OTSymmetricKey</a> * pSymmetricKey = m_pSymmetricKey;
<a name="l01181"></a>01181 
<a name="l01182"></a>01182             m_pSymmetricKey = NULL;
<a name="l01183"></a>01183 
<a name="l01184"></a>01184             <span class="keyword">delete</span> pSymmetricKey; pSymmetricKey = NULL;
<a name="l01185"></a>01185         }
<a name="l01186"></a>01186         <span class="comment">// -----------------------------------------------------</span>
<a name="l01187"></a>01187     }
<a name="l01188"></a>01188 }
</pre></div></div><!-- contents -->
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="_o_t_cached_key_8cpp.html">OTCachedKey.cpp</a>      </li>

    <li class="footer">Generated on Wed May 21 2014 11:26:02 for Open-Transactions by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1 </li>
   </ul>
 </div>


</body>
</html>
